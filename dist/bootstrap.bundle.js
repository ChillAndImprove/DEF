var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// js/graph/mxPoint.js
var mxPoint2 = function(x, y) {
  this.x = x != null ? x : 0;
  this.y = y != null ? y : 0;
};
mxPoint2.prototype.equals = function(obj) {
  return obj != null && obj.x === this.x && obj.y === this.y;
};
mxPoint2.prototype.clone = function() {
  return new mxPoint2(this.x, this.y);
};

// js/graph/mxRectangle.js
var mxRectangle = function(x, y, width, height) {
  mxPoint2.call(this, x, y);
  this.width = width != null ? width : 0;
  this.height = height != null ? height : 0;
};
mxRectangle.prototype = new mxPoint2();
mxRectangle.prototype.constructor = mxRectangle;
mxRectangle.prototype.width = null;
mxRectangle.prototype.height = null;
mxRectangle.prototype.setRect = function(x, y, w2, h2) {
  this.x = x;
  this.y = y;
  this.width = w2;
  this.height = h2;
};
mxRectangle.prototype.getCenterX = function() {
  return this.x + this.width / 2;
};
mxRectangle.prototype.getCenterY = function() {
  return this.y + this.height / 2;
};
mxRectangle.prototype.add = function(rect) {
  if (rect != null) {
    const minX = Math.min(this.x, rect.x);
    const minY = Math.min(this.y, rect.y);
    const maxX = Math.max(this.x + this.width, rect.x + rect.width);
    const maxY = Math.max(this.y + this.height, rect.y + rect.height);
    this.x = minX;
    this.y = minY;
    this.width = maxX - minX;
    this.height = maxY - minY;
  }
};
mxRectangle.prototype.intersect = function(rect) {
  if (rect != null) {
    const r1 = this.x + this.width;
    const r2 = rect.x + rect.width;
    const b1 = this.y + this.height;
    const b2 = rect.y + rect.height;
    this.x = Math.max(this.x, rect.x);
    this.y = Math.max(this.y, rect.y);
    this.width = Math.min(r1, r2) - this.x;
    this.height = Math.min(b1, b2) - this.y;
  }
};
mxRectangle.prototype.grow = function(amount) {
  this.x -= amount;
  this.y -= amount;
  this.width += 2 * amount;
  this.height += 2 * amount;
  return this;
};
mxRectangle.prototype.getPoint = function() {
  return new mxPoint2(this.x, this.y);
};
mxRectangle.prototype.rotate90 = function() {
  const t = (this.width - this.height) / 2;
  this.x += t;
  this.y -= t;
  const tmp = this.width;
  this.width = this.height;
  this.height = tmp;
};
mxRectangle.prototype.equals = function(obj) {
  return obj != null && obj.x === this.x && obj.y === this.y && obj.width === this.width && obj.height === this.height;
};
mxRectangle.fromRectangle = function(rect) {
  return new mxRectangle(rect.x, rect.y, rect.width, rect.height);
};
mxRectangle.prototype.clone = function() {
  return new mxRectangle(this.x, this.y, this.width, this.height);
};

// js/graph/mxConstants.js
var mxConstants2 = {
  DEFAULT_HOTSPOT: 0.3,
  MIN_HOTSPOT_SIZE: 8,
  MAX_HOTSPOT_SIZE: 0,
  RENDERING_HINT_EXACT: "exact",
  RENDERING_HINT_FASTER: "faster",
  RENDERING_HINT_FASTEST: "fastest",
  DIALECT_SVG: "svg",
  DIALECT_VML: "vml",
  DIALECT_MIXEDHTML: "mixedHtml",
  DIALECT_PREFERHTML: "preferHtml",
  DIALECT_STRICTHTML: "strictHtml",
  NS_SVG: "http://www.w3.org/2000/svg",
  NS_XHTML: "http://www.w3.org/1999/xhtml",
  NS_XLINK: "http://www.w3.org/1999/xlink",
  SHADOWCOLOR: "gray",
  VML_SHADOWCOLOR: "gray",
  SHADOW_OFFSET_X: 2,
  SHADOW_OFFSET_Y: 3,
  SHADOW_OPACITY: 1,
  NODETYPE_ELEMENT: 1,
  NODETYPE_ATTRIBUTE: 2,
  NODETYPE_TEXT: 3,
  NODETYPE_CDATA: 4,
  NODETYPE_ENTITY_REFERENCE: 5,
  NODETYPE_ENTITY: 6,
  NODETYPE_PROCESSING_INSTRUCTION: 7,
  NODETYPE_COMMENT: 8,
  NODETYPE_DOCUMENT: 9,
  NODETYPE_DOCUMENTTYPE: 10,
  NODETYPE_DOCUMENT_FRAGMENT: 11,
  NODETYPE_NOTATION: 12,
  TOOLTIP_VERTICAL_OFFSET: 16,
  DEFAULT_VALID_COLOR: "#00a8ff",
  DEFAULT_INVALID_COLOR: "#FF0000",
  OUTLINE_HIGHLIGHT_COLOR: "#00FF00",
  OUTLINE_HIGHLIGHT_STROKEWIDTH: 5,
  HIGHLIGHT_STROKEWIDTH: 3,
  HIGHLIGHT_SIZE: 5,
  HIGHLIGHT_OPACITY: 30,
  CURSOR_MOVABLE_VERTEX: "move",
  CURSOR_MOVABLE_EDGE: "move",
  CURSOR_LABEL_HANDLE: "default",
  CURSOR_TERMINAL_HANDLE: "pointer",
  CURSOR_BEND_HANDLE: "crosshair",
  CURSOR_VIRTUAL_BEND_HANDLE: "crosshair",
  CURSOR_CONNECT: "pointer",
  HIGHLIGHT_COLOR: "#00FF00",
  CONNECT_TARGET_COLOR: "#0000FF",
  INVALID_CONNECT_TARGET_COLOR: "#FF0000",
  DROP_TARGET_COLOR: "#0000FF",
  VALID_COLOR: "#00FF00",
  INVALID_COLOR: "#FF0000",
  EDGE_SELECTION_COLOR: "#00a8ff",
  VERTEX_SELECTION_COLOR: "#00a8ff",
  VERTEX_SELECTION_STROKEWIDTH: 1,
  EDGE_SELECTION_STROKEWIDTH: 1,
  VERTEX_SELECTION_DASHED: true,
  EDGE_SELECTION_DASHED: true,
  GUIDE_COLOR: "#0088cf",
  GUIDE_STROKEWIDTH: 1,
  OUTLINE_COLOR: "#00a8ff",
  OUTLINE_STROKEWIDTH: 3,
  HANDLE_SIZE: 6,
  LABEL_HANDLE_SIZE: 4,
  HANDLE_FILLCOLOR: "#29b6f2",
  HANDLE_STROKECOLOR: "#0088cf",
  LABEL_HANDLE_FILLCOLOR: "#cee7ff",
  CONNECT_HANDLE_FILLCOLOR: "#cee7ff",
  LOCKED_HANDLE_FILLCOLOR: "#FF0000",
  OUTLINE_HANDLE_FILLCOLOR: "#99ccff",
  OUTLINE_HANDLE_STROKECOLOR: "#00a8ff",
  DEFAULT_FONTFAMILY: "Arial,Helvetica",
  DEFAULT_FONTSIZE: 11,
  DEFAULT_TEXT_DIRECTION: "",
  LINE_HEIGHT: 1.2,
  WORD_WRAP: "normal",
  ABSOLUTE_LINE_HEIGHT: false,
  DEFAULT_FONTSTYLE: 0,
  DEFAULT_STARTSIZE: 40,
  DEFAULT_MARKERSIZE: 6,
  DEFAULT_IMAGESIZE: 24,
  ENTITY_SEGMENT: 30,
  RECTANGLE_ROUNDING_FACTOR: 0.15,
  LINE_ARCSIZE: 20,
  ARROW_SPACING: 0,
  ARROW_WIDTH: 30,
  ARROW_SIZE: 30,
  PAGE_FORMAT_A4_PORTRAIT: new mxRectangle(0, 0, 827, 1169),
  PAGE_FORMAT_A4_LANDSCAPE: new mxRectangle(0, 0, 1169, 827),
  PAGE_FORMAT_LETTER_PORTRAIT: new mxRectangle(0, 0, 850, 1100),
  PAGE_FORMAT_LETTER_LANDSCAPE: new mxRectangle(0, 0, 1100, 850),
  NONE: "none",
  STYLE_PERIMETER: "perimeter",
  STYLE_SOURCE_PORT: "sourcePort",
  STYLE_TARGET_PORT: "targetPort",
  STYLE_PORT_CONSTRAINT: "portConstraint",
  STYLE_PORT_CONSTRAINT_ROTATION: "portConstraintRotation",
  STYLE_SOURCE_PORT_CONSTRAINT: "sourcePortConstraint",
  STYLE_TARGET_PORT_CONSTRAINT: "targetPortConstraint",
  STYLE_OPACITY: "opacity",
  STYLE_FILL_OPACITY: "fillOpacity",
  STYLE_STROKE_OPACITY: "strokeOpacity",
  STYLE_TEXT_OPACITY: "textOpacity",
  STYLE_TEXT_DIRECTION: "textDirection",
  STYLE_OVERFLOW: "overflow",
  STYLE_ORTHOGONAL: "orthogonal",
  STYLE_EXIT_X: "exitX",
  STYLE_EXIT_Y: "exitY",
  STYLE_EXIT_DX: "exitDx",
  STYLE_EXIT_DY: "exitDy",
  STYLE_EXIT_PERIMETER: "exitPerimeter",
  STYLE_ENTRY_X: "entryX",
  STYLE_ENTRY_Y: "entryY",
  STYLE_ENTRY_DX: "entryDx",
  STYLE_ENTRY_DY: "entryDy",
  STYLE_ENTRY_PERIMETER: "entryPerimeter",
  STYLE_WHITE_SPACE: "whiteSpace",
  STYLE_ROTATION: "rotation",
  STYLE_FILLCOLOR: "fillColor",
  STYLE_POINTER_EVENTS: "pointerEvents",
  STYLE_SWIMLANE_FILLCOLOR: "swimlaneFillColor",
  STYLE_MARGIN: "margin",
  STYLE_GRADIENTCOLOR: "gradientColor",
  STYLE_GRADIENT_DIRECTION: "gradientDirection",
  STYLE_STROKECOLOR: "strokeColor",
  STYLE_SEPARATORCOLOR: "separatorColor",
  STYLE_STROKEWIDTH: "strokeWidth",
  STYLE_ALIGN: "align",
  STYLE_VERTICAL_ALIGN: "verticalAlign",
  STYLE_LABEL_WIDTH: "labelWidth",
  STYLE_LABEL_POSITION: "labelPosition",
  STYLE_VERTICAL_LABEL_POSITION: "verticalLabelPosition",
  STYLE_IMAGE_ASPECT: "imageAspect",
  STYLE_IMAGE_ALIGN: "imageAlign",
  STYLE_IMAGE_VERTICAL_ALIGN: "imageVerticalAlign",
  STYLE_GLASS: "glass",
  STYLE_IMAGE: "image",
  STYLE_IMAGE_WIDTH: "imageWidth",
  STYLE_IMAGE_HEIGHT: "imageHeight",
  STYLE_IMAGE_BACKGROUND: "imageBackground",
  STYLE_IMAGE_BORDER: "imageBorder",
  STYLE_FLIPH: "flipH",
  STYLE_FLIPV: "flipV",
  STYLE_NOLABEL: "noLabel",
  STYLE_NOEDGESTYLE: "noEdgeStyle",
  STYLE_LABEL_BACKGROUNDCOLOR: "labelBackgroundColor",
  STYLE_LABEL_BORDERCOLOR: "labelBorderColor",
  STYLE_LABEL_PADDING: "labelPadding",
  STYLE_INDICATOR_SHAPE: "indicatorShape",
  STYLE_INDICATOR_IMAGE: "indicatorImage",
  STYLE_INDICATOR_COLOR: "indicatorColor",
  STYLE_INDICATOR_STROKECOLOR: "indicatorStrokeColor",
  STYLE_INDICATOR_GRADIENTCOLOR: "indicatorGradientColor",
  STYLE_INDICATOR_SPACING: "indicatorSpacing",
  STYLE_INDICATOR_WIDTH: "indicatorWidth",
  STYLE_INDICATOR_HEIGHT: "indicatorHeight",
  STYLE_INDICATOR_DIRECTION: "indicatorDirection",
  STYLE_SHADOW: "shadow",
  STYLE_SEGMENT: "segment",
  STYLE_ENDARROW: "endArrow",
  STYLE_STARTARROW: "startArrow",
  STYLE_ENDSIZE: "endSize",
  STYLE_STARTSIZE: "startSize",
  STYLE_SWIMLANE_LINE: "swimlaneLine",
  STYLE_ENDFILL: "endFill",
  STYLE_STARTFILL: "startFill",
  STYLE_DASHED: "dashed",
  STYLE_DASH_PATTERN: "dashPattern",
  STYLE_FIX_DASH: "fixDash",
  STYLE_ROUNDED: "rounded",
  STYLE_CURVED: "curved",
  STYLE_ARCSIZE: "arcSize",
  STYLE_ABSOLUTE_ARCSIZE: "absoluteArcSize",
  STYLE_SOURCE_PERIMETER_SPACING: "sourcePerimeterSpacing",
  STYLE_TARGET_PERIMETER_SPACING: "targetPerimeterSpacing",
  STYLE_PERIMETER_SPACING: "perimeterSpacing",
  STYLE_SPACING: "spacing",
  STYLE_SPACING_TOP: "spacingTop",
  STYLE_SPACING_LEFT: "spacingLeft",
  STYLE_SPACING_BOTTOM: "spacingBottom",
  STYLE_SPACING_RIGHT: "spacingRight",
  STYLE_HORIZONTAL: "horizontal",
  STYLE_DIRECTION: "direction",
  STYLE_ANCHOR_POINT_DIRECTION: "anchorPointDirection",
  STYLE_ELBOW: "elbow",
  STYLE_FONTCOLOR: "fontColor",
  STYLE_FONTFAMILY: "fontFamily",
  STYLE_FONTSIZE: "fontSize",
  STYLE_FONTSTYLE: "fontStyle",
  STYLE_ASPECT: "aspect",
  STYLE_AUTOSIZE: "autosize",
  STYLE_FOLDABLE: "foldable",
  STYLE_EDITABLE: "editable",
  STYLE_BACKGROUND_OUTLINE: "backgroundOutline",
  STYLE_BENDABLE: "bendable",
  STYLE_MOVABLE: "movable",
  STYLE_RESIZABLE: "resizable",
  STYLE_RESIZE_WIDTH: "resizeWidth",
  STYLE_RESIZE_HEIGHT: "resizeHeight",
  STYLE_ROTATABLE: "rotatable",
  STYLE_CLONEABLE: "cloneable",
  STYLE_DELETABLE: "deletable",
  STYLE_SHAPE: "shape",
  STYLE_EDGE: "edgeStyle",
  STYLE_JETTY_SIZE: "jettySize",
  STYLE_SOURCE_JETTY_SIZE: "sourceJettySize",
  STYLE_TARGET_JETTY_SIZE: "targetJettySize",
  STYLE_LOOP: "loopStyle",
  STYLE_ORTHOGONAL_LOOP: "orthogonalLoop",
  STYLE_ROUTING_CENTER_X: "routingCenterX",
  STYLE_ROUTING_CENTER_Y: "routingCenterY",
  FONT_BOLD: 1,
  FONT_ITALIC: 2,
  FONT_UNDERLINE: 4,
  FONT_STRIKETHROUGH: 8,
  SHAPE_RECTANGLE: "rectangle",
  SHAPE_ELLIPSE: "ellipse",
  SHAPE_DOUBLE_ELLIPSE: "doubleEllipse",
  SHAPE_RHOMBUS: "rhombus",
  SHAPE_LINE: "line",
  SHAPE_IMAGE: "image",
  SHAPE_ARROW: "arrow",
  SHAPE_ARROW_CONNECTOR: "arrowConnector",
  SHAPE_LABEL: "label",
  SHAPE_CYLINDER: "cylinder",
  SHAPE_SWIMLANE: "swimlane",
  SHAPE_CONNECTOR: "connector",
  SHAPE_ACTOR: "actor",
  SHAPE_CLOUD: "cloud",
  SHAPE_TRIANGLE: "triangle",
  SHAPE_HEXAGON: "hexagon",
  ARROW_CLASSIC: "classic",
  ARROW_CLASSIC_THIN: "classicThin",
  ARROW_BLOCK: "block",
  ARROW_BLOCK_THIN: "blockThin",
  ARROW_OPEN: "open",
  ARROW_OPEN_THIN: "openThin",
  ARROW_OVAL: "oval",
  ARROW_DIAMOND: "diamond",
  ARROW_DIAMOND_THIN: "diamondThin",
  ALIGN_LEFT: "left",
  ALIGN_CENTER: "center",
  ALIGN_RIGHT: "right",
  ALIGN_TOP: "top",
  ALIGN_MIDDLE: "middle",
  ALIGN_BOTTOM: "bottom",
  DIRECTION_NORTH: "north",
  DIRECTION_SOUTH: "south",
  DIRECTION_EAST: "east",
  DIRECTION_WEST: "west",
  TEXT_DIRECTION_DEFAULT: "",
  TEXT_DIRECTION_AUTO: "auto",
  TEXT_DIRECTION_LTR: "ltr",
  TEXT_DIRECTION_RTL: "rtl",
  DIRECTION_MASK_NONE: 0,
  DIRECTION_MASK_WEST: 1,
  DIRECTION_MASK_NORTH: 2,
  DIRECTION_MASK_SOUTH: 4,
  DIRECTION_MASK_EAST: 8,
  DIRECTION_MASK_ALL: 15,
  ELBOW_VERTICAL: "vertical",
  ELBOW_HORIZONTAL: "horizontal",
  EDGESTYLE_ELBOW: "elbowEdgeStyle",
  EDGESTYLE_ENTITY_RELATION: "entityRelationEdgeStyle",
  EDGESTYLE_LOOP: "loopEdgeStyle",
  EDGESTYLE_SIDETOSIDE: "sideToSideEdgeStyle",
  EDGESTYLE_TOPTOBOTTOM: "topToBottomEdgeStyle",
  EDGESTYLE_ORTHOGONAL: "orthogonalEdgeStyle",
  EDGESTYLE_SEGMENT: "segmentEdgeStyle",
  PERIMETER_ELLIPSE: "ellipsePerimeter",
  PERIMETER_RECTANGLE: "rectanglePerimeter",
  PERIMETER_RHOMBUS: "rhombusPerimeter",
  PERIMETER_HEXAGON: "hexagonPerimeter",
  PERIMETER_TRIANGLE: "trianglePerimeter"
};

// js/graph/mxEventObject.js
var mxEventObject2 = function(name) {
  this.name = name;
  this.properties = [];
  for (let i = 1; i < arguments.length; i += 2) {
    if (arguments[i + 1] != null) {
      this.properties[arguments[i]] = arguments[i + 1];
    }
  }
};
mxEventObject2.prototype.name = null;
mxEventObject2.prototype.properties = null;
mxEventObject2.prototype.consumed = false;
mxEventObject2.prototype.getName = function() {
  return this.name;
};
mxEventObject2.prototype.getProperties = function() {
  return this.properties;
};
mxEventObject2.prototype.getProperty = function(key) {
  return this.properties[key];
};
mxEventObject2.prototype.isConsumed = function() {
  return this.consumed;
};
mxEventObject2.prototype.consume = function() {
  this.consumed = true;
};

// js/graph/mxEventSource.js
var mxEventSource = function(eventSource) {
  this.setEventSource(eventSource);
};
mxEventSource.prototype.eventListeners = null;
mxEventSource.prototype.eventsEnabled = true;
mxEventSource.prototype.eventSource = null;
mxEventSource.prototype.isEventsEnabled = function() {
  return this.eventsEnabled;
};
mxEventSource.prototype.setEventsEnabled = function(value) {
  this.eventsEnabled = value;
};
mxEventSource.prototype.getEventSource = function() {
  return this.eventSource;
};
mxEventSource.prototype.setEventSource = function(value) {
  this.eventSource = value;
};
mxEventSource.prototype.addListener = function(name, funct) {
  if (this.eventListeners == null) {
    this.eventListeners = [];
  }
  this.eventListeners.push(name);
  this.eventListeners.push(funct);
};
mxEventSource.prototype.removeListener = function(funct) {
  if (this.eventListeners != null) {
    let i = 0;
    while (i < this.eventListeners.length) {
      if (this.eventListeners[i + 1] == funct) {
        this.eventListeners.splice(i, 2);
      } else {
        i += 2;
      }
    }
  }
};
mxEventSource.prototype.fireEvent = function(evt, sender) {
  if (this.eventListeners != null && this.isEventsEnabled()) {
    if (evt == null) {
      evt = new mxEventObject2();
    }
    if (sender == null) {
      sender = this.getEventSource();
    }
    if (sender == null) {
      sender = this;
    }
    const args = [sender, evt];
    for (let i = 0; i < this.eventListeners.length; i += 2) {
      const listen = this.eventListeners[i];
      if (listen == null || listen == evt.getName()) {
        this.eventListeners[i + 1].apply(this, args);
      }
    }
  }
};

// js/graph/mxMouseEvent.js
var mxMouseEvent2 = function(evt, state2) {
  this.evt = evt;
  this.state = state2;
  this.sourceState = state2;
};
mxMouseEvent2.prototype.consumed = false;
mxMouseEvent2.prototype.evt = null;
mxMouseEvent2.prototype.graphX = null;
mxMouseEvent2.prototype.graphY = null;
mxMouseEvent2.prototype.state = null;
mxMouseEvent2.prototype.sourceState = null;
mxMouseEvent2.prototype.getEvent = function() {
  return this.evt;
};
mxMouseEvent2.prototype.getSource = function() {
  return mxEvent2.getSource(this.evt);
};
mxMouseEvent2.prototype.isSource = function(shape) {
  if (shape != null) {
    return isAncestorNode(shape.node, this.getSource());
  }
  return false;
};
mxMouseEvent2.prototype.getX = function() {
  return mxEvent2.getClientX(this.getEvent());
};
mxMouseEvent2.prototype.getY = function() {
  return mxEvent2.getClientY(this.getEvent());
};
mxMouseEvent2.prototype.getGraphX = function() {
  return this.graphX;
};
mxMouseEvent2.prototype.getGraphY = function() {
  return this.graphY;
};
mxMouseEvent2.prototype.getState = function() {
  return this.state;
};
mxMouseEvent2.prototype.getCell = function() {
  const state2 = this.getState();
  return state2 != null ? state2.cell : null;
};
mxMouseEvent2.prototype.isPopupTrigger = function() {
  return mxEvent2.isPopupTrigger(this.getEvent());
};
mxMouseEvent2.prototype.isConsumed = function() {
  return this.consumed;
};
mxMouseEvent2.prototype.consume = function(preventDefault = this.evt.touches != null || mxEvent2.isMouseEvent(this.evt)) {
  if (preventDefault && this.evt.preventDefault) {
    this.evt.preventDefault();
  }
  if (mxClient_default.IS_IE) {
    this.evt.returnValue = true;
  }
  this.consumed = true;
};

// js/graph/mxEvent.js
var mxEvent2 = {
  addListener: function() {
    const updateListenerList = function(element, eventName, funct) {
      if (element.mxListenerList == null) {
        element.mxListenerList = [];
      }
      const entry = { name: eventName, f: funct };
      element.mxListenerList.push(entry);
    };
    if (window.addEventListener) {
      return function(element, eventName, funct) {
        element.addEventListener(eventName, funct, false);
        updateListenerList(element, eventName, funct);
      };
    } else {
      return function(element, eventName, funct) {
        element.attachEvent("on" + eventName, funct);
        updateListenerList(element, eventName, funct);
      };
    }
  }(),
  removeListener: function() {
    const updateListener = function(element, eventName, funct) {
      if (element.mxListenerList != null) {
        const listenerCount = element.mxListenerList.length;
        for (let i = 0; i < listenerCount; i++) {
          const entry = element.mxListenerList[i];
          if (entry.f == funct) {
            element.mxListenerList.splice(i, 1);
            break;
          }
        }
        if (element.mxListenerList.length == 0) {
          element.mxListenerList = null;
        }
      }
    };
    if (window.removeEventListener) {
      return function(element, eventName, funct) {
        element.removeEventListener(eventName, funct, false);
        updateListener(element, eventName, funct);
      };
    } else {
      return function(element, eventName, funct) {
        element.detachEvent("on" + eventName, funct);
        updateListener(element, eventName, funct);
      };
    }
  }(),
  removeAllListeners: function(element) {
    const list = element.mxListenerList;
    if (list != null) {
      while (list.length > 0) {
        const entry = list[0];
        mxEvent2.removeListener(element, entry.name, entry.f);
      }
    }
  },
  addGestureListeners: function(node, startListener, moveListener, endListener) {
    if (startListener != null) {
      mxEvent2.addListener(node, mxClient_default.IS_POINTER ? "pointerdown" : "mousedown", startListener);
    }
    if (moveListener != null) {
      mxEvent2.addListener(node, mxClient_default.IS_POINTER ? "pointermove" : "mousemove", moveListener);
    }
    if (endListener != null) {
      mxEvent2.addListener(node, mxClient_default.IS_POINTER ? "pointerup" : "mouseup", endListener);
    }
    if (!mxClient_default.IS_POINTER && mxClient_default.IS_TOUCH) {
      if (startListener != null) {
        mxEvent2.addListener(node, "touchstart", startListener);
      }
      if (moveListener != null) {
        mxEvent2.addListener(node, "touchmove", moveListener);
      }
      if (endListener != null) {
        mxEvent2.addListener(node, "touchend", endListener);
      }
    }
  },
  removeGestureListeners: function(node, startListener, moveListener, endListener) {
    if (startListener != null) {
      mxEvent2.removeListener(node, mxClient_default.IS_POINTER ? "pointerdown" : "mousedown", startListener);
    }
    if (moveListener != null) {
      mxEvent2.removeListener(node, mxClient_default.IS_POINTER ? "pointermove" : "mousemove", moveListener);
    }
    if (endListener != null) {
      mxEvent2.removeListener(node, mxClient_default.IS_POINTER ? "pointerup" : "mouseup", endListener);
    }
    if (!mxClient_default.IS_POINTER && mxClient_default.IS_TOUCH) {
      if (startListener != null) {
        mxEvent2.removeListener(node, "touchstart", startListener);
      }
      if (moveListener != null) {
        mxEvent2.removeListener(node, "touchmove", moveListener);
      }
      if (endListener != null) {
        mxEvent2.removeListener(node, "touchend", endListener);
      }
    }
  },
  redirectMouseEvents: function(node, graph, state2, down, move, up, dblClick) {
    const getState = function(evt) {
      return typeof state2 == "function" ? state2(evt) : state2;
    };
    mxEvent2.addGestureListeners(node, function(evt) {
      if (down != null) {
        down(evt);
      } else if (!mxEvent2.isConsumed(evt)) {
        graph.fireMouseEvent(mxEvent2.MOUSE_DOWN, new mxMouseEvent2(evt, getState(evt)));
      }
    }, function(evt) {
      if (move != null) {
        move(evt);
      } else if (!mxEvent2.isConsumed(evt)) {
        graph.fireMouseEvent(mxEvent2.MOUSE_MOVE, new mxMouseEvent2(evt, getState(evt)));
      }
    }, function(evt) {
      if (up != null) {
        up(evt);
      } else if (!mxEvent2.isConsumed(evt)) {
        graph.fireMouseEvent(mxEvent2.MOUSE_UP, new mxMouseEvent2(evt, getState(evt)));
      }
    });
    mxEvent2.addListener(node, "dblclick", function(evt) {
      if (dblClick != null) {
        dblClick(evt);
      } else if (!mxEvent2.isConsumed(evt)) {
        const tmp = getState(evt);
        graph.dblClick(evt, tmp != null ? tmp.cell : null);
      }
    });
  },
  release: function(element) {
    try {
      if (element != null) {
        mxEvent2.removeAllListeners(element);
        const children = element.childNodes;
        if (children != null) {
          const childCount = children.length;
          for (let i = 0; i < childCount; i += 1) {
            mxEvent2.release(children[i]);
          }
        }
      }
    } catch (e) {
    }
  },
  addMouseWheelListener: function(funct, target) {
    if (funct != null) {
      const wheelHandler = function(evt) {
        if (evt == null) {
          evt = window.event;
        }
        if (evt.ctrlKey) {
          evt.preventDefault();
        }
        const delta = -evt.deltaY;
        if (Math.abs(evt.deltaX) > 0.5 || Math.abs(evt.deltaY) > 0.5) {
          funct(evt, evt.deltaY == 0 ? -evt.deltaX > 0 : -evt.deltaY > 0);
        }
      };
      target = target != null ? target : window;
      if (mxClient_default.IS_SF && !mxClient_default.IS_TOUCH) {
        let scale = 1;
        mxEvent2.addListener(target, "gesturestart", function(evt) {
          mxEvent2.consume(evt);
          scale = 1;
        });
        mxEvent2.addListener(target, "gesturechange", function(evt) {
          mxEvent2.consume(evt);
          const diff = scale - evt.scale;
          if (Math.abs(diff) > 0.2) {
            funct(evt, diff < 0, true);
            scale = evt.scale;
          }
        });
        mxEvent2.addListener(target, "gestureend", function(evt) {
          mxEvent2.consume(evt);
        });
      } else {
        let evtCache = [];
        let dx0 = 0;
        let dy0 = 0;
        mxEvent2.addGestureListeners(target, bind(this, function(evt) {
          if (!mxEvent2.isMouseEvent(evt) && evt.pointerId != null) {
            evtCache.push(evt);
          }
        }), bind(this, function(evt) {
          if (!mxEvent2.isMouseEvent(evt) && evtCache.length == 2) {
            for (let i = 0; i < evtCache.length; i++) {
              if (evt.pointerId == evtCache[i].pointerId) {
                evtCache[i] = evt;
                break;
              }
            }
            const dx = Math.abs(evtCache[0].clientX - evtCache[1].clientX);
            const dy = Math.abs(evtCache[0].clientY - evtCache[1].clientY);
            const tx = Math.abs(dx - dx0);
            const ty = Math.abs(dy - dy0);
            if (tx > mxEvent2.PINCH_THRESHOLD || ty > mxEvent2.PINCH_THRESHOLD) {
              const cx = evtCache[0].clientX + (evtCache[1].clientX - evtCache[0].clientX) / 2;
              const cy = evtCache[0].clientY + (evtCache[1].clientY - evtCache[0].clientY) / 2;
              funct(evtCache[0], tx > ty ? dx > dx0 : dy > dy0, true, cx, cy);
              dx0 = dx;
              dy0 = dy;
            }
          }
        }), bind(this, function(evt) {
          evtCache = [];
          dx0 = 0;
          dy0 = 0;
        }));
      }
      mxEvent2.addListener(target, "wheel", wheelHandler);
    }
  },
  disableContextMenu: function(element) {
    mxEvent2.addListener(element, "contextmenu", function(evt) {
      if (evt.preventDefault) {
        evt.preventDefault();
      }
      return false;
    });
  },
  getSource: function(evt) {
    return evt.srcElement != null ? evt.srcElement : evt.target;
  },
  isConsumed: function(evt) {
    return evt.isConsumed != null && evt.isConsumed;
  },
  isTouchEvent: function(evt) {
    return evt.pointerType != null ? evt.pointerType == "touch" || evt.pointerType === evt.MSPOINTER_TYPE_TOUCH : evt.mozInputSource != null ? evt.mozInputSource == 5 : evt.type.indexOf("touch") == 0;
  },
  isPenEvent: function(evt) {
    return evt.pointerType != null ? evt.pointerType == "pen" || evt.pointerType === evt.MSPOINTER_TYPE_PEN : evt.mozInputSource != null ? evt.mozInputSource == 2 : evt.type.indexOf("pen") == 0;
  },
  isMultiTouchEvent: function(evt) {
    return evt.type != null && evt.type.indexOf("touch") == 0 && evt.touches != null && evt.touches.length > 1;
  },
  isMouseEvent: function(evt) {
    return evt.pointerType != null ? evt.pointerType == "mouse" || evt.pointerType === evt.MSPOINTER_TYPE_MOUSE : evt.mozInputSource != null ? evt.mozInputSource == 1 : evt.type.indexOf("mouse") == 0;
  },
  isLeftMouseButton: function(evt) {
    if ("buttons" in evt && (evt.type == "mousedown" || evt.type == "mousemove")) {
      return evt.buttons == 1;
    } else if ("which" in evt) {
      return evt.which === 1;
    } else {
      return evt.button === 1;
    }
  },
  isMiddleMouseButton: function(evt) {
    if ("which" in evt) {
      return evt.which === 2;
    } else {
      return evt.button === 4;
    }
  },
  isRightMouseButton: function(evt) {
    if ("which" in evt) {
      return evt.which === 3;
    } else {
      return evt.button === 2;
    }
  },
  isPopupTrigger: function(evt) {
    return mxEvent2.isRightMouseButton(evt) || mxClient_default.IS_MAC && mxEvent2.isControlDown(evt) && !mxEvent2.isShiftDown(evt) && !mxEvent2.isMetaDown(evt) && !mxEvent2.isAltDown(evt);
  },
  isShiftDown: function(evt) {
    return evt != null ? evt.shiftKey : false;
  },
  isAltDown: function(evt) {
    return evt != null ? evt.altKey : false;
  },
  isControlDown: function(evt) {
    return evt != null ? evt.ctrlKey : false;
  },
  isMetaDown: function(evt) {
    return evt != null ? evt.metaKey : false;
  },
  getMainEvent: function(e) {
    if ((e.type == "touchstart" || e.type == "touchmove") && e.touches != null && e.touches[0] != null) {
      e = e.touches[0];
    } else if (e.type == "touchend" && e.changedTouches != null && e.changedTouches[0] != null) {
      e = e.changedTouches[0];
    }
    return e;
  },
  getClientX: function(e) {
    return mxEvent2.getMainEvent(e).clientX;
  },
  getClientY: function(e) {
    return mxEvent2.getMainEvent(e).clientY;
  },
  consume: function(evt, preventDefault, stopPropagation) {
    preventDefault = preventDefault != null ? preventDefault : true;
    stopPropagation = stopPropagation != null ? stopPropagation : true;
    if (preventDefault) {
      if (evt.preventDefault) {
        if (stopPropagation) {
          evt.stopPropagation();
        }
        evt.preventDefault();
      } else if (stopPropagation) {
        evt.cancelBubble = true;
      }
    }
    evt.isConsumed = true;
    if (!evt.preventDefault) {
      evt.returnValue = false;
    }
  },
  LABEL_HANDLE: -1,
  ROTATION_HANDLE: -2,
  CUSTOM_HANDLE: -100,
  VIRTUAL_HANDLE: -1e5,
  MOUSE_DOWN: "mouseDown",
  MOUSE_MOVE: "mouseMove",
  MOUSE_UP: "mouseUp",
  ACTIVATE: "activate",
  RESIZE_START: "resizeStart",
  RESIZE: "resize",
  RESIZE_END: "resizeEnd",
  MOVE_START: "moveStart",
  MOVE: "move",
  MOVE_END: "moveEnd",
  PAN_START: "panStart",
  PAN: "pan",
  PAN_END: "panEnd",
  MINIMIZE: "minimize",
  NORMALIZE: "normalize",
  MAXIMIZE: "maximize",
  HIDE: "hide",
  SHOW: "show",
  CLOSE: "close",
  DESTROY: "destroy",
  REFRESH: "refresh",
  SIZE: "size",
  SELECT: "select",
  FIRED: "fired",
  FIRE_MOUSE_EVENT: "fireMouseEvent",
  GESTURE: "gesture",
  TAP_AND_HOLD: "tapAndHold",
  GET: "get",
  RECEIVE: "receive",
  CONNECT: "connect",
  DISCONNECT: "disconnect",
  SUSPEND: "suspend",
  RESUME: "resume",
  MARK: "mark",
  ROOT: "root",
  POST: "post",
  OPEN: "open",
  SAVE: "save",
  BEFORE_ADD_VERTEX: "beforeAddVertex",
  ADD_VERTEX: "addVertex",
  AFTER_ADD_VERTEX: "afterAddVertex",
  DONE: "done",
  EXECUTE: "execute",
  EXECUTED: "executed",
  BEGIN_UPDATE: "beginUpdate",
  START_EDIT: "startEdit",
  END_UPDATE: "endUpdate",
  END_EDIT: "endEdit",
  BEFORE_UNDO: "beforeUndo",
  UNDO: "undo",
  REDO: "redo",
  CHANGE: "change",
  NOTIFY: "notify",
  LAYOUT_CELLS: "layoutCells",
  CLICK: "click",
  SCALE: "scale",
  TRANSLATE: "translate",
  SCALE_AND_TRANSLATE: "scaleAndTranslate",
  UP: "up",
  DOWN: "down",
  ADD: "add",
  REMOVE: "remove",
  CLEAR: "clear",
  ADD_CELLS: "addCells",
  CELLS_ADDED: "cellsAdded",
  MOVE_CELLS: "moveCells",
  CELLS_MOVED: "cellsMoved",
  RESIZE_CELLS: "resizeCells",
  CELLS_RESIZED: "cellsResized",
  TOGGLE_CELLS: "toggleCells",
  CELLS_TOGGLED: "cellsToggled",
  ORDER_CELLS: "orderCells",
  CELLS_ORDERED: "cellsOrdered",
  REMOVE_CELLS: "removeCells",
  CELLS_REMOVED: "cellsRemoved",
  GROUP_CELLS: "groupCells",
  UNGROUP_CELLS: "ungroupCells",
  REMOVE_CELLS_FROM_PARENT: "removeCellsFromParent",
  FOLD_CELLS: "foldCells",
  CELLS_FOLDED: "cellsFolded",
  ALIGN_CELLS: "alignCells",
  LABEL_CHANGED: "labelChanged",
  CONNECT_CELL: "connectCell",
  CELL_CONNECTED: "cellConnected",
  SPLIT_EDGE: "splitEdge",
  FLIP_EDGE: "flipEdge",
  START_EDITING: "startEditing",
  EDITING_STARTED: "editingStarted",
  EDITING_STOPPED: "editingStopped",
  ADD_OVERLAY: "addOverlay",
  REMOVE_OVERLAY: "removeOverlay",
  UPDATE_CELL_SIZE: "updateCellSize",
  ESCAPE: "escape",
  DOUBLE_CLICK: "doubleClick",
  START: "start",
  RESET: "reset",
  PINCH_THRESHOLD: 10
};
function mxXmlRequest(url, params, method, async, username, password) {
  this.url = url;
  this.params = params;
  this.method = method;
  this.async = async;
  this.username = username;
  this.password = password;
}
mxXmlRequest.prototype.send = function(onload, onerror) {
};
mxXmlRequest.prototype.getDocumentElement = function() {
  return null;
};

// js/graph/mxWindow.js
function mxWindow(title, content, x, y, width, height, minimizable, movable, replaceNode, style) {
  if (content != null) {
    minimizable = minimizable != null ? minimizable : true;
    this.content = content;
    this.init(x, y, width, height, style);
    this.installMaximizeHandler();
    this.installMinimizeHandler();
    this.installCloseHandler();
    this.setMinimizable(minimizable);
    this.setTitle(title);
    if (movable == null || movable) {
      this.installMoveHandler();
    }
    if (replaceNode != null && replaceNode.parentNode != null) {
      replaceNode.parentNode.replaceChild(this.div, replaceNode);
    } else {
      document.body.appendChild(this.div);
    }
  }
}
mxWindow.prototype = Object.create(mxEventSource.prototype);
mxWindow.prototype.constructor = mxWindow;
mxWindow.prototype.visible = false;
mxWindow.prototype.minimumSize = new mxRectangle(0, 0, 50, 40);
mxWindow.prototype.destroyOnClose = true;
mxWindow.prototype.contentHeightCorrection = document.documentMode == 8 || document.documentMode == 7 ? 6 : 2;
mxWindow.prototype.title = null;
mxWindow.prototype.content = null;
mxWindow.prototype.init = function(x, y, width, height, style) {
  style = style != null ? style : "mxWindow";
  this.closeImage = mxClient_default.imageBasePath + "/close.gif";
  this.minimizeImage = mxClient_default.imageBasePath + "/minimize.gif";
  this.normalizeImage = mxClient_default.imageBasePath + "/normalize.gif";
  this.maximizeImage = mxClient_default.imageBasePath + "/maximize.gif";
  this.resizeImage = mxClient_default.imageBasePath + "/resize.gif";
  this.div = document.createElement("div");
  this.div.className = style;
  this.div.style.left = x + "px";
  this.div.style.top = y + "px";
  this.table = document.createElement("table");
  this.table.className = style;
  if (mxClient_default.IS_POINTER) {
    this.div.style.touchAction = "none";
  }
  if (width != null) {
    if (!mxClient_default.IS_QUIRKS) {
      this.div.style.width = width + "px";
    }
    this.table.style.width = width + "px";
  }
  if (height != null) {
    if (!mxClient_default.IS_QUIRKS) {
      this.div.style.height = height + "px";
    }
    this.table.style.height = height + "px";
  }
  const tbody = document.createElement("tbody");
  let tr = document.createElement("tr");
  this.title = document.createElement("td");
  this.title.className = style + "Title";
  this.buttons = document.createElement("div");
  this.buttons.style.position = "absolute";
  this.buttons.style.display = "inline-block";
  this.buttons.style.right = "4px";
  this.buttons.style.top = "5px";
  this.title.appendChild(this.buttons);
  tr.appendChild(this.title);
  tbody.appendChild(tr);
  tr = document.createElement("tr");
  this.td = document.createElement("td");
  this.td.className = style + "Pane";
  if (document.documentMode == 7) {
    this.td.style.height = "100%";
  }
  this.contentWrapper = document.createElement("div");
  this.contentWrapper.className = style + "Pane";
  this.contentWrapper.style.width = "100%";
  this.contentWrapper.appendChild(this.content);
  if (mxClient_default.IS_QUIRKS || this.content.nodeName.toUpperCase() != "DIV") {
    this.contentWrapper.style.height = "100%";
  }
  this.td.appendChild(this.contentWrapper);
  tr.appendChild(this.td);
  tbody.appendChild(tr);
  this.table.appendChild(tbody);
  this.div.appendChild(this.table);
  const activator = bind(this, function(evt) {
    this.activate();
  });
  mxEvent2.addGestureListeners(this.title, activator);
  mxEvent2.addGestureListeners(this.table, activator);
  this.hide();
};
mxWindow.prototype.setTitle = function(title) {
  let child = this.title.firstChild;
  while (child != null) {
    const next = child.nextSibling;
    if (child.nodeType == mxConstants2.NODETYPE_TEXT) {
      child.parentNode.removeChild(child);
    }
    child = next;
  }
  write(this.title, title || "");
  this.title.appendChild(this.buttons);
};
mxWindow.prototype.setScrollable = function(scrollable) {
  if (navigator.userAgent == null || navigator.userAgent.indexOf("Presto/2.5") < 0) {
    if (scrollable) {
      this.contentWrapper.style.overflow = "auto";
    } else {
      this.contentWrapper.style.overflow = "hidden";
    }
  }
};
mxWindow.prototype.activate = function() {
  if (mxWindow.activeWindow != this) {
    const style = getCurrentStyle(this.getElement());
    const index = style != null ? style.zIndex : 3;
    if (mxWindow.activeWindow) {
      const elt = mxWindow.activeWindow.getElement();
      if (elt != null && elt.style != null) {
        elt.style.zIndex = index;
      }
    }
    const previousWindow = mxWindow.activeWindow;
    this.getElement().style.zIndex = parseInt(index) + 1;
    mxWindow.activeWindow = this;
    this.fireEvent(new mxEventObject2(mxEvent2.ACTIVATE, "previousWindow", previousWindow));
  }
};
mxWindow.prototype.getElement = function() {
  return this.div;
};
mxWindow.prototype.fit = function() {
  fit(this.div);
};
mxWindow.prototype.isResizable = function() {
  if (this.resize != null) {
    return this.resize.style.display != "none";
  }
  return false;
};
mxWindow.prototype.setResizable = function(resizable) {
  if (resizable) {
    if (this.resize == null) {
      this.resize = document.createElement("img");
      this.resize.style.position = "absolute";
      this.resize.style.bottom = "2px";
      this.resize.style.right = "2px";
      this.resize.setAttribute("src", this.resizeImage);
      this.resize.style.cursor = "nw-resize";
      let startX = null;
      let startY = null;
      let width = null;
      let height = null;
      const start = bind(this, function(evt) {
        this.activate();
        startX = mxEvent2.getClientX(evt);
        startY = mxEvent2.getClientY(evt);
        width = this.div.offsetWidth;
        height = this.div.offsetHeight;
        mxEvent2.addGestureListeners(document, null, dragHandler, dropHandler);
        this.fireEvent(new mxEventObject2(mxEvent2.RESIZE_START, "event", evt));
        mxEvent2.consume(evt);
      });
      const dragHandler = bind(this, function(evt) {
        if (startX != null && startY != null) {
          const dx = mxEvent2.getClientX(evt) - startX;
          const dy = mxEvent2.getClientY(evt) - startY;
          this.setSize(width + dx, height + dy);
          this.fireEvent(new mxEventObject2(mxEvent2.RESIZE, "event", evt));
          mxEvent2.consume(evt);
        }
      });
      const dropHandler = bind(this, function(evt) {
        if (startX != null && startY != null) {
          startX = null;
          startY = null;
          mxEvent2.removeGestureListeners(document, null, dragHandler, dropHandler);
          this.fireEvent(new mxEventObject2(mxEvent2.RESIZE_END, "event", evt));
          mxEvent2.consume(evt);
        }
      });
      mxEvent2.addGestureListeners(this.resize, start, dragHandler, dropHandler);
      this.div.appendChild(this.resize);
    } else {
      this.resize.style.display = "inline";
    }
  } else if (this.resize != null) {
    this.resize.style.display = "none";
  }
};
mxWindow.prototype.setSize = function(width, height) {
  width = Math.max(this.minimumSize.width, width);
  height = Math.max(this.minimumSize.height, height);
  if (!mxClient_default.IS_QUIRKS) {
    this.div.style.width = width + "px";
    this.div.style.height = height + "px";
  }
  this.table.style.width = width + "px";
  this.table.style.height = height + "px";
  if (!mxClient_default.IS_QUIRKS) {
    this.contentWrapper.style.height = this.div.offsetHeight - this.title.offsetHeight - this.contentHeightCorrection + "px";
  }
};
mxWindow.prototype.setMinimizable = function(minimizable) {
  this.minimize.style.display = minimizable ? "" : "none";
};
mxWindow.prototype.getMinimumSize = function() {
  return new mxRectangle(0, 0, 0, this.title.offsetHeight);
};
mxWindow.prototype.installMinimizeHandler = function() {
  this.minimize = document.createElement("img");
  this.minimize.setAttribute("src", this.minimizeImage);
  this.minimize.setAttribute("title", "Minimize");
  this.minimize.style.cursor = "pointer";
  this.minimize.style.marginLeft = "2px";
  this.minimize.style.display = "none";
  this.buttons.appendChild(this.minimize);
  let minimized = false;
  let maxDisplay = null;
  let height = null;
  const funct = bind(this, function(evt) {
    this.activate();
    if (!minimized) {
      minimized = true;
      this.minimize.setAttribute("src", this.normalizeImage);
      this.minimize.setAttribute("title", "Normalize");
      this.contentWrapper.style.display = "none";
      maxDisplay = this.maximize.style.display;
      this.maximize.style.display = "none";
      height = this.table.style.height;
      const minSize = this.getMinimumSize();
      if (minSize.height > 0) {
        if (!mxClient_default.IS_QUIRKS) {
          this.div.style.height = minSize.height + "px";
        }
        this.table.style.height = minSize.height + "px";
      }
      if (minSize.width > 0) {
        if (!mxClient_default.IS_QUIRKS) {
          this.div.style.width = minSize.width + "px";
        }
        this.table.style.width = minSize.width + "px";
      }
      if (this.resize != null) {
        this.resize.style.visibility = "hidden";
      }
      this.fireEvent(new mxEventObject2(mxEvent2.MINIMIZE, "event", evt));
    } else {
      minimized = false;
      this.minimize.setAttribute("src", this.minimizeImage);
      this.minimize.setAttribute("title", "Minimize");
      this.contentWrapper.style.display = "";
      this.maximize.style.display = maxDisplay;
      if (!mxClient_default.IS_QUIRKS) {
        this.div.style.height = height;
      }
      this.table.style.height = height;
      if (this.resize != null) {
        this.resize.style.visibility = "";
      }
      this.fireEvent(new mxEventObject2(mxEvent2.NORMALIZE, "event", evt));
    }
    mxEvent2.consume(evt);
  });
  mxEvent2.addGestureListeners(this.minimize, funct);
};
mxWindow.prototype.setMaximizable = function(maximizable) {
  this.maximize.style.display = maximizable ? "" : "none";
};
mxWindow.prototype.installMaximizeHandler = function() {
  this.maximize = document.createElement("img");
  this.maximize.setAttribute("src", this.maximizeImage);
  this.maximize.setAttribute("title", "Maximize");
  this.maximize.style.cursor = "default";
  this.maximize.style.marginLeft = "2px";
  this.maximize.style.cursor = "pointer";
  this.maximize.style.display = "none";
  this.buttons.appendChild(this.maximize);
  let maximized = false;
  let x = null;
  let y = null;
  let height = null;
  let width = null;
  let minDisplay = null;
  const funct = bind(this, function(evt) {
    this.activate();
    if (this.maximize.style.display != "none") {
      if (!maximized) {
        maximized = true;
        this.maximize.setAttribute("src", this.normalizeImage);
        this.maximize.setAttribute("title", "Normalize");
        this.contentWrapper.style.display = "";
        minDisplay = this.minimize.style.display;
        this.minimize.style.display = "none";
        x = parseInt(this.div.style.left);
        y = parseInt(this.div.style.top);
        height = this.table.style.height;
        width = this.table.style.width;
        this.div.style.left = "0px";
        this.div.style.top = "0px";
        const docHeight = Math.max(document.body.clientHeight || 0, document.documentElement.clientHeight || 0);
        if (!mxClient_default.IS_QUIRKS) {
          this.div.style.width = document.body.clientWidth - 2 + "px";
          this.div.style.height = docHeight - 2 + "px";
        }
        this.table.style.width = document.body.clientWidth - 2 + "px";
        this.table.style.height = docHeight - 2 + "px";
        if (this.resize != null) {
          this.resize.style.visibility = "hidden";
        }
        if (!mxClient_default.IS_QUIRKS) {
          const style = getCurrentStyle(this.contentWrapper);
          if (style.overflow == "auto" || this.resize != null) {
            this.contentWrapper.style.height = this.div.offsetHeight - this.title.offsetHeight - this.contentHeightCorrection + "px";
          }
        }
        this.fireEvent(new mxEventObject2(mxEvent2.MAXIMIZE, "event", evt));
      } else {
        maximized = false;
        this.maximize.setAttribute("src", this.maximizeImage);
        this.maximize.setAttribute("title", "Maximize");
        this.contentWrapper.style.display = "";
        this.minimize.style.display = minDisplay;
        this.div.style.left = x + "px";
        this.div.style.top = y + "px";
        if (!mxClient_default.IS_QUIRKS) {
          this.div.style.height = height;
          this.div.style.width = width;
          const style = getCurrentStyle(this.contentWrapper);
          if (style.overflow == "auto" || this.resize != null) {
            this.contentWrapper.style.height = this.div.offsetHeight - this.title.offsetHeight - this.contentHeightCorrection + "px";
          }
        }
        this.table.style.height = height;
        this.table.style.width = width;
        if (this.resize != null) {
          this.resize.style.visibility = "";
        }
        this.fireEvent(new mxEventObject2(mxEvent2.NORMALIZE, "event", evt));
      }
      mxEvent2.consume(evt);
    }
  });
  mxEvent2.addGestureListeners(this.maximize, funct);
  mxEvent2.addListener(this.title, "dblclick", funct);
};
mxWindow.prototype.installMoveHandler = function() {
  this.title.style.cursor = "move";
  mxEvent2.addGestureListeners(this.title, bind(this, function(evt) {
    const startX = mxEvent2.getClientX(evt);
    const startY = mxEvent2.getClientY(evt);
    const x = this.getX();
    const y = this.getY();
    const dragHandler = bind(this, function(evt2) {
      const dx = mxEvent2.getClientX(evt2) - startX;
      const dy = mxEvent2.getClientY(evt2) - startY;
      this.setLocation(x + dx, y + dy);
      this.fireEvent(new mxEventObject2(mxEvent2.MOVE, "event", evt2));
      mxEvent2.consume(evt2);
    });
    const dropHandler = bind(this, function(evt2) {
      mxEvent2.removeGestureListeners(document, null, dragHandler, dropHandler);
      this.fireEvent(new mxEventObject2(mxEvent2.MOVE_END, "event", evt2));
      mxEvent2.consume(evt2);
    });
    mxEvent2.addGestureListeners(document, null, dragHandler, dropHandler);
    this.fireEvent(new mxEventObject2(mxEvent2.MOVE_START, "event", evt));
    mxEvent2.consume(evt);
  }));
  if (mxClient_default.IS_POINTER) {
    this.title.style.touchAction = "none";
  }
};
mxWindow.prototype.setLocation = function(x, y) {
  this.div.style.left = x + "px";
  this.div.style.top = y + "px";
};
mxWindow.prototype.getX = function() {
  return parseInt(this.div.style.left);
};
mxWindow.prototype.getY = function() {
  return parseInt(this.div.style.top);
};
mxWindow.prototype.installCloseHandler = function() {
  this.closeImg = document.createElement("img");
  this.closeImg.setAttribute("src", this.closeImage);
  this.closeImg.setAttribute("title", "Close");
  this.closeImg.style.marginLeft = "2px";
  this.closeImg.style.cursor = "pointer";
  this.closeImg.style.display = "none";
  this.buttons.appendChild(this.closeImg);
  mxEvent2.addGestureListeners(this.closeImg, bind(this, function(evt) {
    this.fireEvent(new mxEventObject2(mxEvent2.CLOSE, "event", evt));
    if (this.destroyOnClose) {
      this.destroy();
    } else {
      this.setVisible(false);
    }
    mxEvent2.consume(evt);
  }));
};
mxWindow.prototype.setImage = function(image) {
  this.image = document.createElement("img");
  this.image.setAttribute("src", image);
  this.image.setAttribute("align", "left");
  this.image.style.marginRight = "4px";
  this.image.style.marginLeft = "0px";
  this.image.style.marginTop = "-2px";
  this.title.insertBefore(this.image, this.title.firstChild);
};
mxWindow.prototype.setClosable = function(closable) {
  this.closeImg.style.display = closable ? "" : "none";
};
mxWindow.prototype.isVisible = function() {
  if (this.div != null) {
    return this.div.style.display != "none";
  }
  return false;
};
mxWindow.prototype.setVisible = function(visible) {
  if (this.div != null && this.isVisible() != visible) {
    if (visible) {
      this.show();
    } else {
      this.hide();
    }
  }
};
mxWindow.prototype.show = function() {
  this.div.style.display = "";
  this.activate();
  const style = getCurrentStyle(this.contentWrapper);
  if (!mxClient_default.IS_QUIRKS && (style.overflow == "auto" || this.resize != null) && this.contentWrapper.style.display != "none") {
    this.contentWrapper.style.height = this.div.offsetHeight - this.title.offsetHeight - this.contentHeightCorrection + "px";
  }
  this.fireEvent(new mxEventObject2(mxEvent2.SHOW));
};
mxWindow.prototype.hide = function() {
  this.div.style.display = "none";
  this.fireEvent(new mxEventObject2(mxEvent2.HIDE));
};
mxWindow.prototype.destroy = function() {
  this.fireEvent(new mxEventObject2(mxEvent2.DESTROY));
  if (this.div != null) {
    mxEvent2.release(this.div);
    this.div.parentNode.removeChild(this.div);
    this.div = null;
  }
  this.title = null;
  this.content = null;
  this.contentWrapper = null;
};

// js/graph/mxXmlRequest.js
var mxXmlRequest2 = function(url, params, method, async, username, password) {
  this.url = url;
  this.params = params;
  this.method = method || "POST";
  this.async = async != null ? async : true;
  this.username = username;
  this.password = password;
};
mxXmlRequest2.prototype.url = null;
mxXmlRequest2.prototype.params = null;
mxXmlRequest2.prototype.method = null;
mxXmlRequest2.prototype.async = null;
mxXmlRequest2.prototype.binary = false;
mxXmlRequest2.prototype.withCredentials = false;
mxXmlRequest2.prototype.username = null;
mxXmlRequest2.prototype.password = null;
mxXmlRequest2.prototype.request = null;
mxXmlRequest2.prototype.decodeSimulateValues = false;
mxXmlRequest2.prototype.isBinary = function() {
  return this.binary;
};
mxXmlRequest2.prototype.setBinary = function(value) {
  this.binary = value;
};
mxXmlRequest2.prototype.getText = function() {
  return this.request.responseText;
};
mxXmlRequest2.prototype.isReady = function() {
  return this.request.readyState === 4;
};
mxXmlRequest2.prototype.getDocumentElement = function() {
  const doc = this.getXml();
  if (doc != null) {
    return doc.documentElement;
  }
  return null;
};
mxXmlRequest2.prototype.getXml = function() {
  let xml2 = this.request.responseXML;
  if (document.documentMode >= 9 || xml2 == null || xml2.documentElement == null) {
    xml2 = parseXml(this.request.responseText);
  }
  return xml2;
};
mxXmlRequest2.prototype.getStatus = function() {
  return this.request != null ? this.request.status : null;
};
mxXmlRequest2.prototype.create = function() {
  if (window.XMLHttpRequest) {
    return function() {
      const req = new XMLHttpRequest();
      if (this.isBinary() && req.overrideMimeType) {
        req.overrideMimeType("text/plain; charset=x-user-defined");
      }
      return req;
    };
  } else if (typeof ActiveXObject !== "undefined") {
    return function() {
      return new ActiveXObject("Microsoft.XMLHTTP");
    };
  }
}();
mxXmlRequest2.prototype.send = function(onload, onerror, timeout, ontimeout) {
  this.request = this.create();
  if (this.request != null) {
    if (onload != null) {
      this.request.onreadystatechange = bind(this, function() {
        if (this.isReady()) {
          onload(this);
          this.request.onreadystatechange = null;
        }
      });
    }
    this.request.open(this.method, this.url, this.async, this.username, this.password);
    this.setRequestHeaders(this.request, this.params);
    if (window.XMLHttpRequest && this.withCredentials) {
      this.request.withCredentials = "true";
    }
    if (!mxClient_default.IS_QUIRKS && (document.documentMode == null || document.documentMode > 9) && window.XMLHttpRequest && timeout != null && ontimeout != null) {
      this.request.timeout = timeout;
      this.request.ontimeout = ontimeout;
    }
    this.request.send(this.params);
  }
};
mxXmlRequest2.prototype.setRequestHeaders = function(request, params) {
  if (params != null) {
    request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
  }
};
mxXmlRequest2.prototype.simulate = function(doc, target) {
  doc = doc || document;
  let old = null;
  if (doc === document) {
    old = window.onbeforeunload;
    window.onbeforeunload = null;
  }
  const form = doc.createElement("form");
  form.setAttribute("method", this.method);
  form.setAttribute("action", this.url);
  if (target != null) {
    form.setAttribute("target", target);
  }
  form.style.display = "none";
  form.style.visibility = "hidden";
  const pars = this.params.indexOf("&") > 0 ? this.params.split("&") : this.params.split();
  for (let i = 0; i < pars.length; i++) {
    const pos = pars[i].indexOf("=");
    if (pos > 0) {
      const name = pars[i].substring(0, pos);
      let value = pars[i].substring(pos + 1);
      if (this.decodeSimulateValues) {
        value = decodeURIComponent(value);
      }
      const textarea = doc.createElement("textarea");
      textarea.setAttribute("wrap", "off");
      textarea.setAttribute("name", name);
      write(textarea, value);
      form.appendChild(textarea);
    }
  }
  doc.body.appendChild(form);
  form.submit();
  if (form.parentNode != null) {
    form.parentNode.removeChild(form);
  }
  if (old != null) {
    window.onbeforeunload = old;
  }
};

// js/graph/mxLog.js
var mxLog = {
  consoleName: "Console",
  TRACE: false,
  DEBUG: true,
  WARN: true,
  buffer: "",
  init: function() {
    if (mxLog.window == null && document.body != null) {
      const title = `${mxLog.consoleName} - mxGraph ${mxClient_default.VERSION}`;
      const table = document.createElement("table");
      table.setAttribute("width", "100%");
      table.setAttribute("height", "100%");
      const tbody = document.createElement("tbody");
      let tr = document.createElement("tr");
      const td = document.createElement("td");
      td.style.verticalAlign = "top";
      mxLog.textarea = document.createElement("textarea");
      mxLog.textarea.setAttribute("wrap", "off");
      mxLog.textarea.setAttribute("readOnly", "true");
      mxLog.textarea.style.height = "100%";
      mxLog.textarea.style.resize = "none";
      mxLog.textarea.value = mxLog.buffer;
      if (mxClient_default.IS_NS && document.compatMode !== "BackCompat") {
        mxLog.textarea.style.width = "99%";
      } else {
        mxLog.textarea.style.width = "100%";
      }
      td.appendChild(mxLog.textarea);
      tr.appendChild(td);
      tbody.appendChild(tr);
      tr = document.createElement("tr");
      mxLog.td = document.createElement("td");
      mxLog.td.style.verticalAlign = "top";
      mxLog.td.setAttribute("height", "30px");
      tr.appendChild(mxLog.td);
      tbody.appendChild(tr);
      table.appendChild(tbody);
      mxLog.addButton("Info", function() {
        mxLog.info();
      });
      mxLog.addButton("DOM", function() {
        const content = getInnerHtml(document.body);
        mxLog.debug(content);
      });
      mxLog.addButton("Trace", function() {
        mxLog.TRACE = !mxLog.TRACE;
        mxLog.debug(mxLog.TRACE ? "Tracing enabled" : "Tracing disabled");
      });
      mxLog.addButton("Copy", function() {
        try {
          (void 0)(mxLog.textarea.value);
        } catch (err) {
          alert2(err);
        }
      });
      mxLog.addButton("Show", function() {
        try {
          popup(mxLog.textarea.value);
        } catch (err) {
          alert2(err);
        }
      });
      mxLog.addButton("Clear", function() {
        mxLog.textarea.value = "";
      });
      let h2 = 0, w2 = 0;
      if (typeof window.innerWidth === "number") {
        h2 = window.innerHeight;
        w2 = window.innerWidth;
      } else {
        h2 = document.documentElement.clientHeight || document.body.clientHeight;
        w2 = document.body.clientWidth;
      }
      mxLog.window = new mxWindow(title, table, Math.max(0, w2 - 320), Math.max(0, h2 - 210), 300, 160);
      mxLog.window.setMaximizable(true);
      mxLog.window.setScrollable(false);
      mxLog.window.setResizable(true);
      mxLog.window.setClosable(true);
      mxLog.window.destroyOnClose = false;
      if ((mxClient_default.IS_NS || mxClient_default.IS_IE) && !mxClient_default.IS_GC && !mxClient_default.IS_SF && document.compatMode !== "BackCompat" || document.documentMode === 11) {
        const elt = mxLog.window.getElement();
        const resizeHandler = function() {
          mxLog.textarea.style.height = `${Math.max(0, elt.offsetHeight - 70)}px`;
        };
        mxLog.window.addListener(mxEvent2.RESIZE_END, resizeHandler);
        mxLog.window.addListener(mxEvent2.MAXIMIZE, resizeHandler);
        mxLog.window.addListener(mxEvent2.NORMALIZE, resizeHandler);
        mxLog.textarea.style.height = "92px";
      }
    }
  },
  info: function() {
    mxLog.writeln(toString(navigator));
  },
  addButton: function(lab, funct) {
    const button2 = document.createElement("button");
    write(button2, lab);
    mxEvent2.addListener(button2, "click", funct);
    mxLog.td.appendChild(button2);
  },
  isVisible: function() {
    return mxLog.window ? mxLog.window.isVisible() : false;
  },
  show: function() {
    mxLog.setVisible(true);
  },
  setVisible: function(visible) {
    if (mxLog.window == null) {
      mxLog.init();
    }
    if (mxLog.window != null) {
      mxLog.window.setVisible(visible);
    }
  },
  enter: function(string) {
    if (mxLog.TRACE) {
      mxLog.writeln(`Entering ${string}`);
      return Date.now();
    }
  },
  leave: function(string, t0) {
    if (mxLog.TRACE) {
      const dt = t0 ? ` (${Date.now() - t0} ms)` : "";
      mxLog.writeln(`Leaving ${string}${dt}`);
    }
  },
  debug: function() {
    if (mxLog.DEBUG) {
      mxLog.writeln.apply(this, arguments);
    }
  },
  warn: function() {
    if (mxLog.WARN) {
      mxLog.writeln.apply(this, arguments);
    }
  },
  write: function() {
    let string = "";
    for (let i = 0; i < arguments.length; i++) {
      string += arguments[i] + (i < arguments.length - 1 ? " " : "");
    }
    if (mxLog.textarea != null) {
      mxLog.textarea.value += string;
      if (navigator.userAgent != null && navigator.userAgent.indexOf("Presto/2.5") >= 0) {
        mxLog.textarea.style.visibility = "hidden";
        mxLog.textarea.style.visibility = "visible";
      }
      mxLog.textarea.scrollTop = mxLog.textarea.scrollHeight;
    } else {
      mxLog.buffer += string;
    }
  },
  writeln: function() {
    let string = "";
    for (let i = 0; i < arguments.length; i++) {
      string += arguments[i] + (i < arguments.length - 1 ? " " : "");
    }
    mxLog.write(`${string}
`);
  }
};

// js/graph/mxCell.js
function mxCell(value, geometry, style) {
  this.value = value;
  this.setGeometry(geometry);
  this.setStyle(style);
  if (this.onInit != null) {
    this.onInit();
  }
}
mxCell.prototype.id = null;
mxCell.prototype.value = null;
mxCell.prototype.geometry = null;
mxCell.prototype.style = null;
mxCell.prototype.vertex = false;
mxCell.prototype.edge = false;
mxCell.prototype.connectable = true;
mxCell.prototype.visible = true;
mxCell.prototype.collapsed = false;
mxCell.prototype.parent = null;
mxCell.prototype.source = null;
mxCell.prototype.target = null;
mxCell.prototype.children = null;
mxCell.prototype.edges = null;
mxCell.prototype.mxTransient = [
  "id",
  "value",
  "parent",
  "source",
  "target",
  "children",
  "edges"
];
mxCell.prototype.getId = function() {
  return this.id;
};
mxCell.prototype.setId = function(id) {
  this.id = id;
};
mxCell.prototype.getValue = function() {
  return this.value;
};
mxCell.prototype.setValue = function(value) {
  this.value = value;
};
mxCell.prototype.valueChanged = function(newValue) {
  const previous = this.getValue();
  this.setValue(newValue);
  return previous;
};
mxCell.prototype.getGeometry = function() {
  return this.geometry;
};
mxCell.prototype.setGeometry = function(geometry) {
  this.geometry = geometry;
};
mxCell.prototype.getStyle = function() {
  return this.style;
};
mxCell.prototype.setStyle = function(style) {
  this.style = style;
};
mxCell.prototype.isVertex = function() {
  return this.vertex != 0;
};
mxCell.prototype.setVertex = function(vertex) {
  this.vertex = vertex;
};
mxCell.prototype.isEdge = function() {
  return this.edge != 0;
};
mxCell.prototype.setEdge = function(edge) {
  this.edge = edge;
};
mxCell.prototype.isConnectable = function() {
  return this.connectable != 0;
};
mxCell.prototype.setConnectable = function(connectable) {
  this.connectable = connectable;
};
mxCell.prototype.isVisible = function() {
  return this.visible != 0;
};
mxCell.prototype.setVisible = function(visible) {
  this.visible = visible;
};
mxCell.prototype.isCollapsed = function() {
  return this.collapsed != 0;
};
mxCell.prototype.setCollapsed = function(collapsed) {
  this.collapsed = collapsed;
};
mxCell.prototype.getParent = function() {
  return this.parent;
};
mxCell.prototype.setParent = function(parent2) {
  this.parent = parent2;
};
mxCell.prototype.getTerminal = function(source) {
  return source ? this.source : this.target;
};
mxCell.prototype.setTerminal = function(terminal, isSource) {
  if (isSource) {
    this.source = terminal;
  } else {
    this.target = terminal;
  }
  return terminal;
};
mxCell.prototype.getChildCount = function() {
  return this.children == null ? 0 : this.children.length;
};
mxCell.prototype.getIndex = function(child) {
  return indexOf(this.children, child);
};
mxCell.prototype.getChildAt = function(index) {
  return this.children == null ? null : this.children[index];
};
mxCell.prototype.insert = function(child, index) {
  if (child != null) {
    if (index == null) {
      index = this.getChildCount();
      if (child.getParent() == this) {
        index--;
      }
    }
    child.removeFromParent();
    child.setParent(this);
    if (this.children == null) {
      this.children = [];
      this.children.push(child);
    } else {
      this.children.splice(index, 0, child);
    }
  }
  return child;
};
mxCell.prototype.remove = function(index) {
  let child = null;
  if (this.children != null && index >= 0) {
    child = this.getChildAt(index);
    if (child != null) {
      this.children.splice(index, 1);
      child.setParent(null);
    }
  }
  return child;
};
mxCell.prototype.removeFromParent = function() {
  if (this.parent != null) {
    const index = this.parent.getIndex(this);
    this.parent.remove(index);
  }
};
mxCell.prototype.getEdgeCount = function() {
  return this.edges == null ? 0 : this.edges.length;
};
mxCell.prototype.getEdgeIndex = function(edge) {
  return indexOf(this.edges, edge);
};
mxCell.prototype.getEdgeAt = function(index) {
  return this.edges == null ? null : this.edges[index];
};
mxCell.prototype.insertEdge = function(edge, isOutgoing) {
  if (edge != null) {
    edge.removeFromTerminal(isOutgoing);
    edge.setTerminal(this, isOutgoing);
    if (this.edges == null || edge.getTerminal(!isOutgoing) != this || indexOf(this.edges, edge) < 0) {
      if (this.edges == null) {
        this.edges = [];
      }
      this.edges.push(edge);
    }
  }
  return edge;
};
mxCell.prototype.removeEdge = function(edge, isOutgoing) {
  if (edge != null) {
    if (edge.getTerminal(!isOutgoing) != this && this.edges != null) {
      const index = this.getEdgeIndex(edge);
      if (index >= 0) {
        this.edges.splice(index, 1);
      }
    }
    edge.setTerminal(null, isOutgoing);
  }
  return edge;
};
mxCell.prototype.removeFromTerminal = function(isSource) {
  const terminal = this.getTerminal(isSource);
  if (terminal != null) {
    terminal.removeEdge(this, isSource);
  }
};
mxCell.prototype.hasAttribute = function(name) {
  const userObject = this.getValue();
  return userObject != null && userObject.nodeType == mxConstants2.NODETYPE_ELEMENT && userObject.hasAttribute ? userObject.hasAttribute(name) : userObject.getAttribute(name) != null;
};
mxCell.prototype.getAttribute = function(name, defaultValue) {
  const userObject = this.getValue();
  const val = userObject != null && userObject.nodeType == mxConstants2.NODETYPE_ELEMENT ? userObject.getAttribute(name) : null;
  return val != null ? val : defaultValue;
};
mxCell.prototype.setAttribute = function(name, value) {
  const userObject = this.getValue();
  if (userObject != null && userObject.nodeType == mxConstants2.NODETYPE_ELEMENT) {
    userObject.setAttribute(name, value);
  }
};
mxCell.prototype.clone = function() {
  const clone3 = clone(this, this.mxTransient);
  clone3.setValue(this.cloneValue());
  return clone3;
};
mxCell.prototype.cloneValue = function() {
  let value = this.getValue();
  if (value != null) {
    if (typeof value.clone == "function") {
      value = value.clone();
    } else if (!isNaN(value.nodeType)) {
      value = value.cloneNode(true);
    }
  }
  return value;
};

// js/graph/mxCellPath.js
var PATH_SEPARATOR = ".";
var create = function(cell2) {
  let result2 = "";
  if (cell2 != null) {
    let parent2 = cell2.getParent();
    while (parent2 != null) {
      const index = parent2.getIndex(cell2);
      result2 = index + PATH_SEPARATOR + result2;
      cell2 = parent2;
      parent2 = cell2.getParent();
    }
  }
  const n = result2.length;
  if (n > 1) {
    result2 = result2.substring(0, n - 1);
  }
  return result2;
};
var getParentPath = function(path) {
  if (path != null) {
    const index = path.lastIndexOf(PATH_SEPARATOR);
    if (index >= 0) {
      return path.substring(0, index);
    } else if (path.length > 0) {
      return "";
    }
  }
  return null;
};
var resolve = function(root, path) {
  let parent2 = root;
  if (path != null) {
    const tokens = path.split(PATH_SEPARATOR);
    for (let i = 0; i < tokens.length; i++) {
      parent2 = parent2.getChildAt(parseInt(tokens[i], 10));
    }
  }
  return parent2;
};
var compare = function(p1, p2) {
  const min = Math.min(p1.length, p2.length);
  let comp = 0;
  for (let i = 0; i < min; i++) {
    if (p1[i] !== p2[i]) {
      if (p1[i].length === 0 || p2[i].length === 0) {
        comp = p1[i] === p2[i] ? 0 : p1[i] > p2[i] ? 1 : -1;
      } else {
        const t1 = parseInt(p1[i], 10);
        const t2 = parseInt(p2[i], 10);
        comp = t1 === t2 ? 0 : t1 > t2 ? 1 : -1;
      }
      break;
    }
  }
  if (comp === 0) {
    const t1 = p1.length;
    const t2 = p2.length;
    if (t1 !== t2) {
      comp = t1 > t2 ? 1 : -1;
    }
  }
  return comp;
};
var mxCellPath = {
  PATH_SEPARATOR,
  create,
  getParentPath,
  resolve,
  compare
};
var mxCellPath_default = mxCellPath;

// js/graph/mxObjectIdentity.js
var mxObjectIdentity = {
  FIELD_NAME: "mxObjectId",
  counter: 0,
  get: function(obj) {
    if (obj != null) {
      if (obj[this.FIELD_NAME] == null) {
        if (typeof obj === "object") {
          const ctor = getFunctionName(obj.constructor);
          obj[this.FIELD_NAME] = `${ctor}#${mxObjectIdentity.counter++}`;
        } else if (typeof obj === "function") {
          obj[this.FIELD_NAME] = `Function#${mxObjectIdentity.counter++}`;
        }
      }
      return obj[this.FIELD_NAME];
    }
    return null;
  },
  clear: function(obj) {
    if (typeof obj === "object" || typeof obj === "function") {
      delete obj[this.FIELD_NAME];
    }
  }
};

// js/graph/mxGeometry.js
var mxGeometry = function(x, y, width, height) {
  mxRectangle.call(this, x, y, width, height);
};
mxGeometry.prototype = new mxRectangle();
mxGeometry.prototype.constructor = mxGeometry;
mxGeometry.prototype.TRANSLATE_CONTROL_POINTS = true;
mxGeometry.prototype.alternateBounds = null;
mxGeometry.prototype.sourcePoint = null;
mxGeometry.prototype.targetPoint = null;
mxGeometry.prototype.points = null;
mxGeometry.prototype.offset = null;
mxGeometry.prototype.relative = false;
mxGeometry.prototype.swap = function() {
  if (this.alternateBounds != null) {
    const old = new mxRectangle(this.x, this.y, this.width, this.height);
    this.x = this.alternateBounds.x;
    this.y = this.alternateBounds.y;
    this.width = this.alternateBounds.width;
    this.height = this.alternateBounds.height;
    this.alternateBounds = old;
  }
};
mxGeometry.prototype.getTerminalPoint = function(isSource) {
  return isSource ? this.sourcePoint : this.targetPoint;
};
mxGeometry.prototype.setTerminalPoint = function(point, isSource) {
  if (isSource) {
    this.sourcePoint = point;
  } else {
    this.targetPoint = point;
  }
  return point;
};
mxGeometry.prototype.rotate = function(angle, cx) {
  const rad = toRadians(angle);
  const cos = Math.cos(rad);
  const sin = Math.sin(rad);
  if (!this.relative) {
    const ct = new mxPoint2(this.getCenterX(), this.getCenterY());
    const pt = getRotatedPoint(ct, cos, sin, cx);
    this.x = Math.round(pt.x - this.width / 2);
    this.y = Math.round(pt.y - this.height / 2);
  }
  if (this.sourcePoint != null) {
    const pt = getRotatedPoint(this.sourcePoint, cos, sin, cx);
    this.sourcePoint.x = Math.round(pt.x);
    this.sourcePoint.y = Math.round(pt.y);
  }
  if (this.targetPoint != null) {
    const pt = getRotatedPoint(this.targetPoint, cos, sin, cx);
    this.targetPoint.x = Math.round(pt.x);
    this.targetPoint.y = Math.round(pt.y);
  }
  if (this.points != null) {
    for (let i = 0; i < this.points.length; i++) {
      if (this.points[i] != null) {
        const pt = getRotatedPoint(this.points[i], cos, sin, cx);
        this.points[i].x = Math.round(pt.x);
        this.points[i].y = Math.round(pt.y);
      }
    }
  }
};
mxGeometry.prototype.translate = function(dx, dy) {
  dx = parseFloat(dx);
  dy = parseFloat(dy);
  if (!this.relative) {
    this.x = parseFloat(this.x) + dx;
    this.y = parseFloat(this.y) + dy;
  }
  if (this.sourcePoint != null) {
    this.sourcePoint.x = parseFloat(this.sourcePoint.x) + dx;
    this.sourcePoint.y = parseFloat(this.sourcePoint.y) + dy;
  }
  if (this.targetPoint != null) {
    this.targetPoint.x = parseFloat(this.targetPoint.x) + dx;
    this.targetPoint.y = parseFloat(this.targetPoint.y) + dy;
  }
  if (this.TRANSLATE_CONTROL_POINTS && this.points != null) {
    for (let i = 0; i < this.points.length; i++) {
      if (this.points[i] != null) {
        this.points[i].x = parseFloat(this.points[i].x) + dx;
        this.points[i].y = parseFloat(this.points[i].y) + dy;
      }
    }
  }
};
mxGeometry.prototype.scale = function(sx, sy, fixedAspect) {
  sx = parseFloat(sx);
  sy = parseFloat(sy);
  if (this.sourcePoint != null) {
    this.sourcePoint.x = parseFloat(this.sourcePoint.x) * sx;
    this.sourcePoint.y = parseFloat(this.sourcePoint.y) * sy;
  }
  if (this.targetPoint != null) {
    this.targetPoint.x = parseFloat(this.targetPoint.x) * sx;
    this.targetPoint.y = parseFloat(this.targetPoint.y) * sy;
  }
  if (this.points != null) {
    for (let i = 0; i < this.points.length; i++) {
      if (this.points[i] != null) {
        this.points[i].x = parseFloat(this.points[i].x) * sx;
        this.points[i].y = parseFloat(this.points[i].y) * sy;
      }
    }
  }
  if (!this.relative) {
    this.x = parseFloat(this.x) * sx;
    this.y = parseFloat(this.y) * sy;
    if (fixedAspect) {
      sy = sx = Math.min(sx, sy);
    }
    this.width = parseFloat(this.width) * sx;
    this.height = parseFloat(this.height) * sy;
  }
};
mxGeometry.prototype.equals = function(obj) {
  return mxRectangle.prototype.equals.apply(this, arguments) && this.relative === obj.relative && (this.sourcePoint == null && obj.sourcePoint == null || this.sourcePoint != null && this.sourcePoint.equals(obj.sourcePoint)) && (this.targetPoint == null && obj.targetPoint == null || this.targetPoint != null && this.targetPoint.equals(obj.targetPoint)) && (this.points == null && obj.points == null || this.points != null && equalPoints(this.points, obj.points)) && (this.alternateBounds == null && obj.alternateBounds == null || this.alternateBounds != null && this.alternateBounds.equals(obj.alternateBounds)) && (this.offset == null && obj.offset == null || this.offset != null && this.offset.equals(obj.offset));
};
mxGeometry.prototype.clone = function() {
  const clone3 = new mxGeometry(this.x, this.y, this.width, this.height);
  if (this.points != null) {
    clone3.points = [];
    for (let i = 0; i < this.points.length; i++) {
      clone3.points.push(this.points[i].clone());
    }
  }
  if (this.offset != null) {
    clone3.offset = this.offset.clone();
  }
  if (this.sourcePoint != null) {
    clone3.sourcePoint = this.sourcePoint.clone();
  }
  if (this.targetPoint != null) {
    clone3.targetPoint = this.targetPoint.clone();
  }
  clone3.relative = this.relative;
  if (this.alternateBounds != null) {
    clone3.alternateBounds = this.alternateBounds.clone();
  }
  return clone3;
};

// js/graph/mxRootChange.js
var mxRootChange = function(model, root) {
  this.model = model;
  this.root = root;
  this.previous = root;
};
mxRootChange.prototype.execute = function() {
  this.root = this.previous;
  this.previous = this.model.rootChanged(this.previous);
};
var mxChildChange = function(model, child, parent2, index) {
  this.model = model;
  this.child = child;
  this.parent = parent2;
  this.index = index;
  this.previous = null;
};
mxChildChange.prototype.execute = function() {
};

// js/graph/mxChildChange.js
var mxChildChange2 = function(model, parent2, child, index) {
  this.model = model;
  this.parent = parent2;
  this.previous = parent2;
  this.child = child;
  this.index = index;
  this.previousIndex = index;
};
mxChildChange2.prototype.execute = function() {
  if (this.child != null) {
    let tmp = this.model.getParent(this.child);
    const tmp2 = tmp != null ? tmp.getIndex(this.child) : 0;
    if (this.previous == null) {
      this.connect(this.child, false);
    }
    tmp = this.model.parentForCellChanged(this.child, this.previous, this.previousIndex);
    if (this.previous != null) {
      this.connect(this.child, true);
    }
    this.parent = this.previous;
    this.previous = tmp;
    this.index = this.previousIndex;
    this.previousIndex = tmp2;
  }
};
mxChildChange2.prototype.connect = function(cell2, isConnect) {
  isConnect = isConnect != null ? isConnect : true;
  const source = cell2.getTerminal(true);
  const target = cell2.getTerminal(false);
  if (source != null) {
    if (isConnect) {
      this.model.terminalForCellChanged(cell2, source, true);
    } else {
      this.model.terminalForCellChanged(cell2, null, true);
    }
  }
  if (target != null) {
    if (isConnect) {
      this.model.terminalForCellChanged(cell2, target, false);
    } else {
      this.model.terminalForCellChanged(cell2, null, false);
    }
  }
  cell2.setTerminal(source, true);
  cell2.setTerminal(target, false);
  const childCount = this.model.getChildCount(cell2);
  for (let i = 0; i < childCount; i++) {
    this.connect(this.model.getChildAt(cell2, i), isConnect);
  }
};

// js/graph/mxTerminalChange.js
var mxTerminalChange = function(model, cell2, terminal, source) {
  this.model = model;
  this.cell = cell2;
  this.terminal = terminal;
  this.previous = terminal;
  this.source = source;
};
mxTerminalChange.prototype.execute = function() {
  if (this.cell != null) {
    this.terminal = this.previous;
    this.previous = this.model.terminalForCellChanged(this.cell, this.previous, this.source);
  }
};

// js/graph/mxValueChange.js
var mxValueChange = function(model, cell2, value) {
  this.model = model;
  this.cell = cell2;
  this.value = value;
  this.previous = value;
};
mxValueChange.prototype.execute = function() {
  if (this.cell != null) {
    this.value = this.previous;
    this.previous = this.model.valueForCellChanged(this.cell, this.previous);
  }
};

// js/graph/mxGeometryChange.js
var mxGeometryChange = function(model, cell2, geometry) {
  this.model = model;
  this.cell = cell2;
  this.geometry = geometry;
  this.previous = geometry;
};
mxGeometryChange.prototype.execute = function() {
  if (this.cell != null) {
    this.geometry = this.previous;
    this.previous = this.model.geometryForCellChanged(this.cell, this.previous);
  }
};

// js/graph/mxStyleChange.js
var mxStyleChange = function(model, cell2, style) {
  this.model = model;
  this.cell = cell2;
  this.style = style;
  this.previous = style;
};
mxStyleChange.prototype.execute = function() {
  if (this.cell !== null) {
    this.style = this.previous;
    this.previous = this.model.styleForCellChanged(this.cell, this.previous);
  }
};
var mxGeometryChange2 = function(model, cell2, geometry) {
  this.model = model;
  this.cell = cell2;
  this.geometry = geometry;
  this.previous = geometry;
};
mxGeometryChange2.prototype.execute = function() {
  if (this.cell !== null) {
    this.geometry = this.previous;
    this.previous = this.model.geometryForCellChanged(this.cell, this.previous);
  }
};

// js/graph/mxCollapseChange.js
var mxCollapseChange = function(model, cell2, collapsed) {
  this.model = model;
  this.cell = cell2;
  this.collapsed = collapsed;
  this.previous = collapsed;
};
mxCollapseChange.prototype.execute = function() {
  if (this.cell != null) {
    this.collapsed = this.previous;
    this.previous = this.model.collapsedStateForCellChanged(this.cell, this.previous);
  }
};

// js/graph/mxVisibleChange.js
var mxVisibleChange = function(model, cell2, visible) {
  this.model = model;
  this.cell = cell2;
  this.visible = visible;
  this.previous = visible;
};
mxVisibleChange.prototype.execute = function() {
  if (this.cell != null) {
    this.visible = this.previous;
    this.previous = this.model.visibleStateForCellChanged(this.cell, this.previous);
  }
};
var mxCellAttributeChange = function(cell2, attributeName, attributeValue) {
  this.cell = cell2;
  this.attributeName = attributeName;
  this.value = attributeValue;
  this.previous = cell2.value.getAttribute(attributeName);
};
mxCellAttributeChange.prototype.execute = function() {
  if (this.cell != null && this.cell.value != null) {
    const node = this.cell.value;
    const attr2 = this.attributeName;
    const prev = node.getAttribute(attr2);
    this.previous = prev;
    if (this.value != null) {
      node.setAttribute(attr2, this.value);
    } else {
      node.removeAttribute(attr2);
    }
  }
};

// js/graph/mxUndoableEdit.js
var mxUndoableEdit = function(source, significant) {
  this.source = source;
  this.changes = [];
  this.significant = significant != null ? significant : true;
};
mxUndoableEdit.prototype.source = null;
mxUndoableEdit.prototype.changes = null;
mxUndoableEdit.prototype.significant = null;
mxUndoableEdit.prototype.undone = false;
mxUndoableEdit.prototype.redone = false;
mxUndoableEdit.prototype.isEmpty = function() {
  return this.changes.length === 0;
};
mxUndoableEdit.prototype.isSignificant = function() {
  return this.significant;
};
mxUndoableEdit.prototype.add = function(change) {
  this.changes.push(change);
};
mxUndoableEdit.prototype.notify = function() {
};
mxUndoableEdit.prototype.die = function() {
};
mxUndoableEdit.prototype.undo = function() {
  if (!this.undone) {
    this.source.fireEvent(new mxEventObject2(mxEvent2.START_EDIT));
    const count = this.changes.length;
    for (let i = count - 1; i >= 0; i--) {
      const change = this.changes[i];
      if (change.execute != null) {
        change.execute();
      } else if (change.undo != null) {
        change.undo();
      }
      this.source.fireEvent(new mxEventObject2(mxEvent2.EXECUTED, "change", change));
    }
    this.undone = true;
    this.redone = false;
    this.source.fireEvent(new mxEventObject2(mxEvent2.END_EDIT));
  }
  this.notify();
};
mxUndoableEdit.prototype.redo = function() {
  if (!this.redone) {
    this.source.fireEvent(new mxEventObject2(mxEvent2.START_EDIT));
    const count = this.changes.length;
    for (let i = 0; i < count; i++) {
      const change = this.changes[i];
      if (change.execute != null) {
        change.execute();
      } else if (change.redo != null) {
        change.redo();
      }
      this.source.fireEvent(new mxEventObject2(mxEvent2.EXECUTED, "change", change));
    }
    this.undone = false;
    this.redone = true;
    this.source.fireEvent(new mxEventObject2(mxEvent2.END_EDIT));
  }
  this.notify();
};

// js/graph/mxDictionary.js
function mxDictionary() {
  this.clear();
}
mxDictionary.prototype.map = null;
mxDictionary.prototype.clear = function() {
  this.map = {};
};
mxDictionary.prototype.get = function(key) {
  const id = mxObjectIdentity.get(key);
  return this.map[id];
};
mxDictionary.prototype.put = function(key, value) {
  const id = mxObjectIdentity.get(key);
  const previous = this.map[id];
  this.map[id] = value;
  return previous;
};
mxDictionary.prototype.remove = function(key) {
  const id = mxObjectIdentity.get(key);
  const previous = this.map[id];
  delete this.map[id];
  return previous;
};
mxDictionary.prototype.getKeys = function() {
  const result2 = [];
  for (const key in this.map) {
    result2.push(key);
  }
  return result2;
};
mxDictionary.prototype.getValues = function() {
  const result2 = [];
  for (const key in this.map) {
    result2.push(this.map[key]);
  }
  return result2;
};
mxDictionary.prototype.visit = function(visitor) {
  for (const key in this.map) {
    visitor(key, this.map[key]);
  }
};

// js/graph/mxGraphModel.js
function mxGraphModel2(root) {
  this.currentEdit = this.createUndoableEdit();
  if (root != null) {
    this.setRoot(root);
  } else {
    this.clear();
  }
}
mxGraphModel2.prototype = new mxEventSource();
mxGraphModel2.prototype.constructor = mxGraphModel2;
mxGraphModel2.prototype.root = null;
mxGraphModel2.prototype.cells = null;
mxGraphModel2.prototype.maintainEdgeParent = true;
mxGraphModel2.prototype.ignoreRelativeEdgeParent = true;
mxGraphModel2.prototype.createIds = true;
mxGraphModel2.prototype.prefix = "";
mxGraphModel2.prototype.postfix = "";
mxGraphModel2.prototype.nextId = 0;
mxGraphModel2.prototype.currentEdit = null;
mxGraphModel2.prototype.updateLevel = 0;
mxGraphModel2.prototype.endingUpdate = false;
mxGraphModel2.prototype.clear = function() {
  this.setRoot(this.createRoot());
};
mxGraphModel2.prototype.isCreateIds = function() {
  return this.createIds;
};
mxGraphModel2.prototype.setCreateIds = function(value) {
  this.createIds = value;
};
mxGraphModel2.prototype.createRoot = function() {
  const cell2 = new mxCell();
  cell2.insert(new mxCell());
  return cell2;
};
mxGraphModel2.prototype.getCell = function(id) {
  return this.cells != null ? this.cells[id] : null;
};
mxGraphModel2.prototype.filterCells = function(cells, filter) {
  let result2 = null;
  if (cells != null) {
    result2 = [];
    for (let i = 0; i < cells.length; i++) {
      if (filter(cells[i])) {
        result2.push(cells[i]);
      }
    }
  }
  return result2;
};
mxGraphModel2.prototype.getDescendants = function(parent2) {
  return this.filterDescendants(null, parent2);
};
mxGraphModel2.prototype.filterDescendants = function(filter, parent2) {
  let result2 = [];
  parent2 = parent2 || this.getRoot();
  if (filter == null || filter(parent2)) {
    result2.push(parent2);
  }
  const childCount = this.getChildCount(parent2);
  for (let i = 0; i < childCount; i++) {
    const child = this.getChildAt(parent2, i);
    result2 = result2.concat(this.filterDescendants(filter, child));
  }
  return result2;
};
mxGraphModel2.prototype.getRoot = function(cell2) {
  let root = cell2 || this.root;
  if (cell2 != null) {
    while (cell2 != null) {
      root = cell2;
      cell2 = this.getParent(cell2);
    }
  }
  return root;
};
mxGraphModel2.prototype.setRoot = function(root) {
  this.execute(new mxRootChange(this, root));
  return root;
};
mxGraphModel2.prototype.rootChanged = function(root) {
  const oldRoot = this.root;
  this.root = root;
  this.nextId = 0;
  this.cells = null;
  this.cellAdded(root);
  return oldRoot;
};
mxGraphModel2.prototype.isRoot = function(cell2) {
  return cell2 != null && this.root == cell2;
};
mxGraphModel2.prototype.isLayer = function(cell2) {
  return this.isRoot(this.getParent(cell2));
};
mxGraphModel2.prototype.isAncestor = function(parent2, child) {
  while (child != null && child != parent2) {
    child = this.getParent(child);
  }
  return child == parent2;
};
mxGraphModel2.prototype.contains = function(cell2) {
  return this.isAncestor(this.root, cell2);
};
mxGraphModel2.prototype.getParent = function(cell2) {
  return cell2 != null ? cell2.getParent() : null;
};
mxGraphModel2.prototype.add = function(parent2, child, index) {
  if (child != parent2 && parent2 != null && child != null) {
    if (index == null) {
      index = this.getChildCount(parent2);
    }
    const parentChanged = parent2 != this.getParent(child);
    this.execute(new mxChildChange2(this, parent2, child, index));
    if (this.maintainEdgeParent && parentChanged) {
      this.updateEdgeParents(child);
    }
  }
  return child;
};
mxGraphModel2.prototype.cellAdded = function(cell2) {
  if (cell2 != null) {
    if (cell2.getId() == null && this.createIds) {
      cell2.setId(this.createId(cell2));
    }
    if (cell2.getId() != null) {
      let collision = this.getCell(cell2.getId());
      if (collision != cell2) {
        while (collision != null) {
          cell2.setId(this.createId(cell2));
          collision = this.getCell(cell2.getId());
        }
        if (this.cells == null) {
          this.cells = {};
        }
        this.cells[cell2.getId()] = cell2;
      }
    }
    if (isNumeric(cell2.getId())) {
      this.nextId = Math.max(this.nextId, parseInt(cell2.getId()));
    }
    const childCount = this.getChildCount(cell2);
    for (let i = 0; i < childCount; i++) {
      this.cellAdded(this.getChildAt(cell2, i));
    }
  }
};
mxGraphModel2.prototype.createId = function(cell2) {
  const id = this.nextId;
  this.nextId++;
  return this.prefix + id + this.postfix;
};
mxGraphModel2.prototype.updateEdgeParents = function(cell2, root) {
  root = root || this.getRoot(cell2);
  const childCount = this.getChildCount(cell2);
  for (let i = 0; i < childCount; i++) {
    const child = this.getChildAt(cell2, i);
    this.updateEdgeParents(child, root);
  }
  const edgeCount = this.getEdgeCount(cell2);
  const edges = [];
  for (let i = 0; i < edgeCount; i++) {
    edges.push(this.getEdgeAt(cell2, i));
  }
  for (let i = 0; i < edges.length; i++) {
    const edge = edges[i];
    if (this.isAncestor(root, edge)) {
      this.updateEdgeParent(edge, root);
    }
  }
};
mxGraphModel2.prototype.updateEdgeParent = function(edge, root) {
  let source = this.getTerminal(edge, true);
  let target = this.getTerminal(edge, false);
  let cell2 = null;
  while (source != null && !this.isEdge(source) && source.geometry != null && source.geometry.relative) {
    source = this.getParent(source);
  }
  while (target != null && this.ignoreRelativeEdgeParent && !this.isEdge(target) && target.geometry != null && target.geometry.relative) {
    target = this.getParent(target);
  }
  if (this.isAncestor(root, source) && this.isAncestor(root, target)) {
    if (source == target) {
      cell2 = this.getParent(source);
    } else {
      cell2 = this.getNearestCommonAncestor(source, target);
    }
    if (cell2 != null && (this.getParent(cell2) != this.root || this.isAncestor(cell2, edge)) && this.getParent(edge) != cell2) {
      let geo = this.getGeometry(edge);
      if (geo != null) {
        const origin1 = this.getOrigin(this.getParent(edge));
        const origin2 = this.getOrigin(cell2);
        const dx = origin2.x - origin1.x;
        const dy = origin2.y - origin1.y;
        geo = geo.clone();
        geo.translate(-dx, -dy);
        this.setGeometry(edge, geo);
      }
      this.add(cell2, edge, this.getChildCount(cell2));
    }
  }
};
mxGraphModel2.prototype.getOrigin = function(cell2) {
  let result2 = null;
  if (cell2 != null) {
    result2 = this.getOrigin(this.getParent(cell2));
    if (!this.isEdge(cell2)) {
      const geo = this.getGeometry(cell2);
      if (geo != null) {
        result2.x += geo.x;
        result2.y += geo.y;
      }
    }
  } else {
    result2 = new mxPoint2();
  }
  return result2;
};
mxGraphModel2.prototype.getNearestCommonAncestor = function(cell1, cell2) {
  if (cell1 != null && cell2 != null) {
    let path = mxCellPath_default.create(cell2);
    if (path != null && path.length > 0) {
      let cell3 = cell1;
      let current2 = mxCellPath_default.create(cell3);
      if (path.length < current2.length) {
        cell3 = cell2;
        const tmp = current2;
        current2 = path;
        path = tmp;
      }
      while (cell3 != null) {
        const parent2 = this.getParent(cell3);
        if (path.indexOf(current2 + mxCellPath_default.PATH_SEPARATOR) == 0 && parent2 != null) {
          return cell3;
        }
        current2 = mxCellPath_default.getParentPath(current2);
        cell3 = parent2;
      }
    }
  }
  return null;
};
mxGraphModel2.prototype.remove = function(cell2) {
  if (cell2 == this.root) {
    this.setRoot(null);
  } else if (this.getParent(cell2) != null) {
    this.execute(new mxChildChange2(this, null, cell2));
  }
  return cell2;
};
mxGraphModel2.prototype.cellRemoved = function(cell2) {
  if (cell2 != null && this.cells != null) {
    const childCount = this.getChildCount(cell2);
    for (let i = childCount - 1; i >= 0; i--) {
      this.cellRemoved(this.getChildAt(cell2, i));
    }
    if (this.cells != null && cell2.getId() != null) {
      delete this.cells[cell2.getId()];
    }
  }
};
mxGraphModel2.prototype.parentForCellChanged = function(cell2, parent2, index) {
  const previous = this.getParent(cell2);
  if (parent2 != null) {
    if (parent2 != previous || previous.getIndex(cell2) != index) {
      parent2.insert(cell2, index);
    }
  } else if (previous != null) {
    const oldIndex = previous.getIndex(cell2);
    previous.remove(oldIndex);
  }
  const par = this.contains(parent2);
  const pre = this.contains(previous);
  if (par && !pre) {
    this.cellAdded(cell2);
  } else if (pre && !par) {
    this.cellRemoved(cell2);
  }
  return previous;
};
mxGraphModel2.prototype.getChildCount = function(cell2) {
  return cell2 != null ? cell2.getChildCount() : 0;
};
mxGraphModel2.prototype.getChildAt = function(cell2, index) {
  return cell2 != null ? cell2.getChildAt(index) : null;
};
mxGraphModel2.prototype.getChildren = function(cell2) {
  return cell2 != null ? cell2.children : null;
};
mxGraphModel2.prototype.getChildVertices = function(parent2) {
  return this.getChildCells(parent2, true, false);
};
mxGraphModel2.prototype.getChildEdges = function(parent2) {
  return this.getChildCells(parent2, false, true);
};
mxGraphModel2.prototype.getChildCells = function(parent2, vertices, edges) {
  vertices = vertices != null ? vertices : false;
  edges = edges != null ? edges : false;
  const childCount = this.getChildCount(parent2);
  const result2 = [];
  for (let i = 0; i < childCount; i++) {
    const child = this.getChildAt(parent2, i);
    if (!edges && !vertices || edges && this.isEdge(child) || vertices && this.isVertex(child)) {
      result2.push(child);
    }
  }
  return result2;
};
mxGraphModel2.prototype.getTerminal = function(edge, isSource) {
  return edge != null ? edge.getTerminal(isSource) : null;
};
mxGraphModel2.prototype.setTerminal = function(edge, terminal, isSource) {
  const terminalChanged = terminal != this.getTerminal(edge, isSource);
  this.execute(new mxTerminalChange(this, edge, terminal, isSource));
  if (this.maintainEdgeParent && terminalChanged) {
    this.updateEdgeParent(edge, this.getRoot());
  }
  return terminal;
};
mxGraphModel2.prototype.setTerminals = function(edge, source, target) {
  this.beginUpdate();
  try {
    this.setTerminal(edge, source, true);
    this.setTerminal(edge, target, false);
  } finally {
    this.endUpdate();
  }
};
mxGraphModel2.prototype.terminalForCellChanged = function(edge, terminal, isSource) {
  const previous = this.getTerminal(edge, isSource);
  if (terminal != null) {
    terminal.insertEdge(edge, isSource);
  } else if (previous != null) {
    previous.removeEdge(edge, isSource);
  }
  return previous;
};
mxGraphModel2.prototype.getEdgeCount = function(cell2) {
  return cell2 != null ? cell2.getEdgeCount() : 0;
};
mxGraphModel2.prototype.getEdgeAt = function(cell2, index) {
  return cell2 != null ? cell2.getEdgeAt(index) : null;
};
mxGraphModel2.prototype.getDirectedEdgeCount = function(cell2, outgoing, ignoredEdge) {
  let count = 0;
  const edgeCount = this.getEdgeCount(cell2);
  for (let i = 0; i < edgeCount; i++) {
    const edge = this.getEdgeAt(cell2, i);
    if (edge != ignoredEdge && this.getTerminal(edge, outgoing) == cell2) {
      count++;
    }
  }
  return count;
};
mxGraphModel2.prototype.getConnections = function(cell2) {
  return this.getEdges(cell2, true, true, false);
};
mxGraphModel2.prototype.getIncomingEdges = function(cell2) {
  return this.getEdges(cell2, true, false, false);
};
mxGraphModel2.prototype.getOutgoingEdges = function(cell2) {
  return this.getEdges(cell2, false, true, false);
};
mxGraphModel2.prototype.getEdges = function(cell2, incoming, outgoing, includeLoops) {
  incoming = incoming != null ? incoming : true;
  outgoing = outgoing != null ? outgoing : true;
  includeLoops = includeLoops != null ? includeLoops : true;
  const edgeCount = this.getEdgeCount(cell2);
  const result2 = [];
  for (let i = 0; i < edgeCount; i++) {
    const edge = this.getEdgeAt(cell2, i);
    const source = this.getTerminal(edge, true);
    const target = this.getTerminal(edge, false);
    if (includeLoops && source == target || source != target && (incoming && target == cell2 || outgoing && source == cell2)) {
      result2.push(edge);
    }
  }
  return result2;
};
mxGraphModel2.prototype.getEdgesBetween = function(source, target, directed) {
  directed = directed != null ? directed : false;
  const tmp1 = this.getEdgeCount(source);
  const tmp2 = this.getEdgeCount(target);
  let terminal = source;
  let edgeCount = tmp1;
  if (tmp2 < tmp1) {
    edgeCount = tmp2;
    terminal = target;
  }
  const result2 = [];
  for (let i = 0; i < edgeCount; i++) {
    const edge = this.getEdgeAt(terminal, i);
    const src = this.getTerminal(edge, true);
    const trg = this.getTerminal(edge, false);
    const directedMatch = src == source && trg == target;
    const oppositeMatch = trg == source && src == target;
    if (directedMatch || !directed && oppositeMatch) {
      result2.push(edge);
    }
  }
  return result2;
};
mxGraphModel2.prototype.getOpposites = function(edges, terminal, sources, targets) {
  sources = sources != null ? sources : true;
  targets = targets != null ? targets : true;
  const terminals = [];
  if (edges != null) {
    for (let i = 0; i < edges.length; i++) {
      const source = this.getTerminal(edges[i], true);
      const target = this.getTerminal(edges[i], false);
      if (source == terminal && target != null && target != terminal && targets) {
        terminals.push(target);
      } else if (target == terminal && source != null && source != terminal && sources) {
        terminals.push(source);
      }
    }
  }
  return terminals;
};
mxGraphModel2.prototype.getTopmostCells = function(cells) {
  const dict = new mxDictionary();
  const tmp = [];
  for (let i = 0; i < cells.length; i++) {
    dict.put(cells[i], true);
  }
  for (let i = 0; i < cells.length; i++) {
    const cell2 = cells[i];
    let topmost = true;
    let parent2 = this.getParent(cell2);
    while (parent2 != null) {
      if (dict.get(parent2)) {
        topmost = false;
        break;
      }
      parent2 = this.getParent(parent2);
    }
    if (topmost) {
      tmp.push(cell2);
    }
  }
  return tmp;
};
mxGraphModel2.prototype.isVertex = function(cell2) {
  return cell2 != null ? cell2.isVertex() : false;
};
mxGraphModel2.prototype.isEdge = function(cell2) {
  return cell2 != null ? cell2.isEdge() : false;
};
mxGraphModel2.prototype.isConnectable = function(cell2) {
  return cell2 != null ? cell2.isConnectable() : false;
};
mxGraphModel2.prototype.getValue = function(cell2) {
  return cell2 != null ? cell2.getValue() : null;
};
mxGraphModel2.prototype.setValue = function(cell2, value) {
  this.execute(new mxValueChange(this, cell2, value));
  return value;
};
mxGraphModel2.prototype.valueForCellChanged = function(cell2, value) {
  return cell2.valueChanged(value);
};
mxGraphModel2.prototype.getGeometry = function(cell2) {
  return cell2 != null ? cell2.getGeometry() : null;
};
mxGraphModel2.prototype.setGeometry = function(cell2, geometry) {
  if (geometry != this.getGeometry(cell2)) {
    this.execute(new mxGeometryChange(this, cell2, geometry));
  }
  return geometry;
};
mxGraphModel2.prototype.geometryForCellChanged = function(cell2, geometry) {
  const previous = this.getGeometry(cell2);
  cell2.setGeometry(geometry);
  return previous;
};
mxGraphModel2.prototype.getStyle = function(cell2) {
  return cell2 != null ? cell2.getStyle() : null;
};
mxGraphModel2.prototype.setStyle = function(cell2, style) {
  if (style != this.getStyle(cell2)) {
    this.execute(new mxStyleChange(this, cell2, style));
  }
  return style;
};
mxGraphModel2.prototype.styleForCellChanged = function(cell2, style) {
  const previous = this.getStyle(cell2);
  cell2.setStyle(style);
  return previous;
};
mxGraphModel2.prototype.isCollapsed = function(cell2) {
  return cell2 != null ? cell2.isCollapsed() : false;
};
mxGraphModel2.prototype.setCollapsed = function(cell2, collapsed) {
  if (collapsed != this.isCollapsed(cell2)) {
    this.execute(new mxCollapseChange(this, cell2, collapsed));
  }
  return collapsed;
};
mxGraphModel2.prototype.collapsedStateForCellChanged = function(cell2, collapsed) {
  const previous = this.isCollapsed(cell2);
  cell2.setCollapsed(collapsed);
  return previous;
};
mxGraphModel2.prototype.isVisible = function(cell2) {
  return cell2 != null ? cell2.isVisible() : false;
};
mxGraphModel2.prototype.setVisible = function(cell2, visible) {
  if (visible != this.isVisible(cell2)) {
    this.execute(new mxVisibleChange(this, cell2, visible));
  }
  return visible;
};
mxGraphModel2.prototype.visibleStateForCellChanged = function(cell2, visible) {
  const previous = this.isVisible(cell2);
  cell2.setVisible(visible);
  return previous;
};
mxGraphModel2.prototype.execute = function(change) {
  change.execute();
  this.beginUpdate();
  this.currentEdit.add(change);
  this.fireEvent(new mxEventObject2(mxEvent2.EXECUTE, "change", change));
  this.fireEvent(new mxEventObject2(mxEvent2.EXECUTED, "change", change));
  this.endUpdate();
};
mxGraphModel2.prototype.beginUpdate = function() {
  this.updateLevel++;
  this.fireEvent(new mxEventObject2(mxEvent2.BEGIN_UPDATE));
  if (this.updateLevel == 1) {
    this.fireEvent(new mxEventObject2(mxEvent2.START_EDIT));
  }
};
mxGraphModel2.prototype.endUpdate = function() {
  this.updateLevel--;
  if (this.updateLevel == 0) {
    this.fireEvent(new mxEventObject2(mxEvent2.END_EDIT));
  }
  if (!this.endingUpdate) {
    this.endingUpdate = this.updateLevel == 0;
    this.fireEvent(new mxEventObject2(mxEvent2.END_UPDATE, "edit", this.currentEdit));
    try {
      if (this.endingUpdate && !this.currentEdit.isEmpty()) {
        this.fireEvent(new mxEventObject2(mxEvent2.BEFORE_UNDO, "edit", this.currentEdit));
        const tmp = this.currentEdit;
        this.currentEdit = this.createUndoableEdit();
        tmp.notify();
        this.fireEvent(new mxEventObject2(mxEvent2.UNDO, "edit", tmp));
      }
    } finally {
      this.endingUpdate = false;
    }
  }
};
mxGraphModel2.prototype.createUndoableEdit = function(significant) {
  const edit = new mxUndoableEdit(this, significant != null ? significant : true);
  edit.notify = function() {
    edit.source.fireEvent(new mxEventObject2(mxEvent2.CHANGE, "edit", edit, "changes", edit.changes));
    edit.source.fireEvent(new mxEventObject2(mxEvent2.NOTIFY, "edit", edit, "changes", edit.changes));
  };
  return edit;
};
mxGraphModel2.prototype.mergeChildren = function(from, to, cloneAllEdges) {
  cloneAllEdges = cloneAllEdges != null ? cloneAllEdges : true;
  this.beginUpdate();
  try {
    const mapping = {};
    this.mergeChildrenImpl(from, to, cloneAllEdges, mapping);
    for (const key in mapping) {
      const cell2 = mapping[key];
      let terminal = this.getTerminal(cell2, true);
      if (terminal != null) {
        terminal = mapping[mxCellPath_default.create(terminal)];
        this.setTerminal(cell2, terminal, true);
      }
      terminal = this.getTerminal(cell2, false);
      if (terminal != null) {
        terminal = mapping[mxCellPath_default.create(terminal)];
        this.setTerminal(cell2, terminal, false);
      }
    }
  } finally {
    this.endUpdate();
  }
};
mxGraphModel2.prototype.mergeChildrenImpl = function(from, to, cloneAllEdges, mapping) {
  this.beginUpdate();
  try {
    const childCount = from.getChildCount();
    for (let i = 0; i < childCount; i++) {
      const cell2 = from.getChildAt(i);
      if (typeof cell2.getId == "function") {
        const id = cell2.getId();
        let target = id != null && (!this.isEdge(cell2) || !cloneAllEdges) ? this.getCell(id) : null;
        if (target == null) {
          const clone3 = cell2.clone();
          clone3.setId(id);
          clone3.setTerminal(cell2.getTerminal(true), true);
          clone3.setTerminal(cell2.getTerminal(false), false);
          target = to.insert(clone3);
          this.cellAdded(target);
        }
        mapping[mxCellPath_default.create(cell2)] = target;
        this.mergeChildrenImpl(cell2, target, cloneAllEdges, mapping);
      }
    }
  } finally {
    this.endUpdate();
  }
};
mxGraphModel2.prototype.getParents = function(cells) {
  const parents = [];
  if (cells != null) {
    const dict = new mxDictionary();
    for (let i = 0; i < cells.length; i++) {
      const parent2 = this.getParent(cells[i]);
      if (parent2 != null && !dict.get(parent2)) {
        dict.put(parent2, true);
        parents.push(parent2);
      }
    }
  }
  return parents;
};
mxGraphModel2.prototype.cloneCell = function(cell2, includeChildren) {
  if (cell2 != null) {
    return this.cloneCells([cell2], includeChildren)[0];
  }
  return null;
};
mxGraphModel2.prototype.cloneCells = function(cells, includeChildren, mapping) {
  includeChildren = includeChildren != null ? includeChildren : true;
  mapping = mapping != null ? mapping : {};
  const clones = [];
  for (let i = 0; i < cells.length; i++) {
    if (cells[i] != null) {
      clones.push(this.cloneCellImpl(cells[i], mapping, includeChildren));
    } else {
      clones.push(null);
    }
  }
  for (let i = 0; i < clones.length; i++) {
    if (clones[i] != null) {
      this.restoreClone(clones[i], cells[i], mapping);
    }
  }
  return clones;
};
mxGraphModel2.prototype.cloneCellImpl = function(cell2, mapping, includeChildren) {
  const ident = mxObjectIdentity.get(cell2);
  let clone3 = mapping[ident];
  if (clone3 == null) {
    clone3 = this.cellCloned(cell2);
    mapping[ident] = clone3;
    if (includeChildren) {
      const childCount = this.getChildCount(cell2);
      for (let i = 0; i < childCount; i++) {
        const cloneChild = this.cloneCellImpl(this.getChildAt(cell2, i), mapping, true);
        clone3.insert(cloneChild);
      }
    }
  }
  return clone3;
};
mxGraphModel2.prototype.cellCloned = function(cell2) {
  return cell2.clone();
};
mxGraphModel2.prototype.restoreClone = function(clone3, cell2, mapping) {
  const source = this.getTerminal(cell2, true);
  if (source != null) {
    const tmp = mapping[mxObjectIdentity.get(source)];
    if (tmp != null) {
      tmp.insertEdge(clone3, true);
    }
  }
  const target = this.getTerminal(cell2, false);
  if (target != null) {
    const tmp = mapping[mxObjectIdentity.get(target)];
    if (tmp != null) {
      tmp.insertEdge(clone3, false);
    }
  }
  const childCount = this.getChildCount(clone3);
  for (let i = 0; i < childCount; i++) {
    this.restoreClone(this.getChildAt(clone3, i), this.getChildAt(cell2, i), mapping);
  }
};

// js/graph/mxObjectCodec.js
function mxObjectCodec(template, exclude, idrefs, mapping) {
  this.template = template;
  this.exclude = exclude != null ? exclude : [];
  this.idrefs = idrefs != null ? idrefs : [];
  this.mapping = mapping != null ? mapping : [];
  this.reverse = new Object();
  for (const i in this.mapping) {
    this.reverse[this.mapping[i]] = i;
  }
}
mxObjectCodec.allowEval = false;
mxObjectCodec.prototype.template = null;
mxObjectCodec.prototype.exclude = null;
mxObjectCodec.prototype.idrefs = null;
mxObjectCodec.prototype.mapping = null;
mxObjectCodec.prototype.reverse = null;
mxObjectCodec.prototype.getName = function() {
  return getFunctionName(this.template.constructor);
};
mxObjectCodec.prototype.cloneTemplate = function() {
  return new this.template.constructor();
};
mxObjectCodec.prototype.getFieldName = function(attributename) {
  if (attributename != null) {
    const mapped = this.reverse[attributename];
    if (mapped != null) {
      attributename = mapped;
    }
  }
  return attributename;
};
mxObjectCodec.prototype.getAttributeName = function(fieldname) {
  if (fieldname != null) {
    const mapped = this.mapping[fieldname];
    if (mapped != null) {
      fieldname = mapped;
    }
  }
  return fieldname;
};
mxObjectCodec.prototype.isExcluded = function(obj, attr2, value, write2) {
  return attr2 == mxObjectIdentity.FIELD_NAME || indexOf(this.exclude, attr2) >= 0;
};
mxObjectCodec.prototype.isReference = function(obj, attr2, value, write2) {
  return indexOf(this.idrefs, attr2) >= 0;
};
mxObjectCodec.prototype.encode = function(enc, obj) {
  const node = enc.document.createElement(this.getName());
  obj = this.beforeEncode(enc, obj, node);
  this.encodeObject(enc, obj, node);
  return this.afterEncode(enc, obj, node);
};
mxObjectCodec.prototype.encodeObject = function(enc, obj, node) {
  enc.setAttribute(node, "id", enc.getId(obj));
  for (const i in obj) {
    let name = i;
    const value = obj[name];
    if (value != null && !this.isExcluded(obj, name, value, true)) {
      if (isInteger(name)) {
        name = null;
      }
      this.encodeValue(enc, obj, name, value, node);
    }
  }
};
mxObjectCodec.prototype.encodeValue = function(enc, obj, name, value, node) {
  if (value != null) {
    if (this.isReference(obj, name, value, true)) {
      const tmp = enc.getId(value);
      if (tmp == null) {
        mxLog.warn("mxObjectCodec.encode: No ID for " + this.getName() + "." + name + "=" + value);
        return;
      }
      value = tmp;
    }
    const defaultValue = this.template[name];
    if (name == null || enc.encodeDefaults || defaultValue != value) {
      name = this.getAttributeName(name);
      this.writeAttribute(enc, obj, name, value, node);
    }
  }
};
mxObjectCodec.prototype.writeAttribute = function(enc, obj, name, value, node) {
  if (typeof value !== "object" || value === null) {
    this.writePrimitiveAttribute(enc, obj, name, value, node);
  } else {
    this.writeComplexAttribute(enc, obj, name, value, node);
  }
};
mxObjectCodec.prototype.writePrimitiveAttribute = function(enc, obj, name, value, node) {
  value = this.convertAttributeToXml(enc, obj, name, value, node);
  if (name == null) {
    const child = enc.document.createElement("add");
    if (typeof value == "function") {
      child.appendChild(enc.document.createTextNode(value));
    } else {
      enc.setAttribute(child, "value", value);
    }
    node.appendChild(child);
  } else if (typeof value != "function") {
    enc.setAttribute(node, name, value);
  }
};
mxObjectCodec.prototype.writeComplexAttribute = function(enc, obj, name, value, node) {
  const child = enc.encode(value);
  if (child != null) {
    if (name != null) {
      child.setAttribute("as", name);
    }
    node.appendChild(child);
  } else {
    mxLog.warn("mxObjectCodec.encode: No node for " + this.getName() + "." + name + ": " + value);
  }
};
mxObjectCodec.prototype.convertAttributeToXml = function(enc, obj, name, value) {
  if (this.isBooleanAttribute(enc, obj, name, value)) {
    value = value == true ? "1" : "0";
  }
  return value;
};
mxObjectCodec.prototype.isBooleanAttribute = function(enc, obj, name, value) {
  return typeof value.length == "undefined" && (value == true || value == false);
};
mxObjectCodec.prototype.convertAttributeFromXml = function(dec, attr2, obj) {
  let value = attr2.value;
  if (this.isNumericAttribute(dec, attr2, obj)) {
    value = parseFloat(value);
    if (isNaN(value) || !isFinite(value)) {
      value = 0;
    }
  }
  return value;
};
mxObjectCodec.prototype.isNumericAttribute = function(dec, attr2, obj) {
  const result2 = obj.constructor == mxGeometry && (attr2.name == "x" || attr2.name == "y" || attr2.name == "width" || attr2.name == "height") || obj.constructor == mxPoint2 && (attr2.name == "x" || attr2.name == "y") || isNumeric(attr2.value);
  return result2;
};
mxObjectCodec.prototype.beforeEncode = function(enc, obj, node) {
  return obj;
};
mxObjectCodec.prototype.afterEncode = function(enc, obj, node) {
  return node;
};
mxObjectCodec.prototype.decode = function(dec, node, into) {
  const id = node.getAttribute("id");
  let obj = dec.objects[id];
  if (obj == null) {
    obj = into || this.cloneTemplate();
    if (id != null) {
      dec.putObject(id, obj);
    }
  }
  node = this.beforeDecode(dec, node, obj);
  this.decodeNode(dec, node, obj);
  return this.afterDecode(dec, node, obj);
};
mxObjectCodec.prototype.decodeNode = function(dec, node, obj) {
  if (node != null) {
    this.decodeAttributes(dec, node, obj);
    this.decodeChildren(dec, node, obj);
  }
};
mxObjectCodec.prototype.decodeAttributes = function(dec, node, obj) {
  const attrs = node.attributes;
  if (attrs != null) {
    for (let i = 0; i < attrs.length; i++) {
      this.decodeAttribute(dec, attrs[i], obj);
    }
  }
};
mxObjectCodec.prototype.isIgnoredAttribute = function(dec, attr2, obj) {
  return attr2.nodeName == "as" || attr2.nodeName == "id";
};
mxObjectCodec.prototype.decodeAttribute = function(dec, attr2, obj) {
  if (!this.isIgnoredAttribute(dec, attr2, obj)) {
    const name = attr2.nodeName;
    let value = this.convertAttributeFromXml(dec, attr2, obj);
    const fieldname = this.getFieldName(name);
    if (this.isReference(obj, fieldname, value, false)) {
      let tmp = dec.getObject(value);
      if (tmp == null) {
        mxLog.warn("mxObjectCodec.decode: No object for " + this.getName() + "." + name + "=" + value);
        return;
      }
      value = tmp;
    }
    if (!this.isExcluded(obj, name, value, false)) {
      obj[name] = value;
    }
  }
};
mxObjectCodec.prototype.decodeChildren = function(dec, node, obj) {
  let child = node.firstChild;
  while (child != null) {
    const tmp = child.nextSibling;
    if (child.nodeType == mxConstants2.NODETYPE_ELEMENT && !this.processInclude(dec, child, obj)) {
      this.decodeChild(dec, child, obj);
    }
    child = tmp;
  }
};
mxObjectCodec.prototype.decodeChild = function(dec, child, obj) {
  const fieldname = this.getFieldName(child.getAttribute("as"));
  if (fieldname == null || !this.isExcluded(obj, fieldname, child, false)) {
    const template = this.getFieldTemplate(obj, fieldname, child);
    let value = null;
    if (child.nodeName == "add") {
      value = child.getAttribute("value");
      if (value == null && mxObjectCodec.allowEval) {
        value = (void 0)(getTextContent(child));
      }
    } else {
      value = dec.decode(child, template);
    }
    try {
      this.addObjectValue(obj, fieldname, value, template);
    } catch (e) {
      throw new Error(e.message + " for " + child.nodeName);
    }
  }
};
mxObjectCodec.prototype.getFieldTemplate = function(obj, fieldname, child) {
  let template = obj[fieldname];
  if (template instanceof Array && template.length > 0) {
    template = null;
  }
  return template;
};
mxObjectCodec.prototype.addObjectValue = function(obj, fieldname, value, template) {
  if (value != null && value != template) {
    if (fieldname != null && fieldname.length > 0) {
      obj[fieldname] = value;
    } else {
      obj.push(value);
    }
  }
};
mxObjectCodec.prototype.processInclude = function(dec, node, into) {
  if (node.nodeName == "include") {
    const name = node.getAttribute("name");
    if (name != null) {
      try {
        const xml2 = load(name).getDocumentElement();
        if (xml2 != null) {
          dec.decode(xml2, into);
        }
      } catch (e) {
      }
    }
    return true;
  }
  return false;
};
mxObjectCodec.prototype.beforeDecode = function(dec, node, obj) {
  return node;
};
mxObjectCodec.prototype.afterDecode = function(dec, node, obj) {
  return obj;
};

// js/graph/mxCodecRegistry.js
var mxCodecRegistry = {
  codecs: {},
  aliases: {},
  register: function(codec) {
    if (codec != null) {
      const name = codec.getName();
      mxCodecRegistry.codecs[name] = codec;
      const classname = getFunctionName(codec.template.constructor);
      if (classname != name) {
        mxCodecRegistry.addAlias(classname, name);
      }
    }
    return codec;
  },
  addAlias: function(classname, codecname) {
    mxCodecRegistry.aliases[classname] = codecname;
  },
  getCodec: function(ctor) {
    let codec = null;
    if (ctor != null) {
      let name = getFunctionName(ctor);
      const tmp = mxCodecRegistry.aliases[name];
      if (tmp != null) {
        name = tmp;
      }
      codec = mxCodecRegistry.codecs[name];
      if (codec == null) {
        try {
          codec = new mxObjectCodec(new ctor());
          mxCodecRegistry.register(codec);
        } catch (e) {
        }
      }
    }
    return codec;
  }
};

// js/graph/mxCodec.js
function mxCodec(document2) {
  this.document = document2 || createXmlDocument();
  this.objects = [];
}
mxCodec.prototype.document = null;
mxCodec.prototype.objects = null;
mxCodec.prototype.elements = null;
mxCodec.prototype.encodeDefaults = false;
mxCodec.prototype.putObject = function(id, obj) {
  this.objects[id] = obj;
  return obj;
};
mxCodec.prototype.getObject = function(id) {
  let obj = null;
  if (id != null) {
    obj = this.objects[id];
    if (obj == null) {
      obj = this.lookup(id);
      if (obj == null) {
        const node = this.getElementById(id);
        if (node != null) {
          obj = this.decode(node);
        }
      }
    }
  }
  return obj;
};
mxCodec.prototype.lookup = function(id) {
  return null;
};
mxCodec.prototype.getElementById = function(id) {
  this.updateElements();
  return this.elements[id];
};
mxCodec.prototype.updateElements = function() {
  if (this.elements == null) {
    this.elements = new Object();
    if (this.document.documentElement != null) {
      this.addElement(this.document.documentElement);
    }
  }
};
mxCodec.prototype.addElement = function(node) {
  if (node.nodeType == mxConstants2.NODETYPE_ELEMENT) {
    const id = node.getAttribute("id");
    if (id != null) {
      if (this.elements[id] == null) {
        this.elements[id] = node;
      } else if (this.elements[id] != node) {
        throw new Error(id + ": Duplicate ID");
      }
    }
  }
  node = node.firstChild;
  while (node != null) {
    this.addElement(node);
    node = node.nextSibling;
  }
};
mxCodec.prototype.getId = function(obj) {
  let id = null;
  if (obj != null) {
    id = this.reference(obj);
    if (id == null && obj instanceof mxCell) {
      id = obj.getId();
      if (id == null) {
        id = mxCellPath_default.create(obj);
        if (id.length == 0) {
          id = "root";
        }
      }
    }
  }
  return id;
};
mxCodec.prototype.reference = function(obj) {
  return null;
};
mxCodec.prototype.encode = function(obj) {
  let node = null;
  if (obj != null && obj.constructor != null) {
    const enc = mxCodecRegistry.getCodec(obj.constructor);
    if (enc != null) {
      node = enc.encode(this, obj);
    } else {
      if (isNode(obj)) {
        node = importNode(this.document, obj, true);
      } else {
        mxLog.warn("mxCodec.encode: No codec for " + getFunctionName(obj.constructor));
      }
    }
  }
  return node;
};
mxCodec.prototype.decode = function(node, into) {
  this.updateElements();
  let obj = null;
  if (node != null && node.nodeType == mxConstants2.NODETYPE_ELEMENT) {
    let ctor = null;
    try {
      ctor = window[node.nodeName];
    } catch (err) {
    }
    const dec = mxCodecRegistry.getCodec(ctor);
    if (dec != null) {
      obj = dec.decode(this, node, into);
    } else {
      obj = node.cloneNode(true);
      obj.removeAttribute("as");
    }
  }
  return obj;
};
mxCodec.prototype.encodeCell = function(cell2, node, includeChildren) {
  node.appendChild(this.encode(cell2));
  if (includeChildren == null || includeChildren) {
    const childCount = cell2.getChildCount();
    for (let i = 0; i < childCount; i++) {
      this.encodeCell(cell2.getChildAt(i), node);
    }
  }
};
mxCodec.prototype.isCellCodec = function(codec) {
  if (codec != null && typeof codec.isCellCodec == "function") {
    return codec.isCellCodec();
  }
  return false;
};
mxCodec.prototype.decodeCell = function(node, restoreStructures) {
  restoreStructures = restoreStructures != null ? restoreStructures : true;
  let cell2 = null;
  if (node != null && node.nodeType == mxConstants2.NODETYPE_ELEMENT) {
    let decoder = mxCodecRegistry.getCodec(node.nodeName);
    if (!this.isCellCodec(decoder)) {
      let child = node.firstChild;
      while (child != null && !this.isCellCodec(decoder)) {
        decoder = mxCodecRegistry.getCodec(child.nodeName);
        child = child.nextSibling;
      }
    }
    if (!this.isCellCodec(decoder)) {
      decoder = mxCodecRegistry.getCodec(mxCell);
    }
    cell2 = decoder.decode(this, node);
    if (restoreStructures) {
      this.insertIntoGraph(cell2);
    }
  }
  return cell2;
};
mxCodec.prototype.insertIntoGraph = function(cell2) {
  const parent2 = cell2.parent;
  const source = cell2.getTerminal(true);
  const target = cell2.getTerminal(false);
  cell2.setTerminal(null, false);
  cell2.setTerminal(null, true);
  cell2.parent = null;
  if (parent2 != null) {
    if (parent2 == cell2) {
      throw new Error(parent2.id + ": Self Reference");
    } else {
      parent2.insert(cell2);
    }
  }
  if (source != null) {
    source.insertEdge(cell2, true);
  }
  if (target != null) {
    target.insertEdge(cell2, false);
  }
};
mxCodec.prototype.setAttribute = function(node, attribute, value) {
  if (attribute != null && value != null) {
    node.setAttribute(attribute, value);
  }
};

// js/graph/mxEffects.js
var animateChanges = function(graph, changes, done) {
  const maxStep = 10;
  let step = 0;
  const animate = function() {
    let isRequired = false;
    for (let i = 0; i < changes.length; i++) {
      const change = changes[i];
      if (change instanceof mxGeometryChange || change instanceof mxTerminalChange || change instanceof mxValueChange || change instanceof mxChildChange2 || change instanceof mxStyleChange) {
        const state2 = graph.getView().getState(change.cell || change.child, false);
        if (state2 != null) {
          isRequired = true;
          if (change.constructor !== mxGeometryChange || graph.model.isEdge(change.cell)) {
            setOpacity(state2.shape.node, 100 * step / maxStep);
          } else {
            const scale = graph.getView().scale;
            const dx = (change.geometry.x - change.previous.x) * scale;
            const dy = (change.geometry.y - change.previous.y) * scale;
            const sx = (change.geometry.width - change.previous.width) * scale;
            const sy = (change.geometry.height - change.previous.height) * scale;
            if (step === 0) {
              state2.x -= dx;
              state2.y -= dy;
              state2.width -= sx;
              state2.height -= sy;
            } else {
              state2.x += dx / maxStep;
              state2.y += dy / maxStep;
              state2.width += sx / maxStep;
              state2.height += sy / maxStep;
            }
            graph.cellRenderer.redraw(state2);
            cascadeOpacity(graph, change.cell, 100 * step / maxStep);
          }
        }
      }
    }
    if (step < maxStep && isRequired) {
      step++;
      window.setTimeout(animate, delay);
    } else if (done != null) {
      done();
    }
  };
  const delay = 30;
  animate();
};
var cascadeOpacity = function(graph, cell2, opacity) {
  const childCount = graph.model.getChildCount(cell2);
  for (let i = 0; i < childCount; i++) {
    const child = graph.model.getChildAt(cell2, i);
    const childState = graph.getView().getState(child);
    if (childState != null) {
      setOpacity(childState.shape.node, opacity);
      cascadeOpacity(graph, child, opacity);
    }
  }
  const edges = graph.model.getEdges(cell2);
  if (edges != null) {
    for (let j = 0; j < edges.length; j++) {
      const edgeState = graph.getView().getState(edges[j]);
      if (edgeState != null) {
        setOpacity(edgeState.shape.node, opacity);
      }
    }
  }
};
var fadeOut = function(node, from, remove2, step, delay, isEnabled2) {
  step = step || 40;
  delay = delay || 30;
  let opacity = from || 100;
  setOpacity(node, opacity);
  if (isEnabled2 || isEnabled2 == null) {
    const f = function() {
      opacity = Math.max(opacity - step, 0);
      setOpacity(node, opacity);
      if (opacity > 0) {
        window.setTimeout(f, delay);
      } else {
        node.style.visibility = "hidden";
        if (remove2 && node.parentNode) {
          node.parentNode.removeChild(node);
        }
      }
    };
    window.setTimeout(f, delay);
  } else {
    node.style.visibility = "hidden";
    if (remove2 && node.parentNode) {
      node.parentNode.removeChild(node);
    }
  }
};
var mxEffects = {
  animateChanges,
  cascadeOpacity,
  fadeOut
};
var mxEffects_default = mxEffects;

// js/graph/mxTemporaryCellStates.js
var mxTemporaryCellStates = function(view, scale, cells, isCellVisibleFn, getLinkForCellState2) {
  scale = scale != null ? scale : 1;
  this.view = view;
  this.oldValidateCellState = view.validateCellState;
  this.oldBounds = view.getGraphBounds();
  this.oldStates = view.getStates();
  this.oldScale = view.getScale();
  this.oldDoRedrawShape = view.graph.cellRenderer.doRedrawShape;
  const self = this;
  if (getLinkForCellState2 != null) {
    view.graph.cellRenderer.doRedrawShape = function(state2) {
      const oldPaint = state2.shape.paint;
      state2.shape.paint = function(c) {
        const link2 = getLinkForCellState2(state2);
        if (link2 != null) {
          c.setLink(link2);
        }
        oldPaint.apply(this, arguments);
        if (link2 != null) {
          c.setLink(null);
        }
      };
      self.oldDoRedrawShape.apply(view.graph.cellRenderer, arguments);
      state2.shape.paint = oldPaint;
    };
  }
  view.validateCellState = function(cell2, recurse) {
    if (cell2 == null || isCellVisibleFn == null || isCellVisibleFn(cell2)) {
      return self.oldValidateCellState.apply(view, arguments);
    }
    return null;
  };
  view.setStates(new mxDictionary());
  view.setScale(scale);
  if (cells != null) {
    view.resetValidationState();
    let bbox = null;
    for (let i = 0; i < cells.length; i++) {
      const state2 = view.validateCellState(view.validateCell(cells[i]));
      const bounds = view.getBoundingBox(state2);
      if (bbox == null) {
        bbox = bounds;
      } else {
        bbox.add(bounds);
      }
    }
    view.setGraphBounds(bbox || new mxRectangle());
  }
};
mxTemporaryCellStates.prototype.view = null;
mxTemporaryCellStates.prototype.oldStates = null;
mxTemporaryCellStates.prototype.oldBounds = null;
mxTemporaryCellStates.prototype.oldScale = null;
mxTemporaryCellStates.prototype.destroy = function() {
  this.view.setScale(this.oldScale);
  this.view.setStates(this.oldStates);
  this.view.setGraphBounds(this.oldBounds);
  this.view.validateCellState = this.oldValidateCellState;
  this.view.graph.cellRenderer.doRedrawShape = this.oldDoRedrawShape;
};

// js/graph/mxCellHighlight.js
var mxCellHighlight2 = function(graph, highlightColor, strokeWidth, dashed) {
  if (graph != null) {
    this.graph = graph;
    this.highlightColor = highlightColor != null ? highlightColor : mxConstants2.DEFAULT_VALID_COLOR;
    this.strokeWidth = strokeWidth != null ? strokeWidth : mxConstants2.HIGHLIGHT_STROKEWIDTH;
    this.dashed = dashed != null ? dashed : false;
    this.opacity = mxConstants2.HIGHLIGHT_OPACITY;
    this.repaintHandler = bind(this, () => {
      if (this.state != null) {
        const tmp = this.graph.view.getState(this.state.cell);
        if (tmp == null) {
          this.hide();
        } else {
          this.state = tmp;
          this.repaint();
        }
      }
    });
    this.graph.getView().addListener(mxEvent2.SCALE, this.repaintHandler);
    this.graph.getView().addListener(mxEvent2.TRANSLATE, this.repaintHandler);
    this.graph.getView().addListener(mxEvent2.SCALE_AND_TRANSLATE, this.repaintHandler);
    this.graph.getModel().addListener(mxEvent2.CHANGE, this.repaintHandler);
    this.resetHandler = bind(this, () => {
      this.hide();
    });
    this.graph.getView().addListener(mxEvent2.DOWN, this.resetHandler);
    this.graph.getView().addListener(mxEvent2.UP, this.resetHandler);
  }
};
mxCellHighlight2.prototype.keepOnTop = false;
mxCellHighlight2.prototype.graph = null;
mxCellHighlight2.prototype.state = null;
mxCellHighlight2.prototype.spacing = 2;
mxCellHighlight2.prototype.resetHandler = null;
var setHighlightColor = function(color) {
  this.highlightColor = color;
  if (this.shape != null) {
    this.shape.stroke = color;
  }
};
mxCellHighlight2.prototype.setHighlightColor = setHighlightColor;
var drawHighlight = function() {
  this.shape = this.createShape();
  this.repaint();
  if (!this.keepOnTop && this.shape.node.parentNode.firstChild !== this.shape.node) {
    this.shape.node.parentNode.insertBefore(this.shape.node, this.shape.node.parentNode.firstChild);
  }
};
mxCellHighlight2.prototype.drawHighlight = drawHighlight;
var createShape = function() {
  const shape = this.graph.cellRenderer.createShape(this.state);
  shape.svgStrokeTolerance = this.graph.tolerance;
  shape.points = this.state.absolutePoints;
  shape.apply(this.state);
  shape.stroke = this.highlightColor;
  shape.opacity = this.opacity;
  shape.isDashed = this.dashed;
  shape.isShadow = false;
  shape.dialect = this.graph.dialect !== mxConstants2.DIALECT_SVG ? mxConstants2.DIALECT_VML : mxConstants2.DIALECT_SVG;
  shape.init(this.graph.getView().getOverlayPane());
  mxEvent2.redirectMouseEvents(shape.node, this.graph, this.state);
  if (this.graph.dialect !== mxConstants2.DIALECT_SVG) {
    shape.pointerEvents = false;
  } else {
    shape.svgPointerEvents = "stroke";
  }
  return shape;
};
mxCellHighlight2.prototype.createShape = createShape;
var getStrokeWidth = function(state2) {
  return this.strokeWidth;
};
mxCellHighlight2.prototype.getStrokeWidth = getStrokeWidth;
var repaint = function() {
  if (this.state != null && this.shape != null) {
    this.shape.scale = this.state.view.scale;
    if (this.graph.model.isEdge(this.state.cell)) {
      this.shape.strokewidth = this.getStrokeWidth();
      this.shape.points = this.state.absolutePoints;
      this.shape.outline = false;
    } else {
      this.shape.bounds = new mxRectangle(this.state.x - this.spacing, this.state.y - this.spacing, this.state.width + 2 * this.spacing, this.state.height + 2 * this.spacing);
      this.shape.rotation = Number(this.state.style[mxConstants2.STYLE_ROTATION] || "0");
      this.shape.strokewidth = this.getStrokeWidth() / this.state.view.scale;
      this.shape.outline = true;
    }
    if (this.state.shape != null) {
      this.shape.setCursor(this.state.shape.getCursor());
    }
    if (mxClient_default.IS_QUIRKS || document.documentMode === 8) {
      if (this.shape.stroke === "transparent") {
        this.shape.stroke = "white";
        this.shape.opacity = 1;
      } else {
        this.shape.opacity = this.opacity;
      }
    }
    this.shape.redraw();
  }
};
mxCellHighlight2.prototype.repaint = repaint;
var hide = function() {
  this.highlight(null);
};
mxCellHighlight2.prototype.hide = hide;
var highlight = function(state2) {
  if (this.state !== state2) {
    if (this.shape != null) {
      this.shape.destroy();
      this.shape = null;
    }
    this.state = state2;
    if (this.state != null) {
      this.drawHighlight();
    }
  }
};
mxCellHighlight2.prototype.highlight = highlight;
var isHighlightAt = function(x, y) {
  let hit = false;
  if (this.shape != null && document.elementFromPoint != null && !mxClient_default.IS_QUIRKS) {
    let elt = document.elementFromPoint(x, y);
    while (elt != null) {
      if (elt === this.shape.node) {
        hit = true;
        break;
      }
      elt = elt.parentNode;
    }
  }
  return hit;
};
mxCellHighlight2.prototype.isHighlightAt = isHighlightAt;
var destroy = function() {
  this.graph.getView().removeListener(this.resetHandler);
  this.graph.getView().removeListener(this.repaintHandler);
  this.graph.getModel().removeListener(this.repaintHandler);
  if (this.shape != null) {
    this.shape.destroy();
    this.shape = null;
  }
};
mxCellHighlight2.prototype.destroy = destroy;

// js/graph/mxUrlConverter.js
var mxUrlConverter = function() {
};
mxUrlConverter.prototype.enabled = true;
mxUrlConverter.prototype.baseUrl = null;
mxUrlConverter.prototype.baseDomain = null;
mxUrlConverter.prototype.updateBaseUrl = function() {
  this.baseDomain = location.protocol + "//" + location.host;
  this.baseUrl = this.baseDomain + location.pathname;
  const tmp = this.baseUrl.lastIndexOf("/");
  if (tmp > 0) {
    this.baseUrl = this.baseUrl.substring(0, tmp + 1);
  }
};
mxUrlConverter.prototype.isEnabled = function() {
  return this.enabled;
};
mxUrlConverter.prototype.setEnabled = function(value) {
  this.enabled = value;
};
mxUrlConverter.prototype.getBaseUrl = function() {
  return this.baseUrl;
};
mxUrlConverter.prototype.setBaseUrl = function(value) {
  this.baseUrl = value;
};
mxUrlConverter.prototype.getBaseDomain = function() {
  return this.baseDomain;
};
mxUrlConverter.prototype.setBaseDomain = function(value) {
  this.baseDomain = value;
};
mxUrlConverter.prototype.isRelativeUrl = function(url) {
  return url != null && url.substring(0, 2) !== "//" && url.substring(0, 7) !== "http://" && url.substring(0, 8) !== "https://" && url.substring(0, 10) !== "data:image" && url.substring(0, 7) !== "file://";
};
mxUrlConverter.prototype.convert = function(url) {
  if (this.isEnabled() && this.isRelativeUrl(url)) {
    if (this.getBaseUrl() == null) {
      this.updateBaseUrl();
    }
    if (url.charAt(0) === "/") {
      url = this.getBaseDomain() + url;
    } else {
      url = this.getBaseUrl() + url;
    }
  }
  return url;
};

// js/graph/mxAbstractCanvas2D.js
function mxAbstractCanvas2D() {
  this.converter = this.createUrlConverter();
  this.reset();
}
mxAbstractCanvas2D.prototype.state = null;
mxAbstractCanvas2D.prototype.states = null;
mxAbstractCanvas2D.prototype.path = null;
mxAbstractCanvas2D.prototype.rotateHtml = true;
mxAbstractCanvas2D.prototype.lastX = 0;
mxAbstractCanvas2D.prototype.lastY = 0;
mxAbstractCanvas2D.prototype.moveOp = "M";
mxAbstractCanvas2D.prototype.lineOp = "L";
mxAbstractCanvas2D.prototype.quadOp = "Q";
mxAbstractCanvas2D.prototype.curveOp = "C";
mxAbstractCanvas2D.prototype.closeOp = "Z";
mxAbstractCanvas2D.prototype.pointerEvents = false;
mxAbstractCanvas2D.prototype.createUrlConverter = function() {
  return new mxUrlConverter();
};
mxAbstractCanvas2D.prototype.reset = function() {
  this.state = this.createState();
  this.states = [];
};
mxAbstractCanvas2D.prototype.createState = function() {
  return {
    dx: 0,
    dy: 0,
    scale: 1,
    alpha: 1,
    fillAlpha: 1,
    strokeAlpha: 1,
    fillColor: null,
    gradientFillAlpha: 1,
    gradientColor: null,
    gradientAlpha: 1,
    gradientDirection: null,
    strokeColor: null,
    strokeWidth: 1,
    dashed: false,
    dashPattern: "3 3",
    fixDash: false,
    lineCap: "flat",
    lineJoin: "miter",
    miterLimit: 10,
    fontColor: "#000000",
    fontBackgroundColor: null,
    fontBorderColor: null,
    fontSize: mxConstants2.DEFAULT_FONTSIZE,
    fontFamily: mxConstants2.DEFAULT_FONTFAMILY,
    fontStyle: 0,
    shadow: false,
    shadowColor: mxConstants2.SHADOWCOLOR,
    shadowAlpha: mxConstants2.SHADOW_OPACITY,
    shadowDx: mxConstants2.SHADOW_OFFSET_X,
    shadowDy: mxConstants2.SHADOW_OFFSET_Y,
    rotation: 0,
    rotationCx: 0,
    rotationCy: 0
  };
};
mxAbstractCanvas2D.prototype.format = function(value) {
  return Math.round(parseFloat(value));
};
mxAbstractCanvas2D.prototype.addOp = function() {
  if (this.path != null) {
    this.path.push(arguments[0]);
    if (arguments.length > 2) {
      const s = this.state;
      for (let i = 2; i < arguments.length; i += 2) {
        this.lastX = arguments[i - 1];
        this.lastY = arguments[i];
        this.path.push(this.format((this.lastX + s.dx) * s.scale));
        this.path.push(this.format((this.lastY + s.dy) * s.scale));
      }
    }
  }
};
mxAbstractCanvas2D.prototype.rotatePoint = function(x, y, theta, cx, cy) {
  const rad = theta * (Math.PI / 180);
  return getRotatedPoint(new mxPoint2(x, y), Math.cos(rad), Math.sin(rad), new mxPoint2(cx, cy));
};
mxAbstractCanvas2D.prototype.save = function() {
  this.states.push(this.state);
  this.state = clone(this.state);
};
mxAbstractCanvas2D.prototype.restore = function() {
  if (this.states.length > 0) {
    this.state = this.states.pop();
  }
};
mxAbstractCanvas2D.prototype.setLink = function(link2) {
};
mxAbstractCanvas2D.prototype.scale = function(value) {
  this.state.scale *= value;
  this.state.strokeWidth *= value;
};
mxAbstractCanvas2D.prototype.translate = function(dx, dy) {
  this.state.dx += dx;
  this.state.dy += dy;
};
mxAbstractCanvas2D.prototype.rotate = function(theta, flipH, flipV, cx, cy) {
};
mxAbstractCanvas2D.prototype.setAlpha = function(value) {
  this.state.alpha = value;
};
mxAbstractCanvas2D.prototype.setFillAlpha = function(value) {
  this.state.fillAlpha = value;
};
mxAbstractCanvas2D.prototype.setStrokeAlpha = function(value) {
  this.state.strokeAlpha = value;
};
mxAbstractCanvas2D.prototype.setFillColor = function(value) {
  if (value == mxConstants2.NONE) {
    value = null;
  }
  this.state.fillColor = value;
  this.state.gradientColor = null;
};
mxAbstractCanvas2D.prototype.setGradient = function(color1, color2, x, y, w2, h2, direction, alpha12, alpha22) {
  const s = this.state;
  s.fillColor = color1;
  s.gradientFillAlpha = alpha12 != null ? alpha12 : 1;
  s.gradientColor = color2;
  s.gradientAlpha = alpha22 != null ? alpha22 : 1;
  s.gradientDirection = direction;
};
mxAbstractCanvas2D.prototype.setStrokeColor = function(value) {
  if (value == mxConstants2.NONE) {
    value = null;
  }
  this.state.strokeColor = value;
};
mxAbstractCanvas2D.prototype.setStrokeWidth = function(value) {
  this.state.strokeWidth = value;
};
mxAbstractCanvas2D.prototype.setDashed = function(value, fixDash) {
  this.state.dashed = value;
  this.state.fixDash = fixDash;
};
mxAbstractCanvas2D.prototype.setDashPattern = function(value) {
  this.state.dashPattern = value;
};
mxAbstractCanvas2D.prototype.setLineCap = function(value) {
  this.state.lineCap = value;
};
mxAbstractCanvas2D.prototype.setLineJoin = function(value) {
  this.state.lineJoin = value;
};
mxAbstractCanvas2D.prototype.setMiterLimit = function(value) {
  this.state.miterLimit = value;
};
mxAbstractCanvas2D.prototype.setFontColor = function(value) {
  if (value == mxConstants2.NONE) {
    value = null;
  }
  this.state.fontColor = value;
};
mxAbstractCanvas2D.prototype.setFontBackgroundColor = function(value) {
  if (value == mxConstants2.NONE) {
    value = null;
  }
  this.state.fontBackgroundColor = value;
};
mxAbstractCanvas2D.prototype.setFontBorderColor = function(value) {
  if (value == mxConstants2.NONE) {
    value = null;
  }
  this.state.fontBorderColor = value;
};
mxAbstractCanvas2D.prototype.setFontSize = function(value) {
  this.state.fontSize = parseFloat(value);
};
mxAbstractCanvas2D.prototype.setFontFamily = function(value) {
  this.state.fontFamily = value;
};
mxAbstractCanvas2D.prototype.setFontStyle = function(value) {
  if (value == null) {
    value = 0;
  }
  this.state.fontStyle = value;
};
mxAbstractCanvas2D.prototype.setShadow = function(enabled) {
  this.state.shadow = enabled;
};
mxAbstractCanvas2D.prototype.setShadowColor = function(value) {
  if (value == mxConstants2.NONE) {
    value = null;
  }
  this.state.shadowColor = value;
};
mxAbstractCanvas2D.prototype.setShadowAlpha = function(value) {
  this.state.shadowAlpha = value;
};
mxAbstractCanvas2D.prototype.setShadowOffset = function(dx, dy) {
  this.state.shadowDx = dx;
  this.state.shadowDy = dy;
};
mxAbstractCanvas2D.prototype.begin = function() {
  this.lastX = 0;
  this.lastY = 0;
  this.path = [];
};
mxAbstractCanvas2D.prototype.moveTo = function(x, y) {
  this.addOp(this.moveOp, x, y);
};
mxAbstractCanvas2D.prototype.lineTo = function(x, y) {
  this.addOp(this.lineOp, x, y);
};
mxAbstractCanvas2D.prototype.quadTo = function(x1, y1, x2, y2) {
  this.addOp(this.quadOp, x1, y1, x2, y2);
};
mxAbstractCanvas2D.prototype.curveTo = function(x1, y1, x2, y2, x3, y3) {
  this.addOp(this.curveOp, x1, y1, x2, y2, x3, y3);
};
mxAbstractCanvas2D.prototype.arcTo = function(rx, ry, angle, largeArcFlag, sweepFlag, x, y) {
  const curves = arcToCurves(this.lastX, this.lastY, rx, ry, angle, largeArcFlag, sweepFlag, x, y);
  if (curves != null) {
    for (let i = 0; i < curves.length; i += 6) {
      this.curveTo(curves[i], curves[i + 1], curves[i + 2], curves[i + 3], curves[i + 4], curves[i + 5]);
    }
  }
};
mxAbstractCanvas2D.prototype.close = function(x1, y1, x2, y2, x3, y3) {
  this.addOp(this.closeOp);
};
mxAbstractCanvas2D.prototype.end = function() {
};

// js/graph/mxSvgCanvas2D.js
var mxSvgCanvas2D_initialized = false;
function mxSvgCanvas2D(root, styleEnabled) {
  if (!mxSvgCanvas2D_initialized) {
    mxSvgCanvas2D_initialized = true;
    mxSvgCanvas2D.prototype.useDomParser = !mxClient_default.IS_IE && typeof DOMParser === "function" && typeof XMLSerializer === "function";
    if (mxSvgCanvas2D.prototype.useDomParser) {
      try {
        const doc = new DOMParser().parseFromString("test text", "text/html");
        mxSvgCanvas2D.prototype.useDomParser = doc != null;
      } catch (e) {
        mxSvgCanvas2D.prototype.useDomParser = false;
      }
    }
    mxSvgCanvas2D.prototype.useAbsoluteIds = !mxClient_default.IS_CHROMEAPP && !mxClient_default.IS_IE && !mxClient_default.IS_IE11 && !mxClient_default.IS_EDGE && document.getElementsByTagName("base").length > 0;
  }
  mxAbstractCanvas2D.call(this);
  this.root = root;
  this.gradients = [];
  this.defs = null;
  this.styleEnabled = styleEnabled != null ? styleEnabled : false;
  let svg = null;
  if (root.ownerDocument != document) {
    let node = root;
    while (node != null && node.nodeName != "svg") {
      node = node.parentNode;
    }
    svg = node;
  }
  if (svg != null) {
    const tmp = svg.getElementsByTagName("defs");
    if (tmp.length > 0) {
      this.defs = svg.getElementsByTagName("defs")[0];
    }
    if (this.defs == null) {
      this.defs = this.createElement("defs");
      if (svg.firstChild != null) {
        svg.insertBefore(this.defs, svg.firstChild);
      } else {
        svg.appendChild(this.defs);
      }
    }
    if (this.styleEnabled) {
      this.defs.appendChild(this.createStyle());
    }
  }
}
extend(mxSvgCanvas2D, mxAbstractCanvas2D);
mxSvgCanvas2D.prototype.node = null;
mxSvgCanvas2D.prototype.matchHtmlAlignment = true;
mxSvgCanvas2D.prototype.textEnabled = true;
mxSvgCanvas2D.prototype.foEnabled = true;
mxSvgCanvas2D.prototype.foAltText = "[Object]";
mxSvgCanvas2D.prototype.foOffset = 0;
mxSvgCanvas2D.prototype.textOffset = 0;
mxSvgCanvas2D.prototype.imageOffset = 0;
mxSvgCanvas2D.prototype.strokeTolerance = 0;
mxSvgCanvas2D.prototype.minStrokeWidth = 1;
mxSvgCanvas2D.prototype.refCount = 0;
mxSvgCanvas2D.prototype.lineHeightCorrection = 1;
mxSvgCanvas2D.prototype.pointerEventsValue = "all";
mxSvgCanvas2D.prototype.fontMetricsPadding = 10;
mxSvgCanvas2D.prototype.cacheOffsetSize = true;
mxSvgCanvas2D.prototype.format = function(value) {
  return parseFloat(parseFloat(value).toFixed(2));
};
mxSvgCanvas2D.prototype.getBaseUrl = function() {
  let href = window.location.href;
  const hash = href.lastIndexOf("#");
  if (hash > 0) {
    href = href.substring(0, hash);
  }
  return href;
};
mxSvgCanvas2D.prototype.reset = function() {
  mxAbstractCanvas2D.prototype.reset.apply(this, arguments);
  this.gradients = [];
};
mxSvgCanvas2D.prototype.createStyle = function(x) {
  const style = this.createElement("style");
  style.setAttribute("type", "text/css");
  write(style, "svg{font-family:" + mxConstants2.DEFAULT_FONTFAMILY + ";font-size:" + mxConstants2.DEFAULT_FONTSIZE + ";fill:none;stroke-miterlimit:10}");
  return style;
};
mxSvgCanvas2D.prototype.createElement = function(tagName, namespace) {
  if (this.root.ownerDocument.createElementNS != null) {
    return this.root.ownerDocument.createElementNS(namespace || mxConstants2.NS_SVG, tagName);
  } else {
    const elt = this.root.ownerDocument.createElement(tagName);
    if (namespace != null) {
      elt.setAttribute("xmlns", namespace);
    }
    return elt;
  }
};
mxSvgCanvas2D.prototype.getAlternateText = function(fo, x, y, w2, h2, str, align, valign, wrap, format, overflow, clip, rotation) {
  return str != null ? this.foAltText : null;
};
mxSvgCanvas2D.prototype.createAlternateContent = function(fo, x, y, w2, h2, str, align, valign, wrap, format, overflow, clip, rotation) {
  const text = this.getAlternateText(fo, x, y, w2, h2, str, align, valign, wrap, format, overflow, clip, rotation);
  const s = this.state;
  if (text != null && s.fontSize > 0) {
    const dy = valign == mxConstants2.ALIGN_TOP ? 1 : valign == mxConstants2.ALIGN_BOTTOM ? 0 : 0.3;
    const anchor = align == mxConstants2.ALIGN_RIGHT ? "end" : align == mxConstants2.ALIGN_LEFT ? "start" : "middle";
    const alt = this.createElement("text");
    alt.setAttribute("x", Math.round(x + s.dx));
    alt.setAttribute("y", Math.round(y + s.dy + dy * s.fontSize));
    alt.setAttribute("fill", s.fontColor || "black");
    alt.setAttribute("font-family", s.fontFamily);
    alt.setAttribute("font-size", Math.round(s.fontSize) + "px");
    if (anchor != "start") {
      alt.setAttribute("text-anchor", anchor);
    }
    if ((s.fontStyle & mxConstants2.FONT_BOLD) == mxConstants2.FONT_BOLD) {
      alt.setAttribute("font-weight", "bold");
    }
    if ((s.fontStyle & mxConstants2.FONT_ITALIC) == mxConstants2.FONT_ITALIC) {
      alt.setAttribute("font-style", "italic");
    }
    const txtDecor = [];
    if ((s.fontStyle & mxConstants2.FONT_UNDERLINE) == mxConstants2.FONT_UNDERLINE) {
      txtDecor.push("underline");
    }
    if ((s.fontStyle & mxConstants2.FONT_STRIKETHROUGH) == mxConstants2.FONT_STRIKETHROUGH) {
      txtDecor.push("line-through");
    }
    if (txtDecor.length > 0) {
      alt.setAttribute("text-decoration", txtDecor.join(" "));
    }
    write(alt, text);
    return alt;
  } else {
    return null;
  }
};
mxSvgCanvas2D.prototype.createGradientId = function(start, end, alpha12, alpha22, direction) {
  if (start.charAt(0) == "#") {
    start = start.substring(1);
  }
  if (end.charAt(0) == "#") {
    end = end.substring(1);
  }
  start = start.toLowerCase() + "-" + alpha12;
  end = end.toLowerCase() + "-" + alpha22;
  let dir = null;
  if (direction == null || direction == mxConstants2.DIRECTION_SOUTH) {
    dir = "s";
  } else if (direction == mxConstants2.DIRECTION_EAST) {
    dir = "e";
  } else {
    const tmp = start;
    start = end;
    end = tmp;
    if (direction == mxConstants2.DIRECTION_NORTH) {
      dir = "s";
    } else if (direction == mxConstants2.DIRECTION_WEST) {
      dir = "e";
    }
  }
  return "mx-gradient-" + start + "-" + end + "-" + dir;
};
mxSvgCanvas2D.prototype.getSvgGradient = function(start, end, alpha12, alpha22, direction) {
  const id = this.createGradientId(start, end, alpha12, alpha22, direction);
  let gradient = this.gradients[id];
  if (gradient == null) {
    const svg = this.root.ownerSVGElement;
    let counter = 0;
    let tmpId = id + "-" + counter;
    if (svg != null) {
      gradient = svg.ownerDocument.getElementById(tmpId);
      while (gradient != null && gradient.ownerSVGElement != svg) {
        tmpId = id + "-" + counter++;
        gradient = svg.ownerDocument.getElementById(tmpId);
      }
    } else {
      tmpId = "id" + ++this.refCount;
    }
    if (gradient == null) {
      gradient = this.createSvgGradient(start, end, alpha12, alpha22, direction);
      gradient.setAttribute("id", tmpId);
      if (this.defs != null) {
        this.defs.appendChild(gradient);
      } else {
        svg.appendChild(gradient);
      }
    }
    this.gradients[id] = gradient;
  }
  return gradient.getAttribute("id");
};
mxSvgCanvas2D.prototype.createSvgGradient = function(start, end, alpha12, alpha22, direction) {
  const gradient = this.createElement("linearGradient");
  gradient.setAttribute("x1", "0%");
  gradient.setAttribute("y1", "0%");
  gradient.setAttribute("x2", "0%");
  gradient.setAttribute("y2", "0%");
  if (direction == null || direction == mxConstants2.DIRECTION_SOUTH) {
    gradient.setAttribute("y2", "100%");
  } else if (direction == mxConstants2.DIRECTION_EAST) {
    gradient.setAttribute("x2", "100%");
  } else if (direction == mxConstants2.DIRECTION_NORTH) {
    gradient.setAttribute("y1", "100%");
  } else if (direction == mxConstants2.DIRECTION_WEST) {
    gradient.setAttribute("x1", "100%");
  }
  let op = alpha12 < 1 ? ";stop-opacity:" + alpha12 : "";
  let stop = this.createElement("stop");
  stop.setAttribute("offset", "0%");
  stop.setAttribute("style", "stop-color:" + start + op);
  gradient.appendChild(stop);
  op = alpha22 < 1 ? ";stop-opacity:" + alpha22 : "";
  stop = this.createElement("stop");
  stop.setAttribute("offset", "100%");
  stop.setAttribute("style", "stop-color:" + end + op);
  gradient.appendChild(stop);
  return gradient;
};
mxSvgCanvas2D.prototype.addNode = function(filled, stroked) {
  const node = this.node;
  const s = this.state;
  if (node != null) {
    if (node.nodeName == "path") {
      if (this.path != null && this.path.length > 0) {
        node.setAttribute("d", this.path.join(" "));
      } else {
        return;
      }
    }
    if (filled && s.fillColor != null) {
      this.updateFill();
    } else if (!this.styleEnabled) {
      if (node.nodeName == "ellipse" && mxClient_default.IS_FF) {
        node.setAttribute("fill", "transparent");
      } else {
        node.setAttribute("fill", "none");
      }
      filled = false;
    }
    if (stroked && s.strokeColor != null) {
      this.updateStroke();
    } else if (!this.styleEnabled) {
      node.setAttribute("stroke", "none");
    }
    if (s.transform != null && s.transform.length > 0) {
      node.setAttribute("transform", s.transform);
    }
    if (s.shadow) {
      this.root.appendChild(this.createShadow(node));
    }
    if (this.strokeTolerance > 0 && !filled) {
      this.root.appendChild(this.createTolerance(node));
    }
    if (this.pointerEvents) {
      node.setAttribute("pointer-events", this.pointerEventsValue);
    } else if (!this.pointerEvents && this.originalRoot == null) {
      node.setAttribute("pointer-events", "none");
    }
    if (node.nodeName != "rect" && node.nodeName != "path" && node.nodeName != "ellipse" || node.getAttribute("fill") != "none" && node.getAttribute("fill") != "transparent" || node.getAttribute("stroke") != "none" || node.getAttribute("pointer-events") != "none") {
      this.root.appendChild(node);
    }
    this.node = null;
  }
};
mxSvgCanvas2D.prototype.updateFill = function() {
  const s = this.state;
  if (s.alpha < 1 || s.fillAlpha < 1) {
    this.node.setAttribute("fill-opacity", s.alpha * s.fillAlpha);
  }
  if (s.fillColor != null) {
    if (s.gradientColor != null) {
      const id = this.getSvgGradient(String(s.fillColor), String(s.gradientColor), s.gradientFillAlpha, s.gradientAlpha, s.gradientDirection);
      if (this.root.ownerDocument == document && this.useAbsoluteIds) {
        const base = this.getBaseUrl().replace(/([\(\)])/g, "\\$1");
        this.node.setAttribute("fill", "url(" + base + "#" + id + ")");
      } else {
        this.node.setAttribute("fill", "url(#" + id + ")");
      }
    } else {
      this.node.setAttribute("fill", String(s.fillColor).toLowerCase());
    }
  }
};
mxSvgCanvas2D.prototype.getCurrentStrokeWidth = function() {
  return Math.max(this.minStrokeWidth, Math.max(0.01, this.format(this.state.strokeWidth * this.state.scale)));
};
mxSvgCanvas2D.prototype.updateStroke = function() {
  const s = this.state;
  this.node.setAttribute("stroke", String(s.strokeColor).toLowerCase());
  if (s.alpha < 1 || s.strokeAlpha < 1) {
    this.node.setAttribute("stroke-opacity", s.alpha * s.strokeAlpha);
  }
  const sw = this.getCurrentStrokeWidth();
  if (sw != 1) {
    this.node.setAttribute("stroke-width", sw);
  }
  if (this.node.nodeName == "path") {
    this.updateStrokeAttributes();
  }
  if (s.dashed) {
    this.node.setAttribute("stroke-dasharray", this.createDashPattern((s.fixDash ? 1 : s.strokeWidth) * s.scale));
  }
};
mxSvgCanvas2D.prototype.updateStrokeAttributes = function() {
  const s = this.state;
  if (s.lineJoin != null && s.lineJoin != "miter") {
    this.node.setAttribute("stroke-linejoin", s.lineJoin);
  }
  if (s.lineCap != null) {
    let value = s.lineCap;
    if (value == "flat") {
      value = "butt";
    }
    if (value != "butt") {
      this.node.setAttribute("stroke-linecap", value);
    }
  }
  if (s.miterLimit != null && (!this.styleEnabled || s.miterLimit != 10)) {
    this.node.setAttribute("stroke-miterlimit", s.miterLimit);
  }
};
mxSvgCanvas2D.prototype.createDashPattern = function(scale) {
  const pat = [];
  if (typeof this.state.dashPattern === "string") {
    const dash = this.state.dashPattern.split(" ");
    if (dash.length > 0) {
      for (let i = 0; i < dash.length; i++) {
        pat[i] = Number(dash[i]) * scale;
      }
    }
  }
  return pat.join(" ");
};
mxSvgCanvas2D.prototype.createTolerance = function(node) {
  const tol = node.cloneNode(true);
  const sw = parseFloat(tol.getAttribute("stroke-width") || 1) + this.strokeTolerance;
  tol.setAttribute("pointer-events", "stroke");
  tol.setAttribute("visibility", "hidden");
  tol.removeAttribute("stroke-dasharray");
  tol.setAttribute("stroke-width", sw);
  tol.setAttribute("fill", "none");
  tol.setAttribute("stroke", mxClient_default.IS_OT ? "none" : "white");
  return tol;
};
mxSvgCanvas2D.prototype.createShadow = function(node) {
  const shadow = node.cloneNode(true);
  const s = this.state;
  if (shadow.getAttribute("fill") != "none" && (!mxClient_default.IS_FF || shadow.getAttribute("fill") != "transparent")) {
    shadow.setAttribute("fill", s.shadowColor);
  }
  if (shadow.getAttribute("stroke") != "none") {
    shadow.setAttribute("stroke", s.shadowColor);
  }
  shadow.setAttribute("transform", "translate(" + this.format(s.shadowDx * s.scale) + "," + this.format(s.shadowDy * s.scale) + ")" + (s.transform || ""));
  shadow.setAttribute("opacity", s.shadowAlpha);
  return shadow;
};
mxSvgCanvas2D.prototype.setLink = function(link2) {
  if (link2 == null) {
    this.root = this.originalRoot;
  } else {
    this.originalRoot = this.root;
    const node = this.createElement("a");
    if (node.setAttributeNS == null || this.root.ownerDocument != document && document.documentMode == null) {
      node.setAttribute("xlink:href", link2);
    } else {
      node.setAttributeNS(mxConstants2.NS_XLINK, "xlink:href", link2);
    }
    this.root.appendChild(node);
    this.root = node;
  }
};
mxSvgCanvas2D.prototype.rotate = function(theta, flipH, flipV, cx, cy) {
  if (theta != 0 || flipH || flipV) {
    const s = this.state;
    cx += s.dx;
    cy += s.dy;
    cx *= s.scale;
    cy *= s.scale;
    s.transform = s.transform || "";
    if (flipH && flipV) {
      theta += 180;
    } else if (flipH != flipV) {
      const tx = flipH ? cx : 0;
      const sx = flipH ? -1 : 1;
      const ty = flipV ? cy : 0;
      const sy = flipV ? -1 : 1;
      s.transform += "translate(" + this.format(tx) + "," + this.format(ty) + ")scale(" + this.format(sx) + "," + this.format(sy) + ")translate(" + this.format(-tx) + "," + this.format(-ty) + ")";
    }
    if (flipH ? !flipV : flipV) {
      theta *= -1;
    }
    if (theta != 0) {
      s.transform += "rotate(" + this.format(theta) + "," + this.format(cx) + "," + this.format(cy) + ")";
    }
    s.rotation = s.rotation + theta;
    s.rotationCx = cx;
    s.rotationCy = cy;
  }
};
mxSvgCanvas2D.prototype.begin = function() {
  mxAbstractCanvas2D.prototype.begin.apply(this, arguments);
  this.node = this.createElement("path");
};
mxSvgCanvas2D.prototype.rect = function(x, y, w2, h2) {
  const s = this.state;
  const n = this.createElement("rect");
  n.setAttribute("x", this.format((x + s.dx) * s.scale));
  n.setAttribute("y", this.format((y + s.dy) * s.scale));
  n.setAttribute("width", this.format(w2 * s.scale));
  n.setAttribute("height", this.format(h2 * s.scale));
  this.node = n;
};
mxSvgCanvas2D.prototype.roundrect = function(x, y, w2, h2, dx, dy) {
  this.rect(x, y, w2, h2);
  if (dx > 0) {
    this.node.setAttribute("rx", this.format(dx * this.state.scale));
  }
  if (dy > 0) {
    this.node.setAttribute("ry", this.format(dy * this.state.scale));
  }
};
mxSvgCanvas2D.prototype.ellipse = function(x, y, w2, h2) {
  const s = this.state;
  const n = this.createElement("ellipse");
  n.setAttribute("cx", this.format((x + w2 / 2 + s.dx) * s.scale));
  n.setAttribute("cy", this.format((y + h2 / 2 + s.dy) * s.scale));
  n.setAttribute("rx", w2 / 2 * s.scale);
  n.setAttribute("ry", h2 / 2 * s.scale);
  this.node = n;
};
mxSvgCanvas2D.prototype.image = function(x, y, w2, h2, src, aspect, flipH, flipV) {
  src = this.converter.convert(src);
  aspect = aspect != null ? aspect : true;
  flipH = flipH != null ? flipH : false;
  flipV = flipV != null ? flipV : false;
  const s = this.state;
  x += s.dx;
  y += s.dy;
  const node = this.createElement("image");
  node.setAttribute("x", this.format(x * s.scale) + this.imageOffset);
  node.setAttribute("y", this.format(y * s.scale) + this.imageOffset);
  node.setAttribute("width", this.format(w2 * s.scale));
  node.setAttribute("height", this.format(h2 * s.scale));
  if (node.setAttributeNS == null) {
    node.setAttribute("xlink:href", src);
  } else {
    node.setAttributeNS(mxConstants2.NS_XLINK, "xlink:href", src);
  }
  if (!aspect) {
    node.setAttribute("preserveAspectRatio", "none");
  }
  if (s.alpha < 1 || s.fillAlpha < 1) {
    node.setAttribute("opacity", s.alpha * s.fillAlpha);
  }
  let tr = this.state.transform || "";
  if (flipH || flipV) {
    let sx = 1;
    let sy = 1;
    let dx = 0;
    let dy = 0;
    if (flipH) {
      sx = -1;
      dx = -w2 - 2 * x;
    }
    if (flipV) {
      sy = -1;
      dy = -h2 - 2 * y;
    }
    tr += "scale(" + sx + "," + sy + ")translate(" + dx * s.scale + "," + dy * s.scale + ")";
  }
  if (tr.length > 0) {
    node.setAttribute("transform", tr);
  }
  if (!this.pointerEvents) {
    node.setAttribute("pointer-events", "none");
  }
  this.root.appendChild(node);
};
mxSvgCanvas2D.prototype.convertHtml = function(val) {
  if (this.useDomParser) {
    const doc = new DOMParser().parseFromString(val, "text/html");
    if (doc != null) {
      val = new XMLSerializer().serializeToString(doc.body);
      if (val.substring(0, 5) == "<body") {
        val = val.substring(val.indexOf(">", 5) + 1);
      }
      if (val.substring(val.length - 7, val.length) == "</body>") {
        val = val.substring(0, val.length - 7);
      }
    }
  } else if (document.implementation != null && document.implementation.createDocument != null) {
    const xd = document.implementation.createDocument("http://www.w3.org/1999/xhtml", "html", null);
    const xb = xd.createElement("body");
    xd.documentElement.appendChild(xb);
    const div = document.createElement("div");
    div.innerHTML = val;
    let child = div.firstChild;
    while (child != null) {
      const next = child.nextSibling;
      xb.appendChild(xd.adoptNode(child));
      child = next;
    }
    return xb.innerHTML;
  } else {
    const ta = document.createElement("textarea");
    ta.innerHTML = val.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/</g, "<").replace(/>/g, ">");
    val = ta.value.replace(/&/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&").replace(/<br>/g, "<br />").replace(/<hr>/g, "<hr />").replace(/(<img[^>]+)>/gm, "$1 />");
  }
  return val;
};
mxSvgCanvas2D.prototype.createDiv = function(str) {
  if (!mxClient_default.IS_IE && !mxClient_default.IS_IE11 && document.createElementNS) {
    const div = document.createElementNS("http://www.w3.org/1999/xhtml", "div");
    if (isNode(str)) {
      const val = str;
      const div2 = document.createElement("div");
      const div3 = div2.cloneNode(false);
      if (this.root.ownerDocument != document) {
        div2.appendChild(val.cloneNode(true));
      } else {
        div2.appendChild(val);
      }
      div3.appendChild(div2);
      div.appendChild(div3);
    } else {
      const val = "<div><div>" + this.convertHtml(str) + "</div></div>";
      div.innerHTML = val;
    }
    return div;
  } else {
    let val = str;
    if (isNode(val)) {
      val = "<div><div>" + getXml(val) + "</div></div>";
    }
    val = '<div xmlns="http://www.w3.org/1999/xhtml">' + val + "</div>";
    return parseXml(val).documentElement;
  }
};
mxSvgCanvas2D.prototype.updateText = function(x, y, w2, h2, align, valign, wrap, overflow, clip, rotation, node) {
  if (node != null && node.firstChild != null && node.firstChild.firstChild != null) {
    this.updateTextNodes(x, y, w2, h2, align, valign, wrap, overflow, clip, rotation, node.firstChild);
  }
};
mxSvgCanvas2D.prototype.addForeignObject = function(x, y, w2, h2, str, align, valign, wrap, format, overflow, clip, rotation, dir, div, root) {
  const group = this.createElement("g");
  const fo = this.createElement("foreignObject");
  fo.setAttribute("style", "overflow: visible; text-align: left;");
  fo.setAttribute("pointer-events", "none");
  if (div.ownerDocument != document) {
    div = importNodeImplementation(fo.ownerDocument, div, true);
  }
  fo.appendChild(div);
  group.appendChild(fo);
  this.updateTextNodes(x, y, w2, h2, align, valign, wrap, overflow, clip, rotation, group);
  if (this.root.ownerDocument != document) {
    const alt = this.createAlternateContent(fo, x, y, w2, h2, str, align, valign, wrap, format, overflow, clip, rotation);
    if (alt != null) {
      fo.setAttribute("requiredFeatures", "http://www.w3.org/TR/SVG11/feature#Extensibility");
      const sw = this.createElement("switch");
      sw.appendChild(fo);
      sw.appendChild(alt);
      group.appendChild(sw);
    }
  }
  root.appendChild(group);
};
mxSvgCanvas2D.prototype.updateTextNodes = function(x, y, w2, h2, align, valign, wrap, overflow, clip, rotation, g) {
  const s = this.state.scale;
  mxSvgCanvas2D.createCss(w2 + 2, h2, align, valign, wrap, overflow, clip, this.state.fontBackgroundColor != null ? this.state.fontBackgroundColor : null, this.state.fontBorderColor != null ? this.state.fontBorderColor : null, "display: flex; align-items: unsafe " + (valign == mxConstants2.ALIGN_TOP ? "flex-start" : valign == mxConstants2.ALIGN_BOTTOM ? "flex-end" : "center") + "; justify-content: unsafe " + (align == mxConstants2.ALIGN_LEFT ? "flex-start" : align == mxConstants2.ALIGN_RIGHT ? "flex-end" : "center") + "; ", this.getTextCss(), s, bind(this, function(dx, dy, flex, item, block) {
    x += this.state.dx;
    y += this.state.dy;
    const fo = g.firstChild;
    const div = fo.firstChild;
    const box = div.firstChild;
    const text = box.firstChild;
    const r = (this.rotateHtml ? this.state.rotation : 0) + (rotation != null ? rotation : 0);
    let t = (this.foOffset != 0 ? "translate(" + this.foOffset + " " + this.foOffset + ")" : "") + (s != 1 ? "scale(" + s + ")" : "");
    text.setAttribute("style", block);
    box.setAttribute("style", item);
    fo.setAttribute("width", Math.ceil(1 / Math.min(1, s) * 100) + "%");
    fo.setAttribute("height", Math.ceil(1 / Math.min(1, s) * 100) + "%");
    const yp = Math.round(y + dy);
    if (yp < 0) {
      fo.setAttribute("y", yp);
    } else {
      fo.removeAttribute("y");
      flex += "padding-top: " + yp + "px; ";
    }
    div.setAttribute("style", flex + "margin-left: " + Math.round(x + dx) + "px;");
    t += r != 0 ? "rotate(" + r + " " + x + " " + y + ")" : "";
    if (t != "") {
      g.setAttribute("transform", t);
    } else {
      g.removeAttribute("transform");
    }
    if (this.state.alpha != 1) {
      g.setAttribute("opacity", this.state.alpha);
    } else {
      g.removeAttribute("opacity");
    }
  }));
};
mxSvgCanvas2D.createCss = function(w2, h2, align, valign, wrap, overflow, clip, bg, border, flex, block, s, callback) {
  let item = "box-sizing: border-box; font-size: 0; text-align: " + (align == mxConstants2.ALIGN_LEFT ? "left" : align == mxConstants2.ALIGN_RIGHT ? "right" : "center") + "; ";
  const pt = getAlignmentAsPoint(align, valign);
  let ofl = "overflow: hidden; ";
  let fw = "width: 1px; ";
  const fh = "height: 1px; ";
  let dx = pt.x * w2;
  let dy = pt.y * h2;
  if (clip) {
    fw = "width: " + Math.round(w2) + "px; ";
    item += "max-height: " + Math.round(h2) + "px; ";
    dy = 0;
  } else if (overflow == "fill") {
    fw = "width: " + Math.round(w2) + "px; ";
    block += "width: 100%; height: 100%; ";
    item += fw + "height: " + Math.round(h2) + "px; ";
  } else if (overflow == "width") {
    fw = "width: " + Math.round(w2) + "px; ";
    block += "width: 100%; ";
    item += fw;
    dy = 0;
    if (h2 > 0) {
      item += "max-height: " + Math.round(h2) + "px; ";
    }
  } else {
    ofl = "";
    dy = 0;
  }
  let bgc = "";
  if (bg != null) {
    bgc += "background-color: " + bg + "; ";
  }
  if (border != null) {
    bgc += "border: 1px solid " + border + "; ";
  }
  if (ofl == "" || clip) {
    block += bgc;
  } else {
    item += bgc;
  }
  if (wrap && w2 > 0) {
    block += "white-space: normal; word-wrap: " + mxConstants2.WORD_WRAP + "; ";
    fw = "width: " + Math.round(w2) + "px; ";
    if (ofl != "" && overflow != "fill") {
      dy = 0;
    }
  } else {
    block += "white-space: nowrap; ";
    if (ofl == "") {
      dx = 0;
    }
  }
  callback(dx, dy, flex + fw + fh, item + ofl, block, ofl);
};
mxSvgCanvas2D.prototype.getTextCss = function() {
  const s = this.state;
  const lh = mxConstants2.ABSOLUTE_LINE_HEIGHT ? s.fontSize * mxConstants2.LINE_HEIGHT + "px" : mxConstants2.LINE_HEIGHT * this.lineHeightCorrection;
  let css = "display: inline-block; font-size: " + s.fontSize + "px; font-family: " + s.fontFamily + "; color: " + s.fontColor + "; line-height: " + lh + "; pointer-events: " + (this.pointerEvents ? this.pointerEventsValue : "none") + "; ";
  if ((s.fontStyle & mxConstants2.FONT_BOLD) == mxConstants2.FONT_BOLD) {
    css += "font-weight: bold; ";
  }
  if ((s.fontStyle & mxConstants2.FONT_ITALIC) == mxConstants2.FONT_ITALIC) {
    css += "font-style: italic; ";
  }
  const deco = [];
  if ((s.fontStyle & mxConstants2.FONT_UNDERLINE) == mxConstants2.FONT_UNDERLINE) {
    deco.push("underline");
  }
  if ((s.fontStyle & mxConstants2.FONT_STRIKETHROUGH) == mxConstants2.FONT_STRIKETHROUGH) {
    deco.push("line-through");
  }
  if (deco.length > 0) {
    css += "text-decoration: " + deco.join(" ") + "; ";
  }
  return css;
};
mxSvgCanvas2D.prototype.text = function(x, y, w2, h2, str, align, valign, wrap, format, overflow, clip, rotation, dir) {
  if (this.textEnabled && str != null) {
    rotation = rotation != null ? rotation : 0;
    if (this.foEnabled && format == "html") {
      const div = this.createDiv(str);
      if (div != null) {
        if (dir != null) {
          div.setAttribute("dir", dir);
        }
        this.addForeignObject(x, y, w2, h2, str, align, valign, wrap, format, overflow, clip, rotation, dir, div, this.root);
      }
    } else {
      this.plainText(x + this.state.dx, y + this.state.dy, w2, h2, str, align, valign, wrap, overflow, clip, rotation, dir);
    }
  }
};
mxSvgCanvas2D.prototype.createClip = function(x, y, w2, h2) {
  x = Math.round(x);
  y = Math.round(y);
  w2 = Math.round(w2);
  h2 = Math.round(h2);
  const id = "mx-clip-" + x + "-" + y + "-" + w2 + "-" + h2;
  let counter = 0;
  let tmp = id + "-" + counter;
  while (document.getElementById(tmp) != null) {
    tmp = id + "-" + ++counter;
  }
  const clip = this.createElement("clipPath");
  clip.setAttribute("id", tmp);
  const rect = this.createElement("rect");
  rect.setAttribute("x", x);
  rect.setAttribute("y", y);
  rect.setAttribute("width", w2);
  rect.setAttribute("height", h2);
  clip.appendChild(rect);
  return clip;
};
mxSvgCanvas2D.prototype.plainText = function(x, y, w2, h2, str, align, valign, wrap, overflow, clip, rotation, dir) {
  rotation = rotation != null ? rotation : 0;
  const s = this.state;
  const size = s.fontSize;
  const node = this.createElement("g");
  let tr = s.transform || "";
  this.updateFont(node);
  if (!this.pointerEvents && this.originalRoot == null) {
    node.setAttribute("pointer-events", "none");
  }
  if (rotation != 0) {
    tr += "rotate(" + rotation + "," + this.format(x * s.scale) + "," + this.format(y * s.scale) + ")";
  }
  if (dir != null) {
    node.setAttribute("direction", dir);
  }
  if (clip && w2 > 0 && h2 > 0) {
    let cx = x;
    let cy2 = y;
    if (align == mxConstants2.ALIGN_CENTER) {
      cx -= w2 / 2;
    } else if (align == mxConstants2.ALIGN_RIGHT) {
      cx -= w2;
    }
    if (overflow != "fill") {
      if (valign == mxConstants2.ALIGN_MIDDLE) {
        cy2 -= h2 / 2;
      } else if (valign == mxConstants2.ALIGN_BOTTOM) {
        cy2 -= h2;
      }
    }
    const c = this.createClip(cx * s.scale - 2, cy2 * s.scale - 2, w2 * s.scale + 4, h2 * s.scale + 4);
    if (this.defs != null) {
      this.defs.appendChild(c);
    } else {
      this.root.appendChild(c);
    }
    if (!mxClient_default.IS_CHROMEAPP && !mxClient_default.IS_IE && !mxClient_default.IS_IE11 && !mxClient_default.IS_EDGE && this.root.ownerDocument == document) {
      const base = this.getBaseUrl().replace(/([\(\)])/g, "\\$1");
      node.setAttribute("clip-path", "url(" + base + "#" + c.getAttribute("id") + ")");
    } else {
      node.setAttribute("clip-path", "url(#" + c.getAttribute("id") + ")");
    }
  }
  const anchor = align == mxConstants2.ALIGN_RIGHT ? "end" : align == mxConstants2.ALIGN_CENTER ? "middle" : "start";
  if (anchor != "start") {
    node.setAttribute("text-anchor", anchor);
  }
  if (!this.styleEnabled || size != mxConstants2.DEFAULT_FONTSIZE) {
    node.setAttribute("font-size", size * s.scale + "px");
  }
  if (tr.length > 0) {
    node.setAttribute("transform", tr);
  }
  if (s.alpha < 1) {
    node.setAttribute("opacity", s.alpha);
  }
  const lines = str.split("\n");
  const lh = Math.round(size * mxConstants2.LINE_HEIGHT);
  const textHeight = size + (lines.length - 1) * lh;
  let cy = y + size - 1;
  if (valign == mxConstants2.ALIGN_MIDDLE) {
    if (overflow == "fill") {
      cy -= h2 / 2;
    } else {
      const dy = (this.matchHtmlAlignment && clip && h2 > 0 ? Math.min(textHeight, h2) : textHeight) / 2;
      cy -= dy;
    }
  } else if (valign == mxConstants2.ALIGN_BOTTOM) {
    if (overflow == "fill") {
      cy -= h2;
    } else {
      const dy = this.matchHtmlAlignment && clip && h2 > 0 ? Math.min(textHeight, h2) : textHeight;
      cy -= dy + 1;
    }
  }
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].length > 0 && trim(lines[i]).length > 0) {
      const text = this.createElement("text");
      text.setAttribute("x", this.format(x * s.scale) + this.textOffset);
      text.setAttribute("y", this.format(cy * s.scale) + this.textOffset);
      write(text, lines[i]);
      node.appendChild(text);
    }
    cy += lh;
  }
  this.root.appendChild(node);
  this.addTextBackground(node, str, x, y, w2, overflow == "fill" ? h2 : textHeight, align, valign, overflow);
};
mxSvgCanvas2D.prototype.updateFont = function(node) {
  const s = this.state;
  node.setAttribute("fill", s.fontColor);
  if (!this.styleEnabled || s.fontFamily != mxConstants2.DEFAULT_FONTFAMILY) {
    node.setAttribute("font-family", s.fontFamily);
  }
  if ((s.fontStyle & mxConstants2.FONT_BOLD) == mxConstants2.FONT_BOLD) {
    node.setAttribute("font-weight", "bold");
  }
  if ((s.fontStyle & mxConstants2.FONT_ITALIC) == mxConstants2.FONT_ITALIC) {
    node.setAttribute("font-style", "italic");
  }
  const txtDecor = [];
  if ((s.fontStyle & mxConstants2.FONT_UNDERLINE) == mxConstants2.FONT_UNDERLINE) {
    txtDecor.push("underline");
  }
  if ((s.fontStyle & mxConstants2.FONT_STRIKETHROUGH) == mxConstants2.FONT_STRIKETHROUGH) {
    txtDecor.push("line-through");
  }
  if (txtDecor.length > 0) {
    node.setAttribute("text-decoration", txtDecor.join(" "));
  }
};
mxSvgCanvas2D.prototype.addTextBackground = function(node, str, x, y, w2, h2, align, valign, overflow) {
  const s = this.state;
  let bbox = null;
  if (s.fontBackgroundColor != null || s.fontBorderColor != null) {
    if ((bbox == null || bbox.width == 0 || bbox.height == 0) && node.getBBox != null && this.root.ownerDocument == document) {
      try {
        const b = node.getBBox();
        const ie = mxClient_default.IS_IE && mxClient_default.IS_SVG;
        bbox = new mxRectangle(b.x, b.y + (ie ? 0 : 1), b.width, b.height + (ie ? 1 : 0));
      } catch (e) {
      }
    }
    if (bbox == null || bbox.width == 0 || bbox.height == 0) {
      const div = document.createElement("div");
      div.style.lineHeight = mxConstants2.ABSOLUTE_LINE_HEIGHT ? s.fontSize * mxConstants2.LINE_HEIGHT + "px" : mxConstants2.LINE_HEIGHT;
      div.style.fontSize = s.fontSize + "px";
      div.style.fontFamily = s.fontFamily;
      div.style.whiteSpace = "nowrap";
      div.style.position = "absolute";
      div.style.visibility = "hidden";
      div.style.display = mxClient_default.IS_QUIRKS ? "inline" : "inline-block";
      div.style.zoom = "1";
      if ((s.fontStyle & mxConstants2.FONT_BOLD) == mxConstants2.FONT_BOLD) {
        div.style.fontWeight = "bold";
      }
      if ((s.fontStyle & mxConstants2.FONT_ITALIC) == mxConstants2.FONT_ITALIC) {
        div.style.fontStyle = "italic";
      }
      str = htmlEntities(str, false);
      div.innerHTML = str.replace(/\n/g, "<br/>");
      document.body.appendChild(div);
      const width = div.offsetWidth;
      const height = div.offsetHeight;
      div.parentNode.removeChild(div);
      if (align == mxConstants2.ALIGN_CENTER) {
        x -= width / 2;
      } else if (align == mxConstants2.ALIGN_RIGHT) {
        x -= width;
      }
      if (valign == mxConstants2.ALIGN_MIDDLE) {
        y -= height / 2;
      } else if (valign == mxConstants2.ALIGN_BOTTOM) {
        y -= height;
      }
      bbox = new mxRectangle((x + 1) * s.scale, (y + 2) * s.scale, width * s.scale, (height + 1) * s.scale);
    }
    if (bbox != null && typeof node.insertBefore === "function") {
      const n = this.createElement("rect");
      if (n) {
        n.setAttribute("fill", s.fontBackgroundColor || "none");
        n.setAttribute("stroke", s.fontBorderColor || "none");
        n.setAttribute("x", Math.floor(bbox.x - 1));
        n.setAttribute("y", Math.floor(bbox.y - 1));
        n.setAttribute("width", Math.ceil(bbox.width + 2));
        n.setAttribute("height", Math.ceil(bbox.height));
        const sw = s.fontBorderColor != null ? Math.max(1, this.format(s.scale)) : 0;
        n.setAttribute("stroke-width", sw);
        if (this.root.ownerDocument == document && mod(sw, 2) == 1) {
          n.setAttribute("transform", "translate(0.5, 0.5)");
        }
        node.insertBefore(n, node.firstChild);
      }
    }
  }
};
mxSvgCanvas2D.prototype.stroke = function() {
  this.addNode(false, true);
};
mxSvgCanvas2D.prototype.fill = function() {
  this.addNode(true, false);
};
mxSvgCanvas2D.prototype.fillAndStroke = function() {
  this.addNode(true, true);
};

// js/graph/mxVmlCanvas2D.js
function mxVmlCanvas2D(root) {
  mxAbstractCanvas2D.call(this);
  this.root = root;
}
extend(mxVmlCanvas2D, mxAbstractCanvas2D);
mxVmlCanvas2D.prototype.node = null;
mxVmlCanvas2D.prototype.textEnabled = true;
mxVmlCanvas2D.prototype.moveOp = "m";
mxVmlCanvas2D.prototype.lineOp = "l";
mxVmlCanvas2D.prototype.curveOp = "c";
mxVmlCanvas2D.prototype.closeOp = "x";
mxVmlCanvas2D.prototype.rotatedHtmlBackground = "";
mxVmlCanvas2D.prototype.vmlScale = 1;
mxVmlCanvas2D.prototype.createElement = function(name) {
  return document.createElement(name);
};
mxVmlCanvas2D.prototype.createVmlElement = function(name) {
  return this.createElement(mxClient_default.VML_PREFIX + ":" + name);
};
mxVmlCanvas2D.prototype.addNode = function(filled, stroked) {
  const node = this.node;
  const s = this.state;
  if (node != null) {
    if (node.nodeName == "shape") {
      if (this.path != null && this.path.length > 0) {
        node.path = this.path.join(" ") + " e";
        node.style.width = this.root.style.width;
        node.style.height = this.root.style.height;
        node.coordsize = parseInt(node.style.width) + " " + parseInt(node.style.height);
      } else {
        return;
      }
    }
    node.strokeweight = this.format(Math.max(1, s.strokeWidth * s.scale / this.vmlScale)) + "px";
    if (s.shadow) {
      this.root.appendChild(this.createShadow(node, filled && s.fillColor != null, stroked && s.strokeColor != null));
    }
    if (stroked && s.strokeColor != null) {
      node.stroked = "true";
      node.strokecolor = s.strokeColor;
    } else {
      node.stroked = "false";
    }
    node.appendChild(this.createStroke());
    if (filled && s.fillColor != null) {
      node.appendChild(this.createFill());
    } else if (this.pointerEvents && (node.nodeName != "shape" || this.path[this.path.length - 1] == this.closeOp)) {
      node.appendChild(this.createTransparentFill());
    } else {
      node.filled = "false";
    }
    this.root.appendChild(node);
  }
};
mxVmlCanvas2D.prototype.createTransparentFill = function() {
  const fill = this.createVmlElement("fill");
  fill.src = mxClient_default.imageBasePath + "/transparent.gif";
  fill.type = "tile";
  return fill;
};
mxVmlCanvas2D.prototype.createFill = function() {
  const s = this.state;
  const fill = this.createVmlElement("fill");
  fill.color = s.fillColor;
  if (s.gradientColor != null) {
    fill.type = "gradient";
    fill.method = "none";
    fill.color2 = s.gradientColor;
    let angle = 180 - s.rotation;
    if (s.gradientDirection == mxConstants2.DIRECTION_WEST) {
      angle -= 90 + (this.root.style.flip == "x" ? 180 : 0);
    } else if (s.gradientDirection == mxConstants2.DIRECTION_EAST) {
      angle += 90 + (this.root.style.flip == "x" ? 180 : 0);
    } else if (s.gradientDirection == mxConstants2.DIRECTION_NORTH) {
      angle -= 180 + (this.root.style.flip == "y" ? -180 : 0);
    } else {
      angle += this.root.style.flip == "y" ? -180 : 0;
    }
    if (this.root.style.flip == "x" || this.root.style.flip == "y") {
      angle *= -1;
    }
    fill.angle = mod(angle, 360);
    fill.opacity = s.alpha * s.gradientFillAlpha * 100 + "%";
    fill.setAttribute(mxClient_default.OFFICE_PREFIX + ":opacity2", s.alpha * s.gradientAlpha * 100 + "%");
  } else if (s.alpha < 1 || s.fillAlpha < 1) {
    fill.opacity = s.alpha * s.fillAlpha * 100 + "%";
  }
  return fill;
};
mxVmlCanvas2D.prototype.createStroke = function() {
  const s = this.state;
  const stroke = this.createVmlElement("stroke");
  stroke.endcap = s.lineCap || "flat";
  stroke.joinstyle = s.lineJoin || "miter";
  stroke.miterlimit = s.miterLimit || "10";
  if (s.alpha < 1 || s.strokeAlpha < 1) {
    stroke.opacity = s.alpha * s.strokeAlpha * 100 + "%";
  }
  if (s.dashed) {
    stroke.dashstyle = this.getVmlDashStyle();
  }
  return stroke;
};
mxVmlCanvas2D.prototype.getVmlDashStyle = function() {
  let result2 = "dash";
  if (typeof this.state.dashPattern === "string") {
    const tok = this.state.dashPattern.split(" ");
    if (tok.length > 0 && tok[0] == 1) {
      result2 = "0 2";
    }
  }
  return result2;
};
mxVmlCanvas2D.prototype.createShadow = function(node, filled, stroked) {
  const s = this.state;
  const rad = -s.rotation * (Math.PI / 180);
  const cos = Math.cos(rad);
  const sin = Math.sin(rad);
  let dx = s.shadowDx * s.scale;
  let dy = s.shadowDy * s.scale;
  if (this.root.style.flip == "x") {
    dx *= -1;
  } else if (this.root.style.flip == "y") {
    dy *= -1;
  }
  const shadow = node.cloneNode(true);
  shadow.style.marginLeft = Math.round(dx * cos - dy * sin) + "px";
  shadow.style.marginTop = Math.round(dx * sin + dy * cos) + "px";
  if (document.documentMode == 8) {
    shadow.strokeweight = node.strokeweight;
    if (node.nodeName == "shape") {
      shadow.path = this.path.join(" ") + " e";
      shadow.style.width = this.root.style.width;
      shadow.style.height = this.root.style.height;
      shadow.coordsize = parseInt(node.style.width) + " " + parseInt(node.style.height);
    }
  }
  if (stroked) {
    shadow.strokecolor = s.shadowColor;
    shadow.appendChild(this.createShadowStroke());
  } else {
    shadow.stroked = "false";
  }
  if (filled) {
    shadow.appendChild(this.createShadowFill());
  } else {
    shadow.filled = "false";
  }
  return shadow;
};
mxVmlCanvas2D.prototype.createShadowFill = function() {
  const fill = this.createVmlElement("fill");
  fill.color = this.state.shadowColor;
  fill.opacity = this.state.alpha * this.state.shadowAlpha * 100 + "%";
  return fill;
};
mxVmlCanvas2D.prototype.createShadowStroke = function() {
  const stroke = this.createStroke();
  stroke.opacity = this.state.alpha * this.state.shadowAlpha * 100 + "%";
  return stroke;
};
mxVmlCanvas2D.prototype.rotate = function(theta, flipH, flipV, cx, cy) {
  if (flipH && flipV) {
    theta += 180;
  } else if (flipH) {
    this.root.style.flip = "x";
  } else if (flipV) {
    this.root.style.flip = "y";
  }
  if (flipH ? !flipV : flipV) {
    theta *= -1;
  }
  this.root.style.rotation = theta;
  this.state.rotation = this.state.rotation + theta;
  this.state.rotationCx = cx;
  this.state.rotationCy = cy;
};
mxVmlCanvas2D.prototype.begin = function() {
  mxAbstractCanvas2D.prototype.begin.apply(this, arguments);
  this.node = this.createVmlElement("shape");
  this.node.style.position = "absolute";
};
mxVmlCanvas2D.prototype.quadTo = function(x1, y1, x2, y2) {
  const s = this.state;
  const cpx0 = (this.lastX + s.dx) * s.scale;
  const cpy0 = (this.lastY + s.dy) * s.scale;
  const qpx1 = (x1 + s.dx) * s.scale;
  const qpy1 = (y1 + s.dy) * s.scale;
  const cpx3 = (x2 + s.dx) * s.scale;
  const cpy3 = (y2 + s.dy) * s.scale;
  const cpx1 = cpx0 + 2 / 3 * (qpx1 - cpx0);
  const cpy1 = cpy0 + 2 / 3 * (qpy1 - cpy0);
  const cpx2 = cpx3 + 2 / 3 * (qpx1 - cpx3);
  const cpy2 = cpy3 + 2 / 3 * (qpy1 - cpy3);
  this.path.push("c " + this.format(cpx1) + " " + this.format(cpy1) + " " + this.format(cpx2) + " " + this.format(cpy2) + " " + this.format(cpx3) + " " + this.format(cpy3));
  this.lastX = cpx3 / s.scale - s.dx;
  this.lastY = cpy3 / s.scale - s.dy;
};
mxVmlCanvas2D.prototype.createRect = function(nodeName, x, y, w2, h2) {
  const s = this.state;
  const n = this.createVmlElement(nodeName);
  n.style.position = "absolute";
  n.style.left = this.format((x + s.dx) * s.scale) + "px";
  n.style.top = this.format((y + s.dy) * s.scale) + "px";
  n.style.width = this.format(w2 * s.scale) + "px";
  n.style.height = this.format(h2 * s.scale) + "px";
  return n;
};
mxVmlCanvas2D.prototype.rect = function(x, y, w2, h2) {
  this.node = this.createRect("rect", x, y, w2, h2);
};
mxVmlCanvas2D.prototype.roundrect = function(x, y, w2, h2, dx, dy) {
  this.node = this.createRect("roundrect", x, y, w2, h2);
  this.node.setAttribute("arcsize", Math.max(dx * 100 / w2, dy * 100 / h2) + "%");
};
mxVmlCanvas2D.prototype.ellipse = function(x, y, w2, h2) {
  this.node = this.createRect("oval", x, y, w2, h2);
};
mxVmlCanvas2D.prototype.image = function(x, y, w2, h2, src, aspect, flipH, flipV) {
  let node = null;
  if (!aspect) {
    node = this.createRect("image", x, y, w2, h2);
    node.src = src;
  } else {
    node = this.createRect("rect", x, y, w2, h2);
    node.stroked = "false";
    const fill = this.createVmlElement("fill");
    fill.aspect = aspect ? "atmost" : "ignore";
    fill.rotate = "true";
    fill.type = "frame";
    fill.src = src;
    node.appendChild(fill);
  }
  if (flipH && flipV) {
    node.style.rotation = "180";
  } else if (flipH) {
    node.style.flip = "x";
  } else if (flipV) {
    node.style.flip = "y";
  }
  if (this.state.alpha < 1 || this.state.fillAlpha < 1) {
    node.style.filter += "alpha(opacity=" + this.state.alpha * this.state.fillAlpha * 100 + ")";
  }
  this.root.appendChild(node);
};
mxVmlCanvas2D.prototype.createDiv = function(str, align, valign, overflow) {
  const div = this.createElement("div");
  const state2 = this.state;
  let css = "";
  if (state2.fontBackgroundColor != null) {
    css += "background-color:" + htmlEntities(state2.fontBackgroundColor) + ";";
  }
  if (state2.fontBorderColor != null) {
    css += "border:1px solid " + htmlEntities(state2.fontBorderColor) + ";";
  }
  if (isNode(str)) {
    div.appendChild(str);
  } else {
    if (overflow != "fill" && overflow != "width") {
      const div2 = this.createElement("div");
      div2.style.cssText = css;
      div2.style.display = mxClient_default.IS_QUIRKS ? "inline" : "inline-block";
      div2.style.zoom = "1";
      div2.style.textDecoration = "inherit";
      div2.innerHTML = str;
      div.appendChild(div2);
    } else {
      div.style.cssText = css;
      div.innerHTML = str;
    }
  }
  const style = div.style;
  style.fontSize = state2.fontSize / this.vmlScale + "px";
  style.fontFamily = state2.fontFamily;
  style.color = state2.fontColor;
  style.verticalAlign = "top";
  style.textAlign = align || "left";
  style.lineHeight = mxConstants2.ABSOLUTE_LINE_HEIGHT ? state2.fontSize * mxConstants2.LINE_HEIGHT / this.vmlScale + "px" : mxConstants2.LINE_HEIGHT;
  if ((state2.fontStyle & mxConstants2.FONT_BOLD) == mxConstants2.FONT_BOLD) {
    style.fontWeight = "bold";
  }
  if ((state2.fontStyle & mxConstants2.FONT_ITALIC) == mxConstants2.FONT_ITALIC) {
    style.fontStyle = "italic";
  }
  if ((state2.fontStyle & mxConstants2.FONT_UNDERLINE) == mxConstants2.FONT_UNDERLINE) {
    style.textDecoration = "underline";
  }
  return div;
};
mxVmlCanvas2D.prototype.text = function(x, y, w2, h2, str, align, valign, wrap, format, overflow, clip, rotation, dir) {
  if (this.textEnabled && str != null) {
    const s = this.state;
    if (format == "html") {
      if (s.rotation != null) {
        const pt = this.rotatePoint(x, y, s.rotation, s.rotationCx, s.rotationCy);
        x = pt.x;
        y = pt.y;
      }
      if (document.documentMode == 8 && !mxClient_default.IS_EM) {
        x += s.dx;
        y += s.dy;
        if (overflow != "fill" && valign == mxConstants2.ALIGN_TOP) {
          y -= 1;
        }
      } else {
        x *= s.scale;
        y *= s.scale;
      }
      const abs = document.documentMode == 8 && !mxClient_default.IS_EM ? this.createVmlElement("group") : this.createElement("div");
      abs.style.position = "absolute";
      abs.style.display = "inline";
      abs.style.left = this.format(x) + "px";
      abs.style.top = this.format(y) + "px";
      abs.style.zoom = s.scale;
      const box = this.createElement("div");
      box.style.position = "relative";
      box.style.display = "inline";
      const margin = getAlignmentAsPoint(align, valign);
      const dx = margin.x;
      const dy = margin.y;
      const div = this.createDiv(str, align, valign, overflow);
      const inner = this.createElement("div");
      if (dir != null) {
        div.setAttribute("dir", dir);
      }
      if (wrap && w2 > 0) {
        if (!clip) {
          div.style.width = Math.round(w2) + "px";
        }
        div.style.wordWrap = mxConstants2.WORD_WRAP;
        div.style.whiteSpace = "normal";
        if (div.style.wordWrap == "break-word") {
          let tmp = div;
          if (tmp.firstChild != null && tmp.firstChild.nodeName == "DIV") {
            tmp.firstChild.style.width = "100%";
          }
        }
      } else {
        div.style.whiteSpace = "nowrap";
      }
      const rot = s.rotation + (rotation || 0);
      if (this.rotateHtml && rot != 0) {
        inner.style.display = "inline";
        inner.style.zoom = "1";
        inner.appendChild(div);
        if (document.documentMode == 8 && !mxClient_default.IS_EM && this.root.nodeName != "DIV") {
          box.appendChild(inner);
          abs.appendChild(box);
        } else {
          abs.appendChild(inner);
        }
      } else if (document.documentMode == 8 && !mxClient_default.IS_EM) {
        box.appendChild(div);
        abs.appendChild(box);
      } else {
        div.style.display = "inline";
        abs.appendChild(div);
      }
      if (this.root.nodeName != "DIV") {
        const rect = this.createVmlElement("rect");
        rect.stroked = "false";
        rect.filled = "false";
        rect.appendChild(abs);
        this.root.appendChild(rect);
      } else {
        this.root.appendChild(abs);
      }
      if (clip) {
        div.style.overflow = "hidden";
        div.style.width = Math.round(w2) + "px";
        if (!mxClient_default.IS_QUIRKS) {
          div.style.maxHeight = Math.round(h2) + "px";
        }
      } else if (overflow == "fill") {
        div.style.overflow = "hidden";
        div.style.width = Math.max(0, w2) + 1 + "px";
        div.style.height = Math.max(0, h2) + 1 + "px";
      } else if (overflow == "width") {
        div.style.overflow = "hidden";
        div.style.width = Math.max(0, w2) + 1 + "px";
        div.style.maxHeight = Math.max(0, h2) + 1 + "px";
      }
      if (this.rotateHtml && rot != 0) {
        let rad = rot * (Math.PI / 180);
        const real_cos = parseFloat(parseFloat(Math.cos(rad)).toFixed(8));
        const real_sin = parseFloat(parseFloat(Math.sin(-rad)).toFixed(8));
        rad %= 2 * Math.PI;
        if (rad < 0)
          rad += 2 * Math.PI;
        rad %= Math.PI;
        if (rad > Math.PI / 2)
          rad = Math.PI - rad;
        const cos = Math.cos(rad);
        const sin = Math.sin(rad);
        if (document.documentMode == 8 && !mxClient_default.IS_EM) {
          div.style.display = "inline-block";
          inner.style.display = "inline-block";
          box.style.display = "inline-block";
        }
        div.style.visibility = "hidden";
        div.style.position = "absolute";
        document.body.appendChild(div);
        let sizeDiv = div;
        if (sizeDiv.firstChild != null && sizeDiv.firstChild.nodeName == "DIV") {
          sizeDiv = sizeDiv.firstChild;
        }
        const tmp = sizeDiv.offsetWidth + 3;
        let oh = sizeDiv.offsetHeight;
        if (clip) {
          w2 = Math.min(w2, tmp);
          oh = Math.min(oh, h2);
        } else {
          w2 = tmp;
        }
        if (wrap) {
          div.style.width = w2 + "px";
        }
        if (mxClient_default.IS_QUIRKS && (clip || overflow == "width") && oh > h2) {
          oh = h2;
          div.style.height = oh + "px";
        }
        h2 = oh;
        const top_fix = (h2 - h2 * cos + w2 * -sin) / 2 - real_sin * w2 * (dx + 0.5) + real_cos * h2 * (dy + 0.5);
        const left_fix = (w2 - w2 * cos + h2 * -sin) / 2 + real_cos * w2 * (dx + 0.5) + real_sin * h2 * (dy + 0.5);
        if (abs.nodeName == "group" && this.root.nodeName == "DIV") {
          const pos = this.createElement("div");
          pos.style.display = "inline-block";
          pos.style.position = "absolute";
          pos.style.left = this.format(x + (left_fix - w2 / 2) * s.scale) + "px";
          pos.style.top = this.format(y + (top_fix - h2 / 2) * s.scale) + "px";
          abs.parentNode.appendChild(pos);
          pos.appendChild(abs);
        } else {
          const sc = document.documentMode == 8 && !mxClient_default.IS_EM ? 1 : s.scale;
          abs.style.left = this.format(x + (left_fix - w2 / 2) * sc) + "px";
          abs.style.top = this.format(y + (top_fix - h2 / 2) * sc) + "px";
        }
        inner.style.filter = "progid:DXImageTransform.Microsoft.Matrix(M11=" + real_cos + ", M12=" + real_sin + ", M21=" + -real_sin + ", M22=" + real_cos + ", sizingMethod='auto expand')";
        inner.style.backgroundColor = this.rotatedHtmlBackground;
        if (this.state.alpha < 1) {
          inner.style.filter += "alpha(opacity=" + this.state.alpha * 100 + ")";
        }
        inner.appendChild(div);
        div.style.position = "";
        div.style.visibility = "";
      } else if (document.documentMode != 8 || mxClient_default.IS_EM) {
        div.style.verticalAlign = "top";
        if (this.state.alpha < 1) {
          abs.style.filter = "alpha(opacity=" + this.state.alpha * 100 + ")";
        }
        const divParent = div.parentNode;
        div.style.visibility = "hidden";
        document.body.appendChild(div);
        w2 = div.offsetWidth;
        let oh = div.offsetHeight;
        if (mxClient_default.IS_QUIRKS && clip && oh > h2) {
          oh = h2;
          div.style.height = oh + "px";
        }
        h2 = oh;
        div.style.visibility = "";
        divParent.appendChild(div);
        abs.style.left = this.format(x + w2 * dx * this.state.scale) + "px";
        abs.style.top = this.format(y + h2 * dy * this.state.scale) + "px";
      } else {
        if (this.state.alpha < 1) {
          div.style.filter = "alpha(opacity=" + this.state.alpha * 100 + ")";
        }
        box.style.left = dx * 100 + "%";
        box.style.top = dy * 100 + "%";
      }
    } else {
      this.plainText(x, y, w2, h2, htmlEntities(str, false), align, valign, wrap, format, overflow, clip, rotation, dir);
    }
  }
};
mxVmlCanvas2D.prototype.plainText = function(x, y, w2, h2, str, align, valign, wrap, format, overflow, clip, rotation, dir) {
  const s = this.state;
  x = (x + s.dx) * s.scale;
  y = (y + s.dy) * s.scale;
  const node = this.createVmlElement("shape");
  node.style.width = "1px";
  node.style.height = "1px";
  node.stroked = "false";
  const fill = this.createVmlElement("fill");
  fill.color = s.fontColor;
  fill.opacity = s.alpha * 100 + "%";
  node.appendChild(fill);
  const path = this.createVmlElement("path");
  path.textpathok = "true";
  path.v = "m " + this.format(0) + " " + this.format(0) + " l " + this.format(1) + " " + this.format(0);
  node.appendChild(path);
  const tp = this.createVmlElement("textpath");
  tp.style.cssText = "v-text-align:" + align;
  tp.style.align = align;
  tp.style.fontFamily = s.fontFamily;
  tp.string = str;
  tp.on = "true";
  const size = s.fontSize * s.scale / this.vmlScale;
  tp.style.fontSize = size + "px";
  if ((s.fontStyle & mxConstants2.FONT_BOLD) == mxConstants2.FONT_BOLD) {
    tp.style.fontWeight = "bold";
  }
  if ((s.fontStyle & mxConstants2.FONT_ITALIC) == mxConstants2.FONT_ITALIC) {
    tp.style.fontStyle = "italic";
  }
  if ((s.fontStyle & mxConstants2.FONT_UNDERLINE) == mxConstants2.FONT_UNDERLINE) {
    tp.style.textDecoration = "underline";
  }
  const lines = str.split("\n");
  const textHeight = size + (lines.length - 1) * size * mxConstants2.LINE_HEIGHT;
  let dx = 0;
  let dy = 0;
  if (valign == mxConstants2.ALIGN_BOTTOM) {
    dy = -textHeight / 2;
  } else if (valign != mxConstants2.ALIGN_MIDDLE) {
    dy = textHeight / 2;
  }
  if (rotation != null) {
    node.style.rotation = rotation;
    const rad = rotation * (Math.PI / 180);
    dx = Math.sin(rad) * dy;
    dy = Math.cos(rad) * dy;
  }
  node.appendChild(tp);
  node.style.left = this.format(x - dx) + "px";
  node.style.top = this.format(y + dy) + "px";
  this.root.appendChild(node);
};
mxVmlCanvas2D.prototype.stroke = function() {
  this.addNode(false, true);
};
mxVmlCanvas2D.prototype.fill = function() {
  this.addNode(true, false);
};
mxVmlCanvas2D.prototype.fillAndStroke = function() {
  this.addNode(true, true);
};

// js/graph/mxText.js
function mxText(value, bounds, align, valign, color, family, size, fontStyle, spacing, spacingTop, spacingRight, spacingBottom, spacingLeft, horizontal, background, border, wrap, clipped, overflow, labelPadding, textDirection) {
  mxShape.call(this);
  this.value = value;
  this.bounds = bounds;
  this.color = color != null ? color : "black";
  this.align = align != null ? align : mxConstants2.ALIGN_CENTER;
  this.valign = valign != null ? valign : mxConstants2.ALIGN_MIDDLE;
  this.family = family != null ? family : mxConstants2.DEFAULT_FONTFAMILY;
  this.size = size != null ? size : mxConstants2.DEFAULT_FONTSIZE;
  this.fontStyle = fontStyle != null ? fontStyle : mxConstants2.DEFAULT_FONTSTYLE;
  this.spacing = parseInt(spacing || 2);
  this.spacingTop = this.spacing + parseInt(spacingTop || 0);
  this.spacingRight = this.spacing + parseInt(spacingRight || 0);
  this.spacingBottom = this.spacing + parseInt(spacingBottom || 0);
  this.spacingLeft = this.spacing + parseInt(spacingLeft || 0);
  this.horizontal = horizontal != null ? horizontal : true;
  this.background = background;
  this.border = border;
  this.wrap = wrap != null ? wrap : false;
  this.clipped = clipped != null ? clipped : false;
  this.overflow = overflow != null ? overflow : "visible";
  this.labelPadding = labelPadding != null ? labelPadding : 0;
  this.textDirection = textDirection;
  this.rotation = 0;
  this.updateMargin();
}
extend(mxText, mxShape);
mxText.prototype.baseSpacingTop = 0;
mxText.prototype.baseSpacingBottom = 0;
mxText.prototype.baseSpacingLeft = 0;
mxText.prototype.baseSpacingRight = 0;
mxText.prototype.replaceLinefeeds = true;
mxText.prototype.verticalTextRotation = -90;
mxText.prototype.ignoreClippedStringSize = true;
mxText.prototype.ignoreStringSize = false;
mxText.prototype.textWidthPadding = document.documentMode == 8 && !mxClient_default.IS_EM ? 4 : 3;
mxText.prototype.lastValue = null;
mxText.prototype.cacheEnabled = true;
mxText.prototype.isParseVml = function() {
  return false;
};
mxText.prototype.isHtmlAllowed = function() {
  return document.documentMode != 8 || mxClient_default.IS_EM;
};
mxText.prototype.getSvgScreenOffset = function() {
  return 0;
};
mxText.prototype.checkBounds = function() {
  return !isNaN(this.scale) && isFinite(this.scale) && this.scale > 0 && this.bounds != null && !isNaN(this.bounds.x) && !isNaN(this.bounds.y) && !isNaN(this.bounds.width) && !isNaN(this.bounds.height);
};
mxText.prototype.paint = function(c, update) {
  const s = this.scale;
  const x = this.bounds.x / s;
  const y = this.bounds.y / s;
  const w2 = this.bounds.width / s;
  const h2 = this.bounds.height / s;
  this.updateTransform(c, x, y, w2, h2);
  this.configureCanvas(c, x, y, w2, h2);
  if (update) {
    c.updateText(x, y, w2, h2, this.align, this.valign, this.wrap, this.overflow, this.clipped, this.getTextRotation(), this.node);
  } else {
    const realHtml = isNode(this.value) || this.dialect == mxConstants2.DIALECT_STRICTHTML;
    const fmt = realHtml || c instanceof mxVmlCanvas2D ? "html" : "";
    let val = this.value;
    if (!realHtml && fmt == "html") {
      val = htmlEntities(val, false);
    }
    if (fmt == "html" && !isNode(this.value)) {
      val = replaceTrailingNewlines(val, "<div><br></div>");
    }
    val = !isNode(this.value) && this.replaceLinefeeds && fmt == "html" ? val.replace(/\n/g, "<br/>") : val;
    let dir = this.textDirection;
    if (dir == mxConstants2.TEXT_DIRECTION_AUTO && !realHtml) {
      dir = this.getAutoDirection();
    }
    if (dir != mxConstants2.TEXT_DIRECTION_LTR && dir != mxConstants2.TEXT_DIRECTION_RTL) {
      dir = null;
    }
    c.text(x, y, w2, h2, val, this.align, this.valign, this.wrap, fmt, this.overflow, this.clipped, this.getTextRotation(), dir);
  }
};
mxText.prototype.redraw = function() {
  if (this.visible && this.checkBounds() && this.cacheEnabled && this.lastValue == this.value && (isNode(this.value) || this.dialect == mxConstants2.DIALECT_STRICTHTML)) {
    if (this.node.nodeName == "DIV" && (this.isHtmlAllowed() || !mxClient_default.IS_VML)) {
      if (mxClient_default.IS_SVG) {
        this.redrawHtmlShapeWithCss3();
      } else {
        this.updateSize(this.node, this.state == null || this.state.view.textDiv == null);
        if (mxClient_default.IS_IE && (document.documentMode == null || document.documentMode <= 8)) {
          this.updateHtmlFilter();
        } else {
          this.updateHtmlTransform();
        }
      }
      this.updateBoundingBox();
    } else {
      const canvas = this.createCanvas();
      if (canvas != null && canvas.updateText != null) {
        canvas.pointerEvents = this.pointerEvents;
        this.paint(canvas, true);
        this.destroyCanvas(canvas);
        this.updateBoundingBox();
      } else {
        mxShape.prototype.redraw.apply(this, arguments);
      }
    }
  } else {
    mxShape.prototype.redraw.apply(this, arguments);
    if (isNode(this.value) || this.dialect == mxConstants2.DIALECT_STRICTHTML) {
      this.lastValue = this.value;
    } else {
      this.lastValue = null;
    }
  }
};
mxText.prototype.resetStyles = function() {
  mxShape.prototype.resetStyles.apply(this, arguments);
  this.color = "black";
  this.align = mxConstants2.ALIGN_CENTER;
  this.valign = mxConstants2.ALIGN_MIDDLE;
  this.family = mxConstants2.DEFAULT_FONTFAMILY;
  this.size = mxConstants2.DEFAULT_FONTSIZE;
  this.fontStyle = mxConstants2.DEFAULT_FONTSTYLE;
  this.spacing = 2;
  this.spacingTop = 2;
  this.spacingRight = 2;
  this.spacingBottom = 2;
  this.spacingLeft = 2;
  this.horizontal = true;
  delete this.background;
  delete this.border;
  this.textDirection = mxConstants2.DEFAULT_TEXT_DIRECTION;
  delete this.margin;
};
mxText.prototype.apply = function(state2) {
  const old = this.spacing;
  mxShape.prototype.apply.apply(this, arguments);
  if (this.style != null) {
    this.fontStyle = getValue(this.style, mxConstants2.STYLE_FONTSTYLE, this.fontStyle);
    this.family = getValue(this.style, mxConstants2.STYLE_FONTFAMILY, this.family);
    this.size = getValue(this.style, mxConstants2.STYLE_FONTSIZE, this.size);
    this.color = getValue(this.style, mxConstants2.STYLE_FONTCOLOR, this.color);
    this.align = getValue(this.style, mxConstants2.STYLE_ALIGN, this.align);
    this.valign = getValue(this.style, mxConstants2.STYLE_VERTICAL_ALIGN, this.valign);
    this.spacing = parseInt(getValue(this.style, mxConstants2.STYLE_SPACING, this.spacing));
    this.spacingTop = parseInt(getValue(this.style, mxConstants2.STYLE_SPACING_TOP, this.spacingTop - old)) + this.spacing;
    this.spacingRight = parseInt(getValue(this.style, mxConstants2.STYLE_SPACING_RIGHT, this.spacingRight - old)) + this.spacing;
    this.spacingBottom = parseInt(getValue(this.style, mxConstants2.STYLE_SPACING_BOTTOM, this.spacingBottom - old)) + this.spacing;
    this.spacingLeft = parseInt(getValue(this.style, mxConstants2.STYLE_SPACING_LEFT, this.spacingLeft - old)) + this.spacing;
    this.horizontal = getValue(this.style, mxConstants2.STYLE_HORIZONTAL, this.horizontal);
    this.background = getValue(this.style, mxConstants2.STYLE_LABEL_BACKGROUNDCOLOR, this.background);
    this.border = getValue(this.style, mxConstants2.STYLE_LABEL_BORDERCOLOR, this.border);
    this.textDirection = getValue(this.style, mxConstants2.STYLE_TEXT_DIRECTION, mxConstants2.DEFAULT_TEXT_DIRECTION);
    this.opacity = getValue(this.style, mxConstants2.STYLE_TEXT_OPACITY, 100);
    this.updateMargin();
  }
  this.flipV = null;
  this.flipH = null;
};
mxText.prototype.getAutoDirection = function() {
  const tmp = /[A-Za-z\u05d0-\u065f\u066a-\u06ef\u06fa-\u07ff\ufb1d-\ufdff\ufe70-\ufefc]/.exec(this.value);
  return tmp != null && tmp.length > 0 && tmp[0] > "z" ? mxConstants2.TEXT_DIRECTION_RTL : mxConstants2.TEXT_DIRECTION_LTR;
};
mxText.prototype.getContentNode = function() {
  let result2 = this.node;
  if (result2 != null) {
    if (result2.ownerSVGElement == null) {
      result2 = this.node.firstChild.firstChild;
    } else {
      result2 = result2.firstChild.firstChild.firstChild.firstChild.firstChild;
    }
  }
  return result2;
};
mxText.prototype.updateBoundingBox = function() {
  let node = this.node;
  this.boundingBox = this.bounds.clone();
  const rot = this.getTextRotation();
  const h2 = this.style != null ? getValue(this.style, mxConstants2.STYLE_LABEL_POSITION, mxConstants2.ALIGN_CENTER) : null;
  const v = this.style != null ? getValue(this.style, mxConstants2.STYLE_VERTICAL_LABEL_POSITION, mxConstants2.ALIGN_MIDDLE) : null;
  if (!this.ignoreStringSize && node != null && this.overflow != "fill" && (!this.clipped || !this.ignoreClippedStringSize || h2 != mxConstants2.ALIGN_CENTER || v != mxConstants2.ALIGN_MIDDLE)) {
    let ow = null;
    let oh = null;
    if (node.ownerSVGElement != null) {
      if (node.firstChild != null && node.firstChild.firstChild != null && node.firstChild.firstChild.nodeName == "foreignObject") {
        node = node.firstChild.firstChild.firstChild.firstChild;
        oh = node.offsetHeight * this.scale;
        if (this.overflow == "width") {
          ow = this.boundingBox.width;
        } else {
          ow = node.offsetWidth * this.scale;
        }
      } else {
        try {
          const b = node.getBBox();
          if (typeof this.value == "string" && trim(this.value) == 0) {
            this.boundingBox = null;
          } else if (b.width == 0 && b.height == 0) {
            this.boundingBox = null;
          } else {
            this.boundingBox = new mxRectangle(b.x, b.y, b.width, b.height);
          }
          return;
        } catch (e) {
        }
      }
    } else {
      const td = this.state != null ? this.state.view.textDiv : null;
      if (this.offsetWidth != null && this.offsetHeight != null) {
        ow = this.offsetWidth * this.scale;
        oh = this.offsetHeight * this.scale;
      } else {
        if (td != null) {
          this.updateFont(td);
          this.updateSize(td, false);
          this.updateInnerHtml(td);
          node = td;
        }
        let sizeDiv = node;
        if (document.documentMode == 8 && !mxClient_default.IS_EM) {
          const w2 = Math.round(this.bounds.width / this.scale);
          if (this.wrap && w2 > 0) {
            node.style.wordWrap = mxConstants2.WORD_WRAP;
            node.style.whiteSpace = "normal";
            if (node.style.wordWrap != "break-word") {
              let divs = sizeDiv.getElementsByTagName("div");
              if (divs.length > 0) {
                sizeDiv = divs[divs.length - 1];
              }
              ow = sizeDiv.offsetWidth + 2;
              divs = this.node.getElementsByTagName("div");
              if (this.clipped) {
                ow = Math.min(w2, ow);
              }
              if (divs.length > 1) {
                divs[divs.length - 2].style.width = ow + "px";
              }
            }
          } else {
            node.style.whiteSpace = "nowrap";
          }
        } else if (sizeDiv.firstChild != null && sizeDiv.firstChild.nodeName == "DIV") {
          sizeDiv = sizeDiv.firstChild;
        }
        this.offsetWidth = sizeDiv.offsetWidth + this.textWidthPadding;
        this.offsetHeight = sizeDiv.offsetHeight;
        ow = this.offsetWidth * this.scale;
        oh = this.offsetHeight * this.scale;
      }
    }
    if (ow != null && oh != null) {
      this.boundingBox = new mxRectangle(this.bounds.x, this.bounds.y, ow, oh);
    }
  }
  if (this.boundingBox != null) {
    if (rot != 0) {
      const bbox = getBoundingBox(new mxRectangle(this.margin.x * this.boundingBox.width, this.margin.y * this.boundingBox.height, this.boundingBox.width, this.boundingBox.height), rot, new mxPoint2(0, 0));
      this.unrotatedBoundingBox = mxRectangle.fromRectangle(this.boundingBox);
      this.unrotatedBoundingBox.x += this.margin.x * this.unrotatedBoundingBox.width;
      this.unrotatedBoundingBox.y += this.margin.y * this.unrotatedBoundingBox.height;
      this.boundingBox.x += bbox.x;
      this.boundingBox.y += bbox.y;
      this.boundingBox.width = bbox.width;
      this.boundingBox.height = bbox.height;
    } else {
      this.boundingBox.x += this.margin.x * this.boundingBox.width;
      this.boundingBox.y += this.margin.y * this.boundingBox.height;
      this.unrotatedBoundingBox = null;
    }
  }
};
mxText.prototype.getShapeRotation = function() {
  return 0;
};
mxText.prototype.getTextRotation = function() {
  return this.state != null && this.state.shape != null ? this.state.shape.getTextRotation() : 0;
};
mxText.prototype.isPaintBoundsInverted = function() {
  return !this.horizontal && this.state != null && this.state.view.graph.model.isVertex(this.state.cell);
};
mxText.prototype.configureCanvas = function(c, x, y, w2, h2) {
  mxShape.prototype.configureCanvas.apply(this, arguments);
  c.setFontColor(this.color);
  c.setFontBackgroundColor(this.background);
  c.setFontBorderColor(this.border);
  c.setFontFamily(this.family);
  c.setFontSize(this.size);
  c.setFontStyle(this.fontStyle);
};
mxText.prototype.updateVmlContainer = function() {
  this.node.style.left = Math.round(this.bounds.x) + "px";
  this.node.style.top = Math.round(this.bounds.y) + "px";
  this.node.style.width = "1px";
  this.node.style.height = "1px";
  this.node.style.overflow = "visible";
};
mxText.prototype.getHtmlValue = function() {
  let val = this.value;
  if (this.dialect != mxConstants2.DIALECT_STRICTHTML) {
    val = htmlEntities(val, false);
  }
  val = replaceTrailingNewlines(val, "<div><br></div>");
  val = this.replaceLinefeeds ? val.replace(/\n/g, "<br/>") : val;
  return val;
};
mxText.prototype.getTextCss = function() {
  const lh = mxConstants2.ABSOLUTE_LINE_HEIGHT ? this.size * mxConstants2.LINE_HEIGHT + "px" : mxConstants2.LINE_HEIGHT;
  let css = "display: inline-block; font-size: " + this.size + "px; font-family: " + this.family + "; color: " + this.color + "; line-height: " + lh + "; pointer-events: " + (this.pointerEvents ? "all" : "none") + "; ";
  if ((this.fontStyle & mxConstants2.FONT_BOLD) == mxConstants2.FONT_BOLD) {
    css += "font-weight: bold; ";
  }
  if ((this.fontStyle & mxConstants2.FONT_ITALIC) == mxConstants2.FONT_ITALIC) {
    css += "font-style: italic; ";
  }
  const deco = [];
  if ((this.fontStyle & mxConstants2.FONT_UNDERLINE) == mxConstants2.FONT_UNDERLINE) {
    deco.push("underline");
  }
  if ((this.fontStyle & mxConstants2.FONT_STRIKETHROUGH) == mxConstants2.FONT_STRIKETHROUGH) {
    deco.push("line-through");
  }
  if (deco.length > 0) {
    css += "text-decoration: " + deco.join(" ") + "; ";
  }
  return css;
};
mxText.prototype.redrawHtmlShape = function() {
  if (mxClient_default.IS_SVG) {
    this.redrawHtmlShapeWithCss3();
  } else {
    const style = this.node.style;
    style.whiteSpace = "normal";
    style.overflow = "";
    style.width = "";
    style.height = "";
    this.updateValue();
    this.updateFont(this.node);
    this.updateSize(this.node, this.state == null || this.state.view.textDiv == null);
    this.offsetWidth = null;
    this.offsetHeight = null;
    if (mxClient_default.IS_IE && (document.documentMode == null || document.documentMode <= 8)) {
      this.updateHtmlFilter();
    } else {
      this.updateHtmlTransform();
    }
  }
};
mxText.prototype.redrawHtmlShapeWithCss3 = function() {
  const w2 = Math.max(0, Math.round(this.bounds.width / this.scale));
  const h2 = Math.max(0, Math.round(this.bounds.height / this.scale));
  const flex = "position: absolute; left: " + Math.round(this.bounds.x) + "px; top: " + Math.round(this.bounds.y) + "px; pointer-events: none; ";
  const block = this.getTextCss();
  mxSvgCanvas2D.createCss(w2 + 2, h2, this.align, this.valign, this.wrap, this.overflow, this.clipped, this.background != null ? htmlEntities(this.background) : null, this.border != null ? htmlEntities(this.border) : null, flex, block, this.scale, bind(this, function(dx, dy, flex2, item, block2, ofl) {
    const r = this.getTextRotation();
    let tr = (this.scale != 1 ? "scale(" + this.scale + ") " : "") + (r != 0 ? "rotate(" + r + "deg) " : "") + (this.margin.x != 0 || this.margin.y != 0 ? "translate(" + this.margin.x * 100 + "%," + this.margin.y * 100 + "%)" : "");
    if (tr != "") {
      tr = "transform-origin: 0 0; transform: " + tr + "; ";
    }
    if (ofl == "") {
      flex2 += item;
      item = "display:inline-block; min-width: 100%; " + tr;
    } else {
      item += tr;
      if (mxClient_default.IS_SF) {
        item += "-webkit-clip-path: content-box;";
      }
    }
    if (this.opacity < 100) {
      block2 += "opacity: " + this.opacity / 100 + "; ";
    }
    this.node.setAttribute("style", flex2);
    const html = isNode(this.value) ? this.value.outerHTML : this.getHtmlValue();
    if (this.node.firstChild == null) {
      this.node.innerHTML = "<div><div>" + html + "</div></div>";
    }
    this.node.firstChild.firstChild.setAttribute("style", block2);
    this.node.firstChild.setAttribute("style", item);
  }));
};
mxText.prototype.updateHtmlTransform = function() {
  const theta = this.getTextRotation();
  const style = this.node.style;
  const dx = this.margin.x;
  const dy = this.margin.y;
  if (theta != 0) {
    setPrefixedStyle(style, "transformOrigin", -dx * 100 + "% " + -dy * 100 + "%");
    setPrefixedStyle(style, "transform", "translate(" + dx * 100 + "%," + dy * 100 + "%) scale(" + this.scale + ") rotate(" + theta + "deg)");
  } else {
    setPrefixedStyle(style, "transformOrigin", "0% 0%");
    setPrefixedStyle(style, "transform", "scale(" + this.scale + ") translate(" + dx * 100 + "%," + dy * 100 + "%)");
  }
  style.left = Math.round(this.bounds.x - Math.ceil(dx * (this.overflow != "fill" && this.overflow != "width" ? 3 : 1))) + "px";
  style.top = Math.round(this.bounds.y - dy * (this.overflow != "fill" ? 3 : 1)) + "px";
  if (this.opacity < 100) {
    style.opacity = this.opacity / 100;
  } else {
    style.opacity = "";
  }
};
mxText.prototype.updateInnerHtml = function(elt) {
  if (isNode(this.value)) {
    elt.innerHTML = this.value.outerHTML;
  } else {
    let val = this.value;
    if (this.dialect != mxConstants2.DIALECT_STRICTHTML) {
      val = htmlEntities(val, false);
    }
    val = replaceTrailingNewlines(val, "<div>\xA0</div>");
    val = this.replaceLinefeeds ? val.replace(/\n/g, "<br/>") : val;
    val = '<div style="display:inline-block;_display:inline;">' + val + "</div>";
    elt.innerHTML = val;
  }
};
mxText.prototype.updateHtmlFilter = function() {
  const style = this.node.style;
  const dx = this.margin.x;
  let dy = this.margin.y;
  const s = this.scale;
  setOpacity(this.node, this.opacity);
  let ow = 0;
  let oh = 0;
  const td = this.state != null ? this.state.view.textDiv : null;
  let sizeDiv = this.node;
  if (td != null) {
    td.style.overflow = "";
    td.style.height = "";
    td.style.width = "";
    this.updateFont(td);
    this.updateSize(td, false);
    this.updateInnerHtml(td);
    let w3 = Math.round(this.bounds.width / this.scale);
    if (this.wrap && w3 > 0) {
      td.style.whiteSpace = "normal";
      td.style.wordWrap = mxConstants2.WORD_WRAP;
      ow = w3;
      if (this.clipped) {
        ow = Math.min(ow, this.bounds.width);
      }
      td.style.width = ow + "px";
    } else {
      td.style.whiteSpace = "nowrap";
    }
    sizeDiv = td;
    if (sizeDiv.firstChild != null && sizeDiv.firstChild.nodeName == "DIV") {
      sizeDiv = sizeDiv.firstChild;
      if (this.wrap && td.style.wordWrap == "break-word") {
        sizeDiv.style.width = "100%";
      }
    }
    if (!this.clipped && this.wrap && w3 > 0) {
      ow = sizeDiv.offsetWidth + this.textWidthPadding;
      td.style.width = ow + "px";
    }
    oh = sizeDiv.offsetHeight + 2;
    if (mxClient_default.IS_QUIRKS && this.border != null && this.border != mxConstants2.NONE) {
      oh += 3;
    }
  } else if (sizeDiv.firstChild != null && sizeDiv.firstChild.nodeName == "DIV") {
    sizeDiv = sizeDiv.firstChild;
    oh = sizeDiv.offsetHeight;
  }
  ow = sizeDiv.offsetWidth + this.textWidthPadding;
  if (this.clipped) {
    oh = Math.min(oh, this.bounds.height);
  }
  let w2 = this.bounds.width / s;
  let h2 = this.bounds.height / s;
  if (this.overflow == "fill") {
    oh = h2;
    ow = w2;
  } else if (this.overflow == "width") {
    oh = sizeDiv.scrollHeight;
    ow = w2;
  }
  this.offsetWidth = ow;
  this.offsetHeight = oh;
  if (mxClient_default.IS_QUIRKS && (this.clipped || this.overflow == "width" && h2 > 0)) {
    h2 = Math.min(h2, oh);
    style.height = Math.round(h2) + "px";
  } else {
    h2 = oh;
  }
  if (this.overflow != "fill" && this.overflow != "width") {
    if (this.clipped) {
      ow = Math.min(w2, ow);
    }
    w2 = ow;
    if (mxClient_default.IS_QUIRKS && this.clipped || this.wrap) {
      style.width = Math.round(w2) + "px";
    }
  }
  h2 *= s;
  w2 *= s;
  let rad = this.getTextRotation() * (Math.PI / 180);
  const real_cos = parseFloat(parseFloat(Math.cos(rad)).toFixed(8));
  const real_sin = parseFloat(parseFloat(Math.sin(-rad)).toFixed(8));
  rad %= 2 * Math.PI;
  if (rad < 0) {
    rad += 2 * Math.PI;
  }
  rad %= Math.PI;
  if (rad > Math.PI / 2) {
    rad = Math.PI - rad;
  }
  const cos = Math.cos(rad);
  const sin = Math.sin(-rad);
  const tx = w2 * -(dx + 0.5);
  const ty = h2 * -(dy + 0.5);
  const top_fix = (h2 - h2 * cos + w2 * sin) / 2 + real_sin * tx - real_cos * ty;
  const left_fix = (w2 - w2 * cos + h2 * sin) / 2 - real_cos * tx - real_sin * ty;
  if (rad != 0) {
    const f = "progid:DXImageTransform.Microsoft.Matrix(M11=" + real_cos + ", M12=" + real_sin + ", M21=" + -real_sin + ", M22=" + real_cos + ", sizingMethod='auto expand')";
    if (style.filter != null && style.filter.length > 0) {
      style.filter += " " + f;
    } else {
      style.filter = f;
    }
  }
  let dy_fix = 0;
  if (this.overflow != "fill" && mxClient_default.IS_QUIRKS) {
    if (this.valign == mxConstants2.ALIGN_TOP) {
      dy_fix -= 1;
    } else if (this.valign == mxConstants2.ALIGN_BOTTOM) {
      dy_fix += 2;
    } else {
      dy_fix += 1;
    }
  }
  style.zoom = s;
  style.left = Math.round(this.bounds.x + left_fix - w2 / 2) + "px";
  style.top = Math.round(this.bounds.y + top_fix - h2 / 2 + dy_fix) + "px";
};
mxText.prototype.updateValue = function() {
  if (isNode(this.value)) {
    this.node.innerHTML = "";
    this.node.appendChild(this.value);
  } else {
    let val = this.value;
    if (this.dialect != mxConstants2.DIALECT_STRICTHTML) {
      val = htmlEntities(val, false);
    }
    val = replaceTrailingNewlines(val, "<div><br></div>");
    val = this.replaceLinefeeds ? val.replace(/\n/g, "<br/>") : val;
    const bg = this.background != null && this.background != mxConstants2.NONE ? this.background : null;
    const bd = this.border != null && this.border != mxConstants2.NONE ? this.border : null;
    if (this.overflow == "fill" || this.overflow == "width") {
      if (bg != null) {
        this.node.style.backgroundColor = bg;
      }
      if (bd != null) {
        this.node.style.border = "1px solid " + bd;
      }
    } else {
      let css = "";
      if (bg != null) {
        css += "background-color:" + htmlEntities(bg) + ";";
      }
      if (bd != null) {
        css += "border:1px solid " + htmlEntities(bd) + ";";
      }
      const lh = mxConstants2.ABSOLUTE_LINE_HEIGHT ? this.size * mxConstants2.LINE_HEIGHT + "px" : mxConstants2.LINE_HEIGHT;
      val = '<div style="zoom:1;' + css + "display:inline-block;_display:inline;text-decoration:inherit;padding-bottom:1px;padding-right:1px;line-height:" + lh + '">' + val + "</div>";
    }
    this.node.innerHTML = val;
    const divs = this.node.getElementsByTagName("div");
    if (divs.length > 0) {
      let dir = this.textDirection;
      if (dir == mxConstants2.TEXT_DIRECTION_AUTO && this.dialect != mxConstants2.DIALECT_STRICTHTML) {
        dir = this.getAutoDirection();
      }
      if (dir == mxConstants2.TEXT_DIRECTION_LTR || dir == mxConstants2.TEXT_DIRECTION_RTL) {
        divs[divs.length - 1].setAttribute("dir", dir);
      } else {
        divs[divs.length - 1].removeAttribute("dir");
      }
    }
  }
};
mxText.prototype.updateFont = function(node) {
  const style = node.style;
  style.lineHeight = mxConstants2.ABSOLUTE_LINE_HEIGHT ? this.size * mxConstants2.LINE_HEIGHT + "px" : mxConstants2.LINE_HEIGHT;
  style.fontSize = this.size + "px";
  style.fontFamily = this.family;
  style.verticalAlign = "top";
  style.color = this.color;
  if ((this.fontStyle & mxConstants2.FONT_BOLD) == mxConstants2.FONT_BOLD) {
    style.fontWeight = "bold";
  } else {
    style.fontWeight = "";
  }
  if ((this.fontStyle & mxConstants2.FONT_ITALIC) == mxConstants2.FONT_ITALIC) {
    style.fontStyle = "italic";
  } else {
    style.fontStyle = "";
  }
  const txtDecor = [];
  if ((this.fontStyle & mxConstants2.FONT_UNDERLINE) == mxConstants2.FONT_UNDERLINE) {
    txtDecor.push("underline");
  }
  if ((this.fontStyle & mxConstants2.FONT_STRIKETHROUGH) == mxConstants2.FONT_STRIKETHROUGH) {
    txtDecor.push("line-through");
  }
  style.textDecoration = txtDecor.join(" ");
  if (this.align == mxConstants2.ALIGN_CENTER) {
    style.textAlign = "center";
  } else if (this.align == mxConstants2.ALIGN_RIGHT) {
    style.textAlign = "right";
  } else {
    style.textAlign = "left";
  }
};
mxText.prototype.updateSize = function(node, enableWrap) {
  const w2 = Math.max(0, Math.round(this.bounds.width / this.scale));
  const h2 = Math.max(0, Math.round(this.bounds.height / this.scale));
  const style = node.style;
  if (this.clipped) {
    style.overflow = "hidden";
    if (!mxClient_default.IS_QUIRKS) {
      style.maxHeight = h2 + "px";
      style.maxWidth = w2 + "px";
    } else {
      style.width = w2 + "px";
    }
  } else if (this.overflow == "fill") {
    style.width = w2 + 1 + "px";
    style.height = h2 + 1 + "px";
    style.overflow = "hidden";
  } else if (this.overflow == "width") {
    style.width = w2 + 1 + "px";
    style.maxHeight = h2 + 1 + "px";
    style.overflow = "hidden";
  }
  if (this.wrap && w2 > 0) {
    style.wordWrap = mxConstants2.WORD_WRAP;
    style.whiteSpace = "normal";
    style.width = w2 + "px";
    if (enableWrap && this.overflow != "fill" && this.overflow != "width") {
      let sizeDiv = node;
      if (sizeDiv.firstChild != null && sizeDiv.firstChild.nodeName == "DIV") {
        sizeDiv = sizeDiv.firstChild;
        if (node.style.wordWrap == "break-word") {
          sizeDiv.style.width = "100%";
        }
      }
      let tmp = sizeDiv.offsetWidth;
      if (tmp == 0) {
        const prev = node.parentNode;
        node.style.visibility = "hidden";
        document.body.appendChild(node);
        tmp = sizeDiv.offsetWidth;
        node.style.visibility = "";
        prev.appendChild(node);
      }
      tmp += 3;
      if (this.clipped) {
        tmp = Math.min(tmp, w2);
      }
      style.width = tmp + "px";
    }
  } else {
    style.whiteSpace = "nowrap";
  }
};
mxText.prototype.updateMargin = function() {
  this.margin = getAlignmentAsPoint(this.align, this.valign);
};
mxText.prototype.getSpacing = function() {
  let dx = 0;
  let dy = 0;
  if (this.align == mxConstants2.ALIGN_CENTER) {
    dx = (this.spacingLeft - this.spacingRight) / 2;
  } else if (this.align == mxConstants2.ALIGN_RIGHT) {
    dx = -this.spacingRight - this.baseSpacingRight;
  } else {
    dx = this.spacingLeft + this.baseSpacingLeft;
  }
  if (this.valign == mxConstants2.ALIGN_MIDDLE) {
    dy = (this.spacingTop - this.spacingBottom) / 2;
  } else if (this.valign == mxConstants2.ALIGN_BOTTOM) {
    dy = -this.spacingBottom - this.baseSpacingBottom;
    ;
  } else {
    dy = this.spacingTop + this.baseSpacingTop;
  }
  return new mxPoint2(dx, dy);
};

// js/graph/mxShape.js
function mxShape(stencil) {
  this.stencil = stencil;
  this.initStyles();
}
mxShape.prototype.dialect = null;
mxShape.prototype.scale = 1;
mxShape.prototype.antiAlias = true;
mxShape.prototype.minSvgStrokeWidth = 1;
mxShape.prototype.bounds = null;
mxShape.prototype.points = null;
mxShape.prototype.node = null;
mxShape.prototype.state = null;
mxShape.prototype.style = null;
mxShape.prototype.boundingBox = null;
mxShape.prototype.stencil = null;
mxShape.prototype.svgStrokeTolerance = 8;
mxShape.prototype.pointerEvents = true;
mxShape.prototype.svgPointerEvents = "all";
mxShape.prototype.shapePointerEvents = false;
mxShape.prototype.stencilPointerEvents = false;
mxShape.prototype.vmlScale = 1;
mxShape.prototype.outline = false;
mxShape.prototype.visible = true;
mxShape.prototype.useSvgBoundingBox = false;
mxShape.prototype.init = function(container) {
  if (this.node == null) {
    this.node = this.create(container);
    if (container != null) {
      container.appendChild(this.node);
    }
  }
};
mxShape.prototype.initStyles = function(container) {
  this.strokewidth = 1;
  this.rotation = 0;
  this.opacity = 100;
  this.fillOpacity = 100;
  this.strokeOpacity = 100;
  this.flipH = false;
  this.flipV = false;
};
mxShape.prototype.isParseVml = function() {
  return true;
};
mxShape.prototype.isHtmlAllowed = function() {
  return false;
};
mxShape.prototype.getSvgScreenOffset = function() {
  var sw = this.stencil && this.stencil.strokewidth != "inherit" ? Number(this.stencil.strokewidth) : this.strokewidth;
  return mod(Math.max(1, Math.round(sw * this.scale)), 2) == 1 ? 0.5 : 0;
};
mxShape.prototype.create = function(container) {
  var node = null;
  if (container != null && container.ownerSVGElement != null) {
    node = this.createSvg(container);
  } else if (document.documentMode == 8 || !mxClient_default.IS_VML || this.dialect != mxConstants2.DIALECT_VML && this.isHtmlAllowed()) {
    node = this.createHtml(container);
  } else {
    node = this.createVml(container);
  }
  return node;
};
mxShape.prototype.createSvg = function() {
  return document.createElementNS(mxConstants2.NS_SVG, "g");
};
mxShape.prototype.createVml = function() {
  var node = document.createElement(mxClient_default.VML_PREFIX + ":group");
  node.style.position = "absolute";
  return node;
};
mxShape.prototype.createHtml = function() {
  var node = document.createElement("div");
  node.style.position = "absolute";
  return node;
};
mxShape.prototype.reconfigure = function() {
  this.redraw();
};
mxShape.prototype.redraw = function() {
  this.updateBoundsFromPoints();
  if (this.visible && this.checkBounds()) {
    this.node.style.visibility = "visible";
    this.clear();
    if (this.node.nodeName == "DIV" && (this.isHtmlAllowed() || !mxClient_default.IS_VML)) {
      this.redrawHtmlShape();
    } else {
      this.redrawShape();
    }
    this.updateBoundingBox();
  } else {
    this.node.style.visibility = "hidden";
    this.boundingBox = null;
  }
};
mxShape.prototype.clear = function() {
  if (this.node.ownerSVGElement != null) {
    while (this.node.lastChild != null) {
      this.node.removeChild(this.node.lastChild);
    }
  } else {
    this.node.style.cssText = "position:absolute;" + (this.cursor != null ? "cursor:" + this.cursor + ";" : "");
    this.node.innerHTML = "";
  }
};
mxShape.prototype.updateBoundsFromPoints = function() {
  var pts = this.points;
  if (pts != null && pts.length > 0 && pts[0] != null) {
    this.bounds = new mxRectangle(Number(pts[0].x), Number(pts[0].y), 1, 1);
    for (var i = 1; i < this.points.length; i++) {
      if (pts[i] != null) {
        this.bounds.add(new mxRectangle(Number(pts[i].x), Number(pts[i].y), 1, 1));
      }
    }
  }
};
mxShape.prototype.getLabelBounds = function(rect) {
  var d = getValue(this.style, mxConstants2.STYLE_DIRECTION, mxConstants2.DIRECTION_EAST);
  var bounds = rect;
  if (d != mxConstants2.DIRECTION_SOUTH && d != mxConstants2.DIRECTION_NORTH && this.state != null && this.state.text != null && this.state.text.isPaintBoundsInverted()) {
    bounds = bounds.clone();
    var tmp = bounds.width;
    bounds.width = bounds.height;
    bounds.height = tmp;
  }
  var m = this.getLabelMargins(bounds);
  if (m != null) {
    var flipH = getValue(this.style, mxConstants2.STYLE_FLIPH, false) == "1";
    var flipV = getValue(this.style, mxConstants2.STYLE_FLIPV, false) == "1";
    if (this.state != null && this.state.text != null && this.state.text.isPaintBoundsInverted()) {
      var tmp = m.x;
      m.x = m.height;
      m.height = m.width;
      m.width = m.y;
      m.y = tmp;
      tmp = flipH;
      flipH = flipV;
      flipV = tmp;
    }
    return getDirectedBounds(rect, m, this.style, flipH, flipV);
  }
  return rect;
};
mxShape.prototype.getLabelMargins = function(rect) {
  return null;
};
mxShape.prototype.checkBounds = function() {
  return !isNaN(this.scale) && isFinite(this.scale) && this.scale > 0 && this.bounds != null && !isNaN(this.bounds.x) && !isNaN(this.bounds.y) && !isNaN(this.bounds.width) && !isNaN(this.bounds.height) && this.bounds.width > 0 && this.bounds.height > 0;
};
mxShape.prototype.createVmlGroup = function() {
  var node = document.createElement(mxClient_default.VML_PREFIX + ":group");
  node.style.position = "absolute";
  node.style.width = this.node.style.width;
  node.style.height = this.node.style.height;
  return node;
};
mxShape.prototype.redrawShape = function() {
  var canvas = this.createCanvas();
  if (canvas != null) {
    canvas.pointerEvents = this.pointerEvents;
    this.beforePaint(canvas);
    this.paint(canvas);
    this.afterPaint(canvas);
    if (this.node != canvas.root) {
      this.node.insertAdjacentHTML("beforeend", canvas.root.outerHTML);
    }
    if (this.node.nodeName == "DIV" && document.documentMode == 8) {
      this.node.style.filter = "";
      addTransparentBackgroundFilter(this.node);
    }
    this.destroyCanvas(canvas);
  }
};
mxShape.prototype.createCanvas = function() {
  var canvas = null;
  if (this.node.ownerSVGElement != null) {
    canvas = this.createSvgCanvas();
  } else if (mxClient_default.IS_VML) {
    this.updateVmlContainer();
    canvas = this.createVmlCanvas();
  }
  if (canvas != null && this.outline) {
    canvas.setStrokeWidth(this.strokewidth);
    canvas.setStrokeColor(this.stroke);
    if (this.isDashed != null) {
      canvas.setDashed(this.isDashed);
    }
    canvas.setStrokeWidth = function() {
    };
    canvas.setStrokeColor = function() {
    };
    canvas.setFillColor = function() {
    };
    canvas.setGradient = function() {
    };
    canvas.setDashed = function() {
    };
    canvas.text = function() {
    };
  }
  return canvas;
};
mxShape.prototype.createSvgCanvas = function() {
  var canvas = new mxSvgCanvas2D(this.node, false);
  canvas.strokeTolerance = this.pointerEvents ? this.svgStrokeTolerance : 0;
  canvas.pointerEventsValue = this.svgPointerEvents;
  var off = this.getSvgScreenOffset();
  if (off != 0) {
    this.node.setAttribute("transform", "translate(" + off + "," + off + ")");
  } else {
    this.node.removeAttribute("transform");
  }
  canvas.minStrokeWidth = this.minSvgStrokeWidth;
  if (!this.antiAlias) {
    canvas.format = function(value) {
      return Math.round(parseFloat(value));
    };
  }
  return canvas;
};
mxShape.prototype.createVmlCanvas = function() {
  var node = document.documentMode == 8 && this.isParseVml() ? this.createVmlGroup() : this.node;
  var canvas = new mxVmlCanvas2D(node, false);
  if (node.tagUrn != "") {
    var w2 = Math.max(1, Math.round(this.bounds.width));
    var h2 = Math.max(1, Math.round(this.bounds.height));
    node.coordsize = w2 * this.vmlScale + "," + h2 * this.vmlScale;
    canvas.scale(this.vmlScale);
    canvas.vmlScale = this.vmlScale;
  }
  var s = this.scale;
  canvas.translate(-Math.round(this.bounds.x / s), -Math.round(this.bounds.y / s));
  return canvas;
};
mxShape.prototype.updateVmlContainer = function() {
  this.node.style.left = Math.round(this.bounds.x) + "px";
  this.node.style.top = Math.round(this.bounds.y) + "px";
  var w2 = Math.max(1, Math.round(this.bounds.width));
  var h2 = Math.max(1, Math.round(this.bounds.height));
  this.node.style.width = w2 + "px";
  this.node.style.height = h2 + "px";
  this.node.style.overflow = "visible";
};
mxShape.prototype.redrawHtmlShape = function() {
  this.updateHtmlBounds(this.node);
  this.updateHtmlFilters(this.node);
  this.updateHtmlColors(this.node);
};
mxShape.prototype.updateHtmlFilters = function(node) {
  var f = "";
  if (this.opacity < 100) {
    f += "alpha(opacity=" + this.opacity + ")";
  }
  if (this.isShadow) {
    f += "progid:DXImageTransform.Microsoft.dropShadow (OffX='" + Math.round(mxConstants2.SHADOW_OFFSET_X * this.scale) + "', OffY='" + Math.round(mxConstants2.SHADOW_OFFSET_Y * this.scale) + "', Color='" + mxConstants2.VML_SHADOWCOLOR + "')";
  }
  if (this.fill != null && this.fill != mxConstants2.NONE && this.gradient && this.gradient != mxConstants2.NONE) {
    var start = this.fill;
    var end = this.gradient;
    var type = "0";
    var lookup = { east: 0, south: 1, west: 2, north: 3 };
    var dir = this.direction != null ? lookup[this.direction] : 0;
    if (this.gradientDirection != null) {
      dir = mod(dir + lookup[this.gradientDirection] - 1, 4);
    }
    if (dir == 1) {
      type = "1";
      var tmp = start;
      start = end;
      end = tmp;
    } else if (dir == 2) {
      var tmp = start;
      start = end;
      end = tmp;
    } else if (dir == 3) {
      type = "1";
    }
    f += "progid:DXImageTransform.Microsoft.gradient(startColorStr='" + start + "', endColorStr='" + end + "', gradientType='" + type + "')";
  }
  node.style.filter = f;
};
mxShape.prototype.updateHtmlColors = function(node) {
  var color = this.stroke;
  if (color != null && color != mxConstants2.NONE) {
    node.style.borderColor = color;
    if (this.isDashed) {
      node.style.borderStyle = "dashed";
    } else if (this.strokewidth > 0) {
      node.style.borderStyle = "solid";
    }
    node.style.borderWidth = Math.max(1, Math.ceil(this.strokewidth * this.scale)) + "px";
  } else {
    node.style.borderWidth = "0px";
  }
  color = this.outline ? null : this.fill;
  if (color != null && color != mxConstants2.NONE) {
    node.style.backgroundColor = color;
    node.style.backgroundImage = "none";
  } else if (this.pointerEvents) {
    node.style.backgroundColor = "transparent";
  } else if (document.documentMode == 8) {
    addTransparentBackgroundFilter(node);
  } else {
    this.setTransparentBackgroundImage(node);
  }
};
mxShape.prototype.updateHtmlBounds = function(node) {
  var sw = document.documentMode >= 9 ? 0 : Math.ceil(this.strokewidth * this.scale);
  node.style.borderWidth = Math.max(1, sw) + "px";
  node.style.overflow = "hidden";
  node.style.left = Math.round(this.bounds.x - sw / 2) + "px";
  node.style.top = Math.round(this.bounds.y - sw / 2) + "px";
  if (document.compatMode == "CSS1Compat") {
    sw = -sw;
  }
  node.style.width = Math.round(Math.max(0, this.bounds.width + sw)) + "px";
  node.style.height = Math.round(Math.max(0, this.bounds.height + sw)) + "px";
};
mxShape.prototype.destroyCanvas = function(canvas) {
  if (canvas instanceof mxSvgCanvas2D) {
    for (var key in canvas.gradients) {
      var gradient = canvas.gradients[key];
      if (gradient != null) {
        gradient.mxRefCount = (gradient.mxRefCount || 0) + 1;
      }
    }
    this.releaseSvgGradients(this.oldGradients);
    this.oldGradients = canvas.gradients;
  }
};
mxShape.prototype.beforePaint = function(c) {
};
mxShape.prototype.afterPaint = function(c) {
};
mxShape.prototype.paint = function(c) {
  var strokeDrawn = false;
  if (c != null && this.outline) {
    var stroke = c.stroke;
    c.stroke = function() {
      strokeDrawn = true;
      stroke.apply(this, arguments);
    };
    var fillAndStroke = c.fillAndStroke;
    c.fillAndStroke = function() {
      strokeDrawn = true;
      fillAndStroke.apply(this, arguments);
    };
  }
  var s = this.scale;
  var x = this.bounds.x / s;
  var y = this.bounds.y / s;
  var w2 = this.bounds.width / s;
  var h2 = this.bounds.height / s;
  if (this.isPaintBoundsInverted()) {
    var t = (w2 - h2) / 2;
    x += t;
    y -= t;
    var tmp = w2;
    w2 = h2;
    h2 = tmp;
  }
  this.updateTransform(c, x, y, w2, h2);
  this.configureCanvas(c, x, y, w2, h2);
  var bg = null;
  if (this.stencil == null && this.points == null && this.shapePointerEvents || this.stencil != null && this.stencilPointerEvents) {
    var bb = this.createBoundingBox();
    if (this.dialect == mxConstants2.DIALECT_SVG) {
      bg = this.createTransparentSvgRectangle(bb.x, bb.y, bb.width, bb.height);
      this.node.appendChild(bg);
    } else {
      var rect = c.createRect("rect", bb.x / s, bb.y / s, bb.width / s, bb.height / s);
      rect.appendChild(c.createTransparentFill());
      rect.stroked = "false";
      c.root.appendChild(rect);
    }
  }
  if (this.stencil != null) {
    this.stencil.drawShape(c, this, x, y, w2, h2);
  } else {
    c.setStrokeWidth(this.strokewidth);
    if (this.points != null) {
      var pts = [];
      for (var i = 0; i < this.points.length; i++) {
        if (this.points[i] != null) {
          pts.push(new mxPoint2(this.points[i].x / s, this.points[i].y / s));
        }
      }
      this.paintEdgeShape(c, pts);
    } else {
      this.paintVertexShape(c, x, y, w2, h2);
    }
  }
  if (bg != null && c.state != null && c.state.transform != null) {
    bg.setAttribute("transform", c.state.transform);
  }
  if (c != null && this.outline && !strokeDrawn) {
    c.rect(x, y, w2, h2);
    c.stroke();
  }
};
mxShape.prototype.configureCanvas = function(c, x, y, w2, h2) {
  var dash = null;
  if (this.style != null) {
    dash = this.style["dashPattern"];
  }
  c.setAlpha(this.opacity / 100);
  c.setFillAlpha(this.fillOpacity / 100);
  c.setStrokeAlpha(this.strokeOpacity / 100);
  if (this.isShadow != null) {
    c.setShadow(this.isShadow);
  }
  if (this.isDashed != null) {
    c.setDashed(this.isDashed, this.style != null ? getValue(this.style, mxConstants2.STYLE_FIX_DASH, false) == 1 : false);
  }
  if (dash != null) {
    c.setDashPattern(dash);
  }
  if (this.fill != null && this.fill != mxConstants2.NONE && this.gradient && this.gradient != mxConstants2.NONE) {
    var b = this.getGradientBounds(c, x, y, w2, h2);
    c.setGradient(this.fill, this.gradient, b.x, b.y, b.width, b.height, this.gradientDirection);
  } else {
    c.setFillColor(this.fill);
  }
  c.setStrokeColor(this.stroke);
};
mxShape.prototype.getGradientBounds = function(c, x, y, w2, h2) {
  return new mxRectangle(x, y, w2, h2);
};
mxShape.prototype.updateTransform = function(c, x, y, w2, h2) {
  c.scale(this.scale);
  c.rotate(this.getShapeRotation(), this.flipH, this.flipV, x + w2 / 2, y + h2 / 2);
};
mxShape.prototype.paintVertexShape = function(c, x, y, w2, h2) {
  this.paintBackground(c, x, y, w2, h2);
  if (!this.outline || this.style == null || getValue(this.style, mxConstants2.STYLE_BACKGROUND_OUTLINE, 0) == 0) {
    c.setShadow(false);
    this.paintForeground(c, x, y, w2, h2);
  }
};
mxShape.prototype.paintBackground = function(c, x, y, w2, h2) {
};
mxShape.prototype.paintForeground = function(c, x, y, w2, h2) {
};
mxShape.prototype.paintEdgeShape = function(c, pts) {
};
mxShape.prototype.getArcSize = function(w2, h2) {
  var r = 0;
  if (getValue(this.style, mxConstants2.STYLE_ABSOLUTE_ARCSIZE, 0) == "1") {
    r = Math.min(w2 / 2, Math.min(h2 / 2, getValue(this.style, mxConstants2.STYLE_ARCSIZE, mxConstants2.LINE_ARCSIZE) / 2));
  } else {
    var f = getValue(this.style, mxConstants2.STYLE_ARCSIZE, mxConstants2.RECTANGLE_ROUNDING_FACTOR * 100) / 100;
    r = Math.min(w2 * f, h2 * f);
  }
  return r;
};
mxShape.prototype.paintGlassEffect = function(c, x, y, w2, h2, arc) {
  var sw = Math.ceil(this.strokewidth / 2);
  var size = 0.4;
  c.setGradient("#ffffff", "#ffffff", x, y, w2, h2 * 0.6, "south", 0.9, 0.1);
  c.begin();
  arc += 2 * sw;
  if (this.isRounded) {
    c.moveTo(x - sw + arc, y - sw);
    c.quadTo(x - sw, y - sw, x - sw, y - sw + arc);
    c.lineTo(x - sw, y + h2 * size);
    c.quadTo(x + w2 * 0.5, y + h2 * 0.7, x + w2 + sw, y + h2 * size);
    c.lineTo(x + w2 + sw, y - sw + arc);
    c.quadTo(x + w2 + sw, y - sw, x + w2 + sw - arc, y - sw);
  } else {
    c.moveTo(x - sw, y - sw);
    c.lineTo(x - sw, y + h2 * size);
    c.quadTo(x + w2 * 0.5, y + h2 * 0.7, x + w2 + sw, y + h2 * size);
    c.lineTo(x + w2 + sw, y - sw);
  }
  c.close();
  c.fill();
};
mxShape.prototype.addPoints = function(c, pts, rounded, arcSize, close, exclude, initialMove) {
  if (pts != null && pts.length > 0) {
    initialMove = initialMove != null ? initialMove : true;
    var pe = pts[pts.length - 1];
    if (close && rounded) {
      pts = pts.slice();
      var p0 = pts[0];
      var wp = new mxPoint2(pe.x + (p0.x - pe.x) / 2, pe.y + (p0.y - pe.y) / 2);
      pts.splice(0, 0, wp);
    }
    var pt = pts[0];
    var i = 1;
    if (initialMove) {
      c.moveTo(pt.x, pt.y);
    } else {
      c.lineTo(pt.x, pt.y);
    }
    while (i < (close ? pts.length : pts.length - 1)) {
      var tmp = pts[mod(i, pts.length)];
      var dx = pt.x - tmp.x;
      var dy = pt.y - tmp.y;
      if (rounded && (dx != 0 || dy != 0) && (exclude == null || indexOf(exclude, i - 1) < 0)) {
        var dist = Math.sqrt(dx * dx + dy * dy);
        var nx1 = dx * Math.min(arcSize, dist / 2) / dist;
        var ny1 = dy * Math.min(arcSize, dist / 2) / dist;
        var x1 = tmp.x + nx1;
        var y1 = tmp.y + ny1;
        c.lineTo(x1, y1);
        var next = pts[mod(i + 1, pts.length)];
        while (i < pts.length - 2 && Math.round(next.x - tmp.x) == 0 && Math.round(next.y - tmp.y) == 0) {
          next = pts[mod(i + 2, pts.length)];
          i++;
        }
        dx = next.x - tmp.x;
        dy = next.y - tmp.y;
        dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));
        var nx2 = dx * Math.min(arcSize, dist / 2) / dist;
        var ny2 = dy * Math.min(arcSize, dist / 2) / dist;
        var x2 = tmp.x + nx2;
        var y2 = tmp.y + ny2;
        c.quadTo(tmp.x, tmp.y, x2, y2);
        tmp = new mxPoint2(x2, y2);
      } else {
        c.lineTo(tmp.x, tmp.y);
      }
      pt = tmp;
      i++;
    }
    if (close) {
      c.close();
    } else {
      c.lineTo(pe.x, pe.y);
    }
  }
};
mxShape.prototype.resetStyles = function() {
  this.initStyles();
  this.spacing = 0;
  delete this.fill;
  delete this.gradient;
  delete this.gradientDirection;
  delete this.stroke;
  delete this.startSize;
  delete this.endSize;
  delete this.startArrow;
  delete this.endArrow;
  delete this.direction;
  delete this.isShadow;
  delete this.isDashed;
  delete this.isRounded;
  delete this.glass;
};
mxShape.prototype.apply = function(state2) {
  this.state = state2;
  this.style = state2.style;
  if (this.style != null) {
    this.fill = getValue(this.style, mxConstants2.STYLE_FILLCOLOR, this.fill);
    this.gradient = getValue(this.style, mxConstants2.STYLE_GRADIENTCOLOR, this.gradient);
    this.gradientDirection = getValue(this.style, mxConstants2.STYLE_GRADIENT_DIRECTION, this.gradientDirection);
    this.opacity = getValue(this.style, mxConstants2.STYLE_OPACITY, this.opacity);
    this.fillOpacity = getValue(this.style, mxConstants2.STYLE_FILL_OPACITY, this.fillOpacity);
    this.strokeOpacity = getValue(this.style, mxConstants2.STYLE_STROKE_OPACITY, this.strokeOpacity);
    this.stroke = getValue(this.style, mxConstants2.STYLE_STROKECOLOR, this.stroke);
    this.strokewidth = getNumber(this.style, mxConstants2.STYLE_STROKEWIDTH, this.strokewidth);
    this.spacing = getValue(this.style, mxConstants2.STYLE_SPACING, this.spacing);
    this.startSize = getNumber(this.style, mxConstants2.STYLE_STARTSIZE, this.startSize);
    this.endSize = getNumber(this.style, mxConstants2.STYLE_ENDSIZE, this.endSize);
    this.startArrow = getValue(this.style, mxConstants2.STYLE_STARTARROW, this.startArrow);
    this.endArrow = getValue(this.style, mxConstants2.STYLE_ENDARROW, this.endArrow);
    this.rotation = getValue(this.style, mxConstants2.STYLE_ROTATION, this.rotation);
    this.direction = getValue(this.style, mxConstants2.STYLE_DIRECTION, this.direction);
    this.flipH = getValue(this.style, mxConstants2.STYLE_FLIPH, 0) == 1;
    this.flipV = getValue(this.style, mxConstants2.STYLE_FLIPV, 0) == 1;
    if (this.stencil != null) {
      this.flipH = getValue(this.style, "stencilFlipH", 0) == 1 || this.flipH;
      this.flipV = getValue(this.style, "stencilFlipV", 0) == 1 || this.flipV;
    }
    if (this.direction == mxConstants2.DIRECTION_NORTH || this.direction == mxConstants2.DIRECTION_SOUTH) {
      var tmp = this.flipH;
      this.flipH = this.flipV;
      this.flipV = tmp;
    }
    this.isShadow = getValue(this.style, mxConstants2.STYLE_SHADOW, this.isShadow) == 1;
    this.isDashed = getValue(this.style, mxConstants2.STYLE_DASHED, this.isDashed) == 1;
    this.isRounded = getValue(this.style, mxConstants2.STYLE_ROUNDED, this.isRounded) == 1;
    this.glass = getValue(this.style, mxConstants2.STYLE_GLASS, this.glass) == 1;
    if (this.fill == mxConstants2.NONE) {
      this.fill = null;
    }
    if (this.gradient == mxConstants2.NONE) {
      this.gradient = null;
    }
    if (this.stroke == mxConstants2.NONE) {
      this.stroke = null;
    }
  }
};
mxShape.prototype.setCursor = function(cursor) {
  if (cursor == null) {
    cursor = "";
  }
  this.cursor = cursor;
  if (this.node != null) {
    this.node.style.cursor = cursor;
  }
};
mxShape.prototype.getCursor = function() {
  return this.cursor;
};
mxShape.prototype.isRoundable = function() {
  return false;
};
mxShape.prototype.updateBoundingBox = function() {
  if (this.useSvgBoundingBox && this.node != null && this.node.ownerSVGElement != null) {
    try {
      var b = this.node.getBBox();
      if (b.width > 0 && b.height > 0) {
        this.boundingBox = new mxRectangle(b.x, b.y, b.width, b.height);
        this.boundingBox.grow(this.strokewidth * this.scale / 2);
        return;
      }
    } catch (e) {
    }
  }
  if (this.bounds != null) {
    var bbox = this.createBoundingBox();
    if (bbox != null) {
      this.augmentBoundingBox(bbox);
      var rot = this.getShapeRotation();
      if (rot != 0) {
        bbox = getBoundingBox(bbox, rot);
      }
    }
    this.boundingBox = bbox;
  }
};
mxShape.prototype.createBoundingBox = function() {
  var bb = this.bounds.clone();
  if (this.stencil != null && (this.direction == mxConstants2.DIRECTION_NORTH || this.direction == mxConstants2.DIRECTION_SOUTH) || this.isPaintBoundsInverted()) {
    bb.rotate90();
  }
  return bb;
};
mxShape.prototype.augmentBoundingBox = function(bbox) {
  if (this.isShadow) {
    bbox.width += Math.ceil(mxConstants2.SHADOW_OFFSET_X * this.scale);
    bbox.height += Math.ceil(mxConstants2.SHADOW_OFFSET_Y * this.scale);
  }
  bbox.grow(this.strokewidth * this.scale / 2);
};
mxShape.prototype.isPaintBoundsInverted = function() {
  return this.stencil == null && (this.direction == mxConstants2.DIRECTION_NORTH || this.direction == mxConstants2.DIRECTION_SOUTH);
};
mxShape.prototype.getRotation = function() {
  return this.rotation != null ? this.rotation : 0;
};
mxShape.prototype.getTextRotation = function() {
  var rot = this.getRotation();
  if (getValue(this.style, mxConstants2.STYLE_HORIZONTAL, 1) != 1) {
    rot += mxText.prototype.verticalTextRotation;
  }
  return rot;
};
mxShape.prototype.getShapeRotation = function() {
  var rot = this.getRotation();
  if (this.direction != null) {
    if (this.direction == mxConstants2.DIRECTION_NORTH) {
      rot += 270;
    } else if (this.direction == mxConstants2.DIRECTION_WEST) {
      rot += 180;
    } else if (this.direction == mxConstants2.DIRECTION_SOUTH) {
      rot += 90;
    }
  }
  return rot;
};
mxShape.prototype.createTransparentSvgRectangle = function(x, y, w2, h2) {
  var rect = document.createElementNS(mxConstants2.NS_SVG, "rect");
  rect.setAttribute("x", x);
  rect.setAttribute("y", y);
  rect.setAttribute("width", w2);
  rect.setAttribute("height", h2);
  rect.setAttribute("fill", "none");
  rect.setAttribute("stroke", "none");
  rect.setAttribute("pointer-events", "all");
  return rect;
};
mxShape.prototype.setTransparentBackgroundImage = function(node) {
  node.style.backgroundImage = "url('" + mxClient_default.imageBasePath + "/transparent.gif')";
};
mxShape.prototype.releaseSvgGradients = function(grads) {
  if (grads != null) {
    for (var key in grads) {
      var gradient = grads[key];
      if (gradient != null) {
        gradient.mxRefCount = (gradient.mxRefCount || 0) - 1;
        if (gradient.mxRefCount == 0 && gradient.parentNode != null) {
          gradient.parentNode.removeChild(gradient);
        }
      }
    }
  }
};
mxShape.prototype.destroy = function() {
  if (this.node != null) {
    mxEvent2.release(this.node);
    if (this.node.parentNode != null) {
      this.node.parentNode.removeChild(this.node);
    }
    this.node = null;
  }
  this.releaseSvgGradients(this.oldGradients);
  this.oldGradients = null;
};

// js/graph/mxPolyline.js
var mxPolyline = function(points, stroke, strokewidth) {
  mxShape.call(this);
  this.points = points;
  this.stroke = stroke;
  this.strokewidth = strokewidth != null ? strokewidth : 1;
};
extend(mxPolyline, mxShape);
mxPolyline.prototype.getRotation = function() {
  return 0;
};
mxPolyline.prototype.getShapeRotation = function() {
  return 0;
};
mxPolyline.prototype.isPaintBoundsInverted = function() {
  return false;
};
mxPolyline.prototype.paintEdgeShape = function(c, pts) {
  const prev = c.pointerEventsValue;
  c.pointerEventsValue = "stroke";
  if (this.style == null || this.style[mxConstants2.STYLE_CURVED] !== 1) {
    this.paintLine(c, pts, this.isRounded);
  } else {
    this.paintCurvedLine(c, pts);
  }
  c.pointerEventsValue = prev;
};
mxPolyline.prototype.paintLine = function(c, pts, rounded) {
  const arcSize = getValue(this.style, mxConstants2.STYLE_ARCSIZE, mxConstants2.LINE_ARCSIZE) / 2;
  c.begin();
  this.addPoints(c, pts, rounded, arcSize, false);
  c.stroke();
};
mxPolyline.prototype.paintCurvedLine = function(c, pts) {
  c.begin();
  const pt = pts[0];
  const n = pts.length;
  c.moveTo(pt.x, pt.y);
  for (let i = 1; i < n - 2; i++) {
    const p02 = pts[i];
    const p12 = pts[i + 1];
    const ix = (p02.x + p12.x) / 2;
    const iy = (p02.y + p12.y) / 2;
    c.quadTo(p02.x, p02.y, ix, iy);
  }
  const p0 = pts[n - 2];
  const p1 = pts[n - 1];
  c.quadTo(p0.x, p0.y, p1.x, p1.y);
  c.stroke();
};
var mxArrow = function(points, fill, stroke, strokewidth, arrowWidth, spacing, endSize) {
  mxShape.call(this);
  this.points = points;
  this.fill = fill;
  this.stroke = stroke;
  this.strokewidth = strokewidth != null ? strokewidth : 1;
  this.arrowWidth = arrowWidth != null ? arrowWidth : mxConstants2.ARROW_WIDTH;
  this.spacing = spacing != null ? spacing : mxConstants2.ARROW_SPACING;
  this.endSize = endSize != null ? endSize : mxConstants2.ARROW_SIZE;
};
extend(mxArrow, mxShape);

// js/graph/mxGuide.js
var mxGuide = function(graph, states) {
  this.graph = graph;
  this.setStates(states);
};
mxGuide.prototype.graph = null;
mxGuide.prototype.states = null;
mxGuide.prototype.horizontal = true;
mxGuide.prototype.vertical = true;
mxGuide.prototype.guideX = null;
mxGuide.prototype.guideY = null;
mxGuide.prototype.rounded = false;
mxGuide.prototype.tolerance = 2;
mxGuide.prototype.setStates = function(states) {
  this.states = states;
};
mxGuide.prototype.isEnabledForEvent = function(evt) {
  return true;
};
mxGuide.prototype.getGuideTolerance = function(gridEnabled) {
  return gridEnabled && this.graph.gridEnabled ? this.graph.gridSize / 2 : this.tolerance;
};
mxGuide.prototype.createGuideShape = function(horizontal) {
  const guide = new mxPolyline([], mxConstants2.GUIDE_COLOR, mxConstants2.GUIDE_STROKEWIDTH);
  guide.isDashed = true;
  return guide;
};
mxGuide.prototype.isStateIgnored = function(state2) {
  return false;
};
mxGuide.prototype.move = function(bounds, delta, gridEnabled, clone3) {
  if (this.states != null && (this.horizontal || this.vertical) && bounds != null && delta != null) {
    const scale = this.graph.getView().scale;
    const tt = this.getGuideTolerance(gridEnabled) * scale;
    let b = bounds.clone();
    b.x += delta.x;
    b.y += delta.y;
    let overrideX = false;
    let stateX = null;
    let valueX = null;
    let overrideY = false;
    let stateY = null;
    let valueY = null;
    let ttX = tt;
    let ttY = tt;
    const left = b.x;
    const right = b.x + b.width;
    const center = b.getCenterX();
    const top = b.y;
    const bottom = b.y + b.height;
    const middle = b.getCenterY();
    const snapX = (x, state2, centerAlign) => {
      let override = false;
      if (centerAlign && Math.abs(x - center) < ttX) {
        delta.x = x - bounds.getCenterX();
        ttX = Math.abs(x - center);
        override = true;
      } else if (!centerAlign) {
        if (Math.abs(x - left) < ttX) {
          delta.x = x - bounds.x;
          ttX = Math.abs(x - left);
          override = true;
        } else if (Math.abs(x - right) < ttX) {
          delta.x = x - bounds.x - bounds.width;
          ttX = Math.abs(x - right);
          override = true;
        }
      }
      if (override) {
        stateX = state2;
        valueX = x;
        if (this.guideX == null) {
          this.guideX = this.createGuideShape(true);
          this.guideX.dialect = this.graph.dialect !== mxConstants2.DIALECT_SVG ? mxConstants2.DIALECT_VML : mxConstants2.DIALECT_SVG;
          this.guideX.pointerEvents = false;
          this.guideX.init(this.graph.getView().getOverlayPane());
        }
      }
      overrideX = overrideX || override;
    };
    const snapY = (y, state2, centerAlign) => {
      let override = false;
      if (centerAlign && Math.abs(y - middle) < ttY) {
        delta.y = y - bounds.getCenterY();
        ttY = Math.abs(y - middle);
        override = true;
      } else if (!centerAlign) {
        if (Math.abs(y - top) < ttY) {
          delta.y = y - bounds.y;
          ttY = Math.abs(y - top);
          override = true;
        } else if (Math.abs(y - bottom) < ttY) {
          delta.y = y - bounds.y - bounds.height;
          ttY = Math.abs(y - bottom);
          override = true;
        }
      }
      if (override) {
        stateY = state2;
        valueY = y;
        if (this.guideY == null) {
          this.guideY = this.createGuideShape(false);
          this.guideY.dialect = this.graph.dialect !== mxConstants2.DIALECT_SVG ? mxConstants2.DIALECT_VML : mxConstants2.DIALECT_SVG;
          this.guideY.pointerEvents = false;
          this.guideY.init(this.graph.getView().getOverlayPane());
        }
      }
      overrideY = overrideY || override;
    };
    for (let i = 0; i < this.states.length; i++) {
      const state2 = this.states[i];
      if (state2 != null && !this.isStateIgnored(state2)) {
        if (this.horizontal) {
          snapX.call(this, state2.getCenterX(), state2, true);
          snapX.call(this, state2.x, state2, false);
          snapX.call(this, state2.x + state2.width, state2, false);
          if (state2.cell == null) {
            snapX.call(this, state2.getCenterX(), state2, false);
          }
        }
        if (this.vertical) {
          snapY.call(this, state2.getCenterY(), state2, true);
          snapY.call(this, state2.y, state2, false);
          snapY.call(this, state2.y + state2.height, state2, false);
          if (state2.cell == null) {
            snapY.call(this, state2.getCenterY(), state2, false);
          }
        }
      }
    }
    this.graph.snapDelta(delta, bounds, !gridEnabled, overrideX, overrideY);
    delta = this.getDelta(bounds, stateX, delta.x, stateY, delta.y);
    const c = this.graph.container;
    if (!overrideX && this.guideX != null) {
      this.guideX.node.style.visibility = "hidden";
    } else if (this.guideX != null) {
      let minY = null;
      let maxY = null;
      if (stateX != null && bounds != null) {
        minY = Math.min(bounds.y + delta.y - this.graph.panDy, stateX.y);
        maxY = Math.max(bounds.y + bounds.height + delta.y - this.graph.panDy, stateX.y + stateX.height);
      }
      if (minY != null && maxY != null) {
        this.guideX.points = [
          new mxPoint2(valueX, minY),
          new mxPoint2(valueX, maxY)
        ];
      } else {
        this.guideX.points = [
          new mxPoint2(valueX, -this.graph.panDy),
          new mxPoint2(valueX, c.scrollHeight - 3 - this.graph.panDy)
        ];
      }
      this.guideX.stroke = this.getGuideColor(stateX, true);
      this.guideX.node.style.visibility = "visible";
      this.guideX.redraw();
    }
    if (!overrideY && this.guideY != null) {
      this.guideY.node.style.visibility = "hidden";
    } else if (this.guideY != null) {
      let minX = null;
      let maxX = null;
      if (stateY != null && bounds != null) {
        minX = Math.min(bounds.x + delta.x - this.graph.panDx, stateY.x);
        maxX = Math.max(bounds.x + bounds.width + delta.x - this.graph.panDx, stateY.x + stateY.width);
      }
      if (minX != null && maxX != null) {
        this.guideY.points = [
          new mxPoint2(minX, valueY),
          new mxPoint2(maxX, valueY)
        ];
      } else {
        this.guideY.points = [
          new mxPoint2(-this.graph.panDx, valueY),
          new mxPoint2(c.scrollWidth - 3 - this.graph.panDx, valueY)
        ];
      }
      this.guideY.stroke = this.getGuideColor(stateY, false);
      this.guideY.node.style.visibility = "visible";
      this.guideY.redraw();
    }
  }
  return delta;
};
mxGuide.prototype.getDelta = function(bounds, stateX, dx, stateY, dy) {
  const s = this.graph.view.scale;
  if (this.rounded || stateX != null && stateX.cell == null) {
    dx = Math.round((bounds.x + dx) / s) * s - bounds.x;
  }
  if (this.rounded || stateY != null && stateY.cell == null) {
    dy = Math.round((bounds.y + dy) / s) * s - bounds.y;
  }
  return new mxPoint2(dx, dy);
};
mxGuide.prototype.getGuideColor = function(state2, horizontal) {
  return mxConstants2.GUIDE_COLOR;
};
mxGuide.prototype.hide = function() {
  this.setVisible(false);
};
mxGuide.prototype.setVisible = function(visible) {
  if (this.guideX != null) {
    this.guideX.node.style.visibility = visible ? "visible" : "hidden";
  }
  if (this.guideY != null) {
    this.guideY.node.style.visibility = visible ? "visible" : "hidden";
  }
};
mxGuide.prototype.destroy = function() {
  if (this.guideX != null) {
    this.guideX.destroy();
    this.guideX = null;
  }
  if (this.guideY != null) {
    this.guideY.destroy();
    this.guideY = null;
  }
};

// js/graph/mxDragSource.js
function mxDragSource(element, dropHandler) {
  this.element = element;
  this.dropHandler = dropHandler;
  mxEvent2.addGestureListeners(element, bind(this, function(evt) {
    this.mouseDown(evt);
  }));
  mxEvent2.addListener(element, "dragstart", function(evt) {
    mxEvent2.consume(evt);
  });
  this.eventConsumer = function(sender, evt) {
    const evtName = evt.getProperty("eventName");
    const me = evt.getProperty("event");
    if (evtName != mxEvent2.MOUSE_DOWN) {
      me.consume();
    }
  };
}
mxDragSource.prototype.element = null;
mxDragSource.prototype.dropHandler = null;
mxDragSource.prototype.dragOffset = null;
mxDragSource.prototype.dragElement = null;
mxDragSource.prototype.previewElement = null;
mxDragSource.prototype.previewOffset = null;
mxDragSource.prototype.enabled = true;
mxDragSource.prototype.currentGraph = null;
mxDragSource.prototype.currentDropTarget = null;
mxDragSource.prototype.currentPoint = null;
mxDragSource.prototype.currentGuide = null;
mxDragSource.prototype.currentHighlight = null;
mxDragSource.prototype.autoscroll = true;
mxDragSource.prototype.guidesEnabled = true;
mxDragSource.prototype.gridEnabled = true;
mxDragSource.prototype.highlightDropTargets = true;
mxDragSource.prototype.dragElementZIndex = 100;
mxDragSource.prototype.dragElementOpacity = 70;
mxDragSource.prototype.checkEventSource = true;
mxDragSource.prototype.isEnabled = function() {
  return this.enabled;
};
mxDragSource.prototype.setEnabled = function(value) {
  this.enabled = value;
};
mxDragSource.prototype.isGuidesEnabled = function() {
  return this.guidesEnabled;
};
mxDragSource.prototype.setGuidesEnabled = function(value) {
  this.guidesEnabled = value;
};
mxDragSource.prototype.isGridEnabled = function() {
  return this.gridEnabled;
};
mxDragSource.prototype.setGridEnabled = function(value) {
  this.gridEnabled = value;
};
mxDragSource.prototype.getGraphForEvent = function(evt) {
  return null;
};
mxDragSource.prototype.getDropTarget = function(graph, x, y, evt) {
  return graph.getCellAt(x, y);
};
mxDragSource.prototype.createDragElement = function(evt) {
  return this.element.cloneNode(true);
};
mxDragSource.prototype.createPreviewElement = function(graph) {
  return null;
};
mxDragSource.prototype.isActive = function() {
  return this.mouseMoveHandler != null;
};
mxDragSource.prototype.reset = function() {
  if (this.currentGraph != null) {
    this.dragExit(this.currentGraph);
    this.currentGraph = null;
  }
  this.removeDragElement();
  this.removeListeners();
  this.stopDrag();
};
mxDragSource.prototype.mouseDown = function(evt) {
  if (this.enabled && !mxEvent2.isConsumed(evt) && this.mouseMoveHandler == null) {
    this.startDrag(evt);
    this.mouseMoveHandler = bind(this, this.mouseMove);
    this.mouseUpHandler = bind(this, this.mouseUp);
    mxEvent2.addGestureListeners(document, null, this.mouseMoveHandler, this.mouseUpHandler);
    if (mxClient_default.IS_TOUCH && !mxEvent2.isMouseEvent(evt)) {
      this.eventSource = mxEvent2.getSource(evt);
      mxEvent2.addGestureListeners(this.eventSource, null, this.mouseMoveHandler, this.mouseUpHandler);
    }
  }
};
mxDragSource.prototype.startDrag = function(evt) {
  this.dragElement = this.createDragElement(evt);
  this.dragElement.style.position = "absolute";
  this.dragElement.style.zIndex = this.dragElementZIndex;
  setOpacity(this.dragElement, this.dragElementOpacity);
  if (this.checkEventSource && mxClient_default.IS_SVG) {
    this.dragElement.style.pointerEvents = "none";
  }
};
mxDragSource.prototype.stopDrag = function() {
  this.removeDragElement();
};
mxDragSource.prototype.removeDragElement = function() {
  if (this.dragElement != null) {
    if (this.dragElement.parentNode != null) {
      this.dragElement.parentNode.removeChild(this.dragElement);
    }
    this.dragElement = null;
  }
};
mxDragSource.prototype.getElementForEvent = function(evt) {
  return mxEvent2.isTouchEvent(evt) || mxEvent2.isPenEvent(evt) ? document.elementFromPoint(mxEvent2.getClientX(evt), mxEvent2.getClientY(evt)) : mxEvent2.getSource(evt);
};
mxDragSource.prototype.graphContainsEvent = function(graph, evt) {
  const x = mxEvent2.getClientX(evt);
  const y = mxEvent2.getClientY(evt);
  const offset = getOffset(graph.container);
  const origin = getScrollOrigin();
  let elt = this.getElementForEvent(evt);
  if (this.checkEventSource) {
    while (elt != null && elt != graph.container) {
      elt = elt.parentNode;
    }
  }
  return elt != null && x >= offset.x - origin.x && y >= offset.y - origin.y && x <= offset.x - origin.x + graph.container.offsetWidth && y <= offset.y - origin.y + graph.container.offsetHeight;
};
mxDragSource.prototype.mouseMove = function(evt) {
  let graph = this.getGraphForEvent(evt);
  if (graph != null && !this.graphContainsEvent(graph, evt)) {
    graph = null;
  }
  if (graph != this.currentGraph) {
    if (this.currentGraph != null) {
      this.dragExit(this.currentGraph, evt);
    }
    this.currentGraph = graph;
    if (this.currentGraph != null) {
      this.dragEnter(this.currentGraph, evt);
    }
  }
  if (this.currentGraph != null) {
    this.dragOver(this.currentGraph, evt);
  }
  if (this.dragElement != null && (this.previewElement == null || this.previewElement.style.visibility != "visible")) {
    let x = mxEvent2.getClientX(evt);
    let y = mxEvent2.getClientY(evt);
    if (this.dragElement.parentNode == null) {
      document.body.appendChild(this.dragElement);
    }
    this.dragElement.style.visibility = "visible";
    if (this.dragOffset != null) {
      x += this.dragOffset.x;
      y += this.dragOffset.y;
    }
    const offset = getDocumentScrollOrigin(document);
    this.dragElement.style.left = x + offset.x + "px";
    this.dragElement.style.top = y + offset.y + "px";
  } else if (this.dragElement != null) {
    this.dragElement.style.visibility = "hidden";
  }
  mxEvent2.consume(evt);
};
mxDragSource.prototype.mouseUp = function(evt) {
  if (this.currentGraph != null) {
    if (this.currentPoint != null && (this.previewElement == null || this.previewElement.style.visibility != "hidden")) {
      const scale = this.currentGraph.view.scale;
      const tr = this.currentGraph.view.translate;
      const x = this.currentPoint.x / scale - tr.x;
      const y = this.currentPoint.y / scale - tr.y;
      this.drop(this.currentGraph, evt, this.currentDropTarget, x, y);
    }
    this.dragExit(this.currentGraph);
    this.currentGraph = null;
  }
  this.stopDrag();
  this.removeListeners();
  mxEvent2.consume(evt);
};
mxDragSource.prototype.removeListeners = function() {
  if (this.eventSource != null) {
    mxEvent2.removeGestureListeners(this.eventSource, null, this.mouseMoveHandler, this.mouseUpHandler);
    this.eventSource = null;
  }
  mxEvent2.removeGestureListeners(document, null, this.mouseMoveHandler, this.mouseUpHandler);
  this.mouseMoveHandler = null;
  this.mouseUpHandler = null;
};
mxDragSource.prototype.dragEnter = function(graph, evt) {
  graph.isMouseDown = true;
  graph.isMouseTrigger = mxEvent2.isMouseEvent(evt);
  this.previewElement = this.createPreviewElement(graph);
  if (this.previewElement != null && this.checkEventSource && mxClient_default.IS_SVG) {
    this.previewElement.style.pointerEvents = "none";
  }
  if (this.isGuidesEnabled() && this.previewElement != null) {
    this.currentGuide = new mxGuide(graph, graph.graphHandler.getGuideStates());
  }
  if (this.highlightDropTargets) {
    this.currentHighlight = new mxCellHighlight2(graph, mxConstants2.DROP_TARGET_COLOR);
  }
  graph.addListener(mxEvent2.FIRE_MOUSE_EVENT, this.eventConsumer);
};
mxDragSource.prototype.dragExit = function(graph, evt) {
  this.currentDropTarget = null;
  this.currentPoint = null;
  graph.isMouseDown = false;
  graph.removeListener(this.eventConsumer);
  if (this.previewElement != null) {
    if (this.previewElement.parentNode != null) {
      this.previewElement.parentNode.removeChild(this.previewElement);
    }
    this.previewElement = null;
  }
  if (this.currentGuide != null) {
    this.currentGuide.destroy();
    this.currentGuide = null;
  }
  if (this.currentHighlight != null) {
    this.currentHighlight.destroy();
    this.currentHighlight = null;
  }
};
mxDragSource.prototype.dragOver = function(graph, evt) {
  const offset = getOffset(graph.container);
  const origin = getScrollOrigin(graph.container);
  let x = mxEvent2.getClientX(evt) - offset.x + origin.x - graph.panDx;
  let y = mxEvent2.getClientY(evt) - offset.y + origin.y - graph.panDy;
  if (graph.autoScroll && (this.autoscroll == null || this.autoscroll)) {
    graph.scrollPointToVisible(x, y, graph.autoExtend);
  }
  if (this.currentHighlight != null && graph.isDropEnabled()) {
    this.currentDropTarget = this.getDropTarget(graph, x, y, evt);
    const state2 = graph.getView().getState(this.currentDropTarget);
    this.currentHighlight.highlight(state2);
  }
  if (this.previewElement != null) {
    if (this.previewElement.parentNode == null) {
      graph.container.appendChild(this.previewElement);
      this.previewElement.style.zIndex = "3";
      this.previewElement.style.position = "absolute";
    }
    const gridEnabled = this.isGridEnabled() && graph.isGridEnabledEvent(evt);
    let hideGuide = true;
    if (this.currentGuide != null && this.currentGuide.isEnabledForEvent(evt)) {
      const w2 = parseInt(this.previewElement.style.width);
      const h2 = parseInt(this.previewElement.style.height);
      const bounds = new mxRectangle(0, 0, w2, h2);
      let delta = new mxPoint2(x, y);
      delta = this.currentGuide.move(bounds, delta, gridEnabled, true);
      hideGuide = false;
      x = delta.x;
      y = delta.y;
    } else if (gridEnabled) {
      const scale = graph.view.scale;
      const tr = graph.view.translate;
      const off = graph.gridSize / 2;
      x = (graph.snap(x / scale - tr.x - off) + tr.x) * scale;
      y = (graph.snap(y / scale - tr.y - off) + tr.y) * scale;
    }
    if (this.currentGuide != null && hideGuide) {
      this.currentGuide.hide();
    }
    if (this.previewOffset != null) {
      x += this.previewOffset.x;
      y += this.previewOffset.y;
    }
    this.previewElement.style.left = Math.round(x) + "px";
    this.previewElement.style.top = Math.round(y) + "px";
    this.previewElement.style.visibility = "visible";
  }
  this.currentPoint = new mxPoint2(x, y);
};
mxDragSource.prototype.drop = function(graph, evt, dropTarget, x, y) {
  this.dropHandler.apply(this, arguments);
  if (graph.container.style.visibility != "hidden") {
    graph.container.focus();
  }
};

// js/graph/mxTextMetrics.js
function calculateTextDimensions(text, fontSize, fontFamily, textWidth, fontStyle) {
  fontSize = fontSize != null ? fontSize : mxConstants2.DEFAULT_FONTSIZE;
  fontFamily = fontFamily != null ? fontFamily : mxConstants2.DEFAULT_FONTFAMILY;
  const div = document.createElement("div");
  div.style.fontFamily = fontFamily;
  div.style.fontSize = Math.round(fontSize) + "px";
  div.style.lineHeight = Math.round(fontSize * mxConstants2.LINE_HEIGHT) + "px";
  if (fontStyle != null) {
    if ((fontStyle & mxConstants2.FONT_BOLD) == mxConstants2.FONT_BOLD) {
      div.style.fontWeight = "bold";
    }
    if ((fontStyle & mxConstants2.FONT_ITALIC) == mxConstants2.FONT_ITALIC) {
      div.style.fontStyle = "italic";
    }
    const txtDecor = [];
    if ((fontStyle & mxConstants2.FONT_UNDERLINE) == mxConstants2.FONT_UNDERLINE) {
      txtDecor.push("underline");
    }
    if ((fontStyle & mxConstants2.FONT_STRIKETHROUGH) == mxConstants2.FONT_STRIKETHROUGH) {
      txtDecor.push("line-through");
    }
    if (txtDecor.length > 0) {
      div.style.textDecoration = txtDecor.join(" ");
    }
  }
  div.style.position = "absolute";
  div.style.visibility = "hidden";
  div.style.display = mxClient_default.IS_QUIRKS ? "inline" : "inline-block";
  div.style.zoom = "1";
  if (textWidth != null) {
    div.style.width = textWidth + "px";
    div.style.whiteSpace = "normal";
  } else {
    div.style.whiteSpace = "nowrap";
  }
  div.innerHTML = text;
  document.body.appendChild(div);
  const size = new mxRectangle(0, 0, div.offsetWidth, div.offsetHeight);
  document.body.removeChild(div);
  return size;
}

// js/graph/mxUtils.js
var errorResource = () => mxClient_default.language != "none" ? "error" : "";
var closeResource = () => mxClient_default.language != "none" ? "close" : "";
var errorImage = () => mxClient_default.imageBasePath + "/error.gif";
var entities = [
  ["lt", 60],
  ["gt", 62],
  ["amp", 38],
  ["quot", 34],
  ["apos", 39]
];
var removeCursors = function(element) {
  if (element.style != null) {
    element.style.cursor = "";
  }
  let children = element.childNodes;
  if (children != null) {
    let childCount = children.length;
    for (let i = 0; i < childCount; i += 1) {
      removeCursors(children[i]);
    }
  }
};
var _getCurrentStyle = null;
var getCurrentStyle = function(element) {
  if (_getCurrentStyle == null) {
    if (mxClient_default.IS_IE && (document.documentMode == null || document.documentMode < 9)) {
      _getCurrentStyle = function(el) {
        return el != null ? el.currentStyle : null;
      };
    } else {
      _getCurrentStyle = function(el) {
        return el != null ? window.getComputedStyle(el, "") : null;
      };
    }
  }
  return _getCurrentStyle(element);
};
var parseCssNumber = function(value) {
  if (value == "thin") {
    value = "2";
  } else if (value == "medium") {
    value = "4";
  } else if (value == "thick") {
    value = "6";
  }
  value = parseFloat(value);
  if (isNaN2(value)) {
    value = 0;
  }
  return value;
};
var _setPrefixedStyle = null;
var setPrefixedStyle = function(style, name, value) {
  if (_setPrefixedStyle == null) {
    let prefix = null;
    if (mxClient_default.IS_OT) {
      prefix = "O";
    } else if (mxClient_default.IS_SF || mxClient_default.IS_GC) {
      prefix = "Webkit";
    } else if (mxClient_default.IS_MT) {
      prefix = "Moz";
    } else if (mxClient_default.IS_IE && document.documentMode >= 9 && document.documentMode < 10) {
      prefix = "ms";
    }
    _setPrefixedStyle = function(s, n, v) {
      s[n] = v;
      if (prefix != null && n.length > 0) {
        n = prefix + n.substring(0, 1).toUpperCase() + n.substring(1);
        s[n] = v;
      }
    };
  }
  return _setPrefixedStyle(style, name, value);
};
var hasScrollbars = function(node) {
  const style = getCurrentStyle(node);
  return style != null && (style.overflow == "scroll" || style.overflow == "auto");
};
var bind = function(scope, funct) {
  return function() {
    return funct.apply(scope, arguments);
  };
};
var evalExpression = function(expr) {
  let result = null;
  if (expr.indexOf("function") >= 0) {
    try {
      eval("var _mxJavaScriptExpression=" + expr);
      result = _mxJavaScriptExpression;
      _mxJavaScriptExpression = null;
    } catch (e) {
      mxLog.warn(e.message + " while evaluating " + expr);
    }
  } else {
    try {
      result = eval(expr);
    } catch (e) {
      mxLog.warn(e.message + " while evaluating " + expr);
    }
  }
  return result;
};
var findNode = function(node, attr2, value) {
  if (node.nodeType == mxConstants2.NODETYPE_ELEMENT) {
    const tmp = node.getAttribute(attr2);
    if (tmp != null && tmp == value) {
      return node;
    }
  }
  node = node.firstChild;
  while (node != null) {
    const result2 = findNode(node, attr2, value);
    if (result2 != null) {
      return result2;
    }
    node = node.nextSibling;
  }
  return null;
};
var getFunctionName = function(f) {
  let str = null;
  if (f != null) {
    if (f.name != null) {
      str = f.name;
    } else {
      str = trim(f.toString());
      if (/^function\s/.test(str)) {
        str = ltrim(str.substring(9));
        const idx2 = str.indexOf("(");
        if (idx2 > 0) {
          str = str.substring(0, idx2);
        }
      }
    }
  }
  return str;
};
var indexOf = function(array, obj) {
  if (array != null && obj != null) {
    for (let i = 0; i < array.length; i++) {
      if (array[i] == obj) {
        return i;
      }
    }
  }
  return -1;
};
var forEach = function(array, fn) {
  if (array != null && fn != null) {
    for (let i = 0; i < array.length; i++) {
      fn(array[i]);
    }
  }
  return array;
};
var remove = function(obj, array) {
  let result2 = null;
  if (typeof array == "object") {
    let index = indexOf(array, obj);
    while (index >= 0) {
      array.splice(index, 1);
      result2 = obj;
      index = indexOf(array, obj);
    }
  }
  for (let key in array) {
    if (array[key] == obj) {
      delete array[key];
      result2 = obj;
    }
  }
  return result2;
};
var isNode = function(value, nodeName, attributeName, attributeValue) {
  if (typeof Node === "function" && value instanceof Node) {
    if (nodeName == null || value.nodeName?.toLowerCase() === nodeName.toLowerCase()) {
      return attributeName == null || value.getAttribute(attributeName) == attributeValue;
    }
  }
  return false;
};
var isAncestorNode = function(ancestor, child) {
  let parent2 = child;
  while (parent2 != null) {
    if (parent2 == ancestor) {
      return true;
    }
    parent2 = parent2.parentNode;
  }
  return false;
};
var getChildNodes = function(node, nodeType) {
  nodeType = nodeType || mxConstants2.NODETYPE_ELEMENT;
  const children = [];
  let tmp = node.firstChild;
  while (tmp != null) {
    if (tmp.nodeType == nodeType) {
      children.push(tmp);
    }
    tmp = tmp.nextSibling;
  }
  return children;
};
var importNode = function(doc, node, allChildren) {
  if (mxClient_default.IS_IE && (document.documentMode == null || document.documentMode < 10)) {
    return importNodeImplementation(doc, node, allChildren);
  } else {
    return doc.importNode(node, allChildren);
  }
};
var importNodeImplementation = function(doc, node, allChildren) {
  switch (node.nodeType) {
    case 1: {
      const newNode = doc.createElement(node.nodeName);
      if (node.attributes && node.attributes.length > 0) {
        for (let i = 0; i < node.attributes.length; i++) {
          newNode.setAttribute(node.attributes[i].nodeName, node.getAttribute(node.attributes[i].nodeName));
        }
      }
      if (allChildren && node.childNodes && node.childNodes.length > 0) {
        for (let i = 0; i < node.childNodes.length; i++) {
          newNode.appendChild(importNodeImplementation(doc, node.childNodes[i], allChildren));
        }
      }
      return newNode;
      break;
    }
    case 3:
    case 4:
    case 8: {
      return doc.createTextNode(node.nodeValue != null ? node.nodeValue : node.value);
      break;
    }
  }
  ;
};
var createXmlDocument = function() {
  let doc = null;
  if (document.implementation && document.implementation.createDocument) {
    doc = document.implementation.createDocument("", "", null);
  } else if ("ActiveXObject" in window) {
    doc = createMsXmlDocument();
  }
  return doc;
};
var createMsXmlDocument = function() {
  const doc = new ActiveXObject("Microsoft.XMLDOM");
  doc.async = false;
  doc.validateOnParse = false;
  doc.resolveExternals = false;
  return doc;
};
var parseXml = function() {
  const original = window.DOMParser ? (xml2) => new DOMParser().parseFromString(xml2, "text/xml") : (xml2) => {
    const doc = createMsXmlDocument();
    doc.loadXML(xml2);
    return doc;
  };
  return function(text) {
    for (let i = 0; i < entities.length; i++) {
      const [name, code] = entities[i];
      text = text.replace(new RegExp("&" + name + ";", "g"), "&#" + code + ";");
    }
    return original(text);
  };
}();
var clearSelection = function() {
  if (document.selection) {
    return function() {
      document.selection.empty();
    };
  } else if (window.getSelection) {
    return function() {
      if (window.getSelection().empty) {
        window.getSelection().empty();
      } else if (window.getSelection().removeAllRanges) {
        window.getSelection().removeAllRanges();
      }
    };
  } else {
    return function() {
    };
  }
}();
var removeWhitespace = function(node, before) {
  let tmp = before ? node.previousSibling : node.nextSibling;
  while (tmp != null && tmp.nodeType == mxConstants2.NODETYPE_TEXT) {
    const next = before ? tmp.previousSibling : tmp.nextSibling;
    const text = getTextContent(tmp);
    if (trim(text).length == 0) {
      tmp.parentNode.removeChild(tmp);
    }
    tmp = next;
  }
};
var htmlEntities = function(s, newline) {
  s = String(s || "");
  s = s.replace(/&/g, "&amp;");
  s = s.replace(/"/g, "&quot;");
  s = s.replace(/\'/g, "&#39;");
  s = s.replace(/</g, "&lt;");
  s = s.replace(/>/g, "&gt;");
  if (newline == null || newline) {
    s = s.replace(/\n/g, "&#xa;");
  }
  return s;
};
var isVml = function(node) {
  return node != null && node.tagUrn == "urn:schemas-microsoft-com:vml";
};
var getXml = function(node, linefeed) {
  var xml2 = "";
  if (mxClient_default.IS_IE || mxClient_default.IS_IE11) {
    xml2 = mxUtils.getPrettyXml(node, "", "", "");
  } else if (window.XMLSerializer != null) {
    var xmlSerializer = new XMLSerializer();
    xml2 = xmlSerializer.serializeToString(node);
  } else if (node.xml != null) {
    xml2 = node.xml.replace(/\r\n\t[\t]*/g, "").replace(/>\r\n/g, ">").replace(/\r\n/g, "\n");
  }
  linefeed = linefeed || "&#xa;";
  xml2 = xml2.replace(/\n/g, linefeed);
  return xml2;
};
var getPrettyXml = function(node, tab, indent, newline, ns) {
  const result2 = [];
  if (node != null) {
    tab = tab != null ? tab : "  ";
    indent = indent != null ? indent : "";
    newline = newline != null ? newline : "\n";
    if (node.namespaceURI != null && node.namespaceURI != ns) {
      ns = node.namespaceURI;
      if (node.getAttribute("xmlns") == null) {
        node.setAttribute("xmlns", node.namespaceURI);
      }
    }
    if (node.nodeType == mxConstants2.NODETYPE_DOCUMENT) {
      result2.push(getPrettyXml(node.documentElement, tab, indent, newline, ns));
    } else if (node.nodeType == mxConstants2.NODETYPE_DOCUMENT_FRAGMENT) {
      let tmp = node.firstChild;
      if (tmp != null) {
        while (tmp != null) {
          result2.push(getPrettyXml(tmp, tab, indent, newline, ns));
          tmp = tmp.nextSibling;
        }
      }
    } else if (node.nodeType == mxConstants2.NODETYPE_COMMENT) {
      const value = getTextContent(node);
      if (value.length > 0) {
        result2.push(indent + "<!--" + value + "-->" + newline);
      }
    } else if (node.nodeType == mxConstants2.NODETYPE_TEXT) {
      const value = trim(getTextContent(node));
      if (value.length > 0) {
        result2.push(indent + htmlEntities(value, false) + newline);
      }
    } else if (node.nodeType == mxConstants2.NODETYPE_CDATA) {
      const value = getTextContent(node);
      if (value.length > 0) {
        result2.push(indent + "<![CDATA[" + value + "]]" + newline);
      }
    } else {
      result2.push(indent + "<" + node.nodeName);
      const attrs = node.attributes;
      if (attrs != null) {
        for (let i = 0; i < attrs.length; i++) {
          const val = htmlEntities(attrs[i].value);
          result2.push(" " + attrs[i].nodeName + '="' + val + '"');
        }
      }
      let tmp = node.firstChild;
      if (tmp != null) {
        result2.push(">" + newline);
        while (tmp != null) {
          result2.push(getPrettyXml(tmp, tab, indent + tab, newline, ns));
          tmp = tmp.nextSibling;
        }
        result2.push(indent + "</" + node.nodeName + ">" + newline);
      } else {
        result2.push(" />" + newline);
      }
    }
  }
  return result2.join("");
};
var extractTextWithWhitespace = function(elems) {
  const blocks = ["BLOCKQUOTE", "DIV", "H1", "H2", "H3", "H4", "H5", "H6", "OL", "P", "PRE", "TABLE", "UL"];
  const ret = [];
  function doExtract(elts) {
    if (elts.length == 1 && (elts[0].nodeName == "BR" || elts[0].innerHTML == "\n")) {
      return;
    }
    for (let i = 0; i < elts.length; i++) {
      const elem = elts[i];
      if (elem.nodeName == "BR" || elem.innerHTML == "\n" || (elts.length == 1 || i == 0) && (elem.nodeName == "DIV" && elem.innerHTML.toLowerCase() == "<br>")) {
        ret.push("\n");
      } else {
        if (elem.nodeType === 3 || elem.nodeType === 4) {
          if (elem.nodeValue.length > 0) {
            ret.push(elem.nodeValue);
          }
        } else if (elem.nodeType !== 8 && elem.childNodes.length > 0) {
          doExtract(elem.childNodes);
        }
        if (i < elts.length - 1 && indexOf(blocks, elts[i + 1].nodeName) >= 0) {
          ret.push("\n");
        }
      }
    }
  }
  ;
  doExtract(elems);
  return ret.join("");
};
var replaceTrailingNewlines = function(str, pattern) {
  let postfix = "";
  while (str.length > 0 && str.charAt(str.length - 1) == "\n") {
    str = str.substring(0, str.length - 1);
    postfix += pattern;
  }
  return str + postfix;
};
var getTextContent = function(node) {
  if (mxClient_default.IS_IE && node.innerText !== void 0) {
    return node.innerText;
  } else {
    return node != null ? node[node.textContent === void 0 ? "text" : "textContent"] : "";
  }
};
var setTextContent = function(node, text) {
  if (node.innerText !== void 0) {
    node.innerText = text;
  } else {
    node[node.textContent === void 0 ? "text" : "textContent"] = text;
  }
};
var _getInnerHtml = null;
var getInnerHtml = function(node) {
  if (_getInnerHtml == null) {
    if (mxClient_default.IS_IE) {
      _getInnerHtml = function(n) {
        if (n != null) {
          return n.innerHTML;
        }
        return "";
      };
    } else {
      _getInnerHtml = function(n) {
        if (n != null) {
          const serializer = new XMLSerializer();
          let inner = "";
          for (let i = 0; i < n.childNodes.length; i++) {
            inner += serializer.serializeToString(n.childNodes[i]);
          }
          return inner;
        }
        return "";
      };
    }
  }
  return _getInnerHtml(node);
};
var _getOuterHtml = null;
var getOuterHtml = function(node) {
  if (_getOuterHtml == null) {
    if (mxClient_default.IS_IE) {
      _getOuterHtml = function(n) {
        if (n != null) {
          if (n.outerHTML != null) {
            return n.outerHTML;
          } else {
            const tmp = [];
            tmp.push("<" + n.nodeName);
            const attrs = n.attributes;
            if (attrs != null) {
              for (let i = 0; i < attrs.length; i++) {
                const value = attrs[i].value;
                if (value != null && value.length > 0) {
                  tmp.push(" ");
                  tmp.push(attrs[i].nodeName);
                  tmp.push('="');
                  tmp.push(value);
                  tmp.push('"');
                }
              }
            }
            if (n.innerHTML.length == 0) {
              tmp.push("/>");
            } else {
              tmp.push(">");
              tmp.push(n.innerHTML);
              tmp.push("</" + n.nodeName + ">");
            }
            return tmp.join("");
          }
        }
        return "";
      };
    } else {
      _getOuterHtml = function(n) {
        if (n != null) {
          const serializer = new XMLSerializer();
          return serializer.serializeToString(n);
        }
        return "";
      };
    }
  }
  return _getOuterHtml(node);
};
var write = function(parent2, text) {
  const doc = parent2.ownerDocument;
  const node = doc.createTextNode(text);
  if (parent2 != null) {
    parent2.appendChild(node);
  }
  return node;
};
var writeln = function(parent2, text) {
  const doc = parent2.ownerDocument;
  const node = doc.createTextNode(text);
  if (parent2 != null) {
    parent2.appendChild(node);
    parent2.appendChild(document.createElement("br"));
  }
  return node;
};
var br = function(parent2, count) {
  count = count || 1;
  let br2 = null;
  for (let i = 0; i < count; i++) {
    if (parent2 != null) {
      br2 = parent2.ownerDocument.createElement("br");
      parent2.appendChild(br2);
    }
  }
  return br2;
};
var button = function(label, funct, doc) {
  doc = doc != null ? doc : document;
  const button2 = doc.createElement("button");
  write(button2, label);
  mxEvent2.addListener(button2, "click", function(evt) {
    funct(evt);
  });
  return button2;
};
var para = function(parent2, text) {
  const p = document.createElement("p");
  write(p, text);
  if (parent2 != null) {
    parent2.appendChild(p);
  }
  return p;
};
var addTransparentBackgroundFilter = function(node) {
  node.style.filter += "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + mxClient_default.imageBasePath + "/transparent.gif', sizingMethod='scale')";
};
var linkAction = function(parent2, text, editor, action, pad) {
  return link(parent2, text, function() {
    editor.execute(action);
  }, pad);
};
var linkInvoke = function(parent2, text, editor, functName, arg, pad) {
  return link(parent2, text, function() {
    editor[functName](arg);
  }, pad);
};
var link = function(parent2, text, funct, pad) {
  const a = document.createElement("span");
  a.style.color = "blue";
  a.style.textDecoration = "underline";
  a.style.cursor = "pointer";
  if (pad != null) {
    a.style.paddingLeft = pad + "px";
  }
  mxEvent2.addListener(a, "click", funct);
  write(a, text);
  if (parent2 != null) {
    parent2.appendChild(a);
  }
  return a;
};
var getDocumentSize = function() {
  const b = document.body;
  const d = document.documentElement;
  try {
    return new mxRectangle(0, 0, b.clientWidth || d.clientWidth, Math.max(b.clientHeight || 0, d.clientHeight));
  } catch (e) {
    return new mxRectangle();
  }
};
var fit = function(node) {
  const ds = getDocumentSize();
  const left = parseInt(node.offsetLeft);
  const width = parseInt(node.offsetWidth);
  const offset = getDocumentScrollOrigin(node.ownerDocument);
  const sl = offset.x;
  const st = offset.y;
  const b = document.body;
  const d = document.documentElement;
  const right = sl + ds.width;
  if (left + width > right) {
    node.style.left = Math.max(sl, right - width) + "px";
  }
  const top = parseInt(node.offsetTop);
  const height = parseInt(node.offsetHeight);
  const bottom = st + ds.height;
  if (top + height > bottom) {
    node.style.top = Math.max(st, bottom - height) + "px";
  }
};
var load = function(url) {
  const req = new mxXmlRequest2(url, null, "GET", false);
  req.send();
  return req;
};
var get = function(url, onload, onerror, binary, timeout, ontimeout, headers) {
  const req = new mxXmlRequest2(url, null, "GET");
  const setRequestHeaders = req.setRequestHeaders;
  if (headers) {
    req.setRequestHeaders = function(request, params) {
      setRequestHeaders.apply(this, arguments);
      for (let key in headers) {
        request.setRequestHeader(key, headers[key]);
      }
    };
  }
  if (binary != null) {
    req.setBinary(binary);
  }
  req.send(onload, onerror, timeout, ontimeout);
  return req;
};
var getAll = function(urls, onload, onerror) {
  let remain = urls.length;
  const result2 = [];
  let errors = 0;
  const err = function() {
    if (errors == 0 && onerror != null) {
      onerror();
    }
    errors++;
  };
  for (let i = 0; i < urls.length; i++) {
    (function(url, index) {
      get(url, function(req) {
        const status = req.getStatus();
        if (status < 200 || status > 299) {
          err();
        } else {
          result2[index] = req;
          remain--;
          if (remain == 0) {
            onload(result2);
          }
        }
      }, err);
    })(urls[i], i);
  }
  if (remain == 0) {
    onload(result2);
  }
};
var post = function(url, params, onload, onerror) {
  return new mxXmlRequest2(url, params).send(onload, onerror);
};
var submit = function(url, params, doc, target) {
  return new mxXmlRequest2(url, params).simulate(doc, target);
};
var loadInto = function(url, doc, onload) {
  if (mxClient_default.IS_IE) {
    doc.onreadystatechange = function() {
      if (doc.readyState == 4) {
        onload();
      }
    };
  } else {
    doc.addEventListener("load", onload, false);
  }
  doc.load(url);
};
var getValue = function(array, key, defaultValue) {
  let value = array != null ? array[key] : null;
  if (value == null) {
    value = defaultValue;
  }
  return value;
};
var getNumber = function(array, key, defaultValue) {
  let value = array != null ? array[key] : null;
  if (value == null) {
    value = defaultValue || 0;
  }
  return Number(value);
};
var getColor = function(array, key, defaultValue) {
  let value = array != null ? array[key] : null;
  if (value == null) {
    value = defaultValue;
  } else if (value == mxConstants2.NONE) {
    value = null;
  }
  return value;
};
var clone = function(obj, transients, shallow) {
  shallow = shallow != null ? shallow : false;
  let newObj = null;
  if (obj != null && typeof obj.constructor == "function") {
    newObj = new obj.constructor();
    for (let i in obj) {
      if (i != mxObjectIdentity.FIELD_NAME && (transients == null || indexOf(transients, i) < 0)) {
        if (!shallow && typeof obj[i] == "object") {
          newObj[i] = clone(obj[i]);
        } else {
          newObj[i] = obj[i];
        }
      }
    }
  }
  return newObj;
};
var equalPoints = function(a, b) {
  if (a == null && b != null || a != null && b == null || a != null && b != null && a.length != b.length) {
    return false;
  } else if (a != null && b != null) {
    for (let i = 0; i < a.length; i++) {
      if (a[i] != null && b[i] == null || a[i] == null && b[i] != null || a[i] != null && b[i] != null && (a[i].x != b[i].x || a[i].y != b[i].y)) {
        return false;
      }
    }
  }
  return true;
};
var equalEntries = function(a, b) {
  let count = 0;
  if (a == null && b != null || a != null && b == null || a != null && b != null && a.length != b.length) {
    return false;
  } else if (a != null && b != null) {
    for (let key in b) {
      count++;
    }
    for (let key in a) {
      count--;
      if ((!isNaN2(a[key]) || !isNaN2(b[key])) && a[key] != b[key]) {
        return false;
      }
    }
  }
  return count == 0;
};
var removeDuplicates = function(arr) {
  const dict = new mxDictionary();
  const result2 = [];
  for (let i = 0; i < arr.length; i++) {
    if (!dict.get(arr[i])) {
      result2.push(arr[i]);
      dict.put(arr[i], true);
    }
  }
  return result2;
};
var isNaN2 = function(value) {
  return Number.isNaN(value);
};
function extend(ctor, superCtor) {
  const f = function() {
  };
  f.prototype = superCtor.prototype;
  ctor.prototype = new f();
  ctor.prototype.constructor = ctor;
}
var toString = function(obj) {
  let output = "";
  for (let i in obj) {
    try {
      if (obj[i] == null) {
        output += i + " = [null]\n";
      } else if (typeof obj[i] == "function") {
        output += i + " => [Function]\n";
      } else if (typeof obj[i] == "object") {
        const ctor = getFunctionName(obj[i].constructor);
        output += i + " => [" + ctor + "]\n";
      } else {
        output += i + " = " + obj[i] + "\n";
      }
    } catch (e) {
      output += i + "=" + e.message;
    }
  }
  return output;
};
var toRadians = function(deg) {
  return Math.PI * deg / 180;
};
var toDegree = function(rad) {
  return rad * 180 / Math.PI;
};
var arcToCurves = function(x0, y0, r1, r2, angle, largeArcFlag, sweepFlag, x, y) {
  x -= x0;
  y -= y0;
  if (r1 === 0 || r2 === 0) {
    return result2;
  }
  const fS = sweepFlag;
  const psai = angle;
  r1 = Math.abs(r1);
  r2 = Math.abs(r2);
  const ctx = -x / 2;
  const cty = -y / 2;
  const cpsi = Math.cos(psai * Math.PI / 180);
  const spsi = Math.sin(psai * Math.PI / 180);
  const rxd = cpsi * ctx + spsi * cty;
  const ryd = -1 * spsi * ctx + cpsi * cty;
  const rxdd = rxd * rxd;
  const rydd = ryd * ryd;
  const r1x = r1 * r1;
  const r2y = r2 * r2;
  const lamda = rxdd / r1x + rydd / r2y;
  let sds;
  if (lamda > 1) {
    r1 = Math.sqrt(lamda) * r1;
    r2 = Math.sqrt(lamda) * r2;
    sds = 0;
  } else {
    let seif = 1;
    if (largeArcFlag === fS) {
      seif = -1;
    }
    sds = seif * Math.sqrt((r1x * r2y - r1x * rydd - r2y * rxdd) / (r1x * rydd + r2y * rxdd));
  }
  const txd = sds * r1 * ryd / r2;
  const tyd = -1 * sds * r2 * rxd / r1;
  const tx = cpsi * txd - spsi * tyd + x / 2;
  const ty = spsi * txd + cpsi * tyd + y / 2;
  let rad = Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1) - Math.atan2(0, 1);
  let s1 = rad >= 0 ? rad : 2 * Math.PI + rad;
  rad = Math.atan2((-ryd - tyd) / r2, (-rxd - txd) / r1) - Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1);
  let dr = rad >= 0 ? rad : 2 * Math.PI + rad;
  if (fS == 0 && dr > 0) {
    dr -= 2 * Math.PI;
  } else if (fS != 0 && dr < 0) {
    dr += 2 * Math.PI;
  }
  const sse = dr * 2 / Math.PI;
  const seg = Math.ceil(sse < 0 ? -1 * sse : sse);
  const segr = dr / seg;
  const t = 8 / 3 * Math.sin(segr / 4) * Math.sin(segr / 4) / Math.sin(segr / 2);
  const cpsir1 = cpsi * r1;
  const cpsir2 = cpsi * r2;
  const spsir1 = spsi * r1;
  const spsir2 = spsi * r2;
  let mc = Math.cos(s1);
  let ms = Math.sin(s1);
  let x2 = -t * (cpsir1 * ms + spsir2 * mc);
  let y2 = -t * (spsir1 * ms - cpsir2 * mc);
  let x3 = 0;
  let y3 = 0;
  const result2 = [];
  for (let n = 0; n < seg; ++n) {
    s1 += segr;
    mc = Math.cos(s1);
    ms = Math.sin(s1);
    x3 = cpsir1 * mc - spsir2 * ms + tx;
    y3 = spsir1 * mc + cpsir2 * ms + ty;
    const dx = -t * (cpsir1 * ms + spsir2 * mc);
    const dy = -t * (spsir1 * ms - cpsir2 * mc);
    const index = n * 6;
    result2[index] = Number(x2 + x0);
    result2[index + 1] = Number(y2 + y0);
    result2[index + 2] = Number(x3 - dx + x0);
    result2[index + 3] = Number(y3 - dy + y0);
    result2[index + 4] = Number(x3 + x0);
    result2[index + 5] = Number(y3 + y0);
    x2 = x3 + dx;
    y2 = y3 + dy;
  }
  return result2;
};
var getBoundingBox = function(rect, rotation, cx) {
  let result2 = null;
  if (rect != null && rotation != null && rotation != 0) {
    const rad = toRadians(rotation);
    const cos = Math.cos(rad);
    const sin = Math.sin(rad);
    cx = cx != null ? cx : new mxPoint2(rect.x + rect.width / 2, rect.y + rect.height / 2);
    let p1 = new mxPoint2(rect.x, rect.y);
    let p2 = new mxPoint2(rect.x + rect.width, rect.y);
    let p3 = new mxPoint2(p2.x, rect.y + rect.height);
    let p4 = new mxPoint2(rect.x, p3.y);
    p1 = getRotatedPoint(p1, cos, sin, cx);
    p2 = getRotatedPoint(p2, cos, sin, cx);
    p3 = getRotatedPoint(p3, cos, sin, cx);
    p4 = getRotatedPoint(p4, cos, sin, cx);
    result2 = new mxRectangle(p1.x, p1.y, 0, 0);
    result2.add(new mxRectangle(p2.x, p2.y, 0, 0));
    result2.add(new mxRectangle(p3.x, p3.y, 0, 0));
    result2.add(new mxRectangle(p4.x, p4.y, 0, 0));
  }
  return result2;
};
var getRotatedPoint = function(pt, cos, sin, c) {
  c = c != null ? c : new mxPoint2();
  const x = pt.x - c.x;
  const y = pt.y - c.y;
  const x1 = x * cos - y * sin;
  const y1 = y * cos + x * sin;
  return new mxPoint2(x1 + c.x, y1 + c.y);
};
var getPortConstraints = function(terminal, edge, source, defaultValue) {
  const value = getValue(terminal.style, mxConstants2.STYLE_PORT_CONSTRAINT, getValue(edge.style, source ? mxConstants2.STYLE_SOURCE_PORT_CONSTRAINT : mxConstants2.STYLE_TARGET_PORT_CONSTRAINT, null));
  if (value == null) {
    return defaultValue;
  } else {
    const directions = value.toString();
    let returnValue = mxConstants2.DIRECTION_MASK_NONE;
    const constraintRotationEnabled = getValue(terminal.style, mxConstants2.STYLE_PORT_CONSTRAINT_ROTATION, 0);
    let rotation = 0;
    if (constraintRotationEnabled == 1) {
      rotation = getValue(terminal.style, mxConstants2.STYLE_ROTATION, 0);
    }
    let quad = 0;
    if (rotation > 45) {
      quad = 1;
      if (rotation >= 135) {
        quad = 2;
      }
    } else if (rotation < -45) {
      quad = 3;
      if (rotation <= -135) {
        quad = 2;
      }
    }
    if (directions.indexOf(mxConstants2.DIRECTION_NORTH) >= 0) {
      switch (quad) {
        case 0:
          returnValue |= mxConstants2.DIRECTION_MASK_NORTH;
          break;
        case 1:
          returnValue |= mxConstants2.DIRECTION_MASK_EAST;
          break;
        case 2:
          returnValue |= mxConstants2.DIRECTION_MASK_SOUTH;
          break;
        case 3:
          returnValue |= mxConstants2.DIRECTION_MASK_WEST;
          break;
      }
    }
    if (directions.indexOf(mxConstants2.DIRECTION_WEST) >= 0) {
      switch (quad) {
        case 0:
          returnValue |= mxConstants2.DIRECTION_MASK_WEST;
          break;
        case 1:
          returnValue |= mxConstants2.DIRECTION_MASK_NORTH;
          break;
        case 2:
          returnValue |= mxConstants2.DIRECTION_MASK_EAST;
          break;
        case 3:
          returnValue |= mxConstants2.DIRECTION_MASK_SOUTH;
          break;
      }
    }
    if (directions.indexOf(mxConstants2.DIRECTION_SOUTH) >= 0) {
      switch (quad) {
        case 0:
          returnValue |= mxConstants2.DIRECTION_MASK_SOUTH;
          break;
        case 1:
          returnValue |= mxConstants2.DIRECTION_MASK_WEST;
          break;
        case 2:
          returnValue |= mxConstants2.DIRECTION_MASK_NORTH;
          break;
        case 3:
          returnValue |= mxConstants2.DIRECTION_MASK_EAST;
          break;
      }
    }
    if (directions.indexOf(mxConstants2.DIRECTION_EAST) >= 0) {
      switch (quad) {
        case 0:
          returnValue |= mxConstants2.DIRECTION_MASK_EAST;
          break;
        case 1:
          returnValue |= mxConstants2.DIRECTION_MASK_SOUTH;
          break;
        case 2:
          returnValue |= mxConstants2.DIRECTION_MASK_WEST;
          break;
        case 3:
          returnValue |= mxConstants2.DIRECTION_MASK_NORTH;
          break;
      }
    }
    return returnValue;
  }
};
var reversePortConstraints = function(constraint) {
  let result2 = 0;
  result2 = (constraint & mxConstants2.DIRECTION_MASK_WEST) << 3;
  result2 |= (constraint & mxConstants2.DIRECTION_MASK_NORTH) << 1;
  result2 |= (constraint & mxConstants2.DIRECTION_MASK_SOUTH) >> 1;
  result2 |= (constraint & mxConstants2.DIRECTION_MASK_EAST) >> 3;
  return result2;
};
var findNearestSegment = function(state2, x, y) {
  let index = -1;
  if (state2.absolutePoints.length > 0) {
    let last = state2.absolutePoints[0];
    let min = null;
    for (let i = 1; i < state2.absolutePoints.length; i++) {
      const current2 = state2.absolutePoints[i];
      const dist = ptSegDistSq(last.x, last.y, current2.x, current2.y, x, y);
      if (min == null || dist < min) {
        min = dist;
        index = i - 1;
      }
      last = current2;
    }
  }
  return index;
};
var getDirectedBounds = function(rect, m, style, flipH, flipV) {
  const d = getValue(style, mxConstants2.STYLE_DIRECTION, mxConstants2.DIRECTION_EAST);
  flipH = flipH != null ? flipH : getValue(style, mxConstants2.STYLE_FLIPH, false);
  flipV = flipV != null ? flipV : getValue(style, mxConstants2.STYLE_FLIPV, false);
  m.x = Math.round(Math.max(0, Math.min(rect.width, m.x)));
  m.y = Math.round(Math.max(0, Math.min(rect.height, m.y)));
  m.width = Math.round(Math.max(0, Math.min(rect.width, m.width)));
  m.height = Math.round(Math.max(0, Math.min(rect.height, m.height)));
  if (flipV && (d == mxConstants2.DIRECTION_SOUTH || d == mxConstants2.DIRECTION_NORTH) || flipH && (d == mxConstants2.DIRECTION_EAST || d == mxConstants2.DIRECTION_WEST)) {
    const tmp = m.x;
    m.x = m.width;
    m.width = tmp;
  }
  if (flipH && (d == mxConstants2.DIRECTION_SOUTH || d == mxConstants2.DIRECTION_NORTH) || flipV && (d == mxConstants2.DIRECTION_EAST || d == mxConstants2.DIRECTION_WEST)) {
    const tmp = m.y;
    m.y = m.height;
    m.height = tmp;
  }
  const m2 = mxRectangle.fromRectangle(m);
  if (d == mxConstants2.DIRECTION_SOUTH) {
    m2.y = m.x;
    m2.x = m.height;
    m2.width = m.y;
    m2.height = m.width;
  } else if (d == mxConstants2.DIRECTION_WEST) {
    m2.y = m.height;
    m2.x = m.width;
    m2.width = m.x;
    m2.height = m.y;
  } else if (d == mxConstants2.DIRECTION_NORTH) {
    m2.y = m.width;
    m2.x = m.y;
    m2.width = m.height;
    m2.height = m.x;
  }
  return new mxRectangle(rect.x + m2.x, rect.y + m2.y, rect.width - m2.width - m2.x, rect.height - m2.height - m2.y);
};
var getPerimeterPoint = function(pts, center, point) {
  let min = null;
  for (let i = 0; i < pts.length - 1; i++) {
    const pt = intersection(pts[i].x, pts[i].y, pts[i + 1].x, pts[i + 1].y, center.x, center.y, point.x, point.y);
    if (pt != null) {
      const dx = point.x - pt.x;
      const dy = point.y - pt.y;
      const ip = { p: pt, distSq: dy * dy + dx * dx };
      if (ip != null && (min == null || min.distSq > ip.distSq)) {
        min = ip;
      }
    }
  }
  return min != null ? min.p : null;
};
var rectangleIntersectsSegment = function(bounds, p1, p2) {
  const top = bounds.y;
  const left = bounds.x;
  const bottom = top + bounds.height;
  const right = left + bounds.width;
  let minX = p1.x;
  let maxX = p2.x;
  if (p1.x > p2.x) {
    minX = p2.x;
    maxX = p1.x;
  }
  if (maxX > right) {
    maxX = right;
  }
  if (minX < left) {
    minX = left;
  }
  if (minX > maxX) {
    return false;
  }
  let minY = p1.y;
  let maxY = p2.y;
  const dx = p2.x - p1.x;
  if (Math.abs(dx) > 1e-7) {
    const a = (p2.y - p1.y) / dx;
    const b = p1.y - a * p1.x;
    minY = a * minX + b;
    maxY = a * maxX + b;
  }
  if (minY > maxY) {
    const tmp = maxY;
    maxY = minY;
    minY = tmp;
  }
  if (maxY > bottom) {
    maxY = bottom;
  }
  if (minY < top) {
    minY = top;
  }
  if (minY > maxY) {
    return false;
  }
  return true;
};
var contains = function(bounds, x, y) {
  return bounds.x <= x && bounds.x + bounds.width >= x && bounds.y <= y && bounds.y + bounds.height >= y;
};
var intersects = function(a, b) {
  let tw = a.width;
  let th = a.height;
  let rw = b.width;
  let rh = b.height;
  if (rw <= 0 || rh <= 0 || tw <= 0 || th <= 0) {
    return false;
  }
  const tx = a.x;
  const ty = a.y;
  const rx = b.x;
  const ry = b.y;
  rw += rx;
  rh += ry;
  tw += tx;
  th += ty;
  return (rw < rx || rw > tx) && (rh < ry || rh > ty) && (tw < tx || tw > rx) && (th < ty || th > ry);
};
var intersectsHotspot = function(state2, x, y, hotspot, min, max) {
  hotspot = hotspot != null ? hotspot : 1;
  min = min != null ? min : 0;
  max = max != null ? max : 0;
  if (hotspot > 0) {
    let cx = state2.getCenterX();
    let cy = state2.getCenterY();
    let w2 = state2.width;
    let h2 = state2.height;
    const start = getValue(state2.style, mxConstants2.STYLE_STARTSIZE) * state2.view.scale;
    if (start > 0) {
      if (getValue(state2.style, mxConstants2.STYLE_HORIZONTAL, true)) {
        cy = state2.y + start / 2;
        h2 = start;
      } else {
        cx = state2.x + start / 2;
        w2 = start;
      }
    }
    w2 = Math.max(min, w2 * hotspot);
    h2 = Math.max(min, h2 * hotspot);
    if (max > 0) {
      w2 = Math.min(w2, max);
      h2 = Math.min(h2, max);
    }
    const rect = new mxRectangle(cx - w2 / 2, cy - h2 / 2, w2, h2);
    const alpha = toRadians(getValue(state2.style, mxConstants2.STYLE_ROTATION) || 0);
    if (alpha != 0) {
      const cos = Math.cos(-alpha);
      const sin = Math.sin(-alpha);
      const cx2 = new mxPoint2(state2.getCenterX(), state2.getCenterY());
      const pt = getRotatedPoint(new mxPoint2(x, y), cos, sin, cx2);
      x = pt.x;
      y = pt.y;
    }
    return contains(rect, x, y);
  }
  return true;
};
var getOffset = function(container, scrollOffset) {
  let offsetLeft = 0;
  let offsetTop = 0;
  let fixed = false;
  let node = container;
  const b = document.body;
  const d = document.documentElement;
  while (node != null && node != b && node != d && !fixed) {
    const style = getCurrentStyle(node);
    if (style != null) {
      fixed = fixed || style.position == "fixed";
    }
    node = node.parentNode;
  }
  if (!scrollOffset && !fixed) {
    const offset = getDocumentScrollOrigin(container.ownerDocument);
    offsetLeft += offset.x;
    offsetTop += offset.y;
  }
  const r = container.getBoundingClientRect();
  if (r != null) {
    offsetLeft += r.left;
    offsetTop += r.top;
  }
  return new mxPoint2(offsetLeft, offsetTop);
};
var getDocumentScrollOrigin = function(doc) {
  if (mxClient_default.IS_QUIRKS) {
    return new mxPoint2(doc.body.scrollLeft, doc.body.scrollTop);
  } else {
    const wnd = doc.defaultView || doc.parentWindow;
    const x = wnd != null && window.pageXOffset !== void 0 ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft;
    const y = wnd != null && window.pageYOffset !== void 0 ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;
    return new mxPoint2(x, y);
  }
};
var getScrollOrigin = function(node, includeAncestors, includeDocument) {
  includeAncestors = includeAncestors != null ? includeAncestors : false;
  includeDocument = includeDocument != null ? includeDocument : true;
  const doc = node != null ? node.ownerDocument : document;
  const b = doc.body;
  const d = doc.documentElement;
  const result2 = new mxPoint2();
  let fixed = false;
  while (node != null && node != b && node != d) {
    if (!isNaN2(node.scrollLeft) && !isNaN2(node.scrollTop)) {
      result2.x += node.scrollLeft;
      result2.y += node.scrollTop;
    }
    const style = getCurrentStyle(node);
    if (style != null) {
      fixed = fixed || style.position == "fixed";
    }
    node = includeAncestors ? node.parentNode : null;
  }
  if (!fixed && includeDocument) {
    const origin = getDocumentScrollOrigin(doc);
    result2.x += origin.x;
    result2.y += origin.y;
  }
  return result2;
};
var convertPoint = function(container, x, y) {
  const origin = getScrollOrigin(container, false);
  const offset = getOffset(container);
  offset.x -= origin.x;
  offset.y -= origin.y;
  return new mxPoint2(x - offset.x, y - offset.y);
};
var ltrim = function(str, chars) {
  chars = chars || "\\s";
  return str != null ? str.replace(new RegExp("^[" + chars + "]+", "g"), "") : null;
};
var rtrim = function(str, chars) {
  chars = chars || "\\s";
  return str != null ? str.replace(new RegExp("[" + chars + "]+$", "g"), "") : null;
};
var trim = function(str, chars) {
  return ltrim(rtrim(str, chars), chars);
};
var isNumeric = function(n) {
  return !isNaN2(parseFloat(n)) && isFinite(n) && (typeof n != "string" || n.toLowerCase().indexOf("0x") < 0);
};
var isInteger = function(n) {
  return String(parseInt(n)) === String(n);
};
var mod = function(n, m) {
  return (n % m + m) % m;
};
var intersection = function(x0, y0, x1, y1, x2, y2, x3, y3) {
  const denom = (y3 - y2) * (x1 - x0) - (x3 - x2) * (y1 - y0);
  const nume_a = (x3 - x2) * (y0 - y2) - (y3 - y2) * (x0 - x2);
  const nume_b = (x1 - x0) * (y0 - y2) - (y1 - y0) * (x0 - x2);
  const ua = nume_a / denom;
  const ub = nume_b / denom;
  if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
    const x = x0 + ua * (x1 - x0);
    const y = y0 + ua * (y1 - y0);
    return new mxPoint2(x, y);
  }
  return null;
};
var ptSegDistSq = function(x1, y1, x2, y2, px, py) {
  x2 -= x1;
  y2 -= y1;
  px -= x1;
  py -= y1;
  let dotprod = px * x2 + py * y2;
  let projlenSq;
  if (dotprod <= 0) {
    projlenSq = 0;
  } else {
    px = x2 - px;
    py = y2 - py;
    dotprod = px * x2 + py * y2;
    if (dotprod <= 0) {
      projlenSq = 0;
    } else {
      projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);
    }
  }
  let lenSq = px * px + py * py - projlenSq;
  if (lenSq < 0) {
    lenSq = 0;
  }
  return lenSq;
};
var ptLineDist = function(x1, y1, x2, y2, px, py) {
  return Math.abs((y2 - y1) * px - (x2 - x1) * py + x2 * y1 - y2 * x1) / Math.sqrt((y2 - y1) * (y2 - y1) + (x2 - x1) * (x2 - x1));
};
var relativeCcw = function(x1, y1, x2, y2, px, py) {
  x2 -= x1;
  y2 -= y1;
  px -= x1;
  py -= y1;
  let ccw = px * y2 - py * x2;
  if (ccw == 0) {
    ccw = px * x2 + py * y2;
    if (ccw > 0) {
      px -= x2;
      py -= y2;
      ccw = px * x2 + py * y2;
      if (ccw < 0) {
        ccw = 0;
      }
    }
  }
  return ccw < 0 ? -1 : ccw > 0 ? 1 : 0;
};
var animateChanges2 = function(graph, changes) {
  mxEffects_default.animateChanges.apply(this, arguments);
};
var cascadeOpacity2 = function(graph, cell2, opacity) {
  mxEffects_default.cascadeOpacity.apply(this, arguments);
};
var fadeOut2 = function(node, from, remove2, step, delay, isEnabled2) {
  mxEffects_default.fadeOut.apply(this, arguments);
};
var setOpacity = function(node, value) {
  if (isVml(node)) {
    if (value >= 100) {
      node.style.filter = "";
    } else {
      node.style.filter = "alpha(opacity=" + value / 5 + ")";
    }
  } else if (mxClient_default.IS_IE && (typeof document.documentMode === "undefined" || document.documentMode < 9)) {
    if (value >= 100) {
      node.style.filter = "";
    } else {
      node.style.filter = "alpha(opacity=" + value + ")";
    }
  } else {
    node.style.opacity = value / 100;
  }
};
var createImage = function(src) {
  let imageNode = null;
  if (mxClient_default.IS_IE6 && document.compatMode != "CSS1Compat") {
    imageNode = document.createElement(mxClient_default.VML_PREFIX + ":image");
    imageNode.setAttribute("src", src);
    imageNode.style.borderStyle = "none";
  } else {
    imageNode = document.createElement("img");
    imageNode.setAttribute("src", src);
    imageNode.setAttribute("border", "0");
  }
  return imageNode;
};
var sortCells = function(cells, ascending) {
  ascending = ascending != null ? ascending : true;
  const lookup = new mxDictionary();
  cells.sort(function(o1, o2) {
    let p1 = lookup.get(o1);
    if (p1 == null) {
      p1 = mxCellPath_default.create(o1).split(mxCellPath_default.PATH_SEPARATOR);
      lookup.put(o1, p1);
    }
    let p2 = lookup.get(o2);
    if (p2 == null) {
      p2 = mxCellPath_default.create(o2).split(mxCellPath_default.PATH_SEPARATOR);
      lookup.put(o2, p2);
    }
    const comp = mxCellPath_default.compare(p1, p2);
    return comp == 0 ? 0 : comp > 0 == ascending ? 1 : -1;
  });
  return cells;
};
var getStylename = function(style) {
  if (style != null) {
    const pairs = style.split(";");
    const stylename = pairs[0];
    if (stylename.indexOf("=") < 0) {
      return stylename;
    }
  }
  return "";
};
var getStylenames = function(style) {
  const result2 = [];
  if (style != null) {
    const pairs = style.split(";");
    for (let i = 0; i < pairs.length; i++) {
      if (pairs[i].indexOf("=") < 0) {
        result2.push(pairs[i]);
      }
    }
  }
  return result2;
};
var indexOfStylename = function(style, stylename) {
  if (style != null && stylename != null) {
    const tokens = style.split(";");
    let pos = 0;
    for (let i = 0; i < tokens.length; i++) {
      if (tokens[i] == stylename) {
        return pos;
      }
      pos += tokens[i].length + 1;
    }
  }
  return -1;
};
var addStylename = function(style, stylename) {
  if (indexOfStylename(style, stylename) < 0) {
    if (style == null) {
      style = "";
    } else if (style.length > 0 && style.charAt(style.length - 1) != ";") {
      style += ";";
    }
    style += stylename;
  }
  return style;
};
var removeStylename = function(style, stylename) {
  const result2 = [];
  if (style != null) {
    const tokens = style.split(";");
    for (let i = 0; i < tokens.length; i++) {
      if (tokens[i] != stylename) {
        result2.push(tokens[i]);
      }
    }
  }
  return result2.join(";");
};
var removeAllStylenames = function(style) {
  const result2 = [];
  if (style != null) {
    const tokens = style.split(";");
    for (let i = 0; i < tokens.length; i++) {
      if (tokens[i].indexOf("=") >= 0) {
        result2.push(tokens[i]);
      }
    }
  }
  return result2.join(";");
};
var setCellStyles = function(model, cells, key, value) {
  if (cells != null && cells.length > 0) {
    model.beginUpdate();
    try {
      for (let i = 0; i < cells.length; i++) {
        if (cells[i] != null) {
          const style = setStyle(model.getStyle(cells[i]), key, value);
          model.setStyle(cells[i], style);
        }
      }
    } finally {
      model.endUpdate();
    }
  }
};
var setStyle = function(style, key, value) {
  const isValue = value != null && (typeof value.length == "undefined" || value.length > 0);
  if (style == null || style.length == 0) {
    if (isValue) {
      style = key + "=" + value + ";";
    }
  } else {
    if (style.substring(0, key.length + 1) == key + "=") {
      const next = style.indexOf(";");
      if (isValue) {
        style = key + "=" + value + (next < 0 ? ";" : style.substring(next));
      } else {
        style = next < 0 || next == style.length - 1 ? "" : style.substring(next + 1);
      }
    } else {
      const index = style.indexOf(";" + key + "=");
      if (index < 0) {
        if (isValue) {
          const sep = style.charAt(style.length - 1) == ";" ? "" : ";";
          style = style + sep + key + "=" + value + ";";
        }
      } else {
        const next = style.indexOf(";", index + 1);
        if (isValue) {
          style = style.substring(0, index + 1) + key + "=" + value + (next < 0 ? ";" : style.substring(next));
        } else {
          style = style.substring(0, index) + (next < 0 ? ";" : style.substring(next));
        }
      }
    }
  }
  return style;
};
var setCellStyleFlags = function(model, cells, key, flag, value) {
  if (cells != null && cells.length > 0) {
    model.beginUpdate();
    try {
      for (let i = 0; i < cells.length; i++) {
        if (cells[i] != null) {
          const style = setStyleFlag(model.getStyle(cells[i]), key, flag, value);
          model.setStyle(cells[i], style);
        }
      }
    } finally {
      model.endUpdate();
    }
  }
};
var setStyleFlag = function(style, key, flag, value) {
  if (style == null || style.length == 0) {
    if (value || value == null) {
      style = key + "=" + flag;
    } else {
      style = key + "=0";
    }
  } else {
    const index = style.indexOf(key + "=");
    if (index < 0) {
      const sep = style.charAt(style.length - 1) == ";" ? "" : ";";
      if (value || value == null) {
        style = style + sep + key + "=" + flag;
      } else {
        style = style + sep + key + "=0";
      }
    } else {
      const cont = style.indexOf(";", index);
      let tmp = "";
      if (cont < 0) {
        tmp = style.substring(index + key.length + 1);
      } else {
        tmp = style.substring(index + key.length + 1, cont);
      }
      if (value == null) {
        tmp = parseInt(tmp) ^ flag;
      } else if (value) {
        tmp = parseInt(tmp) | flag;
      } else {
        tmp = parseInt(tmp) & ~flag;
      }
      style = style.substring(0, index) + key + "=" + tmp + (cont >= 0 ? style.substring(cont) : "");
    }
  }
  return style;
};
var getAlignmentAsPoint = function(align, valign) {
  let dx = -0.5;
  let dy = -0.5;
  if (align == mxConstants2.ALIGN_LEFT) {
    dx = 0;
  } else if (align == mxConstants2.ALIGN_RIGHT) {
    dx = -1;
  }
  if (valign == mxConstants2.ALIGN_TOP) {
    dy = 0;
  } else if (valign == mxConstants2.ALIGN_BOTTOM) {
    dy = -1;
  }
  return new mxPoint2(dx, dy);
};
var getSizeForString = function(text, fontSize, fontFamily, textWidth, fontStyle) {
  return calculateTextDimensions(text, fontSize, fontFamily, textWidth, fontStyle);
};
var getViewXml = function(graph, scale, cells, x0, y0) {
  x0 = x0 != null ? x0 : 0;
  y0 = y0 != null ? y0 : 0;
  scale = scale != null ? scale : 1;
  if (cells == null) {
    const model = graph.getModel();
    cells = [model.getRoot()];
  }
  const view = graph.getView();
  let result2 = null;
  const eventsEnabled = view.isEventsEnabled();
  view.setEventsEnabled(false);
  const drawPane = view.drawPane;
  const overlayPane = view.overlayPane;
  if (graph.dialect == mxConstants2.DIALECT_SVG) {
    view.drawPane = document.createElementNS(mxConstants2.NS_SVG, "g");
    view.canvas.appendChild(view.drawPane);
    view.overlayPane = document.createElementNS(mxConstants2.NS_SVG, "g");
    view.canvas.appendChild(view.overlayPane);
  } else {
    view.drawPane = view.drawPane.cloneNode(false);
    view.canvas.appendChild(view.drawPane);
    view.overlayPane = view.overlayPane.cloneNode(false);
    view.canvas.appendChild(view.overlayPane);
  }
  const translate = view.getTranslate();
  view.translate = new mxPoint2(x0, y0);
  const temp2 = new mxTemporaryCellStates(graph.getView(), scale, cells);
  try {
    const enc = new mxCodec();
    result2 = enc.encode(graph.getView());
  } finally {
    temp2.destroy();
    view.translate = translate;
    view.canvas.removeChild(view.drawPane);
    view.canvas.removeChild(view.overlayPane);
    view.drawPane = drawPane;
    view.overlayPane = overlayPane;
    view.setEventsEnabled(eventsEnabled);
  }
  return result2;
};
var getScaleForPageCount = function(pageCount, graph, pageFormat, border) {
  if (pageCount < 1) {
    return 1;
  }
  pageFormat = pageFormat != null ? pageFormat : mxConstants2.PAGE_FORMAT_A4_PORTRAIT;
  border = border != null ? border : 0;
  const availablePageWidth = pageFormat.width - border * 2;
  const availablePageHeight = pageFormat.height - border * 2;
  const graphBounds = graph.getGraphBounds().clone();
  const sc = graph.getView().getScale();
  graphBounds.width /= sc;
  graphBounds.height /= sc;
  const graphWidth = graphBounds.width;
  const graphHeight = graphBounds.height;
  let scale = 1;
  const pageFormatAspectRatio = availablePageWidth / availablePageHeight;
  const graphAspectRatio = graphWidth / graphHeight;
  const pagesAspectRatio = graphAspectRatio / pageFormatAspectRatio;
  const pageRoot = Math.sqrt(pageCount);
  const pagesAspectRatioSqrt = Math.sqrt(pagesAspectRatio);
  let numRowPages = pageRoot * pagesAspectRatioSqrt;
  let numColumnPages = pageRoot / pagesAspectRatioSqrt;
  if (numRowPages < 1 && numColumnPages > pageCount) {
    const scaleChange = numColumnPages / pageCount;
    numColumnPages = pageCount;
    numRowPages /= scaleChange;
  }
  if (numColumnPages < 1 && numRowPages > pageCount) {
    const scaleChange = numRowPages / pageCount;
    numRowPages = pageCount;
    numColumnPages /= scaleChange;
  }
  let currentTotalPages = Math.ceil(numRowPages) * Math.ceil(numColumnPages);
  let numLoops = 0;
  while (currentTotalPages > pageCount) {
    let roundRowDownProportion = Math.floor(numRowPages) / numRowPages;
    let roundColumnDownProportion = Math.floor(numColumnPages) / numColumnPages;
    if (roundRowDownProportion == 1) {
      roundRowDownProportion = Math.floor(numRowPages - 1) / numRowPages;
    }
    if (roundColumnDownProportion == 1) {
      roundColumnDownProportion = Math.floor(numColumnPages - 1) / numColumnPages;
    }
    let scaleChange = 1;
    if (roundRowDownProportion > roundColumnDownProportion) {
      scaleChange = roundRowDownProportion;
    } else {
      scaleChange = roundColumnDownProportion;
    }
    numRowPages = numRowPages * scaleChange;
    numColumnPages = numColumnPages * scaleChange;
    currentTotalPages = Math.ceil(numRowPages) * Math.ceil(numColumnPages);
    numLoops++;
    if (numLoops > 10) {
      break;
    }
  }
  const posterWidth = availablePageWidth * numRowPages;
  scale = posterWidth / graphWidth;
  return scale * 0.99999;
};
var show = function(graph, doc, x0, y0, w2, h2) {
  x0 = x0 != null ? x0 : 0;
  y0 = y0 != null ? y0 : 0;
  if (doc == null) {
    var wnd = window.open();
    doc = wnd.document;
  } else {
    doc.open();
  }
  if (document.documentMode == 9) {
    doc.writeln('<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=9"><![endif]-->');
  }
  var bounds = graph.getGraphBounds();
  var dx = Math.ceil(x0 - bounds.x);
  var dy = Math.ceil(y0 - bounds.y);
  if (w2 == null) {
    w2 = Math.ceil(bounds.width + x0) + Math.ceil(Math.ceil(bounds.x) - bounds.x);
  }
  if (h2 == null) {
    h2 = Math.ceil(bounds.height + y0) + Math.ceil(Math.ceil(bounds.y) - bounds.y);
  }
  if (mxClient_default.IS_IE || document.documentMode == 11) {
    var html = "<html><head>";
    var base = document.getElementsByTagName("base");
    for (var i = 0; i < base.length; i++) {
      html += base[i].outerHTML;
    }
    html += "<style>";
    for (var i = 0; i < document.styleSheets.length; i++) {
      try {
        html += document.styleSheets[i].cssText;
      } catch (e) {
      }
    }
    html += '</style></head><body style="margin:0px;">';
    html += '<div style="position:absolute;overflow:hidden;width:' + w2 + "px;height:" + h2 + 'px;"><div style="position:relative;left:' + dx + "px;top:" + dy + 'px;">';
    html += graph.container.innerHTML;
    html += "</div></div></body><html>";
    doc.writeln(html);
    doc.close();
  } else {
    doc.writeln("<html><head>");
    var base = document.getElementsByTagName("base");
    for (var i = 0; i < base.length; i++) {
      doc.writeln(mxUtils.getOuterHtml(base[i]));
    }
    var links = document.getElementsByTagName("link");
    for (var i = 0; i < links.length; i++) {
      doc.writeln(mxUtils.getOuterHtml(links[i]));
    }
    var styles = document.getElementsByTagName("style");
    for (var i = 0; i < styles.length; i++) {
      doc.writeln(mxUtils.getOuterHtml(styles[i]));
    }
    doc.writeln('</head><body style="margin:0px;"></body></html>');
    doc.close();
    var outer = doc.createElement("div");
    outer.position = "absolute";
    outer.overflow = "hidden";
    outer.style.width = w2 + "px";
    outer.style.height = h2 + "px";
    var div = doc.createElement("div");
    div.style.position = "absolute";
    div.style.left = dx + "px";
    div.style.top = dy + "px";
    var node = graph.container.firstChild;
    var svg = null;
    while (node != null) {
      var clone3 = node.cloneNode(true);
      if (node == graph.view.drawPane.ownerSVGElement) {
        outer.appendChild(clone3);
        svg = clone3;
      } else {
        div.appendChild(clone3);
      }
      node = node.nextSibling;
    }
    doc.body.appendChild(outer);
    if (div.firstChild != null) {
      doc.body.appendChild(div);
    }
    if (svg != null) {
      svg.style.minWidth = "";
      svg.style.minHeight = "";
      svg.firstChild.setAttribute("transform", "translate(" + dx + "," + dy + ")");
    }
  }
  mxUtils.removeCursors(doc.body);
  return doc;
};
var printScreen = function(graph) {
  var wnd = window.open();
  var bounds = graph.getGraphBounds();
  mxUtils.show(graph, wnd.document);
  var print = function() {
    wnd.focus();
    wnd.print();
    wnd.close();
  };
  if (mxClient_default.IS_GC) {
    wnd.setTimeout(print, 500);
  } else {
    print();
  }
};
var popup = function(content, isInternalWindow) {
  if (isInternalWindow) {
    var div = document.createElement("div");
    div.style.overflow = "scroll";
    div.style.width = "636px";
    div.style.height = "460px";
    var pre = document.createElement("pre");
    pre.innerHTML = mxUtils.htmlEntities(content, false).replace(/\n/g, "<br>").replace(/ /g, "&nbsp;");
    div.appendChild(pre);
    var w2 = document.body.clientWidth;
    var h2 = Math.max(document.body.clientHeight || 0, document.documentElement.clientHeight);
    var wnd = new mxWindow("Popup Window", div, w2 / 2 - 320, h2 / 2 - 240, 640, 480, false, true);
    wnd.setClosable(true);
    wnd.setVisible(true);
  } else {
    if (mxClient_default.IS_NS) {
      var wnd = window.open();
      wnd.document.writeln("<pre>" + mxUtils.htmlEntities(content) + "</pre");
      wnd.document.close();
    } else {
      var wnd = window.open();
      var pre = wnd.document.createElement("pre");
      pre.innerHTML = mxUtils.htmlEntities(content, false).replace(/\n/g, "<br>").replace(/ /g, "&nbsp;");
      wnd.document.body.appendChild(pre);
    }
  }
};
var alert2 = function(message) {
  alert2(message);
};
var prompt = function(message, defaultValue) {
  return prompt(message, defaultValue != null ? defaultValue : "");
};
var confirm = function(message) {
  return confirm(message);
};
var error = function(message, width, close, icon) {
  var div = document.createElement("div");
  div.style.padding = "20px";
  var img = document.createElement("img");
  img.setAttribute("src", icon || mxUtils.errorImage);
  img.setAttribute("valign", "bottom");
  img.style.verticalAlign = "middle";
  div.appendChild(img);
  div.appendChild(document.createTextNode("\xA0"));
  div.appendChild(document.createTextNode("\xA0"));
  div.appendChild(document.createTextNode("\xA0"));
  mxUtils.write(div, message);
  var w2 = document.body.clientWidth;
  var h2 = document.body.clientHeight || document.documentElement.clientHeight;
  var warn = new mxWindow(mxResources2.get(mxUtils.errorResource) || mxUtils.errorResource, div, (w2 - width) / 2, h2 / 4, width, null, false, true);
  if (close) {
    mxUtils.br(div);
    var tmp = document.createElement("p");
    var button2 = document.createElement("button");
    if (mxClient_default.IS_IE) {
      button2.style.cssText = "float:right";
    } else {
      button2.setAttribute("style", "float:right");
    }
    mxEvent2.addListener(button2, "click", function(evt) {
      warn.destroy();
    });
    mxUtils.write(button2, mxResources2.get(mxUtils.closeResource) || mxUtils.closeResource);
    tmp.appendChild(button2);
    div.appendChild(tmp);
    mxUtils.br(div);
    warn.setClosable(true);
  }
  warn.setVisible(true);
  return warn;
};
var makeDraggable = function(element, graphF, funct, dragElement, dx, dy, autoscroll, scalePreview, highlightDropTargets, getDropTarget) {
  var dragSource = new mxDragSource(element, funct);
  dragSource.dragOffset = new mxPoint2(dx != null ? dx : 0, dy != null ? dy : mxConstants2.TOOLTIP_VERTICAL_OFFSET);
  dragSource.autoscroll = autoscroll;
  dragSource.setGuidesEnabled(false);
  if (highlightDropTargets != null) {
    dragSource.highlightDropTargets = highlightDropTargets;
  }
  if (getDropTarget != null) {
    dragSource.getDropTarget = getDropTarget;
  }
  dragSource.getGraphForEvent = function(evt) {
    return typeof graphF == "function" ? graphF(evt) : graphF;
  };
  if (dragElement != null) {
    dragSource.createDragElement = function() {
      return dragElement.cloneNode(true);
    };
    if (scalePreview) {
      dragSource.createPreviewElement = function(graph) {
        var elt = dragElement.cloneNode(true);
        var w2 = parseInt(elt.style.width);
        var h2 = parseInt(elt.style.height);
        elt.style.width = Math.round(w2 * graph.view.scale) + "px";
        elt.style.height = Math.round(h2 * graph.view.scale) + "px";
        return elt;
      };
    }
  }
  return dragSource;
};

// js/graph/mxResources.js
var mxResources2 = {
  resources: {},
  get extension() {
    return mxClient_default.mxResourceExtension;
  },
  resourcesEncoded: false,
  loadDefaultBundle: true,
  loadSpecialBundle: true,
  isLanguageSupported(lan) {
    if (mxClient_default.languages != null) {
      return indexOf(mxClient_default.languages, lan) >= 0;
    }
    return true;
  },
  getDefaultBundle(basename, lan) {
    if (mxResources2.loadDefaultBundle || !mxResources2.isLanguageSupported(lan)) {
      return basename + mxResources2.extension;
    }
    return null;
  },
  getSpecialBundle(basename, lan) {
    if (mxClient_default.languages == null || !this.isLanguageSupported(lan)) {
      let dash = lan.indexOf("-");
      if (dash > 0) {
        lan = lan.substring(0, dash);
      }
    }
    if (mxResources2.loadSpecialBundle && mxResources2.isLanguageSupported(lan) && lan !== mxClient_default.defaultLanguage) {
      return basename + "_" + lan + mxResources2.extension;
    }
    return null;
  },
  add(basename, lan, callback) {
    lan = lan != null ? lan : mxClient_default.language != null ? mxClient_default.language.toLowerCase() : mxConstants2.NONE;
    if (lan !== mxConstants2.NONE) {
      const defaultBundle = mxResources2.getDefaultBundle(basename, lan);
      const specialBundle = mxResources2.getSpecialBundle(basename, lan);
      const loadSpecialBundle = () => {
        if (specialBundle != null) {
          if (callback) {
            get(specialBundle, (req) => {
              mxResources2.parse(req.getText());
              callback();
            }, () => {
              callback();
            });
          } else {
            try {
              const req = load(specialBundle);
              if (req.isReady()) {
                mxResources2.parse(req.getText());
              }
            } catch (e) {
            }
          }
        } else if (callback != null) {
          callback();
        }
      };
      if (defaultBundle != null) {
        if (callback) {
          get(defaultBundle, (req) => {
            mxResources2.parse(req.getText());
            loadSpecialBundle();
          }, () => {
            loadSpecialBundle();
          });
        } else {
          try {
            const req = load(defaultBundle);
            if (req.isReady()) {
              mxResources2.parse(req.getText());
            }
            loadSpecialBundle();
          } catch (e) {
          }
        }
      } else {
        loadSpecialBundle();
      }
    }
  },
  parse(text) {
    if (text != null) {
      const lines = text.split("\n");
      for (let i = 0; i < lines.length; i++) {
        if (lines[i].charAt(0) !== "#") {
          const index = lines[i].indexOf("=");
          if (index > 0) {
            const key = lines[i].substring(0, index);
            let idx = lines[i].length;
            if (lines[i].charCodeAt(idx - 1) === 13) {
              idx--;
            }
            let value = lines[i].substring(index + 1, idx);
            if (mxResources2.resourcesEncoded) {
              value = value.replace(/\\(?=u[a-fA-F\d]{4})/g, "%");
              mxResources2.resources[key] = unescape(value);
            } else {
              mxResources2.resources[key] = value;
            }
          }
        }
      }
    }
  },
  get(key, params, defaultValue) {
    let value = mxResources2.resources[key];
    if (value == null) {
      value = defaultValue;
    }
    if (value != null && params != null) {
      value = mxResources2.replacePlaceholders(value, params);
    }
    return value;
  },
  replacePlaceholders(value, params) {
    const result2 = [];
    let index = null;
    for (let i = 0; i < value.length; i++) {
      const c = value.charAt(i);
      if (c === "{") {
        index = "";
      } else if (index != null && c === "}") {
        const idx = parseInt(index, 10) - 1;
        if (idx >= 0 && idx < params.length) {
          result2.push(params[idx]);
        }
        index = null;
      } else if (index != null) {
        index += c;
      } else {
        result2.push(c);
      }
    }
    return result2.join("");
  },
  loadResources(callback) {
    mxResources2.add(`${mxClient_default.basePath}/resources/editor`, null, () => {
      mxResources2.add(`${mxClient_default.basePath}/resources/graph`, null, callback);
    });
  }
};

// js/graph/mxClient.js
var mxClient2 = {
  VERSION: "4.2.2",
  IS_IE: navigator.userAgent != null && navigator.userAgent.indexOf("MSIE") >= 0,
  IS_IE6: navigator.userAgent != null && navigator.userAgent.indexOf("MSIE 6") >= 0,
  IS_IE11: navigator.userAgent != null && !!navigator.userAgent.match(/Trident\/7\./),
  IS_EDGE: navigator.userAgent != null && !!navigator.userAgent.match(/Edge\//),
  IS_QUIRKS: navigator.userAgent != null && navigator.userAgent.indexOf("MSIE") >= 0 && (document.documentMode == null || document.documentMode == 5),
  IS_EM: "spellcheck" in document.createElement("textarea") && document.documentMode == 8,
  VML_PREFIX: "v",
  OFFICE_PREFIX: "o",
  IS_NS: navigator.userAgent != null && navigator.userAgent.indexOf("Mozilla/") >= 0 && navigator.userAgent.indexOf("MSIE") < 0 && navigator.userAgent.indexOf("Edge/") < 0,
  IS_OP: navigator.userAgent != null && (navigator.userAgent.indexOf("Opera/") >= 0 || navigator.userAgent.indexOf("OPR/") >= 0),
  IS_OT: navigator.userAgent != null && navigator.userAgent.indexOf("Presto/") >= 0 && navigator.userAgent.indexOf("Presto/2.4.") < 0 && navigator.userAgent.indexOf("Presto/2.3.") < 0 && navigator.userAgent.indexOf("Presto/2.2.") < 0 && navigator.userAgent.indexOf("Presto/2.1.") < 0 && navigator.userAgent.indexOf("Presto/2.0.") < 0 && navigator.userAgent.indexOf("Presto/1.") < 0,
  IS_SF: /Apple Computer, Inc/.test(navigator.vendor),
  IS_ANDROID: navigator.appVersion.indexOf("Android") >= 0,
  IS_IOS: /iP(hone|od|ad)/.test(navigator.platform),
  IS_GC: /Google Inc/.test(navigator.vendor),
  IS_CHROMEAPP: window.chrome != null && chrome.app != null && chrome.app.runtime != null,
  IS_FF: typeof InstallTrigger !== "undefined",
  IS_MT: navigator.userAgent.indexOf("Firefox/") >= 0 && navigator.userAgent.indexOf("Firefox/1.") < 0 && navigator.userAgent.indexOf("Firefox/2.") < 0 || navigator.userAgent.indexOf("Iceweasel/") >= 0 && navigator.userAgent.indexOf("Iceweasel/1.") < 0 && navigator.userAgent.indexOf("Iceweasel/2.") < 0 || navigator.userAgent.indexOf("SeaMonkey/") >= 0 && navigator.userAgent.indexOf("SeaMonkey/1.") < 0 || navigator.userAgent.indexOf("Iceape/") >= 0 && navigator.userAgent.indexOf("Iceape/1.") < 0,
  IS_VML: navigator.appName.toUpperCase() == "MICROSOFT INTERNET EXPLORER",
  IS_SVG: navigator.appName.toUpperCase() != "MICROSOFT INTERNET EXPLORER",
  NO_FO: !document.createElementNS || document.createElementNS("http://www.w3.org/2000/svg", "foreignObject") != "[object SVGForeignObjectElement]" || navigator.userAgent.indexOf("Opera/") >= 0,
  IS_WIN: navigator.appVersion.indexOf("Win") > 0,
  IS_MAC: navigator.appVersion.indexOf("Mac") > 0,
  IS_CHROMEOS: /\bCrOS\b/.test(navigator.appVersion),
  IS_TOUCH: "ontouchstart" in document.documentElement,
  IS_POINTER: window.PointerEvent != null && !(navigator.appVersion.indexOf("Mac") > 0),
  IS_LOCAL: document.location.href.indexOf("http://") < 0 && document.location.href.indexOf("https://") < 0,
  defaultBundles: [],
  isBrowserSupported: function() {
    return mxClient2.IS_VML || mxClient2.IS_SVG;
  },
  link: function(rel, href, doc, id) {
    doc = doc || document;
    if (mxClient2.IS_IE6) {
      doc.write('<link rel="' + rel + '" href="' + href + '" charset="UTF-8" type="text/css"/>');
    } else {
      const link2 = doc.createElement("link");
      link2.setAttribute("rel", rel);
      link2.setAttribute("href", href);
      link2.setAttribute("charset", "UTF-8");
      link2.setAttribute("type", "text/css");
      if (id) {
        link2.setAttribute("id", id);
      }
      const head = doc.getElementsByTagName("head")[0];
      head.appendChild(link2);
    }
  },
  loadResources: function(fn, lan) {
    let pending = mxClient2.defaultBundles.length;
    const callback = function() {
      if (--pending == 0) {
        fn();
      }
    };
    for (let i = 0; i < mxClient2.defaultBundles.length; i++) {
      mxResources2.add(mxClient2.defaultBundles[i], lan, callback);
    }
  },
  include: function(src) {
    document.write('<script src="' + src + '"><\/script>');
  }
};
if (typeof window.mxLoadResources == "undefined") {
  window.mxLoadResources = true;
}
if (typeof window.mxForceIncludes == "undefined") {
  window.mxForceIncludes = false;
}
if (typeof window.mxResourceExtension !== "undefined") {
  mxClient2.mxResourceExtension = window.mxResourceExtension;
} else {
  mxClient2.mxResourceExtension = ".txt";
}
if (typeof window.mxLoadStylesheets == "undefined") {
  window.mxLoadStylesheets = true;
}
if (typeof window.mxBasePath != "undefined" && window.mxBasePath.length > 0) {
  if (window.mxBasePath.substring(window.mxBasePath.length - 1) == "/") {
    window.mxBasePath = window.mxBasePath.substring(0, window.mxBasePath.length - 1);
  }
  mxClient2.basePath = window.mxBasePath;
} else {
  mxClient2.basePath = ".";
}
if (typeof window.mxImageBasePath != "undefined" && window.mxImageBasePath.length > 0) {
  if (window.mxImageBasePath.substring(window.mxImageBasePath.length - 1) == "/") {
    window.mxImageBasePath = window.mxImageBasePath.substring(0, window.mxImageBasePath.length - 1);
  }
  mxClient2.imageBasePath = window.mxImageBasePath;
} else {
  mxClient2.imageBasePath = mxClient2.basePath + "/images";
}
if (typeof window.mxLanguage != "undefined" && window.mxLanguage != null) {
  mxClient2.language = window.mxLanguage;
} else {
  mxClient2.language = mxClient2.IS_IE ? navigator.userLanguage : navigator.language;
}
if (typeof window.mxDefaultLanguage != "undefined" && window.mxDefaultLanguage != null) {
  mxClient2.defaultLanguage = window.mxDefaultLanguage;
} else {
  mxClient2.defaultLanguage = "en";
}
var basePath = mxClient2.basePath;
if (window.location.pathname.includes("/ThreagilePlus/")) {
  basePath = basePath.replace("/src", "/ThreagilePlus/src");
}
if (window.mxLoadStylesheets) {
  mxClient2.link("stylesheet", basePath + "/css/common.css");
}
if (typeof window.mxLanguages != "undefined" && window.mxLanguages != null) {
  mxClient2.languages = window.mxLanguages;
}
if (mxClient2.IS_VML) {
  if (mxClient2.IS_SVG) {
    mxClient2.IS_VML = false;
  } else {
    if (document.namespaces != null) {
      if (document.documentMode == 8) {
        document.namespaces.add(mxClient2.VML_PREFIX, "urn:schemas-microsoft-com:vml", "#default#VML");
        document.namespaces.add(mxClient2.OFFICE_PREFIX, "urn:schemas-microsoft-com:office:office", "#default#VML");
      } else {
        document.namespaces.add(mxClient2.VML_PREFIX, "urn:schemas-microsoft-com:vml");
        document.namespaces.add(mxClient2.OFFICE_PREFIX, "urn:schemas-microsoft-com:office:office");
      }
    }
    if (mxClient2.IS_QUIRKS && document.styleSheets.length >= 30) {
      (function() {
        const node = document.createElement("style");
        node.type = "text/css";
        node.styleSheet.cssText = mxClient2.VML_PREFIX + "\\:*{behavior:url(#default#VML)}" + mxClient2.OFFICE_PREFIX + "\\:*{behavior:url(#default#VML)}";
        document.getElementsByTagName("head")[0].appendChild(node);
      })();
    } else {
      document.createStyleSheet().cssText = mxClient2.VML_PREFIX + "\\:*{behavior:url(#default#VML)}" + mxClient2.OFFICE_PREFIX + "\\:*{behavior:url(#default#VML)}";
    }
    if (window.mxLoadStylesheets) {
      mxClient2.link("stylesheet", mxClient2.basePath + "/css/explorer.css");
    }
  }
}
var mxClient_default = mxClient2;

// js/graph/mxImage.js
var mxImage2 = function(src, width, height) {
  this.src = src;
  this.width = width;
  this.height = height;
};
mxImage2.prototype.src = null;
mxImage2.prototype.width = null;
mxImage2.prototype.height = null;
var mxDivResizer = function(div, container) {
  if (div.nodeName.toLowerCase() == "div") {
    if (container == null) {
      container = window;
    }
    this.div = div;
    const style = getCurrentStyle(div);
    if (style != null) {
      this.resizeWidth = style.width == "auto";
      this.resizeHeight = style.height == "auto";
    }
    mxEvent2.addListener(container, "resize", bind(this, function(evt) {
      if (!this.handlingResize) {
        this.handlingResize = true;
        this.resize();
        this.handlingResize = false;
      }
    }));
    this.resize();
  }
};
mxDivResizer.prototype.div = null;
mxDivResizer.prototype.resizeWidth = true;
mxDivResizer.prototype.resizeHeight = true;
mxDivResizer.prototype.handlingResize = false;
mxDivResizer.prototype.getDocumentWidth = function() {
  return document.body.clientWidth;
};
mxDivResizer.prototype.getDocumentHeight = function() {
  return document.body.clientHeight;
};
mxDivResizer.prototype.resize = function() {
  const w2 = this.getDocumentWidth();
  const h2 = this.getDocumentHeight();
  const l = parseInt(this.div.style.left);
  const t = parseInt(this.div.style.top);
  if (this.resizeWidth) {
    this.div.style.width = Math.max(0, w2 - l) + "px";
  }
  if (this.resizeHeight) {
    this.div.style.height = Math.max(0, h2 - t) + "px";
  }
};
mxDivResizer.prototype.destroy = function() {
};

// js/Helper.js
function createSvgImage(w2, h2, data, coordWidth, coordHeight) {
  var tmp = unescape(encodeURIComponent('<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="' + w2 + 'px" height="' + h2 + 'px" ' + (coordWidth != null && coordHeight != null ? 'viewBox="0 0 ' + coordWidth + " " + coordHeight + '" ' : "") + 'version="1.1">' + data + "</svg>"));
  return new mxImage2("data:image/svg+xml;base64," + (window.btoa ? btoa(tmp) : Base64.encode(tmp, true)), w2, h2);
}

// js/HoverIcons.js
function HoverIcons(graph) {
  this.graph = graph;
  this.currentState = null;
  this.activeArrow = null;
  this.mouseDownPoint = null;
  this.bbox = null;
  this.startTime = null;
  this.prev = null;
  this.updateThread = null;
  this.init();
}
HoverIcons.prototype.arrowSpacing = 2;
HoverIcons.prototype.updateDelay = 500;
HoverIcons.prototype.activationDelay = 140;
HoverIcons.prototype.inactiveOpacity = 15;
HoverIcons.prototype.cssCursor = "copy";
HoverIcons.prototype.checkCollisions = true;
HoverIcons.prototype.arrowFill = "#29b6f2";
HoverIcons.prototype.triangleUp = !mxClient_default.IS_SVG ? new mxImage2(IMAGE_PATH + "/triangle-up.png", 26, 14) : createSvgImage(18, 28, '<path d="m 6 26 L 12 26 L 12 12 L 18 12 L 9 1 L 1 12 L 6 12 z" stroke="#fff" fill="' + HoverIcons.prototype.arrowFill + '"/>');
HoverIcons.prototype.triangleRight = !mxClient_default.IS_SVG ? new mxImage2(IMAGE_PATH + "/triangle-right.png", 14, 26) : createSvgImage(26, 18, '<path d="m 1 6 L 14 6 L 14 1 L 26 9 L 14 18 L 14 12 L 1 12 z" stroke="#fff" fill="' + HoverIcons.prototype.arrowFill + '"/>');
HoverIcons.prototype.triangleDown = !mxClient_default.IS_SVG ? new mxImage2(IMAGE_PATH + "/triangle-down.png", 26, 14) : createSvgImage(18, 26, '<path d="m 6 1 L 6 14 L 1 14 L 9 26 L 18 14 L 12 14 L 12 1 z" stroke="#fff" fill="' + HoverIcons.prototype.arrowFill + '"/>');
HoverIcons.prototype.triangleLeft = !mxClient_default.IS_SVG ? new mxImage2(IMAGE_PATH + "/triangle-left.png", 14, 26) : createSvgImage(28, 18, '<path d="m 1 9 L 12 1 L 12 6 L 26 6 L 26 12 L 12 12 L 12 18 z" stroke="#fff" fill="' + HoverIcons.prototype.arrowFill + '"/>');
HoverIcons.prototype.roundDrop = !mxClient_default.IS_SVG ? new mxImage2(IMAGE_PATH + "/round-drop.png", 26, 26) : createSvgImage(26, 26, '<circle cx="13" cy="13" r="12" stroke="#fff" fill="' + HoverIcons.prototype.arrowFill + '"/>');
HoverIcons.prototype.refreshTarget = new mxImage2(mxClient_default.IS_SVG ? "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjM2cHgiIGhlaWdodD0iMzZweCI+PGVsbGlwc2UgZmlsbD0iIzI5YjZmMiIgY3g9IjEyIiBjeT0iMTIiIHJ4PSIxMiIgcnk9IjEyIi8+PHBhdGggdHJhbnNmb3JtPSJzY2FsZSgwLjgpIHRyYW5zbGF0ZSgyLjQsIDIuNCkiIHN0cm9rZT0iI2ZmZiIgZmlsbD0iI2ZmZiIgZD0iTTEyIDZ2M2w0LTQtNC00djNjLTQuNDIgMC04IDMuNTgtOCA4IDAgMS41Ny40NiAzLjAzIDEuMjQgNC4yNkw2LjcgMTQuOGMtLjQ1LS44My0uNy0xLjc5LS43LTIuOCAwLTMuMzEgMi42OS02IDYtNnptNi43NiAxLjc0TDE3LjMgOS4yYy40NC44NC43IDEuNzkuNyAyLjggMCAzLjMxLTIuNjkgNi02IDZ2LTNsLTQgNCA0IDR2LTNjNC40MiAwIDgtMy41OCA4LTggMC0xLjU3LS40Ni0zLjAzLTEuMjQtNC4yNnoiLz48cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PC9zdmc+Cg==" : IMAGE_PATH + "/refresh.png", 38, 38);
HoverIcons.prototype.tolerance = mxClient_default.IS_TOUCH ? 6 : 0;
HoverIcons.prototype.init = function() {
  this.arrowUp = this.createArrow(this.triangleUp, mxResources2.get("plusTooltip"));
  this.arrowRight = this.createArrow(this.triangleRight, mxResources2.get("plusTooltip"));
  this.arrowDown = this.createArrow(this.triangleDown, mxResources2.get("plusTooltip"));
  this.arrowLeft = this.createArrow(this.triangleLeft, mxResources2.get("plusTooltip"));
  this.elts = [this.arrowUp, this.arrowRight, this.arrowDown, this.arrowLeft];
  this.resetHandler = bind(this, function() {
    this.reset();
  });
  this.repaintHandler = bind(this, function() {
    this.repaint();
  });
  this.graph.selectionModel.addListener(mxEvent2.CHANGE, this.resetHandler);
  this.graph.model.addListener(mxEvent2.CHANGE, this.repaintHandler);
  this.graph.view.addListener(mxEvent2.SCALE_AND_TRANSLATE, this.repaintHandler);
  this.graph.view.addListener(mxEvent2.TRANSLATE, this.repaintHandler);
  this.graph.view.addListener(mxEvent2.SCALE, this.repaintHandler);
  this.graph.view.addListener(mxEvent2.DOWN, this.repaintHandler);
  this.graph.view.addListener(mxEvent2.UP, this.repaintHandler);
  this.graph.addListener(mxEvent2.ROOT, this.repaintHandler);
  this.graph.addListener(mxEvent2.ESCAPE, this.resetHandler);
  mxEvent2.addListener(this.graph.container, "scroll", this.resetHandler);
  this.graph.addListener(mxEvent2.ESCAPE, bind(this, function() {
    this.mouseDownPoint = null;
  }));
  mxEvent2.addListener(this.graph.container, "mouseleave", bind(this, function(evt) {
    if (evt.relatedTarget != null && mxEvent2.getSource(evt) == this.graph.container) {
      this.setDisplay("none");
    }
  }));
  this.graph.addListener(mxEvent2.START_EDITING, bind(this, function(evt) {
    this.reset();
  }));
  const graphClick = this.graph.click;
  this.graph.click = bind(this, function(me) {
    graphClick.apply(this.graph, arguments);
    if (this.currentState != null && !this.graph.isCellSelected(this.currentState.cell) && mxEvent2.isTouchEvent(me.getEvent()) && !this.graph.model.isVertex(me.getCell())) {
      this.reset();
    }
  });
  let connectionHandlerActive = false;
  this.graph.addMouseListener({
    mouseDown: bind(this, function(sender, me) {
      connectionHandlerActive = false;
      const evt = me.getEvent();
      if (this.isResetEvent(evt)) {
        this.reset();
      } else if (!this.isActive()) {
        const state2 = this.getState(me.getState());
        if (state2 != null || !mxEvent2.isTouchEvent(evt)) {
          this.update(state2);
        }
      }
      this.setDisplay("none");
    }),
    mouseMove: bind(this, function(sender, me) {
      const evt = me.getEvent();
      if (this.isResetEvent(evt)) {
        this.reset();
      } else if (!this.graph.isMouseDown && !mxEvent2.isTouchEvent(evt)) {
        this.update(this.getState(me.getState()), me.getGraphX(), me.getGraphY());
      }
      if (this.graph.connectionHandler != null && this.graph.connectionHandler.shape != null) {
        connectionHandlerActive = true;
      }
    }),
    mouseUp: bind(this, function(sender, me) {
      const evt = me.getEvent();
      const pt = convertPoint(this.graph.container, mxEvent2.getClientX(evt), mxEvent2.getClientY(evt));
      if (this.isResetEvent(evt)) {
        this.reset();
      } else if (this.isActive() && !connectionHandlerActive && this.mouseDownPoint != null) {
        this.click(this.currentState, this.getDirection(), me);
      } else if (this.isActive()) {
        if (this.graph.getSelectionCount() != 1 || !this.graph.model.isEdge(this.graph.getSelectionCell())) {
          this.update(this.getState(this.graph.view.getState(this.graph.getCellAt(me.getGraphX(), me.getGraphY()))));
        } else {
          this.reset();
        }
      } else if (mxEvent2.isTouchEvent(evt) || this.bbox != null && contains(this.bbox, me.getGraphX(), me.getGraphY())) {
        this.setDisplay("");
        this.repaint();
      } else if (!mxEvent2.isTouchEvent(evt)) {
        this.reset();
      }
      connectionHandlerActive = false;
      this.resetActiveArrow();
    })
  });
};
HoverIcons.prototype.isResetEvent = function(evt, allowShift) {
  return mxEvent2.isAltDown(evt) || this.activeArrow == null && mxEvent2.isShiftDown(evt) || mxEvent2.isPopupTrigger(evt) && !this.graph.isCloneEvent(evt);
};
HoverIcons.prototype.createArrow = function(img, tooltip) {
  let arrow = null;
  if (mxClient_default.IS_IE && !mxClient_default.IS_SVG) {
    if (mxClient_default.IS_IE6 && document.compatMode != "CSS1Compat") {
      arrow = document.createElement(mxClient_default.VML_PREFIX + ":image");
      arrow.setAttribute("src", img.src);
      arrow.style.borderStyle = "none";
    } else {
      arrow = document.createElement("div");
      arrow.style.backgroundImage = "url(" + img.src + ")";
      arrow.style.backgroundPosition = "center";
      arrow.style.backgroundRepeat = "no-repeat";
    }
    arrow.style.width = img.width + 4 + "px";
    arrow.style.height = img.height + 4 + "px";
    arrow.style.display = mxClient_default.IS_QUIRKS ? "inline" : "inline-block";
  } else {
    arrow = createImage(img.src);
    arrow.style.width = img.width + "px";
    arrow.style.height = img.height + "px";
    arrow.style.padding = this.tolerance + "px";
  }
  if (tooltip != null) {
    arrow.setAttribute("title", tooltip);
  }
  arrow.style.position = "absolute";
  arrow.style.cursor = this.cssCursor;
  mxEvent2.addGestureListeners(arrow, bind(this, function(evt) {
    if (this.currentState != null && !this.isResetEvent(evt)) {
      this.mouseDownPoint = convertPoint(this.graph.container, mxEvent2.getClientX(evt), mxEvent2.getClientY(evt));
      this.drag(evt, this.mouseDownPoint.x, this.mouseDownPoint.y);
      this.activeArrow = arrow;
      this.setDisplay("none");
      mxEvent2.consume(evt);
    }
  }));
  mxEvent2.redirectMouseEvents(arrow, this.graph, this.currentState);
  mxEvent2.addListener(arrow, "mouseenter", bind(this, function(evt) {
    if (mxEvent2.isMouseEvent(evt)) {
      if (this.activeArrow != null && this.activeArrow != arrow) {
        setOpacity(this.activeArrow, this.inactiveOpacity);
      }
      this.graph.connectionHandler.constraintHandler.reset();
      setOpacity(arrow, 100);
      this.activeArrow = arrow;
    }
  }));
  mxEvent2.addListener(arrow, "mouseleave", bind(this, function(evt) {
    if (!this.graph.isMouseDown) {
      this.resetActiveArrow();
    }
  }));
  return arrow;
};
HoverIcons.prototype.resetActiveArrow = function() {
  if (this.activeArrow != null) {
    setOpacity(this.activeArrow, this.inactiveOpacity);
    this.activeArrow = null;
  }
};
HoverIcons.prototype.getDirection = function() {
  let dir = mxConstants2.DIRECTION_EAST;
  if (this.activeArrow == this.arrowUp) {
    dir = mxConstants2.DIRECTION_NORTH;
  } else if (this.activeArrow == this.arrowDown) {
    dir = mxConstants2.DIRECTION_SOUTH;
  } else if (this.activeArrow == this.arrowLeft) {
    dir = mxConstants2.DIRECTION_WEST;
  }
  return dir;
};
HoverIcons.prototype.visitNodes = function(visitor) {
  for (let i = 0; i < this.elts.length; i++) {
    if (this.elts[i] != null) {
      visitor(this.elts[i]);
    }
  }
};
HoverIcons.prototype.removeNodes = function() {
  this.visitNodes(function(elt) {
    if (elt.parentNode != null) {
      elt.parentNode.removeChild(elt);
    }
  });
};
HoverIcons.prototype.setDisplay = function(display) {
  this.visitNodes(function(elt) {
    elt.style.display = display;
  });
};
HoverIcons.prototype.isActive = function() {
  return this.activeArrow != null && this.currentState != null;
};
HoverIcons.prototype.drag = function(evt, x, y) {
  this.graph.popupMenuHandler.hideMenu();
  this.graph.stopEditing(false);
  if (this.currentState != null) {
    this.graph.connectionHandler.start(this.currentState, x, y);
    this.graph.isMouseTrigger = mxEvent2.isMouseEvent(evt);
    this.graph.isMouseDown = true;
    const handler = this.graph.selectionCellsHandler.getHandler(this.currentState.cell);
    if (handler != null) {
      handler.setHandlesVisible(false);
    }
    const es = this.graph.connectionHandler.edgeState;
    if (evt != null && mxEvent2.isShiftDown(evt) && mxEvent2.isControlDown(evt) && es != null && getValue(es.style, mxConstants2.STYLE_EDGE, null) === "orthogonalEdgeStyle") {
      const direction = this.getDirection();
      es.cell.style = setStyle(es.cell.style, "sourcePortConstraint", direction);
      es.style["sourcePortConstraint"] = direction;
    }
  }
};
HoverIcons.prototype.getStateAt = function(state2, x, y) {
  return this.graph.view.getState(this.graph.getCellAt(x, y));
};
HoverIcons.prototype.click = function(state2, dir, me) {
  const evt = me.getEvent();
  const x = me.getGraphX();
  const y = me.getGraphY();
  const tmp = this.getStateAt(state2, x, y);
  if (tmp != null && this.graph.model.isEdge(tmp.cell) && !this.graph.isCloneEvent(evt) && (tmp.getVisibleTerminalState(true) == state2 || tmp.getVisibleTerminalState(false) == state2)) {
    this.graph.setSelectionCell(tmp.cell);
    this.reset();
  } else if (state2 != null) {
    this.execute(state2, dir, me);
  }
  me.consume();
};
HoverIcons.prototype.execute = function(state2, dir, me) {
  const evt = me.getEvent();
  this.graph.selectCellsForConnectVertex(this.graph.connectVertex(state2.cell, dir, this.graph.defaultEdgeLength, evt, this.graph.isCloneEvent(evt), this.graph.isCloneEvent(evt)), evt, this);
};
HoverIcons.prototype.reset = function(clearTimeout2) {
  clearTimeout2 = clearTimeout2 == null ? true : clearTimeout2;
  if (clearTimeout2 && this.updateThread != null) {
    window.clearTimeout(this.updateThread);
  }
  this.mouseDownPoint = null;
  this.currentState = null;
  this.activeArrow = null;
  this.removeNodes();
  this.bbox = null;
};
HoverIcons.prototype.repaint = function() {
  this.bbox = null;
  if (this.currentState != null) {
    this.currentState = this.getState(this.currentState);
    if (this.currentState != null && this.graph.model.isVertex(this.currentState.cell) && this.graph.isCellConnectable(this.currentState.cell)) {
      let bds = mxRectangle.fromRectangle(this.currentState);
      if (this.currentState.shape != null && this.currentState.shape.boundingBox != null) {
        bds = mxRectangle.fromRectangle(this.currentState.shape.boundingBox);
      }
      bds.grow(this.graph.tolerance);
      bds.grow(this.arrowSpacing);
      let handler = this.graph.selectionCellsHandler.getHandler(this.currentState.cell);
      if (this.graph.isTableRow(this.currentState.cell)) {
        handler = this.graph.selectionCellsHandler.getHandler(this.graph.model.getParent(this.currentState.cell));
      }
      let rotationBbox = null;
      if (handler != null) {
        bds.x -= handler.horizontalOffset / 2;
        bds.y -= handler.verticalOffset / 2;
        bds.width += handler.horizontalOffset;
        bds.height += handler.verticalOffset;
        if (handler.rotationShape != null && handler.rotationShape.node != null && handler.rotationShape.node.style.visibility != "hidden" && handler.rotationShape.node.style.display != "none" && handler.rotationShape.boundingBox != null) {
          rotationBbox = handler.rotationShape.boundingBox;
        }
      }
      const positionArrow = bind(this, function(arrow, x, y) {
        if (rotationBbox != null) {
          const bbox = new mxRectangle(x, y, arrow.clientWidth, arrow.clientHeight);
          if (intersects(bbox, rotationBbox)) {
            if (arrow == this.arrowUp) {
              y -= bbox.y + bbox.height - rotationBbox.y;
            } else if (arrow == this.arrowRight) {
              x += rotationBbox.x + rotationBbox.width - bbox.x;
            } else if (arrow == this.arrowDown) {
              y += rotationBbox.y + rotationBbox.height - bbox.y;
            } else if (arrow == this.arrowLeft) {
              x -= bbox.x + bbox.width - rotationBbox.x;
            }
          }
        }
        arrow.style.left = x + "px";
        arrow.style.top = y + "px";
        setOpacity(arrow, this.inactiveOpacity);
      });
      positionArrow(this.arrowUp, Math.round(this.currentState.getCenterX() - this.triangleUp.width / 2 - this.tolerance), Math.round(bds.y - this.triangleUp.height - this.tolerance));
      positionArrow(this.arrowRight, Math.round(bds.x + bds.width - this.tolerance), Math.round(this.currentState.getCenterY() - this.triangleRight.height / 2 - this.tolerance));
      positionArrow(this.arrowDown, parseInt(this.arrowUp.style.left), Math.round(bds.y + bds.height - this.tolerance));
      positionArrow(this.arrowLeft, Math.round(bds.x - this.triangleLeft.width - this.tolerance), parseInt(this.arrowRight.style.top));
      if (this.checkCollisions) {
        let right = this.graph.getCellAt(bds.x + bds.width + this.triangleRight.width / 2, this.currentState.getCenterY());
        let left = this.graph.getCellAt(bds.x - this.triangleLeft.width / 2, this.currentState.getCenterY());
        let top = this.graph.getCellAt(this.currentState.getCenterX(), bds.y - this.triangleUp.height / 2);
        let bottom = this.graph.getCellAt(this.currentState.getCenterX(), bds.y + bds.height + this.triangleDown.height / 2);
        if (right != null && right == left && left == top && top == bottom) {
          right = null;
          left = null;
          top = null;
          bottom = null;
        }
        const currentGeo = this.graph.getCellGeometry(this.currentState.cell);
        const checkCollision = bind(this, function(cell2, arrow) {
          const geo = this.graph.model.isVertex(cell2) && this.graph.getCellGeometry(cell2);
          if (cell2 != null && !this.graph.model.isAncestor(cell2, this.currentState.cell) && !this.graph.isSwimlane(cell2) && (geo == null || currentGeo == null || geo.height < 3 * currentGeo.height && geo.width < 3 * currentGeo.width)) {
            arrow.style.visibility = "hidden";
          } else {
            arrow.style.visibility = "visible";
          }
        });
        checkCollision(right, this.arrowRight);
        checkCollision(left, this.arrowLeft);
        checkCollision(top, this.arrowUp);
        checkCollision(bottom, this.arrowDown);
      } else {
        this.arrowLeft.style.visibility = "visible";
        this.arrowRight.style.visibility = "visible";
        this.arrowUp.style.visibility = "visible";
        this.arrowDown.style.visibility = "visible";
      }
      if (this.graph.tooltipHandler.isEnabled()) {
        this.arrowLeft.setAttribute("title", mxResources2.get("plusTooltip"));
        this.arrowRight.setAttribute("title", mxResources2.get("plusTooltip"));
        this.arrowUp.setAttribute("title", mxResources2.get("plusTooltip"));
        this.arrowDown.setAttribute("title", mxResources2.get("plusTooltip"));
      } else {
        this.arrowLeft.removeAttribute("title");
        this.arrowRight.removeAttribute("title");
        this.arrowUp.removeAttribute("title");
        this.arrowDown.removeAttribute("title");
      }
    } else {
      this.reset();
    }
    if (this.currentState != null) {
      this.bbox = this.computeBoundingBox();
      if (this.bbox != null) {
        this.bbox.grow(10);
      }
    }
  }
};
HoverIcons.prototype.computeBoundingBox = function() {
  let bbox = !this.graph.model.isEdge(this.currentState.cell) ? mxRectangle.fromRectangle(this.currentState) : null;
  this.visitNodes(function(elt) {
    if (elt.parentNode != null) {
      const tmp = new mxRectangle(elt.offsetLeft, elt.offsetTop, elt.offsetWidth, elt.offsetHeight);
      if (bbox == null) {
        bbox = tmp;
      } else {
        bbox.add(tmp);
      }
    }
  });
  return bbox;
};
HoverIcons.prototype.getState = function(state2) {
  if (state2 != null) {
    let cell2 = state2.cell;
    if (!this.graph.getModel().contains(cell2)) {
      state2 = null;
    } else {
      if (this.graph.getModel().isVertex(cell2) && !this.graph.isCellConnectable(cell2)) {
        const parent2 = this.graph.getModel().getParent(cell2);
        if (this.graph.getModel().isVertex(parent2) && this.graph.isCellConnectable(parent2)) {
          cell2 = parent2;
        }
      }
      if (this.graph.isCellLocked(cell2) || this.graph.model.isEdge(cell2)) {
        cell2 = null;
      }
      state2 = this.graph.view.getState(cell2);
      if (state2 != null && state2.style == null) {
        state2 = null;
      }
    }
  }
  return state2;
};
HoverIcons.prototype.update = function(state2, x, y) {
  if (!this.graph.connectionArrowsEnabled || state2 != null && getValue(state2.style, "allowArrows", "1") == "0") {
    this.reset();
  } else {
    if (state2 != null && state2.cell.geometry != null && state2.cell.geometry.relative && this.graph.model.isEdge(state2.cell.parent)) {
      state2 = null;
    }
    let timeOnTarget = null;
    if (this.prev != state2 || this.isActive()) {
      this.startTime = new Date().getTime();
      this.prev = state2;
      timeOnTarget = 0;
      if (this.updateThread != null) {
        window.clearTimeout(this.updateThread);
      }
      if (state2 != null) {
        this.updateThread = window.setTimeout(bind(this, function() {
          if (!this.isActive() && !this.graph.isMouseDown && !this.graph.panningHandler.isActive()) {
            this.prev = state2;
            this.update(state2, x, y);
          }
        }), this.updateDelay + 10);
      }
    } else if (this.startTime != null) {
      timeOnTarget = new Date().getTime() - this.startTime;
    }
    this.setDisplay("");
    if (this.currentState != null && this.currentState != state2 && timeOnTarget < this.activationDelay && this.bbox != null && !contains(this.bbox, x, y)) {
      this.reset(false);
    } else if (this.currentState != null || timeOnTarget > this.activationDelay) {
      if (this.currentState != state2 && (timeOnTarget > this.updateDelay && state2 != null || this.bbox == null || x == null || y == null || !contains(this.bbox, x, y))) {
        if (state2 != null && this.graph.isEnabled()) {
          this.removeNodes();
          this.setCurrentState(state2);
          this.repaint();
          if (this.graph.connectionHandler.constraintHandler.currentFocus != state2) {
            this.graph.connectionHandler.constraintHandler.reset();
          }
        } else {
          this.reset();
        }
      }
    }
  }
};
HoverIcons.prototype.setCurrentState = function(state2) {
  if (state2.style["portConstraint"] != "eastwest") {
    this.graph.container.appendChild(this.arrowUp);
    this.graph.container.appendChild(this.arrowDown);
  }
  this.graph.container.appendChild(this.arrowRight);
  this.graph.container.appendChild(this.arrowLeft);
  this.currentState = state2;
};

// js/graph/mxConnectionConstraint.js
var mxConnectionConstraint2 = function(point, perimeter, name, dx, dy) {
  this.point = point;
  this.perimeter = perimeter != null ? perimeter : true;
  this.name = name;
  this.dx = dx != null ? dx : 0;
  this.dy = dy != null ? dy : 0;
};
mxConnectionConstraint2.prototype.point = null;
mxConnectionConstraint2.prototype.perimeter = null;
mxConnectionConstraint2.prototype.name = null;
mxConnectionConstraint2.prototype.dx = null;
mxConnectionConstraint2.prototype.dy = null;

// js/graph/mxRectangleShape.js
var mxRectangleShape = function(bounds, fill, stroke, strokewidth) {
  mxShape.call(this);
  this.bounds = bounds;
  this.fill = fill;
  this.stroke = stroke;
  this.strokewidth = strokewidth != null ? strokewidth : 1;
};
extend(mxRectangleShape, mxShape);
mxRectangleShape.prototype.isHtmlAllowed = function() {
  let events = true;
  if (this.style != null) {
    events = getValue(this.style, mxConstants2.STYLE_POINTER_EVENTS, "1") === "1";
  }
  return !this.isRounded && !this.glass && this.rotation === 0 && (events || this.fill != null && this.fill !== mxConstants2.NONE);
};
mxRectangleShape.prototype.paintBackground = function(c, x, y, w2, h2) {
  let events = true;
  if (this.style != null) {
    events = getValue(this.style, mxConstants2.STYLE_POINTER_EVENTS, "1") === "1";
  }
  if (events || this.fill != null && this.fill !== mxConstants2.NONE || this.stroke != null && this.stroke !== mxConstants2.NONE) {
    if (!events && (this.fill == null || this.fill === mxConstants2.NONE)) {
      c.pointerEvents = false;
    }
    if (this.isRounded) {
      let r = 0;
      if (getValue(this.style, mxConstants2.STYLE_ABSOLUTE_ARCSIZE, 0) === "1") {
        r = Math.min(w2 / 2, Math.min(h2 / 2, getValue(this.style, mxConstants2.STYLE_ARCSIZE, mxConstants2.LINE_ARCSIZE) / 2));
      } else {
        let f = getValue(this.style, mxConstants2.STYLE_ARCSIZE, mxConstants2.RECTANGLE_ROUNDING_FACTOR * 100) / 100;
        r = Math.min(w2 * f, h2 * f);
      }
      c.roundrect(x, y, w2, h2, r, r);
    } else {
      c.rect(x, y, w2, h2);
    }
    c.fillAndStroke();
  }
};
mxRectangleShape.prototype.isRoundable = function(c, x, y, w2, h2) {
  return true;
};
mxRectangleShape.prototype.paintForeground = function(c, x, y, w2, h2) {
  if (this.glass && !this.outline && this.fill != null && this.fill !== mxConstants2.NONE) {
    this.paintGlassEffect(c, x, y, w2, h2, this.getArcSize(w2 + this.strokewidth, h2 + this.strokewidth));
  }
};

// js/graph/mxImageShape.js
var mxImageShape = function(bounds, image, fill, stroke, strokewidth) {
  mxShape.call(this);
  this.bounds = bounds;
  this.image = image;
  this.fill = fill;
  this.stroke = stroke;
  this.strokewidth = strokewidth != null ? strokewidth : 1;
  this.shadow = false;
};
extend(mxImageShape, mxRectangleShape);
mxImageShape.prototype.preserveImageAspect = true;
mxImageShape.prototype.getSvgScreenOffset = function() {
  return 0;
};
mxImageShape.prototype.apply = function(state2) {
  mxShape.prototype.apply.apply(this, arguments);
  this.fill = null;
  this.stroke = null;
  this.gradient = null;
  if (this.style != null) {
    this.preserveImageAspect = getNumber(this.style, mxConstants2.STYLE_IMAGE_ASPECT, 1) === 1;
    this.flipH = this.flipH || getValue(this.style, "imageFlipH", 0) === 1;
    this.flipV = this.flipV || getValue(this.style, "imageFlipV", 0) === 1;
  }
};
mxImageShape.prototype.isHtmlAllowed = function() {
  return !this.preserveImageAspect;
};
mxImageShape.prototype.createHtml = function() {
  const node = document.createElement("div");
  node.style.position = "absolute";
  return node;
};
mxImageShape.prototype.isRoundable = function(c, x, y, w2, h2) {
  return false;
};
mxImageShape.prototype.paintVertexShape = function(c, x, y, w2, h2) {
  if (this.image != null) {
    const fill = getValue(this.style, mxConstants2.STYLE_IMAGE_BACKGROUND, null);
    let stroke = getValue(this.style, mxConstants2.STYLE_IMAGE_BORDER, null);
    if (fill != null) {
      c.setFillColor(fill);
      c.setStrokeColor(stroke);
      c.rect(x, y, w2, h2);
      c.fillAndStroke();
    }
    c.image(x, y, w2, h2, this.image, this.preserveImageAspect, false, false);
    stroke = getValue(this.style, mxConstants2.STYLE_IMAGE_BORDER, null);
    if (stroke != null) {
      c.setShadow(false);
      c.setStrokeColor(stroke);
      c.rect(x, y, w2, h2);
      c.stroke();
    }
  } else {
    mxRectangleShape.prototype.paintBackground.apply(this, arguments);
  }
};
mxImageShape.prototype.redrawHtmlShape = function() {
  this.node.style.left = Math.round(this.bounds.x) + "px";
  this.node.style.top = Math.round(this.bounds.y) + "px";
  this.node.style.width = Math.max(0, Math.round(this.bounds.width)) + "px";
  this.node.style.height = Math.max(0, Math.round(this.bounds.height)) + "px";
  this.node.innerHTML = "";
  if (this.image != null) {
    const fill = getValue(this.style, mxConstants2.STYLE_IMAGE_BACKGROUND, "");
    const stroke = getValue(this.style, mxConstants2.STYLE_IMAGE_BORDER, "");
    this.node.style.backgroundColor = fill;
    this.node.style.borderColor = stroke;
    const useVml = mxClient_default.IS_IE6 || (document.documentMode == null || document.documentMode <= 8) && this.rotation !== 0;
    const img = document.createElement(useVml ? `${mxClient_default.VML_PREFIX}:image` : "img");
    img.setAttribute("border", "0");
    img.style.position = "absolute";
    img.src = this.image;
    let filter = this.opacity < 100 ? `alpha(opacity=${this.opacity})` : "";
    this.node.style.filter = filter;
    if (this.flipH && this.flipV) {
      filter += "progid:DXImageTransform.Microsoft.BasicImage(rotation=2)";
    } else if (this.flipH) {
      filter += "progid:DXImageTransform.Microsoft.BasicImage(mirror=1)";
    } else if (this.flipV) {
      filter += "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";
    }
    if (img.style.filter !== filter) {
      img.style.filter = filter;
    }
    if (img.nodeName === "image") {
      img.style.rotation = this.rotation;
    } else if (this.rotation !== 0) {
      setPrefixedStyle(img.style, "transform", `rotate(${this.rotation}deg)`);
    } else {
      setPrefixedStyle(img.style, "transform", "");
    }
    img.style.width = this.node.style.width;
    img.style.height = this.node.style.height;
    this.node.style.backgroundImage = "";
    this.node.appendChild(img);
  } else {
    this.setTransparentBackgroundImage(this.node);
  }
};

// js/graph/mxConstraintHandler.js
function mxConstraintHandler(graph) {
  this.graph = graph;
  this.resetHandler = bind(this, function(sender, evt) {
    if (this.currentFocus != null && this.graph.view.getState(this.currentFocus.cell) == null) {
      this.reset();
    } else {
      this.redraw();
    }
  });
  this.graph.model.addListener(mxEvent2.CHANGE, this.resetHandler);
  this.graph.view.addListener(mxEvent2.SCALE_AND_TRANSLATE, this.resetHandler);
  this.graph.view.addListener(mxEvent2.TRANSLATE, this.resetHandler);
  this.graph.view.addListener(mxEvent2.SCALE, this.resetHandler);
  this.graph.addListener(mxEvent2.ROOT, this.resetHandler);
}
mxConstraintHandler.prototype.pointImage = new mxImage2(mxClient_default.imageBasePath + "/point.gif", 5, 5);
mxConstraintHandler.prototype.graph = null;
mxConstraintHandler.prototype.enabled = true;
mxConstraintHandler.prototype.highlightColor = mxConstants2.DEFAULT_VALID_COLOR;
mxConstraintHandler.prototype.isEnabled = function() {
  return this.enabled;
};
mxConstraintHandler.prototype.setEnabled = function(enabled) {
  this.enabled = enabled;
};
mxConstraintHandler.prototype.reset = function() {
  if (this.focusIcons != null) {
    for (let i = 0; i < this.focusIcons.length; i++) {
      this.focusIcons[i].destroy();
    }
    this.focusIcons = null;
  }
  if (this.focusHighlight != null) {
    this.focusHighlight.destroy();
    this.focusHighlight = null;
  }
  this.currentConstraint = null;
  this.currentFocusArea = null;
  this.currentPoint = null;
  this.currentFocus = null;
  this.focusPoints = null;
};
mxConstraintHandler.prototype.getTolerance = function(me) {
  return this.graph.getTolerance();
};
mxConstraintHandler.prototype.getImageForConstraint = function(state2, constraint, point) {
  return this.pointImage;
};
mxConstraintHandler.prototype.isEventIgnored = function(me, source) {
  return false;
};
mxConstraintHandler.prototype.isStateIgnored = function(state2, source) {
  return false;
};
mxConstraintHandler.prototype.destroyIcons = function() {
  if (this.focusIcons != null) {
    for (let i = 0; i < this.focusIcons.length; i++) {
      this.focusIcons[i].destroy();
    }
    this.focusIcons = null;
    this.focusPoints = null;
  }
};
mxConstraintHandler.prototype.destroyFocusHighlight = function() {
  if (this.focusHighlight != null) {
    this.focusHighlight.destroy();
    this.focusHighlight = null;
  }
};
mxConstraintHandler.prototype.isKeepFocusEvent = function(me) {
  return mxEvent2.isShiftDown(me.getEvent());
};
mxConstraintHandler.prototype.getCellForEvent = function(me, point) {
  let cell2 = me.getCell();
  if (cell2 == null && point != null && (me.getGraphX() != point.x || me.getGraphY() != point.y)) {
    cell2 = this.graph.getCellAt(point.x, point.y);
  }
  if (cell2 != null && !this.graph.isCellConnectable(cell2)) {
    const parent2 = this.graph.getModel().getParent(cell2);
    if (this.graph.getModel().isVertex(parent2) && this.graph.isCellConnectable(parent2)) {
      cell2 = parent2;
    }
  }
  return this.graph.isCellLocked(cell2) ? null : cell2;
};
mxConstraintHandler.prototype.update = function(me, source, existingEdge, point) {
  if (this.isEnabled() && !this.isEventIgnored(me)) {
    if (this.mouseleaveHandler == null && this.graph.container != null) {
      this.mouseleaveHandler = bind(this, function() {
        this.reset();
      });
      mxEvent2.addListener(this.graph.container, "mouseleave", this.resetHandler);
    }
    const tol = this.getTolerance(me);
    const x = point != null ? point.x : me.getGraphX();
    const y = point != null ? point.y : me.getGraphY();
    const grid = new mxRectangle(x - tol, y - tol, 2 * tol, 2 * tol);
    const mouse = new mxRectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol);
    const state2 = this.graph.view.getState(this.getCellForEvent(me, point));
    if (!this.isKeepFocusEvent(me) && (this.currentFocusArea == null || this.currentFocus == null || state2 != null || !this.graph.getModel().isVertex(this.currentFocus.cell) || !intersects(this.currentFocusArea, mouse)) && state2 != this.currentFocus) {
      this.currentFocusArea = null;
      this.currentFocus = null;
      this.setFocus(me, state2, source);
    }
    this.currentConstraint = null;
    this.currentPoint = null;
    let minDistSq = null;
    if (this.focusIcons != null && this.constraints != null && (state2 == null || this.currentFocus == state2)) {
      const cx = mouse.getCenterX();
      const cy = mouse.getCenterY();
      for (let i = 0; i < this.focusIcons.length; i++) {
        const dx = cx - this.focusIcons[i].bounds.getCenterX();
        const dy = cy - this.focusIcons[i].bounds.getCenterY();
        let tmp = dx * dx + dy * dy;
        if ((this.intersects(this.focusIcons[i], mouse, source, existingEdge) || point != null && this.intersects(this.focusIcons[i], grid, source, existingEdge)) && (minDistSq == null || tmp < minDistSq)) {
          this.currentConstraint = this.constraints[i];
          this.currentPoint = this.focusPoints[i];
          minDistSq = tmp;
          let tmpRect = this.focusIcons[i].bounds.clone();
          tmpRect.grow(mxConstants2.HIGHLIGHT_SIZE + 1);
          tmpRect.width -= 1;
          tmpRect.height -= 1;
          if (this.focusHighlight == null) {
            const hl = this.createHighlightShape();
            hl.dialect = this.graph.dialect == mxConstants2.DIALECT_SVG ? mxConstants2.DIALECT_SVG : mxConstants2.DIALECT_VML;
            hl.pointerEvents = false;
            hl.init(this.graph.getView().getOverlayPane());
            this.focusHighlight = hl;
            const getState = bind(this, function() {
              return this.currentFocus != null ? this.currentFocus : state2;
            });
            mxEvent2.redirectMouseEvents(hl.node, this.graph, getState);
          }
          this.focusHighlight.bounds = tmpRect;
          this.focusHighlight.redraw();
        }
      }
    }
    if (this.currentConstraint == null) {
      this.destroyFocusHighlight();
    }
  } else {
    this.currentConstraint = null;
    this.currentFocus = null;
    this.currentPoint = null;
  }
};
mxConstraintHandler.prototype.redraw = function() {
  if (this.currentFocus != null && this.constraints != null && this.focusIcons != null) {
    const state2 = this.graph.view.getState(this.currentFocus.cell);
    this.currentFocus = state2;
    this.currentFocusArea = new mxRectangle(state2.x, state2.y, state2.width, state2.height);
    for (let i = 0; i < this.constraints.length; i++) {
      const cp = this.graph.getConnectionPoint(state2, this.constraints[i]);
      const img = this.getImageForConstraint(state2, this.constraints[i], cp);
      const bounds = new mxRectangle(Math.round(cp.x - img.width / 2), Math.round(cp.y - img.height / 2), img.width, img.height);
      this.focusIcons[i].bounds = bounds;
      this.focusIcons[i].redraw();
      this.currentFocusArea.add(this.focusIcons[i].bounds);
      this.focusPoints[i] = cp;
    }
  }
};
mxConstraintHandler.prototype.setFocus = function(me, state2, source) {
  this.constraints = state2 != null && !this.isStateIgnored(state2, source) && this.graph.isCellConnectable(state2.cell) ? this.isEnabled() ? this.graph.getAllConnectionConstraints(state2, source) || [] : [] : null;
  if (this.constraints != null) {
    this.currentFocus = state2;
    this.currentFocusArea = new mxRectangle(state2.x, state2.y, state2.width, state2.height);
    if (this.focusIcons != null) {
      for (let i = 0; i < this.focusIcons.length; i++) {
        this.focusIcons[i].destroy();
      }
      this.focusIcons = null;
      this.focusPoints = null;
    }
    this.focusPoints = [];
    this.focusIcons = [];
    for (let i = 0; i < this.constraints.length; i++) {
      const cp = this.graph.getConnectionPoint(state2, this.constraints[i]);
      const img = this.getImageForConstraint(state2, this.constraints[i], cp);
      const src = img.src;
      const bounds = new mxRectangle(Math.round(cp.x - img.width / 2), Math.round(cp.y - img.height / 2), img.width, img.height);
      const icon = new mxImageShape(bounds, src);
      icon.dialect = this.graph.dialect != mxConstants2.DIALECT_SVG ? mxConstants2.DIALECT_MIXEDHTML : mxConstants2.DIALECT_SVG;
      icon.preserveImageAspect = false;
      icon.init(this.graph.getView().getDecoratorPane());
      if (mxClient_default.IS_QUIRKS || document.documentMode == 8) {
        mxEvent2.addListener(icon.node, "dragstart", function(evt) {
          mxEvent2.consume(evt);
          return false;
        });
      }
      if (icon.node.previousSibling != null) {
        icon.node.parentNode.insertBefore(icon.node, icon.node.parentNode.firstChild);
      }
      const getState = bind(this, function() {
        return this.currentFocus != null ? this.currentFocus : state2;
      });
      icon.redraw();
      mxEvent2.redirectMouseEvents(icon.node, this.graph, getState);
      this.currentFocusArea.add(icon.bounds);
      this.focusIcons.push(icon);
      this.focusPoints.push(cp);
    }
    this.currentFocusArea.grow(this.getTolerance(me));
  } else {
    this.destroyIcons();
    this.destroyFocusHighlight();
  }
};
mxConstraintHandler.prototype.createHighlightShape = function() {
  const hl = new mxRectangleShape(null, this.highlightColor, this.highlightColor, mxConstants2.HIGHLIGHT_STROKEWIDTH);
  hl.opacity = mxConstants2.HIGHLIGHT_OPACITY;
  return hl;
};
mxConstraintHandler.prototype.intersects = function(icon, mouse, source, existingEdge) {
  return intersects(icon.bounds, mouse);
};
mxConstraintHandler.prototype.destroy = function() {
  this.reset();
  if (this.resetHandler != null) {
    this.graph.model.removeListener(this.resetHandler);
    this.graph.view.removeListener(this.resetHandler);
    this.graph.removeListener(this.resetHandler);
    this.resetHandler = null;
  }
  if (this.mouseleaveHandler != null && this.graph.container != null) {
    mxEvent2.removeListener(this.graph.container, "mouseleave", this.mouseleaveHandler);
    this.mouseleaveHandler = null;
  }
};

// js/graph/mxCellMarker.js
var mxCellMarker = function mxCellMarker2(graph, validColor, invalidColor, hotspot) {
  mxEventSource.call(this);
  if (graph != null) {
    this.graph = graph;
    this.validColor = validColor != null ? validColor : mxConstants2.DEFAULT_VALID_COLOR;
    this.invalidColor = invalidColor != null ? invalidColor : mxConstants2.DEFAULT_INVALID_COLOR;
    this.hotspot = hotspot != null ? hotspot : mxConstants2.DEFAULT_HOTSPOT;
    this.highlight = new mxCellHighlight2(graph);
  }
};
extend(mxCellMarker, mxEventSource);
mxCellMarker.prototype.graph = null;
mxCellMarker.prototype.enabled = true;
mxCellMarker.prototype.hotspot = mxConstants2.DEFAULT_HOTSPOT;
mxCellMarker.prototype.hotspotEnabled = false;
mxCellMarker.prototype.validColor = null;
mxCellMarker.prototype.invalidColor = null;
mxCellMarker.prototype.currentColor = null;
mxCellMarker.prototype.validState = null;
mxCellMarker.prototype.markedState = null;
mxCellMarker.prototype.setEnabled = function(enabled) {
  this.enabled = enabled;
};
mxCellMarker.prototype.isEnabled = function() {
  return this.enabled;
};
mxCellMarker.prototype.setHotspot = function(hotspot) {
  this.hotspot = hotspot;
};
mxCellMarker.prototype.getHotspot = function() {
  return this.hotspot;
};
mxCellMarker.prototype.setHotspotEnabled = function(enabled) {
  this.hotspotEnabled = enabled;
};
mxCellMarker.prototype.isHotspotEnabled = function() {
  return this.hotspotEnabled;
};
mxCellMarker.prototype.hasValidState = function() {
  return this.validState != null;
};
mxCellMarker.prototype.getValidState = function() {
  return this.validState;
};
mxCellMarker.prototype.getMarkedState = function() {
  return this.markedState;
};
mxCellMarker.prototype.reset = function() {
  this.validState = null;
  if (this.markedState != null) {
    this.markedState = null;
    this.unmark();
  }
};
mxCellMarker.prototype.process = function(me) {
  let state2 = null;
  if (this.isEnabled()) {
    state2 = this.getState(me);
    this.setCurrentState(state2, me);
  }
  return state2;
};
mxCellMarker.prototype.setCurrentState = function(state2, me, color) {
  const isValid = state2 != null ? this.isValidState(state2) : false;
  color = color != null ? color : this.getMarkerColor(me.getEvent(), state2, isValid);
  if (isValid) {
    this.validState = state2;
  } else {
    this.validState = null;
  }
  if (state2 !== this.markedState || color !== this.currentColor) {
    this.currentColor = color;
    if (state2 != null && this.currentColor != null) {
      this.markedState = state2;
      this.mark();
    } else if (this.markedState != null) {
      this.markedState = null;
      this.unmark();
    }
  }
};
mxCellMarker.prototype.markCell = function(cell2, color) {
  const state2 = this.graph.getView().getState(cell2);
  if (state2 != null) {
    this.currentColor = color != null ? color : this.validColor;
    this.markedState = state2;
    this.mark();
  }
};
mxCellMarker.prototype.mark = function() {
  this.highlight.setHighlightColor(this.currentColor);
  this.highlight.highlight(this.markedState);
  this.fireEvent(new mxEventObject2(mxEvent2.MARK, "state", this.markedState));
};
mxCellMarker.prototype.unmark = function() {
  this.mark();
};
mxCellMarker.prototype.isValidState = function(state2) {
  return true;
};
mxCellMarker.prototype.getMarkerColor = function(evt, state2, isValid) {
  return isValid ? this.validColor : this.invalidColor;
};
mxCellMarker.prototype.getState = function(me) {
  const view = this.graph.getView();
  const cell2 = this.getCell(me);
  const state2 = this.getStateToMark(view.getState(cell2));
  return state2 != null && this.intersects(state2, me) ? state2 : null;
};
mxCellMarker.prototype.getCell = function(me) {
  return me.getCell();
};
mxCellMarker.prototype.getStateToMark = function(state2) {
  return state2;
};
mxCellMarker.prototype.intersects = function(state2, me) {
  if (this.hotspotEnabled) {
    return intersectsHotspot(state2, me.getGraphX(), me.getGraphY(), this.hotspot, mxConstants2.MIN_HOTSPOT_SIZE, mxConstants2.MAX_HOTSPOT_SIZE);
  }
  return true;
};
mxCellMarker.prototype.destroy = function() {
  this.graph.getView().removeListener(this.resetHandler);
  this.graph.getModel().removeListener(this.resetHandler);
  this.highlight.destroy();
};

// js/graph/mxConnectionHandler.js
function mxConnectionHandler(graph, factoryMethod) {
  mxEventSource.call(this);
  if (graph != null) {
    this.graph = graph;
    this.factoryMethod = factoryMethod;
    this.init();
    this.escapeHandler = bind(this, function(sender, evt) {
      this.reset();
    });
    this.graph.addListener(mxEvent2.ESCAPE, this.escapeHandler);
  }
}
extend(mxConnectionHandler, mxEventSource);
mxConnectionHandler.prototype.graph = null;
mxConnectionHandler.prototype.factoryMethod = true;
mxConnectionHandler.prototype.moveIconFront = false;
mxConnectionHandler.prototype.moveIconBack = false;
mxConnectionHandler.prototype.connectImage = null;
mxConnectionHandler.prototype.targetConnectImage = false;
mxConnectionHandler.prototype.enabled = true;
mxConnectionHandler.prototype.select = true;
mxConnectionHandler.prototype.createTarget = false;
mxConnectionHandler.prototype.marker = null;
mxConnectionHandler.prototype.constraintHandler = null;
mxConnectionHandler.prototype.error = null;
mxConnectionHandler.prototype.waypointsEnabled = false;
mxConnectionHandler.prototype.ignoreMouseDown = false;
mxConnectionHandler.prototype.first = null;
mxConnectionHandler.prototype.connectIconOffset = new mxPoint2(0, mxConstants2.TOOLTIP_VERTICAL_OFFSET);
mxConnectionHandler.prototype.edgeState = null;
mxConnectionHandler.prototype.changeHandler = null;
mxConnectionHandler.prototype.drillHandler = null;
mxConnectionHandler.prototype.mouseDownCounter = 0;
mxConnectionHandler.prototype.movePreviewAway = mxClient_default.IS_VML;
mxConnectionHandler.prototype.outlineConnect = false;
mxConnectionHandler.prototype.livePreview = false;
mxConnectionHandler.prototype.cursor = null;
mxConnectionHandler.prototype.insertBeforeSource = false;
mxConnectionHandler.prototype.isEnabled = function() {
  return this.enabled;
};
mxConnectionHandler.prototype.setEnabled = function(enabled) {
  this.enabled = enabled;
};
mxConnectionHandler.prototype.isInsertBefore = function(edge, source, target, evt, dropTarget) {
  return this.insertBeforeSource && source != target;
};
mxConnectionHandler.prototype.isCreateTarget = function(evt) {
  return this.createTarget;
};
mxConnectionHandler.prototype.setCreateTarget = function(value) {
  this.createTarget = value;
};
mxConnectionHandler.prototype.createShape = function() {
  var shape = this.livePreview && this.edgeState != null ? this.graph.cellRenderer.createShape(this.edgeState) : new mxPolyline([], mxConstants2.INVALID_COLOR);
  shape.dialect = this.graph.dialect != mxConstants2.DIALECT_SVG ? mxConstants2.DIALECT_VML : mxConstants2.DIALECT_SVG;
  shape.scale = this.graph.view.scale;
  shape.pointerEvents = false;
  shape.isDashed = true;
  shape.init(this.graph.getView().getOverlayPane());
  mxEvent2.redirectMouseEvents(shape.node, this.graph, null);
  return shape;
};
mxConnectionHandler.prototype.init = function() {
  this.graph.addMouseListener(this);
  this.marker = this.createMarker();
  this.constraintHandler = new mxConstraintHandler(this.graph);
  this.changeHandler = bind(this, function(sender) {
    if (this.iconState != null) {
      this.iconState = this.graph.getView().getState(this.iconState.cell);
    }
    if (this.iconState != null) {
      this.redrawIcons(this.icons, this.iconState);
      this.constraintHandler.reset();
    } else if (this.previous != null && this.graph.view.getState(this.previous.cell) == null) {
      this.reset();
    }
  });
  this.graph.getModel().addListener(mxEvent2.CHANGE, this.changeHandler);
  this.graph.getView().addListener(mxEvent2.SCALE, this.changeHandler);
  this.graph.getView().addListener(mxEvent2.TRANSLATE, this.changeHandler);
  this.graph.getView().addListener(mxEvent2.SCALE_AND_TRANSLATE, this.changeHandler);
  this.drillHandler = bind(this, function(sender) {
    this.reset();
  });
  this.graph.addListener(mxEvent2.START_EDITING, this.drillHandler);
  this.graph.getView().addListener(mxEvent2.DOWN, this.drillHandler);
  this.graph.getView().addListener(mxEvent2.UP, this.drillHandler);
};
mxConnectionHandler.prototype.isConnectableCell = function(cell2) {
  return true;
};
mxConnectionHandler.prototype.createMarker = function() {
  var marker = new mxCellMarker(this.graph);
  marker.hotspotEnabled = true;
  marker.getCell = bind(this, function(me) {
    var cell2 = mxCellMarker.prototype.getCell.apply(marker, arguments);
    this.error = null;
    if (cell2 == null && this.currentPoint != null) {
      cell2 = this.graph.getCellAt(this.currentPoint.x, this.currentPoint.y);
    }
    if (cell2 != null && !this.graph.isCellConnectable(cell2)) {
      var parent2 = this.graph.getModel().getParent(cell2);
      if (this.graph.getModel().isVertex(parent2) && this.graph.isCellConnectable(parent2)) {
        cell2 = parent2;
      }
    }
    if (this.graph.isSwimlane(cell2) && this.currentPoint != null && this.graph.hitsSwimlaneContent(cell2, this.currentPoint.x, this.currentPoint.y) || !this.isConnectableCell(cell2)) {
      cell2 = null;
    }
    if (cell2 != null) {
      if (this.isConnecting()) {
        if (this.previous != null) {
          this.error = this.validateConnection(this.previous.cell, cell2);
          if (this.error != null && this.error.length == 0) {
            cell2 = null;
            if (this.isCreateTarget(me.getEvent())) {
              this.error = null;
            }
          }
        }
      } else if (!this.isValidSource(cell2, me)) {
        cell2 = null;
      }
    } else if (this.isConnecting() && !this.isCreateTarget(me.getEvent()) && !this.graph.allowDanglingEdges) {
      this.error = "";
    }
    return cell2;
  });
  marker.isValidState = bind(this, function(state2) {
    if (this.isConnecting()) {
      return this.error == null;
    } else {
      return mxCellMarker.prototype.isValidState.apply(marker, arguments);
    }
  });
  marker.getMarkerColor = bind(this, function(evt, state2, isValid) {
    return this.connectImage == null || this.isConnecting() ? mxCellMarker.prototype.getMarkerColor.apply(marker, arguments) : null;
  });
  marker.intersects = bind(this, function(state2, evt) {
    if (this.connectImage != null || this.isConnecting()) {
      return true;
    }
    return mxCellMarker.prototype.intersects.apply(marker, arguments);
  });
  return marker;
};
mxConnectionHandler.prototype.start = function(state2, x, y, edgeState) {
  this.previous = state2;
  this.first = new mxPoint2(x, y);
  this.edgeState = edgeState != null ? edgeState : this.createEdgeState(null);
  this.marker.currentColor = this.marker.validColor;
  this.marker.markedState = state2;
  this.marker.mark();
  this.fireEvent(new mxEventObject2(mxEvent2.START, "state", this.previous));
};
mxConnectionHandler.prototype.isConnecting = function() {
  return this.first != null && this.shape != null;
};
mxConnectionHandler.prototype.isValidSource = function(cell2, me) {
  return this.graph.isValidSource(cell2);
};
mxConnectionHandler.prototype.isValidTarget = function(cell2) {
  return true;
};
mxConnectionHandler.prototype.validateConnection = function(source, target) {
  if (!this.isValidTarget(target)) {
    return "";
  }
  return this.graph.getEdgeValidationError(null, source, target);
};
mxConnectionHandler.prototype.getConnectImage = function(state2) {
  return this.connectImage;
};
mxConnectionHandler.prototype.isMoveIconToFrontForState = function(state2) {
  if (state2.text != null && state2.text.node.parentNode == this.graph.container) {
    return true;
  }
  return this.moveIconFront;
};
mxConnectionHandler.prototype.createIcons = function(state2) {
  var image = this.getConnectImage(state2);
  if (image != null && state2 != null) {
    this.iconState = state2;
    var icons = [];
    var bounds = new mxRectangle(0, 0, image.width, image.height);
    var icon = new mxImageShape(bounds, image.src, null, null, 0);
    icon.preserveImageAspect = false;
    if (this.isMoveIconToFrontForState(state2)) {
      icon.dialect = mxConstants2.DIALECT_STRICTHTML;
      icon.init(this.graph.container);
    } else {
      icon.dialect = this.graph.dialect == mxConstants2.DIALECT_SVG ? mxConstants2.DIALECT_SVG : mxConstants2.DIALECT_VML;
      icon.init(this.graph.getView().getOverlayPane());
      if (this.moveIconBack && icon.node.previousSibling != null) {
        icon.node.parentNode.insertBefore(icon.node, icon.node.parentNode.firstChild);
      }
    }
    icon.node.style.cursor = mxConstants2.CURSOR_CONNECT;
    var getState = bind(this, function() {
      return this.currentState != null ? this.currentState : state2;
    });
    var mouseDown2 = bind(this, function(evt) {
      if (!mxEvent2.isConsumed(evt)) {
        this.icon = icon;
        this.graph.fireMouseEvent(mxEvent2.MOUSE_DOWN, new mxMouseEvent2(evt, getState()));
      }
    });
    mxEvent2.redirectMouseEvents(icon.node, this.graph, getState, mouseDown2);
    icons.push(icon);
    this.redrawIcons(icons, this.iconState);
    return icons;
  }
  return null;
};
mxConnectionHandler.prototype.redrawIcons = function(icons, state2) {
  if (icons != null && icons[0] != null && state2 != null) {
    var pos = this.getIconPosition(icons[0], state2);
    icons[0].bounds.x = pos.x;
    icons[0].bounds.y = pos.y;
    icons[0].redraw();
  }
};
mxConnectionHandler.prototype.getIconPosition = function(icon, state2) {
  var scale = this.graph.getView().scale;
  var cx = state2.getCenterX();
  var cy = state2.getCenterY();
  if (this.graph.isSwimlane(state2.cell)) {
    var size = this.graph.getStartSize(state2.cell);
    cx = size.width != 0 ? state2.x + size.width * scale / 2 : cx;
    cy = size.height != 0 ? state2.y + size.height * scale / 2 : cy;
    var alpha = toRadians(getValue(state2.style, mxConstants2.STYLE_ROTATION) || 0);
    if (alpha != 0) {
      var cos = Math.cos(alpha);
      var sin = Math.sin(alpha);
      var ct = new mxPoint2(state2.getCenterX(), state2.getCenterY());
      var pt = getRotatedPoint(new mxPoint2(cx, cy), cos, sin, ct);
      cx = pt.x;
      cy = pt.y;
    }
  }
  return new mxPoint2(cx - icon.bounds.width / 2, cy - icon.bounds.height / 2);
};
mxConnectionHandler.prototype.destroyIcons = function() {
  if (this.icons != null) {
    for (var i = 0; i < this.icons.length; i++) {
      this.icons[i].destroy();
    }
    this.icons = null;
    this.icon = null;
    this.selectedIcon = null;
    this.iconState = null;
  }
};
mxConnectionHandler.prototype.isStartEvent = function(me) {
  return this.constraintHandler.currentFocus != null && this.constraintHandler.currentConstraint != null || this.previous != null && this.error == null && (this.icons == null || this.icons != null && this.icon != null);
};
mxConnectionHandler.prototype.mouseDown = function(sender, me) {
  this.mouseDownCounter++;
  if (this.isEnabled() && this.graph.isEnabled() && !me.isConsumed() && !this.isConnecting() && this.isStartEvent(me)) {
    if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null && this.constraintHandler.currentPoint != null) {
      this.sourceConstraint = this.constraintHandler.currentConstraint;
      this.previous = this.constraintHandler.currentFocus;
      this.first = this.constraintHandler.currentPoint.clone();
    } else {
      this.first = new mxPoint2(me.getGraphX(), me.getGraphY());
    }
    this.edgeState = this.createEdgeState(me);
    this.mouseDownCounter = 1;
    if (this.waypointsEnabled && this.shape == null) {
      this.waypoints = null;
      this.shape = this.createShape();
      if (this.edgeState != null) {
        this.shape.apply(this.edgeState);
      }
    }
    if (this.previous == null && this.edgeState != null) {
      var pt = this.graph.getPointForEvent(me.getEvent());
      this.edgeState.cell.geometry.setTerminalPoint(pt, true);
    }
    this.fireEvent(new mxEventObject2(mxEvent2.START, "state", this.previous));
    me.consume();
  }
  this.selectedIcon = this.icon;
  this.icon = null;
};
mxConnectionHandler.prototype.isImmediateConnectSource = function(state2) {
  return !this.graph.isCellMovable(state2.cell);
};
mxConnectionHandler.prototype.createEdgeState = function(me) {
  return null;
};
mxConnectionHandler.prototype.isOutlineConnectEvent = function(me) {
  var offset = getOffset(this.graph.container);
  var evt = me.getEvent();
  var clientX = mxEvent2.getClientX(evt);
  var clientY = mxEvent2.getClientY(evt);
  var doc = document.documentElement;
  var left = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);
  var top = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);
  var gridX = this.currentPoint.x - this.graph.container.scrollLeft + offset.x - left;
  var gridY = this.currentPoint.y - this.graph.container.scrollTop + offset.y - top;
  return this.outlineConnect && !mxEvent2.isShiftDown(me.getEvent()) && (me.isSource(this.marker.highlight.shape) || mxEvent2.isAltDown(me.getEvent()) && me.getState() != null || this.marker.highlight.isHighlightAt(clientX, clientY) || (gridX != clientX || gridY != clientY) && me.getState() == null && this.marker.highlight.isHighlightAt(gridX, gridY));
};
mxConnectionHandler.prototype.updateCurrentState = function(me, point) {
  this.constraintHandler.update(me, this.first == null, false, this.first == null || me.isSource(this.marker.highlight.shape) ? null : point);
  if (this.constraintHandler.currentFocus != null && this.constraintHandler.currentConstraint != null) {
    if (this.marker.highlight != null && this.marker.highlight.state != null && this.marker.highlight.state.cell == this.constraintHandler.currentFocus.cell) {
      if (this.marker.highlight.shape.stroke != "transparent") {
        this.marker.highlight.shape.stroke = "transparent";
        this.marker.highlight.repaint();
      }
    } else {
      this.marker.markCell(this.constraintHandler.currentFocus.cell, "transparent");
    }
    if (this.previous != null) {
      this.error = this.validateConnection(this.previous.cell, this.constraintHandler.currentFocus.cell);
      if (this.error == null) {
        this.currentState = this.constraintHandler.currentFocus;
      }
      if (this.error != null || this.currentState != null && !this.isCellEnabled(this.currentState.cell)) {
        this.constraintHandler.reset();
      }
    }
  } else {
    if (this.graph.isIgnoreTerminalEvent(me.getEvent())) {
      this.marker.reset();
      this.currentState = null;
    } else {
      this.marker.process(me);
      this.currentState = this.marker.getValidState();
    }
    if (this.currentState != null && !this.isCellEnabled(this.currentState.cell)) {
      this.constraintHandler.reset();
      this.marker.reset();
      this.currentState = null;
    }
    var outline = this.isOutlineConnectEvent(me);
    if (this.currentState != null && outline) {
      if (me.isSource(this.marker.highlight.shape)) {
        point = new mxPoint2(me.getGraphX(), me.getGraphY());
      }
      var constraint = this.graph.getOutlineConstraint(point, this.currentState, me);
      this.constraintHandler.setFocus(me, this.currentState, false);
      this.constraintHandler.currentConstraint = constraint;
      this.constraintHandler.currentPoint = point;
    }
    if (this.outlineConnect) {
      if (this.marker.highlight != null && this.marker.highlight.shape != null) {
        var s = this.graph.view.scale;
        if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null) {
          this.marker.highlight.shape.stroke = mxConstants2.OUTLINE_HIGHLIGHT_COLOR;
          this.marker.highlight.shape.strokewidth = mxConstants2.OUTLINE_HIGHLIGHT_STROKEWIDTH / s / s;
          this.marker.highlight.repaint();
        } else if (this.marker.hasValidState()) {
          if (this.graph.isCellConnectable(me.getCell()) && this.marker.getValidState() != me.getState()) {
            this.marker.highlight.shape.stroke = "transparent";
            this.currentState = null;
          } else {
            this.marker.highlight.shape.stroke = mxConstants2.DEFAULT_VALID_COLOR;
          }
          this.marker.highlight.shape.strokewidth = mxConstants2.HIGHLIGHT_STROKEWIDTH / s / s;
          this.marker.highlight.repaint();
        }
      }
    }
  }
};
mxConnectionHandler.prototype.isCellEnabled = function(cell2) {
  return true;
};
mxConnectionHandler.prototype.convertWaypoint = function(point) {
  var scale = this.graph.getView().getScale();
  var tr = this.graph.getView().getTranslate();
  point.x = point.x / scale - tr.x;
  point.y = point.y / scale - tr.y;
};
mxConnectionHandler.prototype.snapToPreview = function(me, point) {
  if (!mxEvent2.isAltDown(me.getEvent()) && this.previous != null) {
    var tol = this.graph.gridSize * this.graph.view.scale / 2;
    var tmp = this.sourceConstraint != null ? this.first : new mxPoint2(this.previous.getCenterX(), this.previous.getCenterY());
    if (Math.abs(tmp.x - me.getGraphX()) < tol) {
      point.x = tmp.x;
    }
    if (Math.abs(tmp.y - me.getGraphY()) < tol) {
      point.y = tmp.y;
    }
  }
};
mxConnectionHandler.prototype.mouseMove = function(sender, me) {
  if (!me.isConsumed() && (this.ignoreMouseDown || this.first != null || !this.graph.isMouseDown)) {
    if (!this.isEnabled() && this.currentState != null) {
      this.destroyIcons();
      this.currentState = null;
    }
    var view = this.graph.getView();
    var scale = view.scale;
    var tr = view.translate;
    var point = new mxPoint2(me.getGraphX(), me.getGraphY());
    this.error = null;
    if (this.graph.isGridEnabledEvent(me.getEvent())) {
      point = new mxPoint2((this.graph.snap(point.x / scale - tr.x) + tr.x) * scale, (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale);
    }
    this.snapToPreview(me, point);
    this.currentPoint = point;
    if ((this.first != null || this.isEnabled() && this.graph.isEnabled()) && (this.shape != null || this.first == null || Math.abs(me.getGraphX() - this.first.x) > this.graph.tolerance || Math.abs(me.getGraphY() - this.first.y) > this.graph.tolerance)) {
      this.updateCurrentState(me, point);
    }
    if (this.first != null) {
      var constraint = null;
      var current2 = point;
      if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null && this.constraintHandler.currentPoint != null) {
        constraint = this.constraintHandler.currentConstraint;
        current2 = this.constraintHandler.currentPoint.clone();
      } else if (this.previous != null && !this.graph.isIgnoreTerminalEvent(me.getEvent()) && mxEvent2.isShiftDown(me.getEvent())) {
        if (Math.abs(this.previous.getCenterX() - point.x) < Math.abs(this.previous.getCenterY() - point.y)) {
          point.x = this.previous.getCenterX();
        } else {
          point.y = this.previous.getCenterY();
        }
      }
      var pt2 = this.first;
      if (this.selectedIcon != null) {
        var w2 = this.selectedIcon.bounds.width;
        var h2 = this.selectedIcon.bounds.height;
        if (this.currentState != null && this.targetConnectImage) {
          var pos = this.getIconPosition(this.selectedIcon, this.currentState);
          this.selectedIcon.bounds.x = pos.x;
          this.selectedIcon.bounds.y = pos.y;
        } else {
          var bounds = new mxRectangle(me.getGraphX() + this.connectIconOffset.x, me.getGraphY() + this.connectIconOffset.y, w2, h2);
          this.selectedIcon.bounds = bounds;
        }
        this.selectedIcon.redraw();
      }
      if (this.edgeState != null) {
        this.updateEdgeState(current2, constraint);
        current2 = this.edgeState.absolutePoints[this.edgeState.absolutePoints.length - 1];
        pt2 = this.edgeState.absolutePoints[0];
      } else {
        if (this.currentState != null) {
          if (this.constraintHandler.currentConstraint == null) {
            var tmp = this.getTargetPerimeterPoint(this.currentState, me);
            if (tmp != null) {
              current2 = tmp;
            }
          }
        }
        if (this.sourceConstraint == null && this.previous != null) {
          var next = this.waypoints != null && this.waypoints.length > 0 ? this.waypoints[0] : current2;
          var tmp = this.getSourcePerimeterPoint(this.previous, next, me);
          if (tmp != null) {
            pt2 = tmp;
          }
        }
      }
      if (this.currentState == null && this.movePreviewAway) {
        var tmp = pt2;
        if (this.edgeState != null && this.edgeState.absolutePoints.length >= 2) {
          var tmp2 = this.edgeState.absolutePoints[this.edgeState.absolutePoints.length - 2];
          if (tmp2 != null) {
            tmp = tmp2;
          }
        }
        var dx = current2.x - tmp.x;
        var dy = current2.y - tmp.y;
        var len = Math.sqrt(dx * dx + dy * dy);
        if (len == 0) {
          return;
        }
        this.originalPoint = current2.clone();
        current2.x -= dx * 4 / len;
        current2.y -= dy * 4 / len;
      } else {
        this.originalPoint = null;
      }
      if (this.shape == null) {
        var dx = Math.abs(me.getGraphX() - this.first.x);
        var dy = Math.abs(me.getGraphY() - this.first.y);
        if (dx > this.graph.tolerance || dy > this.graph.tolerance) {
          this.shape = this.createShape();
          if (this.edgeState != null) {
            this.shape.apply(this.edgeState);
          }
          this.updateCurrentState(me, point);
        }
      }
      if (this.shape != null) {
        if (this.edgeState != null) {
          this.shape.points = this.edgeState.absolutePoints;
        } else {
          var pts = [pt2];
          if (this.waypoints != null) {
            pts = pts.concat(this.waypoints);
          }
          pts.push(current2);
          this.shape.points = pts;
        }
        this.drawPreview();
      }
      if (this.cursor != null) {
        this.graph.container.style.cursor = this.cursor;
      }
      mxEvent2.consume(me.getEvent());
      me.consume();
    } else if (!this.isEnabled() || !this.graph.isEnabled()) {
      this.constraintHandler.reset();
    } else if (this.previous != this.currentState && this.edgeState == null) {
      this.destroyIcons();
      if (this.currentState != null && this.error == null && this.constraintHandler.currentConstraint == null) {
        this.icons = this.createIcons(this.currentState);
        if (this.icons == null) {
          this.currentState.setCursor(mxConstants2.CURSOR_CONNECT);
          me.consume();
        }
      }
      this.previous = this.currentState;
    } else if (this.previous == this.currentState && this.currentState != null && this.icons == null && !this.graph.isMouseDown) {
      me.consume();
    }
    if (!this.graph.isMouseDown && this.currentState != null && this.icons != null) {
      var hitsIcon = false;
      var target = me.getSource();
      for (var i = 0; i < this.icons.length && !hitsIcon; i++) {
        hitsIcon = target == this.icons[i].node || target.parentNode == this.icons[i].node;
      }
      if (!hitsIcon) {
        this.updateIcons(this.currentState, this.icons, me);
      }
    }
  } else {
    this.constraintHandler.reset();
  }
};
mxConnectionHandler.prototype.updateEdgeState = function(current2, constraint) {
  if (this.sourceConstraint != null && this.sourceConstraint.point != null) {
    this.edgeState.style[mxConstants2.STYLE_EXIT_X] = this.sourceConstraint.point.x;
    this.edgeState.style[mxConstants2.STYLE_EXIT_Y] = this.sourceConstraint.point.y;
  }
  if (constraint != null && constraint.point != null) {
    this.edgeState.style[mxConstants2.STYLE_ENTRY_X] = constraint.point.x;
    this.edgeState.style[mxConstants2.STYLE_ENTRY_Y] = constraint.point.y;
  } else {
    delete this.edgeState.style[mxConstants2.STYLE_ENTRY_X];
    delete this.edgeState.style[mxConstants2.STYLE_ENTRY_Y];
  }
  this.edgeState.absolutePoints = [null, this.currentState != null ? null : current2];
  this.graph.view.updateFixedTerminalPoint(this.edgeState, this.previous, true, this.sourceConstraint);
  if (this.currentState != null) {
    if (constraint == null) {
      constraint = this.graph.getConnectionConstraint(this.edgeState, this.previous, false);
    }
    this.edgeState.setAbsoluteTerminalPoint(null, false);
    this.graph.view.updateFixedTerminalPoint(this.edgeState, this.currentState, false, constraint);
  }
  var realPoints = null;
  if (this.waypoints != null) {
    realPoints = [];
    for (var i = 0; i < this.waypoints.length; i++) {
      var pt = this.waypoints[i].clone();
      this.convertWaypoint(pt);
      realPoints[i] = pt;
    }
  }
  this.graph.view.updatePoints(this.edgeState, realPoints, this.previous, this.currentState);
  this.graph.view.updateFloatingTerminalPoints(this.edgeState, this.previous, this.currentState);
};
mxConnectionHandler.prototype.getTargetPerimeterPoint = function(state2, me) {
  var result2 = null;
  var view = state2.view;
  var targetPerimeter = view.getPerimeterFunction(state2);
  if (targetPerimeter != null) {
    var next = this.waypoints != null && this.waypoints.length > 0 ? this.waypoints[this.waypoints.length - 1] : new mxPoint2(this.previous.getCenterX(), this.previous.getCenterY());
    var tmp = targetPerimeter(view.getPerimeterBounds(state2), this.edgeState, next, false);
    if (tmp != null) {
      result2 = tmp;
    }
  } else {
    result2 = new mxPoint2(state2.getCenterX(), state2.getCenterY());
  }
  return result2;
};
mxConnectionHandler.prototype.getSourcePerimeterPoint = function(state2, next, me) {
  var result2 = null;
  var view = state2.view;
  var sourcePerimeter = view.getPerimeterFunction(state2);
  var c = new mxPoint2(state2.getCenterX(), state2.getCenterY());
  if (sourcePerimeter != null) {
    var theta = getValue(state2.style, mxConstants2.STYLE_ROTATION, 0);
    var rad = -theta * (Math.PI / 180);
    if (theta != 0) {
      next = getRotatedPoint(new mxPoint2(next.x, next.y), Math.cos(rad), Math.sin(rad), c);
    }
    var tmp = sourcePerimeter(view.getPerimeterBounds(state2), state2, next, false);
    if (tmp != null) {
      if (theta != 0) {
        tmp = getRotatedPoint(new mxPoint2(tmp.x, tmp.y), Math.cos(-rad), Math.sin(-rad), c);
      }
      result2 = tmp;
    }
  } else {
    result2 = c;
  }
  return result2;
};
mxConnectionHandler.prototype.updateIcons = function(state2, icons, me) {
};
mxConnectionHandler.prototype.isStopEvent = function(me) {
  return me.getState() != null;
};
mxConnectionHandler.prototype.addWaypointForEvent = function(me) {
  var point = convertPoint(this.graph.container, me.getX(), me.getY());
  var dx = Math.abs(point.x - this.first.x);
  var dy = Math.abs(point.y - this.first.y);
  var addPoint = this.waypoints != null || this.mouseDownCounter > 1 && (dx > this.graph.tolerance || dy > this.graph.tolerance);
  if (addPoint) {
    if (this.waypoints == null) {
      this.waypoints = [];
    }
    var scale = this.graph.view.scale;
    var point = new mxPoint2(this.graph.snap(me.getGraphX() / scale) * scale, this.graph.snap(me.getGraphY() / scale) * scale);
    this.waypoints.push(point);
  }
};
mxConnectionHandler.prototype.checkConstraints = function(c1, c2) {
  return c1 == null || c2 == null || c1.point == null || c2.point == null || !c1.point.equals(c2.point) || c1.dx != c2.dx || c1.dy != c2.dy || c1.perimeter != c2.perimeter;
};
mxConnectionHandler.prototype.mouseUp = function(sender, me) {
  if (!me.isConsumed() && this.isConnecting()) {
    if (this.waypointsEnabled && !this.isStopEvent(me)) {
      this.addWaypointForEvent(me);
      me.consume();
      return;
    }
    var c1 = this.sourceConstraint;
    var c2 = this.constraintHandler.currentConstraint;
    var source = this.previous != null ? this.previous.cell : null;
    var target = null;
    if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null) {
      target = this.constraintHandler.currentFocus.cell;
    }
    if (target == null && this.currentState != null) {
      target = this.currentState.cell;
    }
    if (this.error == null && (source == null || target == null || source != target || this.checkConstraints(c1, c2))) {
      this.connect(source, target, me.getEvent(), me.getCell());
    } else {
      if (this.previous != null && this.marker.validState != null && this.previous.cell == this.marker.validState.cell) {
        this.graph.selectCellForEvent(this.marker.source, me.getEvent());
      }
      if (this.error != null && this.error.length > 0) {
        this.graph.validationAlert(this.error);
      }
    }
    this.destroyIcons();
    me.consume();
  }
  if (this.first != null) {
    this.reset();
  }
};
mxConnectionHandler.prototype.reset = function() {
  if (this.shape != null) {
    this.shape.destroy();
    this.shape = null;
  }
  if (this.cursor != null && this.graph.container != null) {
    this.graph.container.style.cursor = "";
  }
  this.destroyIcons();
  this.marker.reset();
  this.constraintHandler.reset();
  this.originalPoint = null;
  this.currentPoint = null;
  this.edgeState = null;
  this.previous = null;
  this.error = null;
  this.sourceConstraint = null;
  this.mouseDownCounter = 0;
  this.first = null;
  this.fireEvent(new mxEventObject2(mxEvent2.RESET));
};
mxConnectionHandler.prototype.drawPreview = function() {
  this.updatePreview(this.error == null);
  this.shape.redraw();
};
mxConnectionHandler.prototype.updatePreview = function(valid) {
  this.shape.strokewidth = this.getEdgeWidth(valid);
  this.shape.stroke = this.getEdgeColor(valid);
};
mxConnectionHandler.prototype.getEdgeColor = function(valid) {
  return valid ? mxConstants2.VALID_COLOR : mxConstants2.INVALID_COLOR;
};
mxConnectionHandler.prototype.getEdgeWidth = function(valid) {
  return valid ? 3 : 1;
};
mxConnectionHandler.prototype.connect = function(source, target, evt, dropTarget) {
  if (target != null || this.isCreateTarget(evt) || this.graph.allowDanglingEdges) {
    var model = this.graph.getModel();
    var terminalInserted = false;
    var edge = null;
    model.beginUpdate();
    try {
      if (source != null && target == null && !this.graph.isIgnoreTerminalEvent(evt) && this.isCreateTarget(evt)) {
        target = this.createTargetVertex(evt, source);
        if (target != null) {
          dropTarget = this.graph.getDropTarget([target], evt, dropTarget);
          terminalInserted = true;
          if (dropTarget == null || !this.graph.getModel().isEdge(dropTarget)) {
            var pstate = this.graph.getView().getState(dropTarget);
            if (pstate != null) {
              var tmp = model.getGeometry(target);
              tmp.x -= pstate.origin.x;
              tmp.y -= pstate.origin.y;
            }
          } else {
            dropTarget = this.graph.getDefaultParent();
          }
          this.graph.addCell(target, dropTarget);
        }
      }
      var parent2 = this.graph.getDefaultParent();
      if (source != null && target != null && model.getParent(source) == model.getParent(target) && model.getParent(model.getParent(source)) != model.getRoot()) {
        parent2 = model.getParent(source);
        if (source.geometry != null && source.geometry.relative && (target.geometry != null && target.geometry.relative)) {
          parent2 = model.getParent(parent2);
        }
      }
      var value = null;
      var style = null;
      if (this.edgeState != null) {
        value = this.edgeState.cell.value;
        style = this.edgeState.cell.style;
      }
      edge = this.insertEdge(parent2, null, value, source, target, style);
      if (edge != null) {
        this.graph.setConnectionConstraint(edge, source, true, this.sourceConstraint);
        this.graph.setConnectionConstraint(edge, target, false, this.constraintHandler.currentConstraint);
        if (this.edgeState != null) {
          model.setGeometry(edge, this.edgeState.cell.geometry);
        }
        var parent2 = model.getParent(source);
        if (this.isInsertBefore(edge, source, target, evt, dropTarget)) {
          var index = null;
          var tmp = source;
          while (tmp.parent != null && tmp.geometry != null && tmp.geometry.relative && tmp.parent != edge.parent) {
            tmp = this.graph.model.getParent(tmp);
          }
          if (tmp != null && tmp.parent != null && tmp.parent == edge.parent) {
            model.add(parent2, edge, tmp.parent.getIndex(tmp));
          }
        }
        var geo = model.getGeometry(edge);
        if (geo == null) {
          geo = new mxGeometry();
          geo.relative = true;
          model.setGeometry(edge, geo);
        }
        if (this.waypoints != null && this.waypoints.length > 0) {
          var s = this.graph.view.scale;
          var tr = this.graph.view.translate;
          geo.points = [];
          for (var i = 0; i < this.waypoints.length; i++) {
            var pt = this.waypoints[i];
            geo.points.push(new mxPoint2(pt.x / s - tr.x, pt.y / s - tr.y));
          }
        }
        if (target == null) {
          var t = this.graph.view.translate;
          var s = this.graph.view.scale;
          var pt = this.originalPoint != null ? new mxPoint2(this.originalPoint.x / s - t.x, this.originalPoint.y / s - t.y) : new mxPoint2(this.currentPoint.x / s - t.x, this.currentPoint.y / s - t.y);
          pt.x -= this.graph.panDx / this.graph.view.scale;
          pt.y -= this.graph.panDy / this.graph.view.scale;
          geo.setTerminalPoint(pt, false);
        }
        this.fireEvent(new mxEventObject2(mxEvent2.CONNECT, "cell", edge, "terminal", target, "event", evt, "target", dropTarget, "terminalInserted", terminalInserted));
      }
    } catch (e) {
      mxLog.show();
      mxLog.debug(e.message);
    } finally {
      model.endUpdate();
    }
    if (this.select) {
      this.selectCells(edge, terminalInserted ? target : null);
    }
  }
};
mxConnectionHandler.prototype.selectCells = function(edge, target) {
  this.graph.setSelectionCell(edge);
};
mxConnectionHandler.prototype.insertEdge = function(parent2, id, value, source, target, style) {
  if (this.factoryMethod == null) {
    return this.graph.insertEdge(parent2, id, value, source, target, style);
  } else {
    var edge = this.createEdge(value, source, target, style);
    edge = this.graph.addEdge(edge, parent2, source, target);
    return edge;
  }
};
mxConnectionHandler.prototype.createTargetVertex = function(evt, source) {
  var geo = this.graph.getCellGeometry(source);
  while (geo != null && geo.relative) {
    source = this.graph.getModel().getParent(source);
    geo = this.graph.getCellGeometry(source);
  }
  var clone3 = this.graph.cloneCell(source);
  var geo = this.graph.getModel().getGeometry(clone3);
  if (geo != null) {
    var t = this.graph.view.translate;
    var s = this.graph.view.scale;
    var point = new mxPoint2(this.currentPoint.x / s - t.x, this.currentPoint.y / s - t.y);
    geo.x = Math.round(point.x - geo.width / 2 - this.graph.panDx / s);
    geo.y = Math.round(point.y - geo.height / 2 - this.graph.panDy / s);
    var tol = this.getAlignmentTolerance();
    if (tol > 0) {
      var sourceState = this.graph.view.getState(source);
      if (sourceState != null) {
        var x = sourceState.x / s - t.x;
        var y = sourceState.y / s - t.y;
        if (Math.abs(x - geo.x) <= tol) {
          geo.x = Math.round(x);
        }
        if (Math.abs(y - geo.y) <= tol) {
          geo.y = Math.round(y);
        }
      }
    }
  }
  return clone3;
};
mxConnectionHandler.prototype.getAlignmentTolerance = function(evt) {
  return this.graph.isGridEnabled() ? this.graph.gridSize / 2 : this.graph.tolerance;
};
mxConnectionHandler.prototype.createEdge = function(value, source, target, style) {
  var edge = null;
  if (this.factoryMethod != null) {
    edge = this.factoryMethod(source, target, style);
  }
  if (edge == null) {
    edge = new mxCell(value || "");
    edge.setEdge(true);
    edge.setStyle(style);
    var geo = new mxGeometry();
    geo.relative = true;
    edge.setGeometry(geo);
  }
  return edge;
};
mxConnectionHandler.prototype.destroy = function() {
  this.graph.removeMouseListener(this);
  if (this.shape != null) {
    this.shape.destroy();
    this.shape = null;
  }
  if (this.marker != null) {
    this.marker.destroy();
    this.marker = null;
  }
  if (this.constraintHandler != null) {
    this.constraintHandler.destroy();
    this.constraintHandler = null;
  }
  if (this.changeHandler != null) {
    this.graph.getModel().removeListener(this.changeHandler);
    this.graph.getView().removeListener(this.changeHandler);
    this.changeHandler = null;
  }
  if (this.drillHandler != null) {
    this.graph.removeListener(this.drillHandler);
    this.graph.getView().removeListener(this.drillHandler);
    this.drillHandler = null;
  }
  if (this.escapeHandler != null) {
    this.graph.removeListener(this.escapeHandler);
    this.escapeHandler = null;
  }
};

// js/graph/mxGraphHandler.js
function mxGraphHandler(graph) {
  this.graph = graph;
  this.graph.addMouseListener(this);
  this.panHandler = bind(this, function() {
    if (!this.suspended) {
      this.updatePreview();
      this.updateHint();
    }
  });
  this.graph.addListener(mxEvent2.PAN, this.panHandler);
  this.escapeHandler = bind(this, function(sender, evt) {
    this.reset();
  });
  this.graph.addListener(mxEvent2.ESCAPE, this.escapeHandler);
  this.refreshHandler = bind(this, function(sender, evt) {
    if (this.refreshThread) {
      window.clearTimeout(this.refreshThread);
    }
    this.refreshThread = window.setTimeout(bind(this, function() {
      this.refreshThread = null;
      if (this.first != null && !this.suspended) {
        var dx = this.currentDx;
        var dy = this.currentDy;
        this.currentDx = 0;
        this.currentDy = 0;
        this.updatePreview();
        this.bounds = this.graph.getView().getBounds(this.cells);
        this.pBounds = this.getPreviewBounds(this.cells);
        if (this.pBounds == null && !this.livePreviewUsed) {
          this.reset();
        } else {
          this.currentDx = dx;
          this.currentDy = dy;
          this.updatePreview();
          this.updateHint();
          if (this.livePreviewUsed) {
            this.setHandlesVisibleForCells(this.graph.selectionCellsHandler.getHandledSelectionCells(), false, true);
            this.updatePreview();
          }
        }
      }
    }), 0);
  });
  this.graph.getModel().addListener(mxEvent2.CHANGE, this.refreshHandler);
  this.graph.addListener(mxEvent2.REFRESH, this.refreshHandler);
  this.keyHandler = bind(this, function(e) {
    if (this.graph.container != null && this.graph.container.style.visibility != "hidden" && this.first != null && !this.suspended) {
      var clone3 = this.graph.isCloneEvent(e) && this.graph.isCellsCloneable() && this.isCloneEnabled();
      if (clone3 != this.cloning) {
        this.cloning = clone3;
        this.checkPreview();
        this.updatePreview();
      }
    }
  });
  mxEvent2.addListener(document, "keydown", this.keyHandler);
  mxEvent2.addListener(document, "keyup", this.keyHandler);
}
mxGraphHandler.prototype.graph = null;
mxGraphHandler.prototype.maxCells = mxClient_default.IS_IE ? 20 : 50;
mxGraphHandler.prototype.enabled = true;
mxGraphHandler.prototype.highlightEnabled = true;
mxGraphHandler.prototype.cloneEnabled = true;
mxGraphHandler.prototype.moveEnabled = true;
mxGraphHandler.prototype.guidesEnabled = false;
mxGraphHandler.prototype.handlesVisible = true;
mxGraphHandler.prototype.guide = null;
mxGraphHandler.prototype.currentDx = null;
mxGraphHandler.prototype.currentDy = null;
mxGraphHandler.prototype.updateCursor = true;
mxGraphHandler.prototype.selectEnabled = true;
mxGraphHandler.prototype.removeCellsFromParent = true;
mxGraphHandler.prototype.removeEmptyParents = false;
mxGraphHandler.prototype.connectOnDrop = false;
mxGraphHandler.prototype.scrollOnMove = true;
mxGraphHandler.prototype.minimumSize = 6;
mxGraphHandler.prototype.previewColor = "black";
mxGraphHandler.prototype.htmlPreview = false;
mxGraphHandler.prototype.shape = null;
mxGraphHandler.prototype.scaleGrid = false;
mxGraphHandler.prototype.rotationEnabled = true;
mxGraphHandler.prototype.maxLivePreview = 0;
mxGraphHandler.prototype.allowLivePreview = mxClient_default.IS_SVG;
mxGraphHandler.prototype.isEnabled = function() {
  return this.enabled;
};
mxGraphHandler.prototype.setEnabled = function(value) {
  this.enabled = value;
};
mxGraphHandler.prototype.isCloneEnabled = function() {
  return this.cloneEnabled;
};
mxGraphHandler.prototype.setCloneEnabled = function(value) {
  this.cloneEnabled = value;
};
mxGraphHandler.prototype.isMoveEnabled = function() {
  return this.moveEnabled;
};
mxGraphHandler.prototype.setMoveEnabled = function(value) {
  this.moveEnabled = value;
};
mxGraphHandler.prototype.isSelectEnabled = function() {
  return this.selectEnabled;
};
mxGraphHandler.prototype.setSelectEnabled = function(value) {
  this.selectEnabled = value;
};
mxGraphHandler.prototype.isRemoveCellsFromParent = function() {
  return this.removeCellsFromParent;
};
mxGraphHandler.prototype.setRemoveCellsFromParent = function(value) {
  this.removeCellsFromParent = value;
};
mxGraphHandler.prototype.isPropagateSelectionCell = function(cell2, immediate, me) {
  var parent2 = this.graph.model.getParent(cell2);
  if (immediate) {
    var geo = this.graph.model.isEdge(cell2) ? null : this.graph.getCellGeometry(cell2);
    return !this.graph.isSiblingSelected(cell2) && (geo != null && geo.relative || !this.graph.isSwimlane(parent2));
  } else {
    return (!this.graph.isToggleEvent(me.getEvent()) || (!this.graph.isSiblingSelected(cell2) && !this.graph.isCellSelected(cell2) && !this.graph.isSwimlane(parent2) || this.graph.isCellSelected(parent2))) && (this.graph.isToggleEvent(me.getEvent()) || !this.graph.isCellSelected(parent2));
  }
};
mxGraphHandler.prototype.getInitialCellForEvent = function(me) {
  var state2 = me.getState();
  if ((!this.graph.isToggleEvent(me.getEvent()) || !mxEvent2.isAltDown(me.getEvent())) && state2 != null && !this.graph.isCellSelected(state2.cell)) {
    var model = this.graph.model;
    var next = this.graph.view.getState(model.getParent(state2.cell));
    while (next != null && !this.graph.isCellSelected(next.cell) && (model.isVertex(next.cell) || model.isEdge(next.cell)) && this.isPropagateSelectionCell(state2.cell, true, me)) {
      state2 = next;
      next = this.graph.view.getState(this.graph.getModel().getParent(state2.cell));
    }
  }
  return state2 != null ? state2.cell : null;
};
mxGraphHandler.prototype.isDelayedSelection = function(cell2, me) {
  if (!this.graph.isToggleEvent(me.getEvent()) || !mxEvent2.isAltDown(me.getEvent())) {
    while (cell2 != null) {
      if (this.graph.selectionCellsHandler.isHandled(cell2)) {
        return this.graph.cellEditor.getEditingCell() != cell2;
      }
      cell2 = this.graph.model.getParent(cell2);
    }
  }
  return this.graph.isToggleEvent(me.getEvent()) && !mxEvent2.isAltDown(me.getEvent());
};
mxGraphHandler.prototype.selectDelayed = function(me) {
  if (!this.graph.popupMenuHandler.isPopupTrigger(me)) {
    var cell2 = me.getCell();
    if (cell2 == null) {
      cell2 = this.cell;
    }
    this.selectCellForEvent(cell2, me);
  }
};
mxGraphHandler.prototype.selectCellForEvent = function(cell2, me) {
  var state2 = this.graph.view.getState(cell2);
  if (state2 != null) {
    if (me.isSource(state2.control)) {
      this.graph.selectCellForEvent(cell2, me.getEvent());
    } else {
      if (!this.graph.isToggleEvent(me.getEvent()) || !mxEvent2.isAltDown(me.getEvent())) {
        var model = this.graph.getModel();
        var parent2 = model.getParent(cell2);
        while (this.graph.view.getState(parent2) != null && (model.isVertex(parent2) || model.isEdge(parent2)) && this.isPropagateSelectionCell(cell2, false, me)) {
          cell2 = parent2;
          parent2 = model.getParent(cell2);
        }
      }
      this.graph.selectCellForEvent(cell2, me.getEvent());
    }
  }
  return cell2;
};
mxGraphHandler.prototype.consumeMouseEvent = function(evtName, me) {
  me.consume();
};
mxGraphHandler.prototype.mouseDown = function(sender, me) {
  if (!me.isConsumed() && this.isEnabled() && this.graph.isEnabled() && me.getState() != null && !mxEvent2.isMultiTouchEvent(me.getEvent())) {
    var cell2 = this.getInitialCellForEvent(me);
    this.delayedSelection = this.isDelayedSelection(cell2, me);
    this.cell = null;
    if (this.isSelectEnabled() && !this.delayedSelection) {
      this.graph.selectCellForEvent(cell2, me.getEvent());
    }
    if (this.isMoveEnabled()) {
      var model = this.graph.model;
      var geo = model.getGeometry(cell2);
      if (this.graph.isCellMovable(cell2) && (!model.isEdge(cell2) || this.graph.getSelectionCount() > 1 || geo.points != null && geo.points.length > 0 || model.getTerminal(cell2, true) == null || model.getTerminal(cell2, false) == null || this.graph.allowDanglingEdges || this.graph.isCloneEvent(me.getEvent()) && this.graph.isCellsCloneable())) {
        this.start(cell2, me.getX(), me.getY());
      } else if (this.delayedSelection) {
        this.cell = cell2;
      }
      this.cellWasClicked = true;
      this.consumeMouseEvent(mxEvent2.MOUSE_DOWN, me);
    }
  }
};
mxGraphHandler.prototype.getGuideStates = function() {
  var parent2 = this.graph.getDefaultParent();
  var model = this.graph.getModel();
  var filter = bind(this, function(cell2) {
    return this.graph.view.getState(cell2) != null && model.isVertex(cell2) && model.getGeometry(cell2) != null && !model.getGeometry(cell2).relative;
  });
  return this.graph.view.getCellStates(model.filterDescendants(filter, parent2));
};
mxGraphHandler.prototype.getCells = function(initialCell) {
  if (!this.delayedSelection && this.graph.isCellMovable(initialCell)) {
    return [initialCell];
  } else {
    return this.graph.getMovableCells(this.graph.getSelectionCells());
  }
};
mxGraphHandler.prototype.getPreviewBounds = function(cells) {
  var bounds = this.getBoundingBox(cells);
  if (bounds != null) {
    bounds.width = Math.max(0, bounds.width - 1);
    bounds.height = Math.max(0, bounds.height - 1);
    if (bounds.width < this.minimumSize) {
      var dx = this.minimumSize - bounds.width;
      bounds.x -= dx / 2;
      bounds.width = this.minimumSize;
    } else {
      bounds.x = Math.round(bounds.x);
      bounds.width = Math.ceil(bounds.width);
    }
    var tr = this.graph.view.translate;
    var s = this.graph.view.scale;
    if (bounds.height < this.minimumSize) {
      var dy = this.minimumSize - bounds.height;
      bounds.y -= dy / 2;
      bounds.height = this.minimumSize;
    } else {
      bounds.y = Math.round(bounds.y);
      bounds.height = Math.ceil(bounds.height);
    }
  }
  return bounds;
};
mxGraphHandler.prototype.getBoundingBox = function(cells) {
  var result2 = null;
  if (cells != null && cells.length > 0) {
    var model = this.graph.getModel();
    for (var i = 0; i < cells.length; i++) {
      if (model.isVertex(cells[i]) || model.isEdge(cells[i])) {
        var state2 = this.graph.view.getState(cells[i]);
        if (state2 != null) {
          var bbox = state2;
          if (model.isVertex(cells[i]) && state2.shape != null && state2.shape.boundingBox != null) {
            bbox = state2.shape.boundingBox;
          }
          if (result2 == null) {
            result2 = mxRectangle.fromRectangle(bbox);
          } else {
            result2.add(bbox);
          }
        }
      }
    }
  }
  return result2;
};
mxGraphHandler.prototype.createPreviewShape = function(bounds) {
  var shape = new mxRectangleShape(bounds, null, this.previewColor);
  shape.isDashed = true;
  if (this.htmlPreview) {
    shape.dialect = mxConstants2.DIALECT_STRICTHTML;
    shape.init(this.graph.container);
  } else {
    shape.dialect = this.graph.dialect != mxConstants2.DIALECT_SVG ? mxConstants2.DIALECT_VML : mxConstants2.DIALECT_SVG;
    shape.init(this.graph.getView().getOverlayPane());
    shape.pointerEvents = false;
    if (mxClient_default.IS_IOS) {
      shape.getSvgScreenOffset = function() {
        return 0;
      };
    }
  }
  return shape;
};
mxGraphHandler.prototype.start = function(cell2, x, y, cells) {
  this.cell = cell2;
  this.first = convertPoint(this.graph.container, x, y);
  this.cells = cells != null ? cells : this.getCells(this.cell);
  this.bounds = this.graph.getView().getBounds(this.cells);
  this.pBounds = this.getPreviewBounds(this.cells);
  this.allCells = new mxDictionary();
  this.cloning = false;
  this.cellCount = 0;
  for (var i = 0; i < this.cells.length; i++) {
    this.cellCount += this.addStates(this.cells[i], this.allCells);
  }
  if (this.guidesEnabled) {
    this.guide = new mxGuide(this.graph, this.getGuideStates());
    var parent2 = this.graph.model.getParent(cell2);
    var ignore = this.graph.model.getChildCount(parent2) < 2;
    var connected = new mxDictionary();
    var opps = this.graph.getOpposites(this.graph.getEdges(this.cell), this.cell);
    for (var i = 0; i < opps.length; i++) {
      var state2 = this.graph.view.getState(opps[i]);
      if (state2 != null && !connected.get(state2)) {
        connected.put(state2, true);
      }
    }
    this.guide.isStateIgnored = bind(this, function(state3) {
      var p = this.graph.model.getParent(state3.cell);
      return state3.cell != null && (!this.cloning && this.isCellMoving(state3.cell) || state3.cell != (this.target || parent2) && !ignore && !connected.get(state3) && (this.target == null || this.graph.model.getChildCount(this.target) >= 2) && p != (this.target || parent2));
    });
  }
};
mxGraphHandler.prototype.addStates = function(cell2, dict) {
  var state2 = this.graph.view.getState(cell2);
  var count = 0;
  if (state2 != null && dict.get(cell2) == null) {
    dict.put(cell2, state2);
    count++;
    var childCount = this.graph.model.getChildCount(cell2);
    for (var i = 0; i < childCount; i++) {
      count += this.addStates(this.graph.model.getChildAt(cell2, i), dict);
    }
  }
  return count;
};
mxGraphHandler.prototype.isCellMoving = function(cell2) {
  return this.allCells.get(cell2) != null;
};
mxGraphHandler.prototype.useGuidesForEvent = function(me) {
  return this.guide != null ? this.guide.isEnabledForEvent(me.getEvent()) && !this.graph.isConstrainedEvent(me.getEvent()) : true;
};
mxGraphHandler.prototype.snap = function(vector) {
  var scale = this.scaleGrid ? this.graph.view.scale : 1;
  vector.x = this.graph.snap(vector.x / scale) * scale;
  vector.y = this.graph.snap(vector.y / scale) * scale;
  return vector;
};
mxGraphHandler.prototype.getDelta = function(me) {
  var point = convertPoint(this.graph.container, me.getX(), me.getY());
  return new mxPoint2(point.x - this.first.x - this.graph.panDx, point.y - this.first.y - this.graph.panDy);
};
mxGraphHandler.prototype.updateHint = function(me) {
};
mxGraphHandler.prototype.removeHint = function() {
};
mxGraphHandler.prototype.roundLength = function(length) {
  return Math.round(length * 100) / 100;
};
mxGraphHandler.prototype.isValidDropTarget = function(target, me) {
  return this.graph.model.getParent(this.cell) != target;
};
mxGraphHandler.prototype.checkPreview = function() {
  if (this.livePreviewActive && this.cloning) {
    this.resetLivePreview();
    this.livePreviewActive = false;
  } else if (this.maxLivePreview >= this.cellCount && !this.livePreviewActive && this.allowLivePreview) {
    if (!this.cloning || !this.livePreviewActive) {
      this.livePreviewActive = true;
      this.livePreviewUsed = true;
    }
  } else if (!this.livePreviewUsed && this.shape == null) {
    this.shape = this.createPreviewShape(this.bounds);
  }
};
mxGraphHandler.prototype.mouseMove = function(sender, me) {
  var graph = this.graph;
  if (!me.isConsumed() && graph.isMouseDown && this.cell != null && this.first != null && this.bounds != null && !this.suspended) {
    if (mxEvent2.isMultiTouchEvent(me.getEvent())) {
      this.reset();
      return;
    }
    var delta = this.getDelta(me);
    var tol = graph.tolerance;
    if (this.shape != null || this.livePreviewActive || Math.abs(delta.x) > tol || Math.abs(delta.y) > tol) {
      if (this.highlight == null) {
        this.highlight = new mxCellHighlight2(this.graph, mxConstants2.DROP_TARGET_COLOR, 3);
      }
      var clone3 = graph.isCloneEvent(me.getEvent()) && graph.isCellsCloneable() && this.isCloneEnabled();
      var gridEnabled = graph.isGridEnabledEvent(me.getEvent());
      var cell2 = me.getCell();
      var hideGuide = true;
      var target = null;
      this.cloning = clone3;
      if (graph.isDropEnabled() && this.highlightEnabled) {
        target = graph.getDropTarget(this.cells, me.getEvent(), cell2, clone3);
      }
      var state2 = graph.getView().getState(target);
      var highlight2 = false;
      if (state2 != null && (clone3 || this.isValidDropTarget(target, me))) {
        if (this.target != target) {
          this.target = target;
          this.setHighlightColor(mxConstants2.DROP_TARGET_COLOR);
        }
        highlight2 = true;
      } else {
        this.target = null;
        if (this.connectOnDrop && cell2 != null && this.cells.length == 1 && graph.getModel().isVertex(cell2) && graph.isCellConnectable(cell2)) {
          state2 = graph.getView().getState(cell2);
          if (state2 != null) {
            var error2 = graph.getEdgeValidationError(null, this.cell, cell2);
            var color = error2 == null ? mxConstants2.VALID_COLOR : mxConstants2.INVALID_CONNECT_TARGET_COLOR;
            this.setHighlightColor(color);
            highlight2 = true;
          }
        }
      }
      if (state2 != null && highlight2) {
        this.highlight.highlight(state2);
      } else {
        this.highlight.hide();
      }
      if (this.guide != null && this.useGuidesForEvent(me)) {
        delta = this.guide.move(this.bounds, delta, gridEnabled, clone3);
        hideGuide = false;
      } else {
        delta = this.graph.snapDelta(delta, this.bounds, !gridEnabled, false, false);
      }
      if (this.guide != null && hideGuide) {
        this.guide.hide();
      }
      if (graph.isConstrainedEvent(me.getEvent())) {
        if (Math.abs(delta.x) > Math.abs(delta.y)) {
          delta.y = 0;
        } else {
          delta.x = 0;
        }
      }
      this.checkPreview();
      if (this.currentDx != delta.x || this.currentDy != delta.y) {
        this.currentDx = delta.x;
        this.currentDy = delta.y;
        this.updatePreview();
      }
    }
    this.updateHint(me);
    this.consumeMouseEvent(mxEvent2.MOUSE_MOVE, me);
    mxEvent2.consume(me.getEvent());
  } else if ((this.isMoveEnabled() || this.isCloneEnabled()) && this.updateCursor && !me.isConsumed() && (me.getState() != null || me.sourceState != null) && !graph.isMouseDown) {
    var cursor = graph.getCursorForMouseEvent(me);
    if (cursor == null && graph.isEnabled() && graph.isCellMovable(me.getCell())) {
      if (graph.getModel().isEdge(me.getCell())) {
        cursor = mxConstants2.CURSOR_MOVABLE_EDGE;
      } else {
        cursor = mxConstants2.CURSOR_MOVABLE_VERTEX;
      }
    }
    if (cursor != null && me.sourceState != null) {
      me.sourceState.setCursor(cursor);
    }
  }
};
mxGraphHandler.prototype.updatePreview = function(remote) {
  if (this.livePreviewUsed && !remote) {
    if (this.cells != null) {
      this.setHandlesVisibleForCells(this.graph.selectionCellsHandler.getHandledSelectionCells(), false);
      this.updateLivePreview(this.currentDx, this.currentDy);
    }
  } else {
    this.updatePreviewShape();
  }
};
mxGraphHandler.prototype.updatePreviewShape = function() {
  if (this.shape != null && this.pBounds != null) {
    this.shape.bounds = new mxRectangle(Math.round(this.pBounds.x + this.currentDx), Math.round(this.pBounds.y + this.currentDy), this.pBounds.width, this.pBounds.height);
    this.shape.redraw();
  }
};
mxGraphHandler.prototype.updateLivePreview = function(dx, dy) {
  if (!this.suspended) {
    var states = [];
    if (this.allCells != null) {
      this.allCells.visit(bind(this, function(key, state3) {
        var realState = this.graph.view.getState(state3.cell);
        if (realState != state3) {
          state3.destroy();
          if (realState != null) {
            this.allCells.put(state3.cell, realState);
          } else {
            this.allCells.remove(state3.cell);
          }
          state3 = realState;
        }
        if (state3 != null) {
          var tempState = state3.clone();
          states.push([state3, tempState]);
          if (state3.shape != null) {
            if (state3.shape.originalPointerEvents == null) {
              state3.shape.originalPointerEvents = state3.shape.pointerEvents;
            }
            state3.shape.pointerEvents = false;
            if (state3.text != null) {
              if (state3.text.originalPointerEvents == null) {
                state3.text.originalPointerEvents = state3.text.pointerEvents;
              }
              state3.text.pointerEvents = false;
            }
          }
          if (this.graph.model.isVertex(state3.cell)) {
            state3.x += dx;
            state3.y += dy;
            if (!this.cloning) {
              state3.view.graph.cellRenderer.redraw(state3, true);
              state3.view.invalidate(state3.cell);
              state3.invalid = false;
              if (state3.control != null && state3.control.node != null) {
                state3.control.node.style.visibility = "hidden";
              }
            } else if (state3.text != null) {
              state3.text.updateBoundingBox();
              if (state3.text.boundingBox != null) {
                state3.text.boundingBox.x += dx;
                state3.text.boundingBox.y += dy;
              }
              if (state3.text.unrotatedBoundingBox != null) {
                state3.text.unrotatedBoundingBox.x += dx;
                state3.text.unrotatedBoundingBox.y += dy;
              }
            }
          }
        }
      }));
    }
    if (states.length == 0) {
      this.reset();
    } else {
      var s = this.graph.view.scale;
      for (var i = 0; i < states.length; i++) {
        var state2 = states[i][0];
        if (this.graph.model.isEdge(state2.cell)) {
          var geometry = this.graph.getCellGeometry(state2.cell);
          var points = [];
          if (geometry != null && geometry.points != null) {
            for (var j = 0; j < geometry.points.length; j++) {
              if (geometry.points[j] != null) {
                points.push(new mxPoint2(geometry.points[j].x + dx / s, geometry.points[j].y + dy / s));
              }
            }
          }
          var source = state2.visibleSourceState;
          var target = state2.visibleTargetState;
          var pts = states[i][1].absolutePoints;
          if (source == null || !this.isCellMoving(source.cell)) {
            var pt0 = pts[0];
            state2.setAbsoluteTerminalPoint(new mxPoint2(pt0.x + dx, pt0.y + dy), true);
            source = null;
          } else {
            state2.view.updateFixedTerminalPoint(state2, source, true, this.graph.getConnectionConstraint(state2, source, true));
          }
          if (target == null || !this.isCellMoving(target.cell)) {
            var ptn = pts[pts.length - 1];
            state2.setAbsoluteTerminalPoint(new mxPoint2(ptn.x + dx, ptn.y + dy), false);
            target = null;
          } else {
            state2.view.updateFixedTerminalPoint(state2, target, false, this.graph.getConnectionConstraint(state2, target, false));
          }
          state2.view.updatePoints(state2, points, source, target);
          state2.view.updateFloatingTerminalPoints(state2, source, target);
          state2.view.updateEdgeLabelOffset(state2);
          state2.invalid = false;
          if (!this.cloning) {
            state2.view.graph.cellRenderer.redraw(state2, true);
          }
        }
      }
      this.graph.view.validate();
      this.redrawHandles(states);
      this.resetPreviewStates(states);
    }
  }
};
mxGraphHandler.prototype.redrawHandles = function(states) {
  for (var i = 0; i < states.length; i++) {
    var handler = this.graph.selectionCellsHandler.getHandler(states[i][0].cell);
    if (handler != null) {
      handler.redraw(true);
    }
  }
};
mxGraphHandler.prototype.resetPreviewStates = function(states) {
  for (var i = 0; i < states.length; i++) {
    states[i][0].setState(states[i][1]);
  }
};
mxGraphHandler.prototype.suspend = function() {
  if (!this.suspended) {
    if (this.livePreviewUsed) {
      this.updateLivePreview(0, 0);
    }
    if (this.shape != null) {
      this.shape.node.style.visibility = "hidden";
    }
    if (this.guide != null) {
      this.guide.setVisible(false);
    }
    this.suspended = true;
  }
};
mxGraphHandler.prototype.resume = function() {
  if (this.suspended) {
    this.suspended = null;
    if (this.livePreviewUsed) {
      this.livePreviewActive = true;
    }
    if (this.shape != null) {
      this.shape.node.style.visibility = "visible";
    }
    if (this.guide != null) {
      this.guide.setVisible(true);
    }
  }
};
mxGraphHandler.prototype.resetLivePreview = function() {
  if (this.allCells != null) {
    this.allCells.visit(bind(this, function(key, state2) {
      if (state2.shape != null && state2.shape.originalPointerEvents != null) {
        state2.shape.pointerEvents = state2.shape.originalPointerEvents;
        state2.shape.originalPointerEvents = null;
        state2.shape.bounds = null;
        if (state2.text != null) {
          state2.text.pointerEvents = state2.text.originalPointerEvents;
          state2.text.originalPointerEvents = null;
        }
      }
      if (state2.control != null && state2.control.node != null && state2.control.node.style.visibility == "hidden") {
        state2.control.node.style.visibility = "";
      }
      if (!this.cloning) {
        if (state2.text != null) {
          state2.text.updateBoundingBox();
        }
      }
      state2.view.invalidate(state2.cell);
    }));
    this.graph.view.validate();
  }
};
mxGraphHandler.prototype.setHandlesVisibleForCells = function(cells, visible, force) {
  if (force || this.handlesVisible != visible) {
    this.handlesVisible = visible;
    for (var i = 0; i < cells.length; i++) {
      var handler = this.graph.selectionCellsHandler.getHandler(cells[i]);
      if (handler != null) {
        handler.setHandlesVisible(visible);
        if (visible) {
          handler.redraw();
        }
      }
    }
  }
};
mxGraphHandler.prototype.setHighlightColor = function(color) {
  if (this.highlight != null) {
    this.highlight.setHighlightColor(color);
  }
};
mxGraphHandler.prototype.mouseUp = function(sender, me) {
  if (!me.isConsumed()) {
    if (this.livePreviewUsed) {
      this.resetLivePreview();
    }
    if (this.cell != null && this.first != null && (this.shape != null || this.livePreviewUsed) && this.currentDx != null && this.currentDy != null) {
      var graph = this.graph;
      var cell2 = me.getCell();
      if (this.connectOnDrop && this.target == null && cell2 != null && graph.getModel().isVertex(cell2) && graph.isCellConnectable(cell2) && graph.isEdgeValid(null, this.cell, cell2)) {
        graph.connectionHandler.connect(this.cell, cell2, me.getEvent());
      } else {
        var clone3 = graph.isCloneEvent(me.getEvent()) && graph.isCellsCloneable() && this.isCloneEnabled();
        var scale = graph.getView().scale;
        var dx = this.roundLength(this.currentDx / scale);
        var dy = this.roundLength(this.currentDy / scale);
        var target = this.target;
        if (graph.isSplitEnabled() && graph.isSplitTarget(target, this.cells, me.getEvent())) {
          graph.splitEdge(target, this.cells, null, dx, dy, me.getGraphX(), me.getGraphY());
        } else {
          this.moveCells(this.cells, dx, dy, clone3, this.target, me.getEvent());
        }
      }
    } else if (this.isSelectEnabled() && this.delayedSelection && this.cell != null) {
      this.selectDelayed(me);
    }
  }
  if (this.cellWasClicked) {
    this.consumeMouseEvent(mxEvent2.MOUSE_UP, me);
  }
  this.reset();
};
mxGraphHandler.prototype.reset = function() {
  if (this.livePreviewUsed) {
    this.resetLivePreview();
    this.setHandlesVisibleForCells(this.graph.selectionCellsHandler.getHandledSelectionCells(), true);
  }
  this.destroyShapes();
  this.removeHint();
  this.delayedSelection = false;
  this.livePreviewActive = null;
  this.livePreviewUsed = null;
  this.cellWasClicked = false;
  this.suspended = null;
  this.currentDx = null;
  this.currentDy = null;
  this.cellCount = null;
  this.cloning = false;
  this.allCells = null;
  this.pBounds = null;
  this.guides = null;
  this.target = null;
  this.first = null;
  this.cells = null;
  this.cell = null;
};
mxGraphHandler.prototype.shouldRemoveCellsFromParent = function(parent2, cells, evt) {
  if (this.graph.getModel().isVertex(parent2)) {
    var pState = this.graph.getView().getState(parent2);
    if (pState != null) {
      var pt = convertPoint(this.graph.container, mxEvent2.getClientX(evt), mxEvent2.getClientY(evt));
      var alpha = toRadians(getValue(pState.style, mxConstants2.STYLE_ROTATION) || 0);
      if (alpha != 0) {
        var cos = Math.cos(-alpha);
        var sin = Math.sin(-alpha);
        var cx = new mxPoint2(pState.getCenterX(), pState.getCenterY());
        pt = getRotatedPoint(pt, cos, sin, cx);
      }
      return !contains(pState, pt.x, pt.y);
    }
  }
  return false;
};
mxGraphHandler.prototype.moveCells = function(cells, dx, dy, clone3, target, evt) {
  if (clone3) {
    cells = this.graph.getCloneableCells(cells);
  }
  var parent2 = this.graph.getModel().getParent(this.cell);
  if (target == null && this.isRemoveCellsFromParent() && this.shouldRemoveCellsFromParent(parent2, cells, evt)) {
    target = this.graph.getDefaultParent();
  }
  clone3 = clone3 && !this.graph.isCellLocked(target || this.graph.getDefaultParent());
  this.graph.getModel().beginUpdate();
  try {
    var parents = [];
    if (!clone3 && target != null && this.removeEmptyParents) {
      var dict = new mxDictionary();
      for (var i = 0; i < cells.length; i++) {
        dict.put(cells[i], true);
      }
      for (var i = 0; i < cells.length; i++) {
        var par = this.graph.model.getParent(cells[i]);
        if (par != null && !dict.get(par)) {
          dict.put(par, true);
          parents.push(par);
        }
      }
    }
    cells = this.graph.moveCells(cells, dx, dy, clone3, target, evt);
    var temp2 = [];
    for (var i = 0; i < parents.length; i++) {
      if (this.shouldRemoveParent(parents[i])) {
        temp2.push(parents[i]);
      }
    }
    this.graph.removeCells(temp2, false);
  } finally {
    this.graph.getModel().endUpdate();
  }
  if (clone3) {
    this.graph.setSelectionCells(cells);
  }
  if (this.isSelectEnabled() && this.scrollOnMove) {
    this.graph.scrollCellToVisible(cells[0]);
  }
};
mxGraphHandler.prototype.shouldRemoveParent = function(parent2) {
  var state2 = this.graph.view.getState(parent2);
  return state2 != null && (this.graph.model.isEdge(state2.cell) || this.graph.model.isVertex(state2.cell)) && this.graph.isCellDeletable(state2.cell) && this.graph.model.getChildCount(state2.cell) == 0 && this.graph.isTransparentState(state2);
};
mxGraphHandler.prototype.destroyShapes = function() {
  if (this.shape != null) {
    this.shape.destroy();
    this.shape = null;
  }
  if (this.guide != null) {
    this.guide.destroy();
    this.guide = null;
  }
  if (this.highlight != null) {
    this.highlight.destroy();
    this.highlight = null;
  }
};
mxGraphHandler.prototype.destroy = function() {
  this.graph.removeMouseListener(this);
  this.graph.removeListener(this.panHandler);
  if (this.escapeHandler != null) {
    this.graph.removeListener(this.escapeHandler);
    this.escapeHandler = null;
  }
  if (this.refreshHandler != null) {
    this.graph.getModel().removeListener(this.refreshHandler);
    this.graph.removeListener(this.refreshHandler);
    this.refreshHandler = null;
  }
  mxEvent2.removeListener(document, "keydown", this.keyHandler);
  mxEvent2.removeListener(document, "keyup", this.keyHandler);
  this.destroyShapes();
  this.removeHint();
};

// js/graph/mxEllipse.js
var mxEllipse = function(bounds, fill, stroke, strokewidth) {
  mxShape.call(this);
  this.bounds = bounds;
  this.fill = fill;
  this.stroke = stroke;
  this.strokewidth = strokewidth != null ? strokewidth : 1;
};
extend(mxEllipse, mxShape);
mxEllipse.prototype.paintVertexShape = function(c, x, y, w2, h2) {
  c.ellipse(x, y, w2, h2);
  c.fillAndStroke();
};
var mxDoubleEllipse = function(bounds, fill, stroke, strokewidth) {
  mxEllipse.call(this, bounds, fill, stroke, strokewidth);
};
extend(mxDoubleEllipse, mxEllipse);
mxDoubleEllipse.prototype.paintVertexShape = function(c, x, y, w2, h2) {
  c.ellipse(x, y, w2, h2);
  c.stroke();
  const inset = getValue(this.style, mxConstants2.STYLE_MARGIN, Math.min(3 + this.strokewidth, Math.min(w2 / 5, h2 / 5)));
  x += inset;
  y += inset;
  w2 -= 2 * inset;
  h2 -= 2 * inset;
  if (w2 > 0 && h2 > 0) {
    c.ellipse(x, y, w2, h2);
  }
  c.fillAndStroke();
};

// js/graph/mxVertexHandler.js
var mxVertexHandler2 = function(state2) {
  if (state2 != null) {
    this.state = state2;
    this.init();
    this.escapeHandler = bind(this, function(sender, evt) {
      if (this.livePreview && this.index != null) {
        this.state.view.graph.cellRenderer.redraw(this.state, true);
        this.state.view.invalidate(this.state.cell);
        this.state.invalid = false;
        this.state.view.validate();
      }
      this.reset();
    });
    this.state.view.graph.addListener(mxEvent2.ESCAPE, this.escapeHandler);
  }
};
mxVertexHandler2.prototype.graph = null;
mxVertexHandler2.prototype.state = null;
mxVertexHandler2.prototype.singleSizer = false;
mxVertexHandler2.prototype.index = null;
mxVertexHandler2.prototype.allowHandleBoundsCheck = true;
mxVertexHandler2.prototype.handleImage = null;
mxVertexHandler2.prototype.handlesVisible = true;
mxVertexHandler2.prototype.tolerance = 0;
mxVertexHandler2.prototype.rotationEnabled = false;
mxVertexHandler2.prototype.parentHighlightEnabled = false;
mxVertexHandler2.prototype.rotationRaster = true;
mxVertexHandler2.prototype.rotationCursor = "crosshair";
mxVertexHandler2.prototype.livePreview = false;
mxVertexHandler2.prototype.movePreviewToFront = false;
mxVertexHandler2.prototype.manageSizers = false;
mxVertexHandler2.prototype.constrainGroupByChildren = false;
mxVertexHandler2.prototype.rotationHandleVSpacing = -16;
mxVertexHandler2.prototype.horizontalOffset = 0;
mxVertexHandler2.prototype.verticalOffset = 0;
mxVertexHandler2.prototype.EMPTY_POINT = new mxPoint2();
mxVertexHandler2.prototype.init = function() {
  this.graph = this.state.view.graph;
  this.selectionBounds = this.getSelectionBounds(this.state);
  this.bounds = new mxRectangle(this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);
  this.selectionBorder = this.createSelectionShape(this.bounds);
  this.selectionBorder.dialect = this.graph.dialect != mxConstants2.DIALECT_SVG ? mxConstants2.DIALECT_VML : mxConstants2.DIALECT_SVG;
  this.selectionBorder.pointerEvents = false;
  this.selectionBorder.rotation = Number(this.state.style[mxConstants2.STYLE_ROTATION] || "0");
  this.selectionBorder.init(this.graph.getView().getOverlayPane());
  mxEvent2.redirectMouseEvents(this.selectionBorder.node, this.graph, this.state);
  if (this.graph.isCellMovable(this.state.cell)) {
    this.selectionBorder.setCursor(mxConstants2.CURSOR_MOVABLE_VERTEX);
  }
  if (mxGraphHandler.prototype.maxCells <= 0 || this.graph.getSelectionCount() < mxGraphHandler.prototype.maxCells) {
    const resizable = this.graph.isCellResizable(this.state.cell);
    this.sizers = [];
    if (resizable || this.graph.isLabelMovable(this.state.cell) && this.state.width >= 2 && this.state.height >= 2) {
      let i = 0;
      if (resizable) {
        if (!this.singleSizer) {
          this.sizers.push(this.createSizer("nw-resize", i++));
          this.sizers.push(this.createSizer("n-resize", i++));
          this.sizers.push(this.createSizer("ne-resize", i++));
          this.sizers.push(this.createSizer("w-resize", i++));
          this.sizers.push(this.createSizer("e-resize", i++));
          this.sizers.push(this.createSizer("sw-resize", i++));
          this.sizers.push(this.createSizer("s-resize", i++));
        }
        this.sizers.push(this.createSizer("se-resize", i++));
      }
      const geo = this.graph.model.getGeometry(this.state.cell);
      if (geo != null && !geo.relative && !this.graph.isSwimlane(this.state.cell) && this.graph.isLabelMovable(this.state.cell)) {
        this.labelShape = this.createSizer(mxConstants2.CURSOR_LABEL_HANDLE, mxEvent2.LABEL_HANDLE, mxConstants2.LABEL_HANDLE_SIZE, mxConstants2.LABEL_HANDLE_FILLCOLOR);
        this.sizers.push(this.labelShape);
      }
    } else if (this.graph.isCellMovable(this.state.cell) && !this.graph.isCellResizable(this.state.cell) && this.state.width < 2 && this.state.height < 2) {
      this.labelShape = this.createSizer(mxConstants2.CURSOR_MOVABLE_VERTEX, mxEvent2.LABEL_HANDLE, null, mxConstants2.LABEL_HANDLE_FILLCOLOR);
      this.sizers.push(this.labelShape);
    }
  }
  if (this.isRotationHandleVisible()) {
    this.rotationShape = this.createSizer(this.rotationCursor, mxEvent2.ROTATION_HANDLE, mxConstants2.HANDLE_SIZE + 3, mxConstants2.HANDLE_FILLCOLOR);
    this.sizers.push(this.rotationShape);
  }
  this.customHandles = this.createCustomHandles();
  this.redraw();
  if (this.constrainGroupByChildren) {
    this.updateMinBounds();
  }
};
mxVertexHandler2.prototype.isRotationHandleVisible = function() {
  return this.graph.isEnabled() && this.rotationEnabled && this.graph.isCellRotatable(this.state.cell) && (mxGraphHandler.prototype.maxCells <= 0 || this.graph.getSelectionCount() < mxGraphHandler.prototype.maxCells);
};
mxVertexHandler2.prototype.isConstrainedEvent = function(me) {
  return mxEvent2.isShiftDown(me.getEvent()) || this.state.style[mxConstants2.STYLE_ASPECT] == "fixed";
};
mxVertexHandler2.prototype.isCenteredEvent = function(state2, me) {
  return false;
};
mxVertexHandler2.prototype.createCustomHandles = function() {
  return null;
};
mxVertexHandler2.prototype.updateMinBounds = function() {
  const children = this.graph.getChildCells(this.state.cell);
  if (children.length > 0) {
    this.minBounds = this.graph.view.getBounds(children);
    if (this.minBounds != null) {
      const s = this.state.view.scale;
      const t = this.state.view.translate;
      this.minBounds.x -= this.state.x;
      this.minBounds.y -= this.state.y;
      this.minBounds.x /= s;
      this.minBounds.y /= s;
      this.minBounds.width /= s;
      this.minBounds.height /= s;
      this.x0 = this.state.x / s - t.x;
      this.y0 = this.state.y / s - t.y;
    }
  }
};
mxVertexHandler2.prototype.getSelectionBounds = function(state2) {
  return new mxRectangle(Math.round(state2.x), Math.round(state2.y), Math.round(state2.width), Math.round(state2.height));
};
mxVertexHandler2.prototype.createParentHighlightShape = function(bounds) {
  return this.createSelectionShape(bounds);
};
mxVertexHandler2.prototype.createSelectionShape = function(bounds) {
  const shape = new mxRectangleShape(mxRectangle.fromRectangle(bounds), null, this.getSelectionColor());
  shape.strokewidth = this.getSelectionStrokeWidth();
  shape.isDashed = this.isSelectionDashed();
  return shape;
};
mxVertexHandler2.prototype.getSelectionColor = function() {
  return mxConstants2.VERTEX_SELECTION_COLOR;
};
mxVertexHandler2.prototype.getSelectionStrokeWidth = function() {
  return mxConstants2.VERTEX_SELECTION_STROKEWIDTH;
};
mxVertexHandler2.prototype.isSelectionDashed = function() {
  return mxConstants2.VERTEX_SELECTION_DASHED;
};
mxVertexHandler2.prototype.createSizer = function(cursor, index, size, fillColor) {
  size = size || mxConstants2.HANDLE_SIZE;
  const bounds = new mxRectangle(0, 0, size, size);
  const sizer = this.createSizerShape(bounds, index, fillColor);
  if (sizer.isHtmlAllowed() && this.state.text != null && this.state.text.node.parentNode == this.graph.container) {
    sizer.bounds.height -= 1;
    sizer.bounds.width -= 1;
    sizer.dialect = mxConstants2.DIALECT_STRICTHTML;
    sizer.init(this.graph.container);
  } else {
    sizer.dialect = this.graph.dialect != mxConstants2.DIALECT_SVG ? mxConstants2.DIALECT_MIXEDHTML : mxConstants2.DIALECT_SVG;
    sizer.init(this.graph.getView().getOverlayPane());
  }
  mxEvent2.redirectMouseEvents(sizer.node, this.graph, this.state);
  if (this.graph.isEnabled()) {
    sizer.setCursor(cursor);
  }
  if (!this.isSizerVisible(index)) {
    sizer.visible = false;
  }
  return sizer;
};
mxVertexHandler2.prototype.isSizerVisible = function(index) {
  return true;
};
mxVertexHandler2.prototype.createSizerShape = function(bounds, index, fillColor) {
  if (this.handleImage != null) {
    bounds = new mxRectangle(bounds.x, bounds.y, this.handleImage.width, this.handleImage.height);
    const shape = new mxImageShape(bounds, this.handleImage.src);
    shape.preserveImageAspect = false;
    return shape;
  } else if (index == mxEvent2.ROTATION_HANDLE) {
    return new mxEllipse(bounds, fillColor || mxConstants2.HANDLE_FILLCOLOR, mxConstants2.HANDLE_STROKECOLOR);
  } else {
    return new mxRectangleShape(bounds, fillColor || mxConstants2.HANDLE_FILLCOLOR, mxConstants2.HANDLE_STROKECOLOR);
  }
};
mxVertexHandler2.prototype.moveSizerTo = function(shape, x, y) {
  if (shape != null) {
    shape.bounds.x = Math.floor(x - shape.bounds.width / 2);
    shape.bounds.y = Math.floor(y - shape.bounds.height / 2);
    if (shape.node != null && shape.node.style.display != "none") {
      shape.redraw();
    }
  }
};
mxVertexHandler2.prototype.getHandleForEvent = function(me) {
  const tol = !mxEvent2.isMouseEvent(me.getEvent()) ? this.tolerance : 1;
  const hit = this.allowHandleBoundsCheck && (mxClient_default.IS_IE || tol > 0) ? new mxRectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol) : null;
  const checkShape = bind(this, function(shape) {
    const st = shape != null && shape.constructor != mxImageShape && this.allowHandleBoundsCheck ? shape.strokewidth + shape.svgStrokeTolerance : null;
    const real = st != null ? new mxRectangle(me.getGraphX() - Math.floor(st / 2), me.getGraphY() - Math.floor(st / 2), st, st) : hit;
    return shape != null && (me.isSource(shape) || real != null && intersects(shape.bounds, real) && shape.node.style.display != "none" && shape.node.style.visibility != "hidden");
  });
  if (checkShape(this.rotationShape)) {
    return mxEvent2.ROTATION_HANDLE;
  } else if (checkShape(this.labelShape)) {
    return mxEvent2.LABEL_HANDLE;
  }
  if (this.sizers != null) {
    for (let i = 0; i < this.sizers.length; i++) {
      if (checkShape(this.sizers[i])) {
        return i;
      }
    }
  }
  if (this.customHandles != null && this.isCustomHandleEvent(me)) {
    for (let i = this.customHandles.length - 1; i >= 0; i--) {
      if (checkShape(this.customHandles[i].shape)) {
        return mxEvent2.CUSTOM_HANDLE - i;
      }
    }
  }
  return null;
};
mxVertexHandler2.prototype.isCustomHandleEvent = function(me) {
  return true;
};
mxVertexHandler2.prototype.mouseDown = function(sender, me) {
  if (!me.isConsumed() && this.graph.isEnabled()) {
    const handle = this.getHandleForEvent(me);
    if (handle != null) {
      this.start(me.getGraphX(), me.getGraphY(), handle);
      me.consume();
    }
  }
};
mxVertexHandler2.prototype.isLivePreviewBorder = function() {
  return this.state.shape != null && this.state.shape.fill == null && this.state.shape.stroke == null;
};
mxVertexHandler2.prototype.start = function(x, y, index) {
  if (this.selectionBorder != null) {
    this.livePreviewActive = this.livePreview && this.graph.model.getChildCount(this.state.cell) == 0;
    this.inTolerance = true;
    this.childOffsetX = 0;
    this.childOffsetY = 0;
    this.index = index;
    this.startX = x;
    this.startY = y;
    if (this.index <= mxEvent2.CUSTOM_HANDLE && this.isGhostPreview()) {
      this.ghostPreview = this.createGhostPreview();
    } else {
      const model = this.state.view.graph.model;
      const parent2 = model.getParent(this.state.cell);
      if (this.state.view.currentRoot != parent2 && (model.isVertex(parent2) || model.isEdge(parent2))) {
        this.parentState = this.state.view.graph.view.getState(parent2);
      }
      this.selectionBorder.node.style.display = index == mxEvent2.ROTATION_HANDLE ? "inline" : "none";
      if (!this.livePreviewActive || this.isLivePreviewBorder()) {
        this.preview = this.createSelectionShape(this.bounds);
        if (!(mxClient_default.IS_SVG && Number(this.state.style[mxConstants2.STYLE_ROTATION] || "0") != 0) && this.state.text != null && this.state.text.node.parentNode == this.graph.container) {
          this.preview.dialect = mxConstants2.DIALECT_STRICTHTML;
          this.preview.init(this.graph.container);
        } else {
          this.preview.dialect = this.graph.dialect != mxConstants2.DIALECT_SVG ? mxConstants2.DIALECT_VML : mxConstants2.DIALECT_SVG;
          this.preview.init(this.graph.view.getOverlayPane());
        }
      }
      if (index == mxEvent2.ROTATION_HANDLE) {
        const pos = this.getRotationHandlePosition();
        const dx = pos.x - this.state.getCenterX();
        const dy = pos.y - this.state.getCenterY();
        this.startAngle = dx != 0 ? Math.atan(dy / dx) * 180 / Math.PI + 90 : 0;
        this.startDist = Math.sqrt(dx * dx + dy * dy);
      }
      if (this.livePreviewActive) {
        this.hideSizers();
        if (index == mxEvent2.ROTATION_HANDLE) {
          this.rotationShape.node.style.display = "";
        } else if (index == mxEvent2.LABEL_HANDLE) {
          this.labelShape.node.style.display = "";
        } else if (this.sizers != null && this.sizers[index] != null) {
          this.sizers[index].node.style.display = "";
        } else if (index <= mxEvent2.CUSTOM_HANDLE && this.customHandles != null) {
          this.customHandles[mxEvent2.CUSTOM_HANDLE - index].setVisible(true);
        }
        const edges = this.graph.getEdges(this.state.cell);
        this.edgeHandlers = [];
        for (let i = 0; i < edges.length; i++) {
          const handler = this.graph.selectionCellsHandler.getHandler(edges[i]);
          if (handler != null) {
            this.edgeHandlers.push(handler);
          }
        }
      }
    }
  }
};
mxVertexHandler2.prototype.createGhostPreview = function() {
  const shape = this.graph.cellRenderer.createShape(this.state);
  shape.init(this.graph.view.getOverlayPane());
  shape.scale = this.state.view.scale;
  shape.bounds = this.bounds;
  shape.outline = true;
  return shape;
};
mxVertexHandler2.prototype.setHandlesVisible = function(visible) {
  this.handlesVisible = visible;
  if (this.sizers != null) {
    for (let i = 0; i < this.sizers.length; i++) {
      this.sizers[i].node.style.display = visible ? "" : "none";
    }
  }
  if (this.customHandles != null) {
    for (let i = 0; i < this.customHandles.length; i++) {
      this.customHandles[i].setVisible(visible);
    }
  }
};
mxVertexHandler2.prototype.hideSizers = function() {
  this.setHandlesVisible(false);
};
mxVertexHandler2.prototype.checkTolerance = function(me) {
  if (this.inTolerance && this.startX != null && this.startY != null) {
    if (mxEvent2.isMouseEvent(me.getEvent()) || Math.abs(me.getGraphX() - this.startX) > this.graph.tolerance || Math.abs(me.getGraphY() - this.startY) > this.graph.tolerance) {
      this.inTolerance = false;
    }
  }
};
mxVertexHandler2.prototype.updateHint = function(me) {
};
mxVertexHandler2.prototype.removeHint = function() {
};
mxVertexHandler2.prototype.roundAngle = function(angle) {
  return Math.round(angle * 10) / 10;
};
mxVertexHandler2.prototype.roundLength = function(length) {
  return Math.round(length * 100) / 100;
};
mxVertexHandler2.prototype.mouseMove = function(sender, me) {
  if (!me.isConsumed() && this.index != null) {
    this.checkTolerance(me);
    if (!this.inTolerance) {
      if (this.index <= mxEvent2.CUSTOM_HANDLE) {
        if (this.customHandles != null) {
          this.customHandles[mxEvent2.CUSTOM_HANDLE - this.index].processEvent(me);
          this.customHandles[mxEvent2.CUSTOM_HANDLE - this.index].active = true;
          if (this.ghostPreview != null) {
            this.ghostPreview.apply(this.state);
            this.ghostPreview.strokewidth = this.getSelectionStrokeWidth() / this.ghostPreview.scale / this.ghostPreview.scale;
            this.ghostPreview.isDashed = this.isSelectionDashed();
            this.ghostPreview.stroke = this.getSelectionColor();
            this.ghostPreview.redraw();
            if (this.selectionBounds != null) {
              this.selectionBorder.node.style.display = "none";
            }
          } else {
            if (this.movePreviewToFront) {
              this.moveToFront();
            }
            this.customHandles[mxEvent2.CUSTOM_HANDLE - this.index].positionChanged();
          }
        }
      } else if (this.index == mxEvent2.LABEL_HANDLE) {
        this.moveLabel(me);
      } else {
        if (this.index == mxEvent2.ROTATION_HANDLE) {
          this.rotateVertex(me);
        } else {
          this.resizeVertex(me);
        }
        this.updateHint(me);
      }
    }
    me.consume();
  } else if (!this.graph.isMouseDown && this.getHandleForEvent(me) != null) {
    me.consume(false);
  }
};
mxVertexHandler2.prototype.isGhostPreview = function() {
  return this.state.view.graph.model.getChildCount(this.state.cell) > 0;
};
mxVertexHandler2.prototype.moveLabel = function(me) {
  const point = new mxPoint2(me.getGraphX(), me.getGraphY());
  const tr = this.graph.view.translate;
  const scale = this.graph.view.scale;
  if (this.graph.isGridEnabledEvent(me.getEvent())) {
    point.x = (this.graph.snap(point.x / scale - tr.x) + tr.x) * scale;
    point.y = (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale;
  }
  const index = this.rotationShape != null ? this.sizers.length - 2 : this.sizers.length - 1;
  this.moveSizerTo(this.sizers[index], point.x, point.y);
};
mxVertexHandler2.prototype.rotateVertex = function(me) {
  const point = new mxPoint2(me.getGraphX(), me.getGraphY());
  let dx = this.state.x + this.state.width / 2 - point.x;
  let dy = this.state.y + this.state.height / 2 - point.y;
  this.currentAlpha = dx != 0 ? Math.atan(dy / dx) * 180 / Math.PI + 90 : dy < 0 ? 180 : 0;
  if (dx > 0) {
    this.currentAlpha -= 180;
  }
  this.currentAlpha -= this.startAngle;
  if (this.rotationRaster && this.graph.isGridEnabledEvent(me.getEvent())) {
    const dx_raster = point.x - this.state.getCenterX();
    const dy_raster = point.y - this.state.getCenterY();
    const dist = Math.sqrt(dx_raster * dx_raster + dy_raster * dy_raster);
    let raster;
    if (dist - this.startDist < 2) {
      raster = 15;
    } else if (dist - this.startDist < 25) {
      raster = 5;
    } else {
      raster = 1;
    }
    this.currentAlpha = Math.round(this.currentAlpha / raster) * raster;
  } else {
    this.currentAlpha = this.roundAngle(this.currentAlpha);
  }
  this.selectionBorder.rotation = this.currentAlpha;
  this.selectionBorder.redraw();
  if (this.livePreviewActive) {
    this.redrawHandles();
  }
};
mxVertexHandler2.prototype.resizeVertex = function(me) {
  const ct = new mxPoint2(this.state.getCenterX(), this.state.getCenterY());
  const alpha = toRadians(this.state.style[mxConstants2.STYLE_ROTATION] || "0");
  const point = new mxPoint2(me.getGraphX(), me.getGraphY());
  const tr = this.graph.view.translate;
  const scale = this.graph.view.scale;
  let cos = Math.cos(-alpha);
  let sin = Math.sin(-alpha);
  let dx = point.x - this.startX;
  let dy = point.y - this.startY;
  const tx = cos * dx - sin * dy;
  const ty = sin * dx + cos * dy;
  dx = tx;
  dy = ty;
  const geo = this.graph.getCellGeometry(this.state.cell);
  this.unscaledBounds = this.union(geo, dx / scale, dy / scale, this.index, this.graph.isGridEnabledEvent(me.getEvent()), 1, new mxPoint2(0, 0), this.isConstrainedEvent(me), this.isCenteredEvent(this.state, me));
  if (!geo.relative) {
    let max = this.graph.getMaximumGraphBounds();
    if (max != null && this.parentState != null) {
      max = mxRectangle.fromRectangle(max);
      max.x -= (this.parentState.x - tr.x * scale) / scale;
      max.y -= (this.parentState.y - tr.y * scale) / scale;
    }
    if (this.graph.isConstrainChild(this.state.cell)) {
      let tmp = this.graph.getCellContainmentArea(this.state.cell);
      if (tmp != null) {
        const overlap = this.graph.getOverlap(this.state.cell);
        if (overlap > 0) {
          tmp = mxRectangle.fromRectangle(tmp);
          tmp.x -= tmp.width * overlap;
          tmp.y -= tmp.height * overlap;
          tmp.width += 2 * tmp.width * overlap;
          tmp.height += 2 * tmp.height * overlap;
        }
        if (max == null) {
          max = tmp;
        } else {
          max = mxRectangle.fromRectangle(max);
          max.intersect(tmp);
        }
      }
    }
    if (max != null) {
      if (this.unscaledBounds.x < max.x) {
        this.unscaledBounds.width -= max.x - this.unscaledBounds.x;
        this.unscaledBounds.x = max.x;
      }
      if (this.unscaledBounds.y < max.y) {
        this.unscaledBounds.height -= max.y - this.unscaledBounds.y;
        this.unscaledBounds.y = max.y;
      }
      if (this.unscaledBounds.x + this.unscaledBounds.width > max.x + max.width) {
        this.unscaledBounds.width -= this.unscaledBounds.x + this.unscaledBounds.width - max.x - max.width;
      }
      if (this.unscaledBounds.y + this.unscaledBounds.height > max.y + max.height) {
        this.unscaledBounds.height -= this.unscaledBounds.y + this.unscaledBounds.height - max.y - max.height;
      }
    }
  }
  const old = this.bounds;
  this.bounds = new mxRectangle((this.parentState != null ? this.parentState.x : tr.x * scale) + this.unscaledBounds.x * scale, (this.parentState != null ? this.parentState.y : tr.y * scale) + this.unscaledBounds.y * scale, this.unscaledBounds.width * scale, this.unscaledBounds.height * scale);
  if (geo.relative && this.parentState != null) {
    this.bounds.x += this.state.x - this.parentState.x;
    this.bounds.y += this.state.y - this.parentState.y;
  }
  cos = Math.cos(alpha);
  sin = Math.sin(alpha);
  const c2 = new mxPoint2(this.bounds.getCenterX(), this.bounds.getCenterY());
  const rotDx = c2.x - ct.x;
  const rotDy = c2.y - ct.y;
  const rotDx2 = cos * rotDx - sin * rotDy;
  const rotDy2 = sin * rotDx + cos * rotDy;
  const rotDx3 = rotDx2 - rotDx;
  const rotDy3 = rotDy2 - rotDy;
  const bDx4 = this.bounds.x - this.state.x;
  const bDy4 = this.bounds.y - this.state.y;
  const bDx5 = cos * bDx4 - sin * bDy4;
  const bDy5 = sin * bDx4 + cos * bDy4;
  this.bounds.x += rotDx3;
  this.bounds.y += rotDy3;
  this.unscaledBounds.x = this.roundLength(this.unscaledBounds.x + rotDx3 / scale);
  this.unscaledBounds.y = this.roundLength(this.unscaledBounds.y + rotDy3 / scale);
  this.unscaledBounds.width = this.roundLength(this.unscaledBounds.width);
  this.unscaledBounds.height = this.roundLength(this.unscaledBounds.height);
  if (!this.graph.isCellCollapsed(this.state.cell) && (rotDx3 != 0 || rotDy3 != 0)) {
    this.childOffsetX = this.state.x - this.bounds.x + bDx5;
    this.childOffsetY = this.state.y - this.bounds.y + bDy5;
  } else {
    this.childOffsetX = 0;
    this.childOffsetY = 0;
  }
  if (!old.equals(this.bounds)) {
    if (this.livePreviewActive) {
      this.updateLivePreview(me);
    }
    if (this.preview != null) {
      this.drawPreview();
    } else {
      this.updateParentHighlight();
    }
  }
};
mxVertexHandler2.prototype.updateLivePreview = function(me) {
  const scale = this.graph.view.scale;
  const tr = this.graph.view.translate;
  const tempState = this.state.clone();
  this.state.x = this.bounds.x;
  this.state.y = this.bounds.y;
  this.state.origin = new mxPoint2(this.state.x / scale - tr.x, this.state.y / scale - tr.y);
  this.state.width = this.bounds.width;
  this.state.height = this.bounds.height;
  let off = this.state.absoluteOffset;
  off = new mxPoint2(off.x, off.y);
  this.state.absoluteOffset.x = 0;
  this.state.absoluteOffset.y = 0;
  const geo = this.graph.getCellGeometry(this.state.cell);
  if (geo != null) {
    const offset = geo.offset || this.EMPTY_POINT;
    if (offset != null && !geo.relative) {
      this.state.absoluteOffset.x = this.state.view.scale * offset.x;
      this.state.absoluteOffset.y = this.state.view.scale * offset.y;
    }
    this.state.view.updateVertexLabelOffset(this.state);
  }
  this.state.view.graph.cellRenderer.redraw(this.state, true);
  this.state.view.invalidate(this.state.cell);
  this.state.invalid = false;
  this.state.view.validate();
  this.redrawHandles();
  if (this.movePreviewToFront) {
    this.moveToFront();
  }
  if (this.state.control != null && this.state.control.node != null) {
    this.state.control.node.style.visibility = "hidden";
  }
  this.state.setState(tempState);
};
mxVertexHandler2.prototype.moveToFront = function() {
  if (this.state.text != null && this.state.text.node != null && this.state.text.node.nextSibling != null || this.state.shape != null && this.state.shape.node != null && this.state.shape.node.nextSibling != null && (this.state.text == null || this.state.shape.node.nextSibling != this.state.text.node)) {
    if (this.state.shape != null && this.state.shape.node != null) {
      this.state.shape.node.parentNode.appendChild(this.state.shape.node);
    }
    if (this.state.text != null && this.state.text.node != null) {
      this.state.text.node.parentNode.appendChild(this.state.text.node);
    }
  }
};
mxVertexHandler2.prototype.mouseUp = function(sender, me) {
  if (this.index != null && this.state != null) {
    const point = new mxPoint2(me.getGraphX(), me.getGraphY());
    const index = this.index;
    this.index = null;
    if (this.ghostPreview == null) {
      this.state.view.invalidate(this.state.cell, false, false);
      this.state.view.validate();
    }
    this.graph.getModel().beginUpdate();
    try {
      if (index <= mxEvent2.CUSTOM_HANDLE) {
        if (this.customHandles != null) {
          const style = this.state.view.graph.getCellStyle(this.state.cell);
          this.customHandles[mxEvent2.CUSTOM_HANDLE - index].active = false;
          this.customHandles[mxEvent2.CUSTOM_HANDLE - index].execute(me);
          if (this.customHandles != null && this.customHandles[mxEvent2.CUSTOM_HANDLE - index] != null) {
            this.state.style = style;
            this.customHandles[mxEvent2.CUSTOM_HANDLE - index].positionChanged();
          }
        }
      } else if (index == mxEvent2.ROTATION_HANDLE) {
        if (this.currentAlpha != null) {
          const delta = this.currentAlpha - (this.state.style[mxConstants2.STYLE_ROTATION] || 0);
          if (delta != 0) {
            this.rotateCell(this.state.cell, delta);
          }
        } else {
          this.rotateClick();
        }
      } else {
        const gridEnabled = this.graph.isGridEnabledEvent(me.getEvent());
        const alpha = toRadians(this.state.style[mxConstants2.STYLE_ROTATION] || "0");
        const cos = Math.cos(-alpha);
        const sin = Math.sin(-alpha);
        let dx = point.x - this.startX;
        let dy = point.y - this.startY;
        const tx = cos * dx - sin * dy;
        const ty = sin * dx + cos * dy;
        dx = tx;
        dy = ty;
        const s = this.graph.view.scale;
        const recurse = this.isRecursiveResize(this.state, me);
        this.resizeCell(this.state.cell, this.roundLength(dx / s), this.roundLength(dy / s), index, gridEnabled, this.isConstrainedEvent(me), recurse);
      }
    } finally {
      this.graph.getModel().endUpdate();
    }
    me.consume();
    this.reset();
    this.redrawHandles();
  }
};
mxVertexHandler2.prototype.isRecursiveResize = function(state2, me) {
  return this.graph.isRecursiveResize(this.state);
};
mxVertexHandler2.prototype.rotateClick = function() {
};
mxVertexHandler2.prototype.rotateCell = function(cell2, angle, parent2) {
  if (angle != 0) {
    const model = this.graph.getModel();
    if (model.isVertex(cell2) || model.isEdge(cell2)) {
      if (!model.isEdge(cell2)) {
        const style = this.graph.getCurrentCellStyle(cell2);
        const total = (style[mxConstants2.STYLE_ROTATION] || 0) + angle;
        this.graph.setCellStyles(mxConstants2.STYLE_ROTATION, total, [cell2]);
      }
      let geo = this.graph.getCellGeometry(cell2);
      if (geo != null) {
        const pgeo = this.graph.getCellGeometry(parent2);
        if (pgeo != null && !model.isEdge(parent2)) {
          geo = geo.clone();
          geo.rotate(angle, new mxPoint2(pgeo.width / 2, pgeo.height / 2));
          model.setGeometry(cell2, geo);
        }
        if (model.isVertex(cell2) && !geo.relative || model.isEdge(cell2)) {
          const childCount = model.getChildCount(cell2);
          for (let i = 0; i < childCount; i++) {
            this.rotateCell(model.getChildAt(cell2, i), angle, cell2);
          }
        }
      }
    }
  }
};
mxVertexHandler2.prototype.reset = function() {
  if (this.sizers != null && this.index != null && this.sizers[this.index] != null && this.sizers[this.index].node.style.display == "none") {
    this.sizers[this.index].node.style.display = "";
  }
  this.currentAlpha = null;
  this.inTolerance = null;
  this.index = null;
  if (this.preview != null) {
    this.preview.destroy();
    this.preview = null;
  }
  if (this.ghostPreview != null) {
    this.ghostPreview.destroy();
    this.ghostPreview = null;
  }
  if (this.livePreviewActive && this.sizers != null) {
    for (let i = 0; i < this.sizers.length; i++) {
      if (this.sizers[i] != null) {
        this.sizers[i].node.style.display = "";
      }
    }
    if (this.state.control != null && this.state.control.node != null) {
      this.state.control.node.style.visibility = "";
    }
  }
  if (this.customHandles != null) {
    for (let i = 0; i < this.customHandles.length; i++) {
      if (this.customHandles[i].active) {
        this.customHandles[i].active = false;
        this.customHandles[i].reset();
      } else {
        this.customHandles[i].setVisible(true);
      }
    }
  }
  if (this.selectionBorder != null) {
    this.selectionBorder.node.style.display = "inline";
    this.selectionBounds = this.getSelectionBounds(this.state);
    this.bounds = new mxRectangle(this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);
    this.drawPreview();
  }
  this.removeHint();
  this.redrawHandles();
  this.edgeHandlers = null;
  this.handlesVisible = true;
  this.unscaledBounds = null;
  this.livePreviewActive = null;
};
mxVertexHandler2.prototype.resizeCell = function(cell2, dx, dy, index, gridEnabled, constrained, recurse) {
  let geo = this.graph.model.getGeometry(cell2);
  if (geo != null) {
    if (index == mxEvent2.LABEL_HANDLE) {
      const alpha = -toRadians(this.state.style[mxConstants2.STYLE_ROTATION] || "0");
      const cos = Math.cos(alpha);
      const sin = Math.sin(alpha);
      const scale = this.graph.view.scale;
      const pt = getRotatedPoint(new mxPoint2(Math.round((this.labelShape.bounds.getCenterX() - this.startX) / scale), Math.round((this.labelShape.bounds.getCenterY() - this.startY) / scale)), cos, sin);
      geo = geo.clone();
      if (geo.offset == null) {
        geo.offset = pt;
      } else {
        geo.offset.x += pt.x;
        geo.offset.y += pt.y;
      }
      this.graph.model.setGeometry(cell2, geo);
    } else if (this.unscaledBounds != null) {
      const scale = this.graph.view.scale;
      if (this.childOffsetX != 0 || this.childOffsetY != 0) {
        this.moveChildren(cell2, Math.round(this.childOffsetX / scale), Math.round(this.childOffsetY / scale));
      }
      this.graph.resizeCell(cell2, this.unscaledBounds, recurse);
    }
  }
};
mxVertexHandler2.prototype.moveChildren = function(cell2, dx, dy) {
  const model = this.graph.getModel();
  const childCount = model.getChildCount(cell2);
  for (let i = 0; i < childCount; i++) {
    const child = model.getChildAt(cell2, i);
    let geo = this.graph.getCellGeometry(child);
    if (geo != null) {
      geo = geo.clone();
      geo.translate(dx, dy);
      model.setGeometry(child, geo);
    }
  }
};
mxVertexHandler2.prototype.union = function(bounds, dx, dy, index, gridEnabled, scale, tr, constrained, centered) {
  gridEnabled = gridEnabled != null ? gridEnabled && this.graph.gridEnabled : this.graph.gridEnabled;
  if (this.singleSizer) {
    let x = bounds.x + bounds.width + dx;
    let y = bounds.y + bounds.height + dy;
    if (gridEnabled) {
      x = this.graph.snap(x / scale) * scale;
      y = this.graph.snap(y / scale) * scale;
    }
    const rect = new mxRectangle(bounds.x, bounds.y, 0, 0);
    rect.add(new mxRectangle(x, y, 0, 0));
    return rect;
  } else {
    const w0 = bounds.width;
    const h0 = bounds.height;
    let left = bounds.x - tr.x * scale;
    let right = left + w0;
    let top = bounds.y - tr.y * scale;
    let bottom = top + h0;
    const cx = left + w0 / 2;
    const cy = top + h0 / 2;
    if (index > 4) {
      bottom = bottom + dy;
      if (gridEnabled) {
        bottom = this.graph.snap(bottom / scale) * scale;
      } else {
        bottom = Math.round(bottom / scale) * scale;
      }
    } else if (index < 3) {
      top = top + dy;
      if (gridEnabled) {
        top = this.graph.snap(top / scale) * scale;
      } else {
        top = Math.round(top / scale) * scale;
      }
    }
    if (index == 0 || index == 3 || index == 5) {
      left += dx;
      if (gridEnabled) {
        left = this.graph.snap(left / scale) * scale;
      } else {
        left = Math.round(left / scale) * scale;
      }
    } else if (index == 2 || index == 4 || index == 7) {
      right += dx;
      if (gridEnabled) {
        right = this.graph.snap(right / scale) * scale;
      } else {
        right = Math.round(right / scale) * scale;
      }
    }
    let width = right - left;
    let height = bottom - top;
    if (constrained) {
      const geo = this.graph.getCellGeometry(this.state.cell);
      if (geo != null) {
        const aspect = geo.width / geo.height;
        if (index == 1 || index == 2 || index == 7 || index == 6) {
          width = height * aspect;
        } else {
          height = width / aspect;
        }
        if (index == 0) {
          left = right - width;
          top = bottom - height;
        }
      }
    }
    if (centered) {
      width += width - w0;
      height += height - h0;
      const cdx = cx - (left + width / 2);
      const cdy = cy - (top + height / 2);
      left += cdx;
      top += cdy;
      right += cdx;
      bottom += cdy;
    }
    if (width < 0) {
      left += width;
      width = Math.abs(width);
    }
    if (height < 0) {
      top += height;
      height = Math.abs(height);
    }
    const result2 = new mxRectangle(left + tr.x * scale, top + tr.y * scale, width, height);
    if (this.minBounds != null) {
      result2.width = Math.max(result2.width, this.minBounds.x * scale + this.minBounds.width * scale + Math.max(0, this.x0 * scale - result2.x));
      result2.height = Math.max(result2.height, this.minBounds.y * scale + this.minBounds.height * scale + Math.max(0, this.y0 * scale - result2.y));
    }
    return result2;
  }
};
mxVertexHandler2.prototype.redraw = function(ignoreHandles) {
  this.selectionBounds = this.getSelectionBounds(this.state);
  this.bounds = new mxRectangle(this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);
  this.drawPreview();
  if (!ignoreHandles) {
    this.redrawHandles();
  }
};
mxVertexHandler2.prototype.getHandlePadding = function() {
  const result2 = new mxPoint2(0, 0);
  let tol = this.tolerance;
  if (this.sizers != null && this.sizers.length > 0 && this.sizers[0] != null && (this.bounds.width < 2 * this.sizers[0].bounds.width + 2 * tol || this.bounds.height < 2 * this.sizers[0].bounds.height + 2 * tol)) {
    tol /= 2;
    result2.x = this.sizers[0].bounds.width + tol;
    result2.y = this.sizers[0].bounds.height + tol;
  }
  return result2;
};
mxVertexHandler2.prototype.getSizerBounds = function() {
  return this.bounds;
};
mxVertexHandler2.prototype.redrawHandles = function() {
  let s = this.getSizerBounds();
  const tol = this.tolerance;
  this.horizontalOffset = 0;
  this.verticalOffset = 0;
  if (this.customHandles != null) {
    for (let i = 0; i < this.customHandles.length; i++) {
      const temp2 = this.customHandles[i].shape.node.style.display;
      this.customHandles[i].redraw();
      this.customHandles[i].shape.node.style.display = temp2;
      this.customHandles[i].shape.node.style.visibility = this.handlesVisible && this.isCustomHandleVisible(this.customHandles[i]) ? "" : "hidden";
    }
  }
  if (this.sizers != null && this.sizers.length > 0 && this.sizers[0] != null) {
    if (this.index == null && this.manageSizers && this.sizers.length >= 8) {
      const padding = this.getHandlePadding();
      this.horizontalOffset = padding.x;
      this.verticalOffset = padding.y;
      if (this.horizontalOffset != 0 || this.verticalOffset != 0) {
        s = new mxRectangle(s.x, s.y, s.width, s.height);
        s.x -= this.horizontalOffset / 2;
        s.width += this.horizontalOffset;
        s.y -= this.verticalOffset / 2;
        s.height += this.verticalOffset;
      }
      if (this.sizers.length >= 8) {
        if (s.width < 2 * this.sizers[0].bounds.width + 2 * tol || s.height < 2 * this.sizers[0].bounds.height + 2 * tol) {
          this.sizers[0].node.style.display = "none";
          this.sizers[2].node.style.display = "none";
          this.sizers[5].node.style.display = "none";
          this.sizers[7].node.style.display = "none";
        } else if (this.handlesVisible) {
          this.sizers[0].node.style.display = "";
          this.sizers[2].node.style.display = "";
          this.sizers[5].node.style.display = "";
          this.sizers[7].node.style.display = "";
        }
      }
    }
    const r = s.x + s.width;
    const b = s.y + s.height;
    if (this.singleSizer) {
      this.moveSizerTo(this.sizers[0], r, b);
    } else {
      const cx = s.x + s.width / 2;
      const cy = s.y + s.height / 2;
      if (this.sizers.length >= 8) {
        const crs = ["nw-resize", "n-resize", "ne-resize", "e-resize", "se-resize", "s-resize", "sw-resize", "w-resize"];
        const alpha = toRadians(this.state.style[mxConstants2.STYLE_ROTATION] || "0");
        const cos = Math.cos(alpha);
        const sin = Math.sin(alpha);
        const da = Math.round(alpha * 4 / Math.PI);
        const ct = new mxPoint2(s.getCenterX(), s.getCenterY());
        let pt = getRotatedPoint(new mxPoint2(s.x, s.y), cos, sin, ct);
        this.moveSizerTo(this.sizers[0], pt.x, pt.y);
        this.sizers[0].setCursor(crs[mod(0 + da, crs.length)]);
        pt.x = cx;
        pt.y = s.y;
        pt = getRotatedPoint(pt, cos, sin, ct);
        this.moveSizerTo(this.sizers[1], pt.x, pt.y);
        this.sizers[1].setCursor(crs[mod(1 + da, crs.length)]);
        pt.x = r;
        pt.y = s.y;
        pt = getRotatedPoint(pt, cos, sin, ct);
        this.moveSizerTo(this.sizers[2], pt.x, pt.y);
        this.sizers[2].setCursor(crs[mod(2 + da, crs.length)]);
        pt.x = s.x;
        pt.y = cy;
        pt = getRotatedPoint(pt, cos, sin, ct);
        this.moveSizerTo(this.sizers[3], pt.x, pt.y);
        this.sizers[3].setCursor(crs[mod(7 + da, crs.length)]);
        pt.x = r;
        pt.y = cy;
        pt = getRotatedPoint(pt, cos, sin, ct);
        this.moveSizerTo(this.sizers[4], pt.x, pt.y);
        this.sizers[4].setCursor(crs[mod(3 + da, crs.length)]);
        pt.x = s.x;
        pt.y = b;
        pt = getRotatedPoint(pt, cos, sin, ct);
        this.moveSizerTo(this.sizers[5], pt.x, pt.y);
        this.sizers[5].setCursor(crs[mod(6 + da, crs.length)]);
        pt.x = cx;
        pt.y = b;
        pt = getRotatedPoint(pt, cos, sin, ct);
        this.moveSizerTo(this.sizers[6], pt.x, pt.y);
        this.sizers[6].setCursor(crs[mod(5 + da, crs.length)]);
        pt.x = r;
        pt.y = b;
        pt = getRotatedPoint(pt, cos, sin, ct);
        this.moveSizerTo(this.sizers[7], pt.x, pt.y);
        this.sizers[7].setCursor(crs[mod(4 + da, crs.length)]);
        pt.x = cx + this.state.absoluteOffset.x;
        pt.y = cy + this.state.absoluteOffset.y;
        pt = getRotatedPoint(pt, cos, sin, ct);
        this.moveSizerTo(this.sizers[8], pt.x, pt.y);
      } else if (this.state.width >= 2 && this.state.height >= 2) {
        this.moveSizerTo(this.sizers[0], cx + this.state.absoluteOffset.x, cy + this.state.absoluteOffset.y);
      } else {
        this.moveSizerTo(this.sizers[0], this.state.x, this.state.y);
      }
    }
  }
  if (this.rotationShape != null) {
    const alpha = toRadians(this.currentAlpha != null ? this.currentAlpha : this.state.style[mxConstants2.STYLE_ROTATION] || "0");
    const cos = Math.cos(alpha);
    const sin = Math.sin(alpha);
    const ct = new mxPoint2(this.state.getCenterX(), this.state.getCenterY());
    const pt = getRotatedPoint(this.getRotationHandlePosition(), cos, sin, ct);
    if (this.rotationShape.node != null) {
      this.moveSizerTo(this.rotationShape, pt.x, pt.y);
      this.rotationShape.node.style.visibility = this.state.view.graph.isEditing() || !this.handlesVisible ? "hidden" : "";
    }
  }
  if (this.selectionBorder != null) {
    this.selectionBorder.rotation = Number(this.state.style[mxConstants2.STYLE_ROTATION] || "0");
  }
  if (this.edgeHandlers != null) {
    for (let i = 0; i < this.edgeHandlers.length; i++) {
      this.edgeHandlers[i].redraw();
    }
  }
};
mxVertexHandler2.prototype.isCustomHandleVisible = function(handle) {
  return !this.graph.isEditing() && this.state.view.graph.getSelectionCount() == 1;
};
mxVertexHandler2.prototype.getRotationHandlePosition = function() {
  return new mxPoint2(this.bounds.x + this.bounds.width / 2, this.bounds.y + this.rotationHandleVSpacing);
};
mxVertexHandler2.prototype.isParentHighlightVisible = function() {
  return !this.graph.isCellSelected(this.graph.model.getParent(this.state.cell));
};
mxVertexHandler2.prototype.updateParentHighlight = function() {
  if (!this.isDestroyed()) {
    const visible = this.isParentHighlightVisible();
    const parent2 = this.graph.model.getParent(this.state.cell);
    const pstate = this.graph.view.getState(parent2);
    if (this.parentHighlight != null) {
      if (this.graph.model.isVertex(parent2) && visible) {
        const b = this.parentHighlight.bounds;
        if (pstate != null && (b.x != pstate.x || b.y != pstate.y || b.width != pstate.width || b.height != pstate.height)) {
          this.parentHighlight.bounds = mxRectangle.fromRectangle(pstate);
          this.parentHighlight.redraw();
        }
      } else {
        if (pstate != null && pstate.parentHighlight == this.parentHighlight) {
          pstate.parentHighlight = null;
        }
        this.parentHighlight.destroy();
        this.parentHighlight = null;
      }
    } else if (this.parentHighlightEnabled && visible) {
      if (this.graph.model.isVertex(parent2) && pstate != null && pstate.parentHighlight == null) {
        this.parentHighlight = this.createParentHighlightShape(pstate);
        this.parentHighlight.dialect = this.graph.dialect != mxConstants2.DIALECT_SVG ? mxConstants2.DIALECT_VML : mxConstants2.DIALECT_SVG;
        this.parentHighlight.pointerEvents = false;
        this.parentHighlight.rotation = Number(pstate.style[mxConstants2.STYLE_ROTATION] || "0");
        this.parentHighlight.init(this.graph.getView().getOverlayPane());
        this.parentHighlight.redraw();
        pstate.parentHighlight = this.parentHighlight;
      }
    }
  }
};
mxVertexHandler2.prototype.drawPreview = function() {
  if (this.preview != null) {
    this.preview.bounds = this.bounds;
    if (this.preview.node.parentNode == this.graph.container) {
      this.preview.bounds.width = Math.max(0, this.preview.bounds.width - 1);
      this.preview.bounds.height = Math.max(0, this.preview.bounds.height - 1);
    }
    this.preview.rotation = Number(this.state.style[mxConstants2.STYLE_ROTATION] || "0");
    this.preview.redraw();
  }
  this.selectionBorder.bounds = this.getSelectionBorderBounds();
  this.selectionBorder.redraw();
  this.updateParentHighlight();
};
mxVertexHandler2.prototype.getSelectionBorderBounds = function() {
  return this.bounds;
};
mxVertexHandler2.prototype.isDestroyed = function() {
  return this.selectionBorder == null;
};
mxVertexHandler2.prototype.destroy = function() {
  if (this.escapeHandler != null) {
    this.state.view.graph.removeListener(this.escapeHandler);
    this.escapeHandler = null;
  }
  if (this.preview != null) {
    this.preview.destroy();
    this.preview = null;
  }
  if (this.parentHighlight != null) {
    const parent2 = this.graph.model.getParent(this.state.cell);
    const pstate = this.graph.view.getState(parent2);
    if (pstate != null && pstate.parentHighlight == this.parentHighlight) {
      pstate.parentHighlight = null;
    }
    this.parentHighlight.destroy();
    this.parentHighlight = null;
  }
  if (this.ghostPreview != null) {
    this.ghostPreview.destroy();
    this.ghostPreview = null;
  }
  if (this.selectionBorder != null) {
    this.selectionBorder.destroy();
    this.selectionBorder = null;
  }
  this.labelShape = null;
  this.removeHint();
  if (this.sizers != null) {
    for (let i = 0; i < this.sizers.length; i++) {
      this.sizers[i].destroy();
    }
    this.sizers = null;
  }
  if (this.customHandles != null) {
    for (let i = 0; i < this.customHandles.length; i++) {
      this.customHandles[i].destroy();
    }
    this.customHandles = null;
  }
};

// js/graph/mxCellState.js
var mxCellState = function(view, cell2, style) {
  this.view = view;
  this.cell = cell2;
  this.style = style != null ? style : {};
  this.origin = new mxPoint2();
  this.absoluteOffset = new mxPoint2();
};
mxCellState.prototype = new mxRectangle();
mxCellState.prototype.constructor = mxCellState;
mxCellState.prototype.view = null;
mxCellState.prototype.cell = null;
mxCellState.prototype.style = null;
mxCellState.prototype.invalidStyle = false;
mxCellState.prototype.invalid = true;
mxCellState.prototype.origin = null;
mxCellState.prototype.absolutePoints = null;
mxCellState.prototype.absoluteOffset = null;
mxCellState.prototype.visibleSourceState = null;
mxCellState.prototype.visibleTargetState = null;
mxCellState.prototype.terminalDistance = 0;
mxCellState.prototype.length = 0;
mxCellState.prototype.segments = null;
mxCellState.prototype.shape = null;
mxCellState.prototype.text = null;
mxCellState.prototype.unscaledWidth = null;
mxCellState.prototype.unscaledHeight = null;
var getPerimeterBounds = function(border, bounds) {
  border = border || 0;
  bounds = bounds != null ? bounds : new mxRectangle(this.x, this.y, this.width, this.height);
  if (this.shape != null && this.shape.stencil != null && this.shape.stencil.aspect === "fixed") {
    const aspect = this.shape.stencil.computeAspect(this.style, bounds.x, bounds.y, bounds.width, bounds.height);
    bounds.x = aspect.x;
    bounds.y = aspect.y;
    bounds.width = this.shape.stencil.w0 * aspect.width;
    bounds.height = this.shape.stencil.h0 * aspect.height;
  }
  if (border !== 0) {
    bounds.grow(border);
  }
  return bounds;
};
mxCellState.prototype.getPerimeterBounds = getPerimeterBounds;
var setAbsoluteTerminalPoint = function(point, isSource) {
  if (isSource) {
    if (this.absolutePoints == null) {
      this.absolutePoints = [];
    }
    if (this.absolutePoints.length === 0) {
      this.absolutePoints.push(point);
    } else {
      this.absolutePoints[0] = point;
    }
  } else {
    if (this.absolutePoints == null) {
      this.absolutePoints = [];
      this.absolutePoints.push(null);
      this.absolutePoints.push(point);
    } else if (this.absolutePoints.length === 1) {
      this.absolutePoints.push(point);
    } else {
      this.absolutePoints[this.absolutePoints.length - 1] = point;
    }
  }
};
mxCellState.prototype.setAbsoluteTerminalPoint = setAbsoluteTerminalPoint;
var setCursor = function(cursor) {
  if (this.shape != null) {
    this.shape.setCursor(cursor);
  }
  if (this.text != null) {
    this.text.setCursor(cursor);
  }
};
mxCellState.prototype.setCursor = setCursor;
var getVisibleTerminal = function(source) {
  const tmp = this.getVisibleTerminalState(source);
  return tmp != null ? tmp.cell : null;
};
mxCellState.prototype.getVisibleTerminal = getVisibleTerminal;
var getVisibleTerminalState = function(source) {
  return source ? this.visibleSourceState : this.visibleTargetState;
};
mxCellState.prototype.getVisibleTerminalState = getVisibleTerminalState;
var setVisibleTerminalState = function(terminalState, source) {
  if (source) {
    this.visibleSourceState = terminalState;
  } else {
    this.visibleTargetState = terminalState;
  }
};
mxCellState.prototype.setVisibleTerminalState = setVisibleTerminalState;
var getCellBounds = function() {
  return this.cellBounds;
};
mxCellState.prototype.getCellBounds = getCellBounds;
var getPaintBounds = function() {
  return this.paintBounds;
};
mxCellState.prototype.getPaintBounds = getPaintBounds;
var updateCachedBounds = function() {
  const tr = this.view.translate;
  const s = this.view.scale;
  this.cellBounds = new mxRectangle(this.x / s - tr.x, this.y / s - tr.y, this.width / s, this.height / s);
  this.paintBounds = mxRectangle.fromRectangle(this.cellBounds);
  if (this.shape != null && this.shape.isPaintBoundsInverted()) {
    this.paintBounds.rotate90();
  }
};
mxCellState.prototype.updateCachedBounds = updateCachedBounds;
var setState = function(state2) {
  this.view = state2.view;
  this.cell = state2.cell;
  this.style = state2.style;
  this.absolutePoints = state2.absolutePoints;
  this.origin = state2.origin;
  this.absoluteOffset = state2.absoluteOffset;
  this.boundingBox = state2.boundingBox;
  this.terminalDistance = state2.terminalDistance;
  this.segments = state2.segments;
  this.length = state2.length;
  this.x = state2.x;
  this.y = state2.y;
  this.width = state2.width;
  this.height = state2.height;
  this.unscaledWidth = state2.unscaledWidth;
  this.unscaledHeight = state2.unscaledHeight;
};
mxCellState.prototype.setState = setState;
var clone2 = function() {
  const clone3 = new mxCellState(this.view, this.cell, this.style);
  if (this.absolutePoints != null) {
    clone3.absolutePoints = [];
    for (let i = 0; i < this.absolutePoints.length; i++) {
      clone3.absolutePoints[i] = this.absolutePoints[i].clone();
    }
  }
  if (this.origin != null) {
    clone3.origin = this.origin.clone();
  }
  if (this.absoluteOffset != null) {
    clone3.absoluteOffset = this.absoluteOffset.clone();
  }
  if (this.boundingBox != null) {
    clone3.boundingBox = this.boundingBox.clone();
  }
  clone3.terminalDistance = this.terminalDistance;
  clone3.segments = this.segments;
  clone3.length = this.length;
  clone3.x = this.x;
  clone3.y = this.y;
  clone3.width = this.width;
  clone3.height = this.height;
  clone3.unscaledWidth = this.unscaledWidth;
  clone3.unscaledHeight = this.unscaledHeight;
  return clone3;
};
mxCellState.prototype.clone = clone2;
var destroy2 = function() {
  this.view.graph.cellRenderer.destroy(this);
};
mxCellState.prototype.destroy = destroy2;

// js/graph/mxEdgeStyle.js
var mxEdgeStyle = {
  EntityRelation: function(state2, source, target, points, result2) {
    const view = state2.view;
    const graph = view.graph;
    const segment = getValue(state2.style, mxConstants2.STYLE_SEGMENT, mxConstants2.ENTITY_SEGMENT) * view.scale;
    const pts = state2.absolutePoints;
    const p0 = pts[0];
    const pe = pts[pts.length - 1];
    let isSourceLeft = false;
    if (source != null) {
      const sourceGeometry = graph.getCellGeometry(source.cell);
      if (sourceGeometry.relative) {
        isSourceLeft = sourceGeometry.x <= 0.5;
      } else if (target != null) {
        isSourceLeft = (pe != null ? pe.x : target.x + target.width) < (p0 != null ? p0.x : source.x);
      }
    }
    if (p0 != null) {
      source = new mxCellState();
      source.x = p0.x;
      source.y = p0.y;
    } else if (source != null) {
      const constraint = getPortConstraints(source, state2, true, mxConstants2.DIRECTION_MASK_NONE);
      if (constraint != mxConstants2.DIRECTION_MASK_NONE && constraint != mxConstants2.DIRECTION_MASK_WEST + mxConstants2.DIRECTION_MASK_EAST) {
        isSourceLeft = constraint == mxConstants2.DIRECTION_MASK_WEST;
      }
    } else {
      return;
    }
    let isTargetLeft = true;
    if (target != null) {
      const targetGeometry = graph.getCellGeometry(target.cell);
      if (targetGeometry.relative) {
        isTargetLeft = targetGeometry.x <= 0.5;
      } else if (source != null) {
        isTargetLeft = (p0 != null ? p0.x : source.x + source.width) < (pe != null ? pe.x : target.x);
      }
    }
    if (pe != null) {
      target = new mxCellState();
      target.x = pe.x;
      target.y = pe.y;
    } else if (target != null) {
      const constraint = getPortConstraints(target, state2, false, mxConstants2.DIRECTION_MASK_NONE);
      if (constraint != mxConstants2.DIRECTION_MASK_NONE && constraint != mxConstants2.DIRECTION_MASK_WEST + mxConstants2.DIRECTION_MASK_EAST) {
        isTargetLeft = constraint == mxConstants2.DIRECTION_MASK_WEST;
      }
    }
    if (source != null && target != null) {
      const x0 = isSourceLeft ? source.x : source.x + source.width;
      const y0 = view.getRoutingCenterY(source);
      const xe = isTargetLeft ? target.x : target.x + target.width;
      const ye = view.getRoutingCenterY(target);
      const seg = segment;
      let dx = isSourceLeft ? -seg : seg;
      const dep = new mxPoint2(x0 + dx, y0);
      dx = isTargetLeft ? -seg : seg;
      const arr = new mxPoint2(xe + dx, ye);
      if (isSourceLeft == isTargetLeft) {
        const x = isSourceLeft ? Math.min(x0, xe) - segment : Math.max(x0, xe) + segment;
        result2.push(new mxPoint2(x, y0));
        result2.push(new mxPoint2(x, ye));
      } else if (dep.x < arr.x == isSourceLeft) {
        const midY = y0 + (ye - y0) / 2;
        result2.push(dep);
        result2.push(new mxPoint2(dep.x, midY));
        result2.push(new mxPoint2(arr.x, midY));
        result2.push(arr);
      } else {
        result2.push(dep);
        result2.push(arr);
      }
    }
  },
  Loop: function(state2, source, target, points, result2) {
    const pts = state2.absolutePoints;
    const p0 = pts[0];
    const pe = pts[pts.length - 1];
    if (p0 != null && pe != null) {
      if (points != null && points.length > 0) {
        for (let i = 0; i < points.length; i++) {
          let pt = points[i];
          pt = state2.view.transformControlPoint(state2, pt);
          result2.push(new mxPoint2(pt.x, pt.y));
        }
      }
      return;
    }
    if (source != null) {
      const view = state2.view;
      const graph = view.graph;
      let pt = points != null && points.length > 0 ? points[0] : null;
      if (pt != null) {
        pt = view.transformControlPoint(state2, pt);
        if (contains(source, pt.x, pt.y)) {
          pt = null;
        }
      }
      let x = 0;
      let dx = 0;
      let y = 0;
      let dy = 0;
      const seg = getValue(state2.style, mxConstants2.STYLE_SEGMENT, graph.gridSize) * view.scale;
      const dir = getValue(state2.style, mxConstants2.STYLE_DIRECTION, mxConstants2.DIRECTION_WEST);
      if (dir == mxConstants2.DIRECTION_NORTH || dir == mxConstants2.DIRECTION_SOUTH) {
        x = view.getRoutingCenterX(source);
        dx = seg;
      } else {
        y = view.getRoutingCenterY(source);
        dy = seg;
      }
      if (pt == null || pt.x < source.x || pt.x > source.x + source.width) {
        if (pt != null) {
          x = pt.x;
          dy = Math.max(Math.abs(y - pt.y), dy);
        } else {
          if (dir == mxConstants2.DIRECTION_NORTH) {
            y = source.y - 2 * dx;
          } else if (dir == mxConstants2.DIRECTION_SOUTH) {
            y = source.y + source.height + 2 * dx;
          } else if (dir == mxConstants2.DIRECTION_EAST) {
            x = source.x - 2 * dy;
          } else {
            x = source.x + source.width + 2 * dy;
          }
        }
      } else if (pt != null) {
        x = view.getRoutingCenterX(source);
        dx = Math.max(Math.abs(x - pt.x), dy);
        y = pt.y;
        dy = 0;
      }
      result2.push(new mxPoint2(x - dx, y - dy));
      result2.push(new mxPoint2(x + dx, y + dy));
    }
  },
  ElbowConnector: function(state2, source, target, points, result2) {
    let pt = points != null && points.length > 0 ? points[0] : null;
    let vertical = false;
    let horizontal = false;
    if (source != null && target != null) {
      if (pt != null) {
        const left = Math.min(source.x, target.x);
        const right = Math.max(source.x + source.width, target.x + target.width);
        const top = Math.min(source.y, target.y);
        const bottom = Math.max(source.y + source.height, target.y + target.height);
        pt = state2.view.transformControlPoint(state2, pt);
        vertical = pt.y < top || pt.y > bottom;
        horizontal = pt.x < left || pt.x > right;
      } else {
        const left = Math.max(source.x, target.x);
        const right = Math.min(source.x + source.width, target.x + target.width);
        vertical = left == right;
        if (!vertical) {
          const top = Math.max(source.y, target.y);
          const bottom = Math.min(source.y + source.height, target.y + target.height);
          horizontal = top == bottom;
        }
      }
    }
    if (!horizontal && (vertical || state2.style[mxConstants2.STYLE_ELBOW] == mxConstants2.ELBOW_VERTICAL)) {
      mxEdgeStyle.TopToBottom(state2, source, target, points, result2);
    } else {
      mxEdgeStyle.SideToSide(state2, source, target, points, result2);
    }
  },
  SideToSide: function(state2, source, target, points, result2) {
    const view = state2.view;
    let pt = points != null && points.length > 0 ? points[0] : null;
    const pts = state2.absolutePoints;
    const p0 = pts[0];
    const pe = pts[pts.length - 1];
    if (pt != null) {
      pt = view.transformControlPoint(state2, pt);
    }
    if (p0 != null) {
      source = new mxCellState();
      source.x = p0.x;
      source.y = p0.y;
    }
    if (pe != null) {
      target = new mxCellState();
      target.x = pe.x;
      target.y = pe.y;
    }
    if (source != null && target != null) {
      const l = Math.max(source.x, target.x);
      const r = Math.min(source.x + source.width, target.x + target.width);
      const x = pt != null ? pt.x : Math.round(r + (l - r) / 2);
      let y1 = view.getRoutingCenterY(source);
      let y2 = view.getRoutingCenterY(target);
      if (pt != null) {
        if (pt.y >= source.y && pt.y <= source.y + source.height) {
          y1 = pt.y;
        }
        if (pt.y >= target.y && pt.y <= target.y + target.height) {
          y2 = pt.y;
        }
      }
      if (!contains(target, x, y1) && !contains(source, x, y1)) {
        result2.push(new mxPoint2(x, y1));
      }
      if (!contains(target, x, y2) && !contains(source, x, y2)) {
        result2.push(new mxPoint2(x, y2));
      }
      if (result2.length == 1) {
        if (pt != null) {
          if (!contains(target, x, pt.y) && !contains(source, x, pt.y)) {
            result2.push(new mxPoint2(x, pt.y));
          }
        } else {
          const t = Math.max(source.y, target.y);
          const b = Math.min(source.y + source.height, target.y + target.height);
          result2.push(new mxPoint2(x, t + (b - t) / 2));
        }
      }
    }
  },
  TopToBottom: function(state2, source, target, points, result2) {
    const view = state2.view;
    let pt = points != null && points.length > 0 ? points[0] : null;
    const pts = state2.absolutePoints;
    const p0 = pts[0];
    const pe = pts[pts.length - 1];
    if (pt != null) {
      pt = view.transformControlPoint(state2, pt);
    }
    if (p0 != null) {
      source = new mxCellState();
      source.x = p0.x;
      source.y = p0.y;
    }
    if (pe != null) {
      target = new mxCellState();
      target.x = pe.x;
      target.y = pe.y;
    }
    if (source != null && target != null) {
      const t = Math.max(source.y, target.y);
      const b = Math.min(source.y + source.height, target.y + target.height);
      let x = view.getRoutingCenterX(source);
      if (pt != null && pt.x >= source.x && pt.x <= source.x + source.width) {
        x = pt.x;
      }
      const y = pt != null ? pt.y : Math.round(b + (t - b) / 2);
      if (!contains(target, x, y) && !contains(source, x, y)) {
        result2.push(new mxPoint2(x, y));
      }
      if (pt != null && pt.x >= target.x && pt.x <= target.x + target.width) {
        x = pt.x;
      } else {
        x = view.getRoutingCenterX(target);
      }
      if (!contains(target, x, y) && !contains(source, x, y)) {
        result2.push(new mxPoint2(x, y));
      }
      if (result2.length == 1) {
        if (pt != null && result2.length == 1) {
          if (!contains(target, pt.x, y) && !contains(source, pt.x, y)) {
            result2.push(new mxPoint2(pt.x, y));
          }
        } else {
          const l = Math.max(source.x, target.x);
          const r = Math.min(source.x + source.width, target.x + target.width);
          result2.push(new mxPoint2(l + (r - l) / 2, y));
        }
      }
    }
  },
  SegmentConnector: function(state2, sourceScaled, targetScaled, controlHints, result2) {
    const pts = mxEdgeStyle.scalePointArray(state2.absolutePoints, state2.view.scale);
    const source = mxEdgeStyle.scaleCellState(sourceScaled, state2.view.scale);
    const target = mxEdgeStyle.scaleCellState(targetScaled, state2.view.scale);
    const tol = 1;
    let lastPushed = result2.length > 0 ? result2[0] : null;
    let horizontal = true;
    let hint = null;
    function pushPoint(pt2) {
      pt2.x = Math.round(pt2.x * state2.view.scale * 10) / 10;
      pt2.y = Math.round(pt2.y * state2.view.scale * 10) / 10;
      if (lastPushed == null || Math.abs(lastPushed.x - pt2.x) >= tol || Math.abs(lastPushed.y - pt2.y) >= Math.max(1, state2.view.scale)) {
        result2.push(pt2);
        lastPushed = pt2;
      }
      return lastPushed;
    }
    ;
    let pt = pts[0];
    if (pt == null && source != null) {
      pt = new mxPoint2(state2.view.getRoutingCenterX(source), state2.view.getRoutingCenterY(source));
    } else if (pt != null) {
      pt = pt.clone();
    }
    const lastInx = pts.length - 1;
    const pe = pts[lastInx];
    if (controlHints != null && controlHints.length > 0) {
      let hints = [];
      for (let i = 0; i < controlHints.length; i++) {
        const tmp = state2.view.transformControlPoint(state2, controlHints[i], true);
        if (tmp != null) {
          hints.push(tmp);
        }
      }
      if (hints.length == 0) {
        return;
      }
      if (pt != null && hints[0] != null) {
        if (Math.abs(hints[0].x - pt.x) < tol) {
          hints[0].x = pt.x;
        }
        if (Math.abs(hints[0].y - pt.y) < tol) {
          hints[0].y = pt.y;
        }
      }
      if (pe != null && hints[hints.length - 1] != null) {
        if (Math.abs(hints[hints.length - 1].x - pe.x) < tol) {
          hints[hints.length - 1].x = pe.x;
        }
        if (Math.abs(hints[hints.length - 1].y - pe.y) < tol) {
          hints[hints.length - 1].y = pe.y;
        }
      }
      hint = hints[0];
      let currentTerm = source;
      let currentPt = pts[0];
      let hozChan = false;
      let vertChan = false;
      let currentHint = hint;
      if (currentPt != null) {
        currentTerm = null;
      }
      for (let i = 0; i < 2; i++) {
        const fixedVertAlign = currentPt != null && currentPt.x == currentHint.x;
        const fixedHozAlign = currentPt != null && currentPt.y == currentHint.y;
        const inHozChan = currentTerm != null && (currentHint.y >= currentTerm.y && currentHint.y <= currentTerm.y + currentTerm.height);
        const inVertChan = currentTerm != null && (currentHint.x >= currentTerm.x && currentHint.x <= currentTerm.x + currentTerm.width);
        hozChan = fixedHozAlign || currentPt == null && inHozChan;
        vertChan = fixedVertAlign || currentPt == null && inVertChan;
        if (i == 0 && (hozChan && vertChan || fixedVertAlign && fixedHozAlign)) {
        } else {
          if (currentPt != null && (!fixedHozAlign && !fixedVertAlign) && (inHozChan || inVertChan)) {
            horizontal = inHozChan ? false : true;
            break;
          }
          if (vertChan || hozChan) {
            horizontal = hozChan;
            if (i == 1) {
              horizontal = hints.length % 2 == 0 ? hozChan : vertChan;
            }
            break;
          }
        }
        currentTerm = target;
        currentPt = pts[lastInx];
        if (currentPt != null) {
          currentTerm = null;
        }
        currentHint = hints[hints.length - 1];
        if (fixedVertAlign && fixedHozAlign) {
          hints = hints.slice(1);
        }
      }
      if (horizontal && (pts[0] != null && pts[0].y != hint.y || pts[0] == null && source != null && (hint.y < source.y || hint.y > source.y + source.height))) {
        pushPoint(new mxPoint2(pt.x, hint.y));
      } else if (!horizontal && (pts[0] != null && pts[0].x != hint.x || pts[0] == null && source != null && (hint.x < source.x || hint.x > source.x + source.width))) {
        pushPoint(new mxPoint2(hint.x, pt.y));
      }
      if (horizontal) {
        pt.y = hint.y;
      } else {
        pt.x = hint.x;
      }
      for (let i = 0; i < hints.length; i++) {
        horizontal = !horizontal;
        hint = hints[i];
        if (horizontal) {
          pt.y = hint.y;
        } else {
          pt.x = hint.x;
        }
        pushPoint(pt.clone());
      }
    } else {
      hint = pt;
      horizontal = true;
    }
    pt = pts[lastInx];
    if (pt == null && target != null) {
      pt = new mxPoint2(state2.view.getRoutingCenterX(target), state2.view.getRoutingCenterY(target));
    }
    if (pt != null) {
      if (hint != null) {
        if (horizontal && (pts[lastInx] != null && pts[lastInx].y != hint.y || pts[lastInx] == null && target != null && (hint.y < target.y || hint.y > target.y + target.height))) {
          pushPoint(new mxPoint2(pt.x, hint.y));
        } else if (!horizontal && (pts[lastInx] != null && pts[lastInx].x != hint.x || pts[lastInx] == null && target != null && (hint.x < target.x || hint.x > target.x + target.width))) {
          pushPoint(new mxPoint2(hint.x, pt.y));
        }
      }
    }
    if (pts[0] == null && source != null) {
      while (result2.length > 1 && result2[1] != null && contains(source, result2[1].x, result2[1].y)) {
        result2.splice(1, 1);
      }
    }
    if (pts[lastInx] == null && target != null) {
      while (result2.length > 1 && result2[result2.length - 1] != null && contains(target, result2[result2.length - 1].x, result2[result2.length - 1].y)) {
        result2.splice(result2.length - 1, 1);
      }
    }
    if (pe != null && result2[result2.length - 1] != null && Math.abs(pe.x - result2[result2.length - 1].x) <= tol && Math.abs(pe.y - result2[result2.length - 1].y) <= tol) {
      result2.splice(result2.length - 1, 1);
      if (result2[result2.length - 1] != null) {
        if (Math.abs(result2[result2.length - 1].x - pe.x) < tol) {
          result2[result2.length - 1].x = pe.x;
        }
        if (Math.abs(result2[result2.length - 1].y - pe.y) < tol) {
          result2[result2.length - 1].y = pe.y;
        }
      }
    }
  },
  orthBuffer: 10,
  orthPointsFallback: true,
  dirVectors: [
    [-1, 0],
    [0, -1],
    [1, 0],
    [0, 1],
    [-1, 0],
    [0, -1],
    [1, 0]
  ],
  wayPoints1: [
    [0, 0],
    [0, 0],
    [0, 0],
    [0, 0],
    [0, 0],
    [0, 0],
    [0, 0],
    [0, 0],
    [0, 0],
    [0, 0],
    [0, 0],
    [0, 0]
  ],
  routePatterns: [
    [
      [513, 2308, 2081, 2562],
      [513, 1090, 514, 2184, 2114, 2561],
      [513, 1090, 514, 2564, 2184, 2562],
      [513, 2308, 2561, 1090, 514, 2568, 2308]
    ],
    [
      [514, 1057, 513, 2308, 2081, 2562],
      [514, 2184, 2114, 2561],
      [514, 2184, 2562, 1057, 513, 2564, 2184],
      [514, 1057, 513, 2568, 2308, 2561]
    ],
    [
      [1090, 514, 1057, 513, 2308, 2081, 2562],
      [2114, 2561],
      [1090, 2562, 1057, 513, 2564, 2184],
      [1090, 514, 1057, 513, 2308, 2561, 2568]
    ],
    [
      [2081, 2562],
      [1057, 513, 1090, 514, 2184, 2114, 2561],
      [1057, 513, 1090, 514, 2184, 2562, 2564],
      [1057, 2561, 1090, 514, 2568, 2308]
    ]
  ],
  inlineRoutePatterns: [
    [null, [2114, 2568], null, null],
    [null, [514, 2081, 2114, 2568], null, null],
    [null, [2114, 2561], null, null],
    [
      [2081, 2562],
      [1057, 2114, 2568],
      [2184, 2562],
      null
    ]
  ],
  vertexSeperations: [],
  limits: [
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0]
  ],
  LEFT_MASK: 32,
  TOP_MASK: 64,
  RIGHT_MASK: 128,
  BOTTOM_MASK: 256,
  LEFT: 1,
  TOP: 2,
  RIGHT: 4,
  BOTTOM: 8,
  SIDE_MASK: 480,
  CENTER_MASK: 512,
  SOURCE_MASK: 1024,
  TARGET_MASK: 2048,
  VERTEX_MASK: 3072,
  getJettySize: function(state2, isSource) {
    let value = getValue(state2.style, isSource ? mxConstants2.STYLE_SOURCE_JETTY_SIZE : mxConstants2.STYLE_TARGET_JETTY_SIZE, getValue(state2.style, mxConstants2.STYLE_JETTY_SIZE, mxEdgeStyle.orthBuffer));
    if (value == "auto") {
      const type = getValue(state2.style, isSource ? mxConstants2.STYLE_STARTARROW : mxConstants2.STYLE_ENDARROW, mxConstants2.NONE);
      if (type != mxConstants2.NONE) {
        const size = getNumber(state2.style, isSource ? mxConstants2.STYLE_STARTSIZE : mxConstants2.STYLE_ENDSIZE, mxConstants2.DEFAULT_MARKERSIZE);
        value = Math.max(2, Math.ceil((size + mxEdgeStyle.orthBuffer) / mxEdgeStyle.orthBuffer)) * mxEdgeStyle.orthBuffer;
      } else {
        value = 2 * mxEdgeStyle.orthBuffer;
      }
    }
    return value;
  },
  scalePointArray: function(points, scale) {
    const result2 = [];
    if (points != null) {
      for (let i = 0; i < points.length; i++) {
        if (points[i] != null) {
          const pt = new mxPoint2(Math.round(points[i].x / scale * 10) / 10, Math.round(points[i].y / scale * 10) / 10);
          result2[i] = pt;
        } else {
          result2[i] = null;
        }
      }
    } else {
      return null;
    }
    return result2;
  },
  scaleCellState: function(state2, scale) {
    let result2 = null;
    if (state2 != null) {
      result2 = state2.clone();
      result2.setRect(Math.round(state2.x / scale * 10) / 10, Math.round(state2.y / scale * 10) / 10, Math.round(state2.width / scale * 10) / 10, Math.round(state2.height / scale * 10) / 10);
    } else {
      result2 = null;
    }
    return result2;
  },
  OrthConnector: function(state2, sourceScaled, targetScaled, controlHints, result2) {
    const graph = state2.view.graph;
    const source = mxEdgeStyle.scaleCellState(sourceScaled, state2.view.scale);
    const target = mxEdgeStyle.scaleCellState(targetScaled, state2.view.scale);
    const sourceEdge = source == null ? false : graph.getModel().isEdge(source.cell);
    const targetEdge = target == null ? false : graph.getModel().isEdge(target.cell);
    const pts = mxEdgeStyle.scalePointArray(state2.absolutePoints, state2.view.scale);
    const p0 = pts[0];
    const pe = pts[pts.length - 1];
    let sourceX = source != null ? source.x : p0.x;
    let sourceY = source != null ? source.y : p0.y;
    let sourceWidth = source != null ? source.width : 0;
    let sourceHeight = source != null ? source.height : 0;
    let targetX = target != null ? target.x : pe.x;
    let targetY = target != null ? target.y : pe.y;
    let targetWidth = target != null ? target.width : 0;
    let targetHeight = target != null ? target.height : 0;
    let sourceBuffer = mxEdgeStyle.getJettySize(state2, true);
    let targetBuffer = mxEdgeStyle.getJettySize(state2, false);
    if (source != null && target == source) {
      targetBuffer = Math.max(sourceBuffer, targetBuffer);
      sourceBuffer = targetBuffer;
    }
    const totalBuffer = targetBuffer + sourceBuffer;
    let tooShort = false;
    if (p0 != null && pe != null) {
      const dx2 = pe.x - p0.x;
      const dy2 = pe.y - p0.y;
      tooShort = dx2 * dx2 + dy2 * dy2 < totalBuffer * totalBuffer;
    }
    if (tooShort || mxEdgeStyle.orthPointsFallback && (controlHints != null && controlHints.length > 0) || sourceEdge || targetEdge) {
      mxEdgeStyle.SegmentConnector(state2, sourceScaled, targetScaled, controlHints, result2);
      return;
    }
    const portConstraint = [mxConstants2.DIRECTION_MASK_ALL, mxConstants2.DIRECTION_MASK_ALL];
    let rotation = 0;
    if (source != null) {
      portConstraint[0] = getPortConstraints(source, state2, true, mxConstants2.DIRECTION_MASK_ALL);
      rotation = getValue(source.style, mxConstants2.STYLE_ROTATION, 0);
      if (rotation != 0) {
        const newRect = getBoundingBox(new mxRectangle(sourceX, sourceY, sourceWidth, sourceHeight), rotation);
        sourceX = newRect.x;
        sourceY = newRect.y;
        sourceWidth = newRect.width;
        sourceHeight = newRect.height;
      }
    }
    if (target != null) {
      portConstraint[1] = getPortConstraints(target, state2, false, mxConstants2.DIRECTION_MASK_ALL);
      rotation = getValue(target.style, mxConstants2.STYLE_ROTATION, 0);
      if (rotation != 0) {
        const newRect = getBoundingBox(new mxRectangle(targetX, targetY, targetWidth, targetHeight), rotation);
        targetX = newRect.x;
        targetY = newRect.y;
        targetWidth = newRect.width;
        targetHeight = newRect.height;
      }
    }
    const dir = [0, 0];
    const geo = [
      [sourceX, sourceY, sourceWidth, sourceHeight],
      [targetX, targetY, targetWidth, targetHeight]
    ];
    const buffer = [sourceBuffer, targetBuffer];
    for (let i = 0; i < 2; i++) {
      mxEdgeStyle.limits[i][1] = geo[i][0] - buffer[i];
      mxEdgeStyle.limits[i][2] = geo[i][1] - buffer[i];
      mxEdgeStyle.limits[i][4] = geo[i][0] + geo[i][2] + buffer[i];
      mxEdgeStyle.limits[i][8] = geo[i][1] + geo[i][3] + buffer[i];
    }
    const sourceCenX = geo[0][0] + geo[0][2] / 2;
    const sourceCenY = geo[0][1] + geo[0][3] / 2;
    const targetCenX = geo[1][0] + geo[1][2] / 2;
    const targetCenY = geo[1][1] + geo[1][3] / 2;
    const dx = sourceCenX - targetCenX;
    const dy = sourceCenY - targetCenY;
    let quad = 0;
    if (dx < 0) {
      if (dy < 0) {
        quad = 2;
      } else {
        quad = 1;
      }
    } else {
      if (dy <= 0) {
        quad = 3;
        if (dx == 0) {
          quad = 2;
        }
      }
    }
    let currentTerm = null;
    if (source != null) {
      currentTerm = p0;
    }
    const constraint = [[0.5, 0.5], [0.5, 0.5]];
    for (let i = 0; i < 2; i++) {
      if (currentTerm != null) {
        constraint[i][0] = (currentTerm.x - geo[i][0]) / geo[i][2];
        if (Math.abs(currentTerm.x - geo[i][0]) <= 1) {
          dir[i] = mxConstants2.DIRECTION_MASK_WEST;
        } else if (Math.abs(currentTerm.x - geo[i][0] - geo[i][2]) <= 1) {
          dir[i] = mxConstants2.DIRECTION_MASK_EAST;
        }
        constraint[i][1] = (currentTerm.y - geo[i][1]) / geo[i][3];
        if (Math.abs(currentTerm.y - geo[i][1]) <= 1) {
          dir[i] = mxConstants2.DIRECTION_MASK_NORTH;
        } else if (Math.abs(currentTerm.y - geo[i][1] - geo[i][3]) <= 1) {
          dir[i] = mxConstants2.DIRECTION_MASK_SOUTH;
        }
      }
      currentTerm = null;
      if (target != null) {
        currentTerm = pe;
      }
    }
    const sourceTopDist = geo[0][1] - (geo[1][1] + geo[1][3]);
    const sourceLeftDist = geo[0][0] - (geo[1][0] + geo[1][2]);
    const sourceBottomDist = geo[1][1] - (geo[0][1] + geo[0][3]);
    const sourceRightDist = geo[1][0] - (geo[0][0] + geo[0][2]);
    mxEdgeStyle.vertexSeperations[1] = Math.max(sourceLeftDist - totalBuffer, 0);
    mxEdgeStyle.vertexSeperations[2] = Math.max(sourceTopDist - totalBuffer, 0);
    mxEdgeStyle.vertexSeperations[4] = Math.max(sourceBottomDist - totalBuffer, 0);
    mxEdgeStyle.vertexSeperations[3] = Math.max(sourceRightDist - totalBuffer, 0);
    const dirPref = [];
    const horPref = [];
    const vertPref = [];
    horPref[0] = sourceLeftDist >= sourceRightDist ? mxConstants2.DIRECTION_MASK_WEST : mxConstants2.DIRECTION_MASK_EAST;
    vertPref[0] = sourceTopDist >= sourceBottomDist ? mxConstants2.DIRECTION_MASK_NORTH : mxConstants2.DIRECTION_MASK_SOUTH;
    horPref[1] = reversePortConstraints(horPref[0]);
    vertPref[1] = reversePortConstraints(vertPref[0]);
    const preferredHorizDist = sourceLeftDist >= sourceRightDist ? sourceLeftDist : sourceRightDist;
    const preferredVertDist = sourceTopDist >= sourceBottomDist ? sourceTopDist : sourceBottomDist;
    const prefOrdering = [[0, 0], [0, 0]];
    let preferredOrderSet = false;
    for (let i = 0; i < 2; i++) {
      if (dir[i] != 0) {
        continue;
      }
      if ((horPref[i] & portConstraint[i]) == 0) {
        horPref[i] = reversePortConstraints(horPref[i]);
      }
      if ((vertPref[i] & portConstraint[i]) == 0) {
        vertPref[i] = reversePortConstraints(vertPref[i]);
      }
      prefOrdering[i][0] = vertPref[i];
      prefOrdering[i][1] = horPref[i];
    }
    if (preferredVertDist > 0 && preferredHorizDist > 0) {
      if ((horPref[0] & portConstraint[0]) > 0 && (vertPref[1] & portConstraint[1]) > 0) {
        prefOrdering[0][0] = horPref[0];
        prefOrdering[0][1] = vertPref[0];
        prefOrdering[1][0] = vertPref[1];
        prefOrdering[1][1] = horPref[1];
        preferredOrderSet = true;
      } else if ((vertPref[0] & portConstraint[0]) > 0 && (horPref[1] & portConstraint[1]) > 0) {
        prefOrdering[0][0] = vertPref[0];
        prefOrdering[0][1] = horPref[0];
        prefOrdering[1][0] = horPref[1];
        prefOrdering[1][1] = vertPref[1];
        preferredOrderSet = true;
      }
    }
    if (preferredVertDist > 0 && !preferredOrderSet) {
      prefOrdering[0][0] = vertPref[0];
      prefOrdering[0][1] = horPref[0];
      prefOrdering[1][0] = vertPref[1];
      prefOrdering[1][1] = horPref[1];
      preferredOrderSet = true;
    }
    if (preferredHorizDist > 0 && !preferredOrderSet) {
      prefOrdering[0][0] = horPref[0];
      prefOrdering[0][1] = vertPref[0];
      prefOrdering[1][0] = horPref[1];
      prefOrdering[1][1] = vertPref[1];
      preferredOrderSet = true;
    }
    for (let i = 0; i < 2; i++) {
      if (dir[i] != 0) {
        continue;
      }
      if ((prefOrdering[i][0] & portConstraint[i]) == 0) {
        prefOrdering[i][0] = prefOrdering[i][1];
      }
      dirPref[i] = prefOrdering[i][0] & portConstraint[i];
      dirPref[i] |= (prefOrdering[i][1] & portConstraint[i]) << 8;
      dirPref[i] |= (prefOrdering[1 - i][i] & portConstraint[i]) << 16;
      dirPref[i] |= (prefOrdering[1 - i][1 - i] & portConstraint[i]) << 24;
      if ((dirPref[i] & 15) == 0) {
        dirPref[i] = dirPref[i] << 8;
      }
      if ((dirPref[i] & 3840) == 0) {
        dirPref[i] = dirPref[i] & 15 | dirPref[i] >> 8;
      }
      if ((dirPref[i] & 983040) == 0) {
        dirPref[i] = dirPref[i] & 65535 | (dirPref[i] & 251658240) >> 8;
      }
      dir[i] = dirPref[i] & 15;
      if (portConstraint[i] == mxConstants2.DIRECTION_MASK_WEST || portConstraint[i] == mxConstants2.DIRECTION_MASK_NORTH || portConstraint[i] == mxConstants2.DIRECTION_MASK_EAST || portConstraint[i] == mxConstants2.DIRECTION_MASK_SOUTH) {
        dir[i] = portConstraint[i];
      }
    }
    let sourceIndex = dir[0] == mxConstants2.DIRECTION_MASK_EAST ? 3 : dir[0];
    let targetIndex = dir[1] == mxConstants2.DIRECTION_MASK_EAST ? 3 : dir[1];
    sourceIndex -= quad;
    targetIndex -= quad;
    if (sourceIndex < 1) {
      sourceIndex += 4;
    }
    if (targetIndex < 1) {
      targetIndex += 4;
    }
    const routePattern = mxEdgeStyle.routePatterns[sourceIndex - 1][targetIndex - 1];
    mxEdgeStyle.wayPoints1[0][0] = geo[0][0];
    mxEdgeStyle.wayPoints1[0][1] = geo[0][1];
    switch (dir[0]) {
      case mxConstants2.DIRECTION_MASK_WEST:
        mxEdgeStyle.wayPoints1[0][0] -= sourceBuffer;
        mxEdgeStyle.wayPoints1[0][1] += constraint[0][1] * geo[0][3];
        break;
      case mxConstants2.DIRECTION_MASK_SOUTH:
        mxEdgeStyle.wayPoints1[0][0] += constraint[0][0] * geo[0][2];
        mxEdgeStyle.wayPoints1[0][1] += geo[0][3] + sourceBuffer;
        break;
      case mxConstants2.DIRECTION_MASK_EAST:
        mxEdgeStyle.wayPoints1[0][0] += geo[0][2] + sourceBuffer;
        mxEdgeStyle.wayPoints1[0][1] += constraint[0][1] * geo[0][3];
        break;
      case mxConstants2.DIRECTION_MASK_NORTH:
        mxEdgeStyle.wayPoints1[0][0] += constraint[0][0] * geo[0][2];
        mxEdgeStyle.wayPoints1[0][1] -= sourceBuffer;
        break;
    }
    let currentIndex = 0;
    let lastOrientation = (dir[0] & (mxConstants2.DIRECTION_MASK_EAST | mxConstants2.DIRECTION_MASK_WEST)) > 0 ? 0 : 1;
    const initialOrientation = lastOrientation;
    let currentOrientation = 0;
    for (let i = 0; i < routePattern.length; i++) {
      const nextDirection = routePattern[i] & 15;
      let directionIndex = nextDirection == mxConstants2.DIRECTION_MASK_EAST ? 3 : nextDirection;
      directionIndex += quad;
      if (directionIndex > 4) {
        directionIndex -= 4;
      }
      const direction = mxEdgeStyle.dirVectors[directionIndex - 1];
      currentOrientation = directionIndex % 2 > 0 ? 0 : 1;
      if (currentOrientation != lastOrientation) {
        currentIndex++;
        mxEdgeStyle.wayPoints1[currentIndex][0] = mxEdgeStyle.wayPoints1[currentIndex - 1][0];
        mxEdgeStyle.wayPoints1[currentIndex][1] = mxEdgeStyle.wayPoints1[currentIndex - 1][1];
      }
      const tar = (routePattern[i] & mxEdgeStyle.TARGET_MASK) > 0;
      const sou = (routePattern[i] & mxEdgeStyle.SOURCE_MASK) > 0;
      let side = (routePattern[i] & mxEdgeStyle.SIDE_MASK) >> 5;
      side = side << quad;
      if (side > 15) {
        side = side >> 4;
      }
      const center = (routePattern[i] & mxEdgeStyle.CENTER_MASK) > 0;
      if ((sou || tar) && side < 9) {
        let limit = 0;
        const souTar = sou ? 0 : 1;
        if (center && currentOrientation == 0) {
          limit = geo[souTar][0] + constraint[souTar][0] * geo[souTar][2];
        } else if (center) {
          limit = geo[souTar][1] + constraint[souTar][1] * geo[souTar][3];
        } else {
          limit = mxEdgeStyle.limits[souTar][side];
        }
        if (currentOrientation == 0) {
          const lastX = mxEdgeStyle.wayPoints1[currentIndex][0];
          const deltaX = (limit - lastX) * direction[0];
          if (deltaX > 0) {
            mxEdgeStyle.wayPoints1[currentIndex][0] += direction[0] * deltaX;
          }
        } else {
          const lastY = mxEdgeStyle.wayPoints1[currentIndex][1];
          const deltaY = (limit - lastY) * direction[1];
          if (deltaY > 0) {
            mxEdgeStyle.wayPoints1[currentIndex][1] += direction[1] * deltaY;
          }
        }
      } else if (center) {
        mxEdgeStyle.wayPoints1[currentIndex][0] += direction[0] * Math.abs(mxEdgeStyle.vertexSeperations[directionIndex] / 2);
        mxEdgeStyle.wayPoints1[currentIndex][1] += direction[1] * Math.abs(mxEdgeStyle.vertexSeperations[directionIndex] / 2);
      }
      if (currentIndex > 0 && mxEdgeStyle.wayPoints1[currentIndex][currentOrientation] == mxEdgeStyle.wayPoints1[currentIndex - 1][currentOrientation]) {
        currentIndex--;
      } else {
        lastOrientation = currentOrientation;
      }
    }
    for (let i = 0; i <= currentIndex; i++) {
      if (i == currentIndex) {
        const targetOrientation = (dir[1] & (mxConstants2.DIRECTION_MASK_EAST | mxConstants2.DIRECTION_MASK_WEST)) > 0 ? 0 : 1;
        const sameOrient = targetOrientation == initialOrientation ? 0 : 1;
        if (sameOrient != (currentIndex + 1) % 2) {
          break;
        }
      }
      result2.push(new mxPoint2(Math.round(mxEdgeStyle.wayPoints1[i][0] * state2.view.scale * 10) / 10, Math.round(mxEdgeStyle.wayPoints1[i][1] * state2.view.scale * 10) / 10));
    }
    let index = 1;
    while (index < result2.length) {
      if (result2[index - 1] == null || result2[index] == null || result2[index - 1].x != result2[index].x || result2[index - 1].y != result2[index].y) {
        index++;
      } else {
        result2.splice(index, 1);
      }
    }
  },
  getRoutePattern: function(dir, quad, dx, dy) {
    let sourceIndex = dir[0] == mxConstants2.DIRECTION_MASK_EAST ? 3 : dir[0];
    let targetIndex = dir[1] == mxConstants2.DIRECTION_MASK_EAST ? 3 : dir[1];
    sourceIndex -= quad;
    targetIndex -= quad;
    if (sourceIndex < 1) {
      sourceIndex += 4;
    }
    if (targetIndex < 1) {
      targetIndex += 4;
    }
    let result2 = routePatterns[sourceIndex - 1][targetIndex - 1];
    if (dx == 0 || dy == 0) {
      if (inlineRoutePatterns[sourceIndex - 1][targetIndex - 1] != null) {
        result2 = inlineRoutePatterns[sourceIndex - 1][targetIndex - 1];
      }
    }
    return result2;
  }
};

// js/graph/mxEdgeHandler.js
function mxEdgeHandler2(state2) {
  if (state2 != null && state2.shape != null) {
    this.state = state2;
    this.init();
    this.escapeHandler = bind(this, function(sender, evt) {
      const dirty = this.index != null;
      this.reset();
      if (dirty) {
        this.graph.cellRenderer.redraw(this.state, false, state2.view.isRendering());
      }
    });
    this.state.view.graph.addListener(mxEvent2.ESCAPE, this.escapeHandler);
  }
}
mxEdgeHandler2.prototype.graph = null;
mxEdgeHandler2.prototype.state = null;
mxEdgeHandler2.prototype.marker = null;
mxEdgeHandler2.prototype.constraintHandler = null;
mxEdgeHandler2.prototype.error = null;
mxEdgeHandler2.prototype.shape = null;
mxEdgeHandler2.prototype.bends = null;
mxEdgeHandler2.prototype.labelShape = null;
mxEdgeHandler2.prototype.cloneEnabled = true;
mxEdgeHandler2.prototype.addEnabled = false;
mxEdgeHandler2.prototype.removeEnabled = false;
mxEdgeHandler2.prototype.dblClickRemoveEnabled = false;
mxEdgeHandler2.prototype.mergeRemoveEnabled = false;
mxEdgeHandler2.prototype.straightRemoveEnabled = false;
mxEdgeHandler2.prototype.virtualBendsEnabled = false;
mxEdgeHandler2.prototype.virtualBendOpacity = 20;
mxEdgeHandler2.prototype.parentHighlightEnabled = false;
mxEdgeHandler2.prototype.preferHtml = false;
mxEdgeHandler2.prototype.allowHandleBoundsCheck = true;
mxEdgeHandler2.prototype.snapToTerminals = false;
mxEdgeHandler2.prototype.handleImage = null;
mxEdgeHandler2.prototype.tolerance = 0;
mxEdgeHandler2.prototype.outlineConnect = false;
mxEdgeHandler2.prototype.manageLabelHandle = false;
mxEdgeHandler2.prototype.init = function() {
  this.graph = this.state.view.graph;
  this.marker = this.createMarker();
  this.constraintHandler = new mxConstraintHandler(this.graph);
  this.points = [];
  this.abspoints = this.getSelectionPoints(this.state);
  this.shape = this.createSelectionShape(this.abspoints);
  this.shape.dialect = this.graph.dialect != mxConstants2.DIALECT_SVG ? mxConstants2.DIALECT_MIXEDHTML : mxConstants2.DIALECT_SVG;
  this.shape.init(this.graph.getView().getOverlayPane());
  this.shape.pointerEvents = false;
  this.shape.setCursor(mxConstants2.CURSOR_MOVABLE_EDGE);
  mxEvent2.redirectMouseEvents(this.shape.node, this.graph, this.state);
  this.preferHtml = this.state.text != null && this.state.text.node.parentNode == this.graph.container;
  if (!this.preferHtml) {
    const sourceState = this.state.getVisibleTerminalState(true);
    if (sourceState != null) {
      this.preferHtml = sourceState.text != null && sourceState.text.node.parentNode == this.graph.container;
    }
    if (!this.preferHtml) {
      const targetState = this.state.getVisibleTerminalState(false);
      if (targetState != null) {
        this.preferHtml = targetState.text != null && targetState.text.node.parentNode == this.graph.container;
      }
    }
  }
  if (this.graph.getSelectionCount() < mxGraphHandler.prototype.maxCells || mxGraphHandler.prototype.maxCells <= 0) {
    this.bends = this.createBends();
    if (this.isVirtualBendsEnabled()) {
      this.virtualBends = this.createVirtualBends();
    }
  }
  this.label = new mxPoint2(this.state.absoluteOffset.x, this.state.absoluteOffset.y);
  this.labelShape = this.createLabelHandleShape();
  this.initBend(this.labelShape);
  this.labelShape.setCursor(mxConstants2.CURSOR_LABEL_HANDLE);
  this.customHandles = this.createCustomHandles();
  this.updateParentHighlight();
  this.redraw();
};
mxEdgeHandler2.prototype.isParentHighlightVisible = mxVertexHandler2.prototype.isParentHighlightVisible;
mxEdgeHandler2.prototype.updateParentHighlight = mxVertexHandler2.prototype.updateParentHighlight;
mxEdgeHandler2.prototype.createCustomHandles = function() {
  return null;
};
mxEdgeHandler2.prototype.isVirtualBendsEnabled = function(evt) {
  return this.virtualBendsEnabled && (this.state.style[mxConstants2.STYLE_EDGE] == null || this.state.style[mxConstants2.STYLE_EDGE] == mxConstants2.NONE || this.state.style[mxConstants2.STYLE_NOEDGESTYLE] == 1) && getValue(this.state.style, mxConstants2.STYLE_SHAPE, null) != "arrow";
};
mxEdgeHandler2.prototype.isCellEnabled = function(cell2) {
  return true;
};
mxEdgeHandler2.prototype.isAddPointEvent = function(evt) {
  return mxEvent2.isShiftDown(evt);
};
mxEdgeHandler2.prototype.isRemovePointEvent = function(evt) {
  return mxEvent2.isShiftDown(evt);
};
mxEdgeHandler2.prototype.getSelectionPoints = function(state2) {
  return state2.absolutePoints;
};
mxEdgeHandler2.prototype.createParentHighlightShape = function(bounds) {
  const shape = new mxRectangleShape(mxRectangle.fromRectangle(bounds), null, this.getSelectionColor());
  shape.strokewidth = this.getSelectionStrokeWidth();
  shape.isDashed = this.isSelectionDashed();
  return shape;
};
mxEdgeHandler2.prototype.createSelectionShape = function(points) {
  const shape = new this.state.shape.constructor();
  shape.outline = true;
  shape.apply(this.state);
  shape.isDashed = this.isSelectionDashed();
  shape.stroke = this.getSelectionColor();
  shape.isShadow = false;
  return shape;
};
mxEdgeHandler2.prototype.getSelectionColor = function() {
  return mxConstants2.EDGE_SELECTION_COLOR;
};
mxEdgeHandler2.prototype.getSelectionStrokeWidth = function() {
  return mxConstants2.EDGE_SELECTION_STROKEWIDTH;
};
mxEdgeHandler2.prototype.isSelectionDashed = function() {
  return mxConstants2.EDGE_SELECTION_DASHED;
};
mxEdgeHandler2.prototype.isConnectableCell = function(cell2) {
  return true;
};
mxEdgeHandler2.prototype.getCellAt = function(x, y) {
  return !this.outlineConnect ? this.graph.getCellAt(x, y) : null;
};
mxEdgeHandler2.prototype.createMarker = function() {
  const marker = new mxCellMarker(this.graph);
  const self = this;
  marker.getCell = function(me) {
    let cell2 = mxCellMarker.prototype.getCell.apply(this, arguments);
    if ((cell2 == self.state.cell || cell2 == null) && self.currentPoint != null) {
      cell2 = self.graph.getCellAt(self.currentPoint.x, self.currentPoint.y);
    }
    if (cell2 != null && !this.graph.isCellConnectable(cell2)) {
      const parent2 = this.graph.getModel().getParent(cell2);
      if (this.graph.getModel().isVertex(parent2) && this.graph.isCellConnectable(parent2)) {
        cell2 = parent2;
      }
    }
    const model = self.graph.getModel();
    if (this.graph.isSwimlane(cell2) && self.currentPoint != null && this.graph.hitsSwimlaneContent(cell2, self.currentPoint.x, self.currentPoint.y) || !self.isConnectableCell(cell2) || (cell2 == self.state.cell || cell2 != null && !self.graph.connectableEdges && model.isEdge(cell2)) || model.isAncestor(self.state.cell, cell2)) {
      cell2 = null;
    }
    if (!this.graph.isCellConnectable(cell2)) {
      cell2 = null;
    }
    return cell2;
  };
  marker.isValidState = function(state2) {
    const model = self.graph.getModel();
    const other = self.graph.view.getTerminalPort(state2, self.graph.view.getState(model.getTerminal(self.state.cell, !self.isSource)), !self.isSource);
    const otherCell = other != null ? other.cell : null;
    const source = self.isSource ? state2.cell : otherCell;
    const target = self.isSource ? otherCell : state2.cell;
    self.error = self.validateConnection(source, target);
    return self.error == null;
  };
  return marker;
};
mxEdgeHandler2.prototype.validateConnection = function(source, target) {
  return this.graph.getEdgeValidationError(this.state.cell, source, target);
};
mxEdgeHandler2.prototype.createBends = function() {
  const cell2 = this.state.cell;
  const bends = [];
  for (let i = 0; i < this.abspoints.length; i++) {
    if (this.isHandleVisible(i)) {
      const source = i == 0;
      const target = i == this.abspoints.length - 1;
      const terminal = source || target;
      if (terminal || this.graph.isCellBendable(cell2)) {
        bind(this, function(index) {
          const bend = this.createHandleShape(index);
          this.initBend(bend, bind(this, bind(this, function() {
            if (this.dblClickRemoveEnabled) {
              this.removePoint(this.state, index);
            }
          })));
          if (this.isHandleEnabled(i)) {
            bend.setCursor(terminal ? mxConstants2.CURSOR_TERMINAL_HANDLE : mxConstants2.CURSOR_BEND_HANDLE);
          }
          bends.push(bend);
          if (!terminal) {
            this.points.push(new mxPoint2(0, 0));
            bend.node.style.visibility = "hidden";
          }
        })(i);
      }
    }
  }
  return bends;
};
mxEdgeHandler2.prototype.createVirtualBends = function() {
  const cell2 = this.state.cell;
  const last = this.abspoints[0];
  const bends = [];
  if (this.graph.isCellBendable(cell2)) {
    for (let i = 1; i < this.abspoints.length; i++) {
      bind(this, function(bend) {
        this.initBend(bend);
        bend.setCursor(mxConstants2.CURSOR_VIRTUAL_BEND_HANDLE);
        bends.push(bend);
      })(this.createHandleShape());
    }
  }
  return bends;
};
mxEdgeHandler2.prototype.isHandleEnabled = function(index) {
  return true;
};
mxEdgeHandler2.prototype.isHandleVisible = function(index) {
  const source = this.state.getVisibleTerminalState(true);
  const target = this.state.getVisibleTerminalState(false);
  const geo = this.graph.getCellGeometry(this.state.cell);
  const edgeStyle = geo != null ? this.graph.view.getEdgeStyle(this.state, geo.points, source, target) : null;
  return edgeStyle != mxEdgeStyle.EntityRelation || index == 0 || index == this.abspoints.length - 1;
};
mxEdgeHandler2.prototype.createHandleShape = function(index) {
  if (this.handleImage != null) {
    const shape = new mxImageShape(new mxRectangle(0, 0, this.handleImage.width, this.handleImage.height), this.handleImage.src);
    shape.preserveImageAspect = false;
    return shape;
  } else {
    let s = mxConstants2.HANDLE_SIZE;
    if (this.preferHtml) {
      s -= 1;
    }
    return new mxRectangleShape(new mxRectangle(0, 0, s, s), mxConstants2.HANDLE_FILLCOLOR, mxConstants2.HANDLE_STROKECOLOR);
  }
};
mxEdgeHandler2.prototype.createLabelHandleShape = function() {
  if (this.labelHandleImage != null) {
    const shape = new mxImageShape(new mxRectangle(0, 0, this.labelHandleImage.width, this.labelHandleImage.height), this.labelHandleImage.src);
    shape.preserveImageAspect = false;
    return shape;
  } else {
    const s = mxConstants2.LABEL_HANDLE_SIZE;
    return new mxRectangleShape(new mxRectangle(0, 0, s, s), mxConstants2.LABEL_HANDLE_FILLCOLOR, mxConstants2.HANDLE_STROKECOLOR);
  }
};
mxEdgeHandler2.prototype.initBend = function(bend, dblClick) {
  if (this.preferHtml) {
    bend.dialect = mxConstants2.DIALECT_STRICTHTML;
    bend.init(this.graph.container);
  } else {
    bend.dialect = this.graph.dialect != mxConstants2.DIALECT_SVG ? mxConstants2.DIALECT_MIXEDHTML : mxConstants2.DIALECT_SVG;
    bend.init(this.graph.getView().getOverlayPane());
  }
  mxEvent2.redirectMouseEvents(bend.node, this.graph, this.state, null, null, null, dblClick);
  if (mxClient_default.IS_QUIRKS || document.documentMode == 8) {
    mxEvent2.addListener(bend.node, "dragstart", function(evt) {
      mxEvent2.consume(evt);
      return false;
    });
  }
  if (mxClient_default.IS_TOUCH) {
    bend.node.setAttribute("pointer-events", "none");
  }
};
mxEdgeHandler2.prototype.getHandleForEvent = function(me) {
  let result2 = null;
  if (this.state != null) {
    let checkShape = function(shape) {
      if (shape != null && shape.node != null && shape.node.style.display != "none" && shape.node.style.visibility != "hidden" && (me.isSource(shape) || hit != null && intersects(shape.bounds, hit))) {
        const dx = me.getGraphX() - shape.bounds.getCenterX();
        const dy = me.getGraphY() - shape.bounds.getCenterY();
        const tmp = dx * dx + dy * dy;
        if (minDistSq == null || tmp <= minDistSq) {
          minDistSq = tmp;
          return true;
        }
      }
      return false;
    };
    const tol = !mxEvent2.isMouseEvent(me.getEvent()) ? this.tolerance : 1;
    const hit = this.allowHandleBoundsCheck && (mxClient_default.IS_IE || tol > 0) ? new mxRectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol) : null;
    let minDistSq = null;
    if (this.customHandles != null && this.isCustomHandleEvent(me)) {
      for (let i = this.customHandles.length - 1; i >= 0; i--) {
        if (checkShape(this.customHandles[i].shape)) {
          return mxEvent2.CUSTOM_HANDLE - i;
        }
      }
    }
    if (me.isSource(this.state.text) || checkShape(this.labelShape)) {
      result2 = mxEvent2.LABEL_HANDLE;
    }
    if (this.bends != null) {
      for (let i = 0; i < this.bends.length; i++) {
        if (checkShape(this.bends[i])) {
          result2 = i;
        }
      }
    }
    if (this.virtualBends != null && this.isAddVirtualBendEvent(me)) {
      for (let i = 0; i < this.virtualBends.length; i++) {
        if (checkShape(this.virtualBends[i])) {
          result2 = mxEvent2.VIRTUAL_HANDLE - i;
        }
      }
    }
  }
  return result2;
};
mxEdgeHandler2.prototype.isAddVirtualBendEvent = function(me) {
  return true;
};
mxEdgeHandler2.prototype.isCustomHandleEvent = function(me) {
  return true;
};
mxEdgeHandler2.prototype.mouseDown = function(sender, me) {
  const handle = this.getHandleForEvent(me);
  if (this.bends != null && this.bends[handle] != null) {
    const b = this.bends[handle].bounds;
    this.snapPoint = new mxPoint2(b.getCenterX(), b.getCenterY());
  }
  if (this.addEnabled && handle == null && this.isAddPointEvent(me.getEvent())) {
    this.addPoint(this.state, me.getEvent());
    me.consume();
  } else if (handle != null && !me.isConsumed() && this.graph.isEnabled()) {
    if (this.removeEnabled && this.isRemovePointEvent(me.getEvent())) {
      this.removePoint(this.state, handle);
    } else if (handle != mxEvent2.LABEL_HANDLE || this.graph.isLabelMovable(me.getCell())) {
      if (handle <= mxEvent2.VIRTUAL_HANDLE) {
        setOpacity(this.virtualBends[mxEvent2.VIRTUAL_HANDLE - handle].node, 100);
      }
      this.start(me.getX(), me.getY(), handle);
    }
    me.consume();
  }
};
mxEdgeHandler2.prototype.start = function(x, y, index) {
  this.startX = x;
  this.startY = y;
  this.isSource = this.bends == null ? false : index == 0;
  this.isTarget = this.bends == null ? false : index == this.bends.length - 1;
  this.isLabel = index == mxEvent2.LABEL_HANDLE;
  if (this.isSource || this.isTarget) {
    const cell2 = this.state.cell;
    const terminal = this.graph.model.getTerminal(cell2, this.isSource);
    if (terminal == null && this.graph.isTerminalPointMovable(cell2, this.isSource) || terminal != null && this.graph.isCellDisconnectable(cell2, terminal, this.isSource)) {
      this.index = index;
    }
  } else {
    this.index = index;
  }
  if (this.index <= mxEvent2.CUSTOM_HANDLE && this.index > mxEvent2.VIRTUAL_HANDLE) {
    if (this.customHandles != null) {
      for (let i = 0; i < this.customHandles.length; i++) {
        if (i != mxEvent2.CUSTOM_HANDLE - this.index) {
          this.customHandles[i].setVisible(false);
        }
      }
    }
  }
};
mxEdgeHandler2.prototype.clonePreviewState = function(point, terminal) {
  return this.state.clone();
};
mxEdgeHandler2.prototype.getSnapToTerminalTolerance = function() {
  return this.graph.gridSize * this.graph.view.scale / 2;
};
mxEdgeHandler2.prototype.updateHint = function(me, point) {
};
mxEdgeHandler2.prototype.removeHint = function() {
};
mxEdgeHandler2.prototype.roundLength = function(length) {
  return Math.round(length);
};
mxEdgeHandler2.prototype.isSnapToTerminalsEvent = function(me) {
  return this.snapToTerminals && !mxEvent2.isAltDown(me.getEvent());
};
mxEdgeHandler2.prototype.getPointForEvent = function(me) {
  const view = this.graph.getView();
  const scale = view.scale;
  const point = new mxPoint2(this.roundLength(me.getGraphX() / scale) * scale, this.roundLength(me.getGraphY() / scale) * scale);
  const tt = this.getSnapToTerminalTolerance();
  let overrideX = false;
  let overrideY = false;
  if (tt > 0 && this.isSnapToTerminalsEvent(me)) {
    let snapToPoint = function(pt) {
      if (pt != null) {
        const x = pt.x;
        if (Math.abs(point.x - x) < tt) {
          point.x = x;
          overrideX = true;
        }
        const y = pt.y;
        if (Math.abs(point.y - y) < tt) {
          point.y = y;
          overrideY = true;
        }
      }
    }, snapToTerminal = function(terminal) {
      if (terminal != null) {
        snapToPoint.call(this, new mxPoint2(view.getRoutingCenterX(terminal), view.getRoutingCenterY(terminal)));
      }
    };
    ;
    snapToTerminal.call(this, this.state.getVisibleTerminalState(true));
    snapToTerminal.call(this, this.state.getVisibleTerminalState(false));
    if (this.state.absolutePoints != null) {
      for (let i = 0; i < this.state.absolutePoints.length; i++) {
        snapToPoint.call(this, this.state.absolutePoints[i]);
      }
    }
  }
  if (this.graph.isGridEnabledEvent(me.getEvent())) {
    const tr = view.translate;
    if (!overrideX) {
      point.x = (this.graph.snap(point.x / scale - tr.x) + tr.x) * scale;
    }
    if (!overrideY) {
      point.y = (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale;
    }
  }
  return point;
};
mxEdgeHandler2.prototype.getPreviewTerminalState = function(me) {
  this.constraintHandler.update(me, this.isSource, true, me.isSource(this.marker.highlight.shape) ? null : this.currentPoint);
  if (this.constraintHandler.currentFocus != null && this.constraintHandler.currentConstraint != null) {
    if (this.marker.highlight != null && this.marker.highlight.state != null && this.marker.highlight.state.cell == this.constraintHandler.currentFocus.cell) {
      if (this.marker.highlight.shape.stroke != "transparent") {
        this.marker.highlight.shape.stroke = "transparent";
        this.marker.highlight.repaint();
      }
    } else {
      this.marker.markCell(this.constraintHandler.currentFocus.cell, "transparent");
    }
    const model = this.graph.getModel();
    const other = this.graph.view.getTerminalPort(this.state, this.graph.view.getState(model.getTerminal(this.state.cell, !this.isSource)), !this.isSource);
    const otherCell = other != null ? other.cell : null;
    const source = this.isSource ? this.constraintHandler.currentFocus.cell : otherCell;
    const target = this.isSource ? otherCell : this.constraintHandler.currentFocus.cell;
    this.error = this.validateConnection(source, target);
    let result2 = null;
    if (this.error == null) {
      result2 = this.constraintHandler.currentFocus;
    }
    if (this.error != null || result2 != null && !this.isCellEnabled(result2.cell)) {
      this.constraintHandler.reset();
    }
    return result2;
  } else if (!this.graph.isIgnoreTerminalEvent(me.getEvent())) {
    this.marker.process(me);
    const state2 = this.marker.getValidState();
    if (state2 != null && !this.isCellEnabled(state2.cell)) {
      this.constraintHandler.reset();
      this.marker.reset();
    }
    return this.marker.getValidState();
  } else {
    this.marker.reset();
    return null;
  }
};
mxEdgeHandler2.prototype.getPreviewPoints = function(pt, me) {
  const geometry = this.graph.getCellGeometry(this.state.cell);
  let points = geometry.points != null ? geometry.points.slice() : null;
  const point = new mxPoint2(pt.x, pt.y);
  let result2 = null;
  if (!this.isSource && !this.isTarget) {
    this.convertPoint(point, false);
    if (points == null) {
      points = [point];
    } else {
      if (this.index <= mxEvent2.VIRTUAL_HANDLE) {
        points.splice(mxEvent2.VIRTUAL_HANDLE - this.index, 0, point);
      }
      if (!this.isSource && !this.isTarget) {
        for (let i = 0; i < this.bends.length; i++) {
          if (i != this.index) {
            const bend = this.bends[i];
            if (bend != null && contains(bend.bounds, pt.x, pt.y)) {
              if (this.index <= mxEvent2.VIRTUAL_HANDLE) {
                points.splice(mxEvent2.VIRTUAL_HANDLE - this.index, 1);
              } else {
                points.splice(this.index - 1, 1);
              }
              result2 = points;
            }
          }
        }
        if (result2 == null && this.straightRemoveEnabled && (me == null || !mxEvent2.isAltDown(me.getEvent()))) {
          let checkRemove = function(idx, tmp) {
            if (idx > 0 && idx < abs.length - 1 && ptSegDistSq(abs[idx - 1].x, abs[idx - 1].y, abs[idx + 1].x, abs[idx + 1].y, tmp.x, tmp.y) < tol) {
              points.splice(idx - 1, 1);
              result2 = points;
            }
          };
          const tol = this.graph.tolerance * this.graph.tolerance;
          const abs = this.state.absolutePoints.slice();
          abs[this.index] = pt;
          const src = this.state.getVisibleTerminalState(true);
          if (src != null) {
            const c = this.graph.getConnectionConstraint(this.state, src, true);
            if (c == null || this.graph.getConnectionPoint(src, c) == null) {
              abs[0] = new mxPoint2(src.view.getRoutingCenterX(src), src.view.getRoutingCenterY(src));
            }
          }
          const trg = this.state.getVisibleTerminalState(false);
          if (trg != null) {
            const c = this.graph.getConnectionConstraint(this.state, trg, false);
            if (c == null || this.graph.getConnectionPoint(trg, c) == null) {
              abs[abs.length - 1] = new mxPoint2(trg.view.getRoutingCenterX(trg), trg.view.getRoutingCenterY(trg));
            }
          }
          ;
          checkRemove(this.index, pt);
        }
      }
      if (result2 == null && this.index > mxEvent2.VIRTUAL_HANDLE) {
        points[this.index - 1] = point;
      }
    }
  } else if (this.graph.resetEdgesOnConnect) {
    points = null;
  }
  return result2 != null ? result2 : points;
};
mxEdgeHandler2.prototype.isOutlineConnectEvent = function(me) {
  const offset = getOffset(this.graph.container);
  const evt = me.getEvent();
  const clientX = mxEvent2.getClientX(evt);
  const clientY = mxEvent2.getClientY(evt);
  const doc = document.documentElement;
  const left = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);
  const top = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);
  const gridX = this.currentPoint.x - this.graph.container.scrollLeft + offset.x - left;
  const gridY = this.currentPoint.y - this.graph.container.scrollTop + offset.y - top;
  return this.outlineConnect && !mxEvent2.isShiftDown(me.getEvent()) && (me.isSource(this.marker.highlight.shape) || mxEvent2.isAltDown(me.getEvent()) && me.getState() != null || this.marker.highlight.isHighlightAt(clientX, clientY) || (gridX != clientX || gridY != clientY) && me.getState() == null && this.marker.highlight.isHighlightAt(gridX, gridY));
};
mxEdgeHandler2.prototype.updatePreviewState = function(edge, point, terminalState, me, outline) {
  const sourceState = this.isSource ? terminalState : this.state.getVisibleTerminalState(true);
  const targetState = this.isTarget ? terminalState : this.state.getVisibleTerminalState(false);
  let sourceConstraint = this.graph.getConnectionConstraint(edge, sourceState, true);
  let targetConstraint = this.graph.getConnectionConstraint(edge, targetState, false);
  let constraint = this.constraintHandler.currentConstraint;
  if (constraint == null && outline) {
    if (terminalState != null) {
      if (me.isSource(this.marker.highlight.shape)) {
        point = new mxPoint2(me.getGraphX(), me.getGraphY());
      }
      constraint = this.graph.getOutlineConstraint(point, terminalState, me);
      this.constraintHandler.setFocus(me, terminalState, this.isSource);
      this.constraintHandler.currentConstraint = constraint;
      this.constraintHandler.currentPoint = point;
    } else {
      constraint = new mxConnectionConstraint2();
    }
  }
  if (this.outlineConnect && this.marker.highlight != null && this.marker.highlight.shape != null) {
    const s = this.graph.view.scale;
    if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null) {
      this.marker.highlight.shape.stroke = outline ? mxConstants2.OUTLINE_HIGHLIGHT_COLOR : "transparent";
      this.marker.highlight.shape.strokewidth = mxConstants2.OUTLINE_HIGHLIGHT_STROKEWIDTH / s / s;
      this.marker.highlight.repaint();
    } else if (this.marker.hasValidState()) {
      this.marker.highlight.shape.stroke = this.graph.isCellConnectable(me.getCell()) && this.marker.getValidState() != me.getState() ? "transparent" : mxConstants2.DEFAULT_VALID_COLOR;
      this.marker.highlight.shape.strokewidth = mxConstants2.HIGHLIGHT_STROKEWIDTH / s / s;
      this.marker.highlight.repaint();
    }
  }
  if (this.isSource) {
    sourceConstraint = constraint;
  } else if (this.isTarget) {
    targetConstraint = constraint;
  }
  if (this.isSource || this.isTarget) {
    if (constraint != null && constraint.point != null) {
      edge.style[this.isSource ? mxConstants2.STYLE_EXIT_X : mxConstants2.STYLE_ENTRY_X] = constraint.point.x;
      edge.style[this.isSource ? mxConstants2.STYLE_EXIT_Y : mxConstants2.STYLE_ENTRY_Y] = constraint.point.y;
    } else {
      delete edge.style[this.isSource ? mxConstants2.STYLE_EXIT_X : mxConstants2.STYLE_ENTRY_X];
      delete edge.style[this.isSource ? mxConstants2.STYLE_EXIT_Y : mxConstants2.STYLE_ENTRY_Y];
    }
  }
  edge.setVisibleTerminalState(sourceState, true);
  edge.setVisibleTerminalState(targetState, false);
  if (!this.isSource || sourceState != null) {
    edge.view.updateFixedTerminalPoint(edge, sourceState, true, sourceConstraint);
  }
  if (!this.isTarget || targetState != null) {
    edge.view.updateFixedTerminalPoint(edge, targetState, false, targetConstraint);
  }
  if ((this.isSource || this.isTarget) && terminalState == null) {
    edge.setAbsoluteTerminalPoint(point, this.isSource);
    if (this.marker.getMarkedState() == null) {
      this.error = this.graph.allowDanglingEdges ? null : "";
    }
  }
  edge.view.updatePoints(edge, this.points, sourceState, targetState);
  edge.view.updateFloatingTerminalPoints(edge, sourceState, targetState);
};
mxEdgeHandler2.prototype.mouseMove = function(sender, me) {
  if (this.index != null && this.marker != null) {
    this.currentPoint = this.getPointForEvent(me);
    this.error = null;
    if (!this.graph.isIgnoreTerminalEvent(me.getEvent()) && mxEvent2.isShiftDown(me.getEvent()) && this.snapPoint != null) {
      if (Math.abs(this.snapPoint.x - this.currentPoint.x) < Math.abs(this.snapPoint.y - this.currentPoint.y)) {
        this.currentPoint.x = this.snapPoint.x;
      } else {
        this.currentPoint.y = this.snapPoint.y;
      }
    }
    if (this.index <= mxEvent2.CUSTOM_HANDLE && this.index > mxEvent2.VIRTUAL_HANDLE) {
      if (this.customHandles != null) {
        this.customHandles[mxEvent2.CUSTOM_HANDLE - this.index].processEvent(me);
        this.customHandles[mxEvent2.CUSTOM_HANDLE - this.index].positionChanged();
        if (this.shape != null && this.shape.node != null) {
          this.shape.node.style.display = "none";
        }
      }
    } else if (this.isLabel) {
      this.label.x = this.currentPoint.x;
      this.label.y = this.currentPoint.y;
    } else {
      this.points = this.getPreviewPoints(this.currentPoint, me);
      let terminalState = this.isSource || this.isTarget ? this.getPreviewTerminalState(me) : null;
      let outline;
      if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null && this.constraintHandler.currentPoint != null) {
        this.currentPoint = this.constraintHandler.currentPoint.clone();
      } else if (this.outlineConnect) {
        outline = this.isSource || this.isTarget ? this.isOutlineConnectEvent(me) : false;
        if (outline) {
          terminalState = this.marker.highlight.state;
        } else if (terminalState != null && terminalState != me.getState() && this.graph.isCellConnectable(me.getCell()) && this.marker.highlight.shape != null) {
          this.marker.highlight.shape.stroke = "transparent";
          this.marker.highlight.repaint();
          terminalState = null;
        }
      }
      if (terminalState != null && !this.isCellEnabled(terminalState.cell)) {
        terminalState = null;
        this.marker.reset();
      }
      const clone3 = this.clonePreviewState(this.currentPoint, terminalState != null ? terminalState.cell : null);
      this.updatePreviewState(clone3, this.currentPoint, terminalState, me, outline);
      const color = this.error == null ? this.marker.validColor : this.marker.invalidColor;
      this.setPreviewColor(color);
      this.abspoints = clone3.absolutePoints;
      this.active = true;
      this.updateHint(me, this.currentPoint);
    }
    this.drawPreview();
    mxEvent2.consume(me.getEvent());
    me.consume();
  } else if (mxClient_default.IS_IE && this.getHandleForEvent(me) != null) {
    me.consume(false);
  }
};
mxEdgeHandler2.prototype.mouseUp = function(sender, me) {
  if (this.index != null && this.marker != null) {
    if (this.shape != null && this.shape.node != null) {
      this.shape.node.style.display = "";
    }
    let edge = this.state.cell;
    const index = this.index;
    this.index = null;
    if (me.getX() != this.startX || me.getY() != this.startY) {
      const clone3 = !this.graph.isIgnoreTerminalEvent(me.getEvent()) && this.graph.isCloneEvent(me.getEvent()) && this.cloneEnabled && this.graph.isCellsCloneable();
      if (this.error != null) {
        if (this.error.length > 0) {
          this.graph.validationAlert(this.error);
        }
      } else if (index <= mxEvent2.CUSTOM_HANDLE && index > mxEvent2.VIRTUAL_HANDLE) {
        if (this.customHandles != null) {
          const model = this.graph.getModel();
          model.beginUpdate();
          try {
            this.customHandles[mxEvent2.CUSTOM_HANDLE - index].execute(me);
            if (this.shape != null && this.shape.node != null) {
              this.shape.apply(this.state);
              this.shape.redraw();
            }
          } finally {
            model.endUpdate();
          }
        }
      } else if (this.isLabel) {
        this.moveLabel(this.state, this.label.x, this.label.y);
      } else if (this.isSource || this.isTarget) {
        let terminal = null;
        if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null) {
          terminal = this.constraintHandler.currentFocus.cell;
        }
        if (terminal == null && this.marker.hasValidState() && this.marker.highlight != null && this.marker.highlight.shape != null && this.marker.highlight.shape.stroke != "transparent" && this.marker.highlight.shape.stroke != "white") {
          terminal = this.marker.validState.cell;
        }
        if (terminal != null) {
          const model = this.graph.getModel();
          const parent2 = model.getParent(edge);
          model.beginUpdate();
          try {
            if (clone3) {
              let geo = model.getGeometry(edge);
              const cloneCell = this.graph.cloneCell(edge);
              model.add(parent2, cloneCell, model.getChildCount(parent2));
              if (geo != null) {
                geo = geo.clone();
                model.setGeometry(cloneCell, geo);
              }
              const other = model.getTerminal(edge, !this.isSource);
              this.graph.connectCell(cloneCell, other, !this.isSource);
              edge = cloneCell;
            }
            edge = this.connect(edge, terminal, this.isSource, clone3, me);
          } finally {
            model.endUpdate();
          }
        } else if (this.graph.isAllowDanglingEdges()) {
          const pt = this.abspoints[this.isSource ? 0 : this.abspoints.length - 1];
          pt.x = this.roundLength(pt.x / this.graph.view.scale - this.graph.view.translate.x);
          pt.y = this.roundLength(pt.y / this.graph.view.scale - this.graph.view.translate.y);
          const pstate = this.graph.getView().getState(this.graph.getModel().getParent(edge));
          if (pstate != null) {
            pt.x -= pstate.origin.x;
            pt.y -= pstate.origin.y;
          }
          pt.x -= this.graph.panDx / this.graph.view.scale;
          pt.y -= this.graph.panDy / this.graph.view.scale;
          edge = this.changeTerminalPoint(edge, pt, this.isSource, clone3);
        }
      } else if (this.active) {
        edge = this.changePoints(edge, this.points, clone3);
      } else {
        this.graph.getView().invalidate(this.state.cell);
        this.graph.getView().validate(this.state.cell);
      }
    } else if (this.graph.isToggleEvent(me.getEvent())) {
      this.graph.selectCellForEvent(this.state.cell, me.getEvent());
    }
    if (this.marker != null) {
      this.reset();
      if (edge != this.state.cell) {
        this.graph.setSelectionCell(edge);
      }
    }
    me.consume();
  }
};
mxEdgeHandler2.prototype.reset = function() {
  if (this.active) {
    this.refresh();
  }
  this.error = null;
  this.index = null;
  this.label = null;
  this.points = null;
  this.snapPoint = null;
  this.isLabel = false;
  this.isSource = false;
  this.isTarget = false;
  this.active = false;
  if (this.livePreview && this.sizers != null) {
    for (let i = 0; i < this.sizers.length; i++) {
      if (this.sizers[i] != null) {
        this.sizers[i].node.style.display = "";
      }
    }
  }
  if (this.marker != null) {
    this.marker.reset();
  }
  if (this.constraintHandler != null) {
    this.constraintHandler.reset();
  }
  if (this.customHandles != null) {
    for (let i = 0; i < this.customHandles.length; i++) {
      this.customHandles[i].reset();
    }
  }
  this.setPreviewColor(mxConstants2.EDGE_SELECTION_COLOR);
  this.removeHint();
  this.redraw();
};
mxEdgeHandler2.prototype.setPreviewColor = function(color) {
  if (this.shape != null) {
    this.shape.stroke = color;
  }
};
mxEdgeHandler2.prototype.convertPoint = function(point, gridEnabled) {
  const scale = this.graph.getView().getScale();
  const tr = this.graph.getView().getTranslate();
  if (gridEnabled) {
    point.x = this.graph.snap(point.x);
    point.y = this.graph.snap(point.y);
  }
  point.x = Math.round(point.x / scale - tr.x);
  point.y = Math.round(point.y / scale - tr.y);
  const pstate = this.graph.getView().getState(this.graph.getModel().getParent(this.state.cell));
  if (pstate != null) {
    point.x -= pstate.origin.x;
    point.y -= pstate.origin.y;
  }
  return point;
};
mxEdgeHandler2.prototype.moveLabel = function(edgeState, x, y) {
  const model = this.graph.getModel();
  let geometry = model.getGeometry(edgeState.cell);
  if (geometry != null) {
    const scale = this.graph.getView().scale;
    geometry = geometry.clone();
    if (geometry.relative) {
      let pt = this.graph.getView().getRelativePoint(edgeState, x, y);
      geometry.x = Math.round(pt.x * 1e4) / 1e4;
      geometry.y = Math.round(pt.y);
      geometry.offset = new mxPoint2(0, 0);
      pt = this.graph.view.getPoint(edgeState, geometry);
      geometry.offset = new mxPoint2(Math.round((x - pt.x) / scale), Math.round((y - pt.y) / scale));
    } else {
      const points = edgeState.absolutePoints;
      const p0 = points[0];
      const pe = points[points.length - 1];
      if (p0 != null && pe != null) {
        const cx = p0.x + (pe.x - p0.x) / 2;
        const cy = p0.y + (pe.y - p0.y) / 2;
        geometry.offset = new mxPoint2(Math.round((x - cx) / scale), Math.round((y - cy) / scale));
        geometry.x = 0;
        geometry.y = 0;
      }
    }
    model.setGeometry(edgeState.cell, geometry);
  }
};
mxEdgeHandler2.prototype.connect = function(edge, terminal, isSource, isClone, me) {
  const model = this.graph.getModel();
  const parent2 = model.getParent(edge);
  model.beginUpdate();
  try {
    let constraint = this.constraintHandler.currentConstraint;
    if (constraint == null) {
      constraint = new mxConnectionConstraint2();
    }
    this.graph.connectCell(edge, terminal, isSource, constraint);
  } finally {
    model.endUpdate();
  }
  return edge;
};
mxEdgeHandler2.prototype.changeTerminalPoint = function(edge, point, isSource, clone3) {
  const model = this.graph.getModel();
  model.beginUpdate();
  try {
    if (clone3) {
      const parent2 = model.getParent(edge);
      const terminal = model.getTerminal(edge, !isSource);
      edge = this.graph.cloneCell(edge);
      model.add(parent2, edge, model.getChildCount(parent2));
      model.setTerminal(edge, terminal, !isSource);
    }
    let geo = model.getGeometry(edge);
    if (geo != null) {
      geo = geo.clone();
      geo.setTerminalPoint(point, isSource);
      model.setGeometry(edge, geo);
      this.graph.connectCell(edge, null, isSource, new mxConnectionConstraint2());
    }
  } finally {
    model.endUpdate();
  }
  return edge;
};
mxEdgeHandler2.prototype.changePoints = function(edge, points, clone3) {
  const model = this.graph.getModel();
  model.beginUpdate();
  try {
    if (clone3) {
      const parent2 = model.getParent(edge);
      const source = model.getTerminal(edge, true);
      const target = model.getTerminal(edge, false);
      edge = this.graph.cloneCell(edge);
      model.add(parent2, edge, model.getChildCount(parent2));
      model.setTerminal(edge, source, true);
      model.setTerminal(edge, target, false);
    }
    let geo = model.getGeometry(edge);
    if (geo != null) {
      geo = geo.clone();
      geo.points = points;
      model.setGeometry(edge, geo);
    }
  } finally {
    model.endUpdate();
  }
  return edge;
};
mxEdgeHandler2.prototype.addPoint = function(state2, evt) {
  const pt = convertPoint(this.graph.container, mxEvent2.getClientX(evt), mxEvent2.getClientY(evt));
  const gridEnabled = this.graph.isGridEnabledEvent(evt);
  this.convertPoint(pt, gridEnabled);
  this.addPointAt(state2, pt.x, pt.y);
  mxEvent2.consume(evt);
};
mxEdgeHandler2.prototype.addPointAt = function(state2, x, y) {
  let geo = this.graph.getCellGeometry(state2.cell);
  const pt = new mxPoint2(x, y);
  if (geo != null) {
    geo = geo.clone();
    const t = this.graph.view.translate;
    const s = this.graph.view.scale;
    let offset = new mxPoint2(t.x * s, t.y * s);
    const parent2 = this.graph.model.getParent(this.state.cell);
    if (this.graph.model.isVertex(parent2)) {
      const pState = this.graph.view.getState(parent2);
      offset = new mxPoint2(pState.x, pState.y);
    }
    const index = findNearestSegment(state2, pt.x * s + offset.x, pt.y * s + offset.y);
    if (geo.points == null) {
      geo.points = [pt];
    } else {
      geo.points.splice(index, 0, pt);
    }
    this.graph.getModel().setGeometry(state2.cell, geo);
    this.refresh();
    this.redraw();
  }
};
mxEdgeHandler2.prototype.removePoint = function(state2, index) {
  if (index > 0 && index < this.abspoints.length - 1) {
    let geo = this.graph.getCellGeometry(this.state.cell);
    if (geo != null && geo.points != null) {
      geo = geo.clone();
      geo.points.splice(index - 1, 1);
      this.graph.getModel().setGeometry(state2.cell, geo);
      this.refresh();
      this.redraw();
    }
  }
};
mxEdgeHandler2.prototype.getHandleFillColor = function(index) {
  const isSource = index == 0;
  const cell2 = this.state.cell;
  const terminal = this.graph.getModel().getTerminal(cell2, isSource);
  let color = mxConstants2.HANDLE_FILLCOLOR;
  if (terminal != null && !this.graph.isCellDisconnectable(cell2, terminal, isSource) || terminal == null && !this.graph.isTerminalPointMovable(cell2, isSource)) {
    color = mxConstants2.LOCKED_HANDLE_FILLCOLOR;
  } else if (terminal != null && this.graph.isCellDisconnectable(cell2, terminal, isSource)) {
    color = mxConstants2.CONNECT_HANDLE_FILLCOLOR;
  }
  return color;
};
mxEdgeHandler2.prototype.redraw = function(ignoreHandles) {
  if (this.state != null) {
    this.abspoints = this.state.absolutePoints.slice();
    const g = this.graph.getModel().getGeometry(this.state.cell);
    if (g != null) {
      const pts = g.points;
      if (this.bends != null && this.bends.length > 0) {
        if (pts != null) {
          if (this.points == null) {
            this.points = [];
          }
          for (let i = 1; i < this.bends.length - 1; i++) {
            if (this.bends[i] != null && this.abspoints[i] != null) {
              this.points[i - 1] = pts[i - 1];
            }
          }
        }
      }
    }
    this.drawPreview();
    if (!ignoreHandles) {
      this.redrawHandles();
    }
  }
};
mxEdgeHandler2.prototype.redrawHandles = function() {
  const cell2 = this.state.cell;
  let b = this.labelShape.bounds;
  this.label = new mxPoint2(this.state.absoluteOffset.x, this.state.absoluteOffset.y);
  this.labelShape.bounds = new mxRectangle(Math.round(this.label.x - b.width / 2), Math.round(this.label.y - b.height / 2), b.width, b.height);
  const lab = this.graph.getLabel(cell2);
  this.labelShape.visible = lab != null && lab.length > 0 && this.graph.isLabelMovable(cell2);
  if (this.bends != null && this.bends.length > 0) {
    const n = this.abspoints.length - 1;
    const p0 = this.abspoints[0];
    const x0 = p0.x;
    const y0 = p0.y;
    b = this.bends[0].bounds;
    this.bends[0].bounds = new mxRectangle(Math.floor(x0 - b.width / 2), Math.floor(y0 - b.height / 2), b.width, b.height);
    this.bends[0].fill = this.getHandleFillColor(0);
    this.bends[0].redraw();
    if (this.manageLabelHandle) {
      this.checkLabelHandle(this.bends[0].bounds);
    }
    const pe = this.abspoints[n];
    const xn = pe.x;
    const yn = pe.y;
    const bn = this.bends.length - 1;
    b = this.bends[bn].bounds;
    this.bends[bn].bounds = new mxRectangle(Math.floor(xn - b.width / 2), Math.floor(yn - b.height / 2), b.width, b.height);
    this.bends[bn].fill = this.getHandleFillColor(bn);
    this.bends[bn].redraw();
    if (this.manageLabelHandle) {
      this.checkLabelHandle(this.bends[bn].bounds);
    }
    this.redrawInnerBends(p0, pe);
  }
  if (this.abspoints != null && this.virtualBends != null && this.virtualBends.length > 0) {
    let last = this.abspoints[0];
    for (let i = 0; i < this.virtualBends.length; i++) {
      if (this.virtualBends[i] != null && this.abspoints[i + 1] != null) {
        const pt = this.abspoints[i + 1];
        const b2 = this.virtualBends[i];
        const x = last.x + (pt.x - last.x) / 2;
        const y = last.y + (pt.y - last.y) / 2;
        b2.bounds = new mxRectangle(Math.floor(x - b2.bounds.width / 2), Math.floor(y - b2.bounds.height / 2), b2.bounds.width, b2.bounds.height);
        b2.redraw();
        setOpacity(b2.node, this.virtualBendOpacity);
        last = pt;
        if (this.manageLabelHandle) {
          this.checkLabelHandle(b2.bounds);
        }
      }
    }
  }
  if (this.labelShape != null) {
    this.labelShape.redraw();
  }
  if (this.customHandles != null) {
    for (let i = 0; i < this.customHandles.length; i++) {
      const temp2 = this.customHandles[i].shape.node.style.display;
      this.customHandles[i].redraw();
      this.customHandles[i].shape.node.style.display = temp2;
      this.customHandles[i].shape.node.style.visibility = this.isCustomHandleVisible(this.customHandles[i]) ? "" : "hidden";
    }
  }
};
mxEdgeHandler2.prototype.isCustomHandleVisible = function(handle) {
  return !this.graph.isEditing() && this.state.view.graph.getSelectionCount() == 1;
};
mxEdgeHandler2.prototype.setHandlesVisible = function(visible) {
  if (this.bends != null) {
    for (let i = 0; i < this.bends.length; i++) {
      this.bends[i].node.style.display = visible ? "" : "none";
    }
  }
  if (this.virtualBends != null) {
    for (let i = 0; i < this.virtualBends.length; i++) {
      this.virtualBends[i].node.style.display = visible ? "" : "none";
    }
  }
  if (this.labelShape != null) {
    this.labelShape.node.style.display = visible ? "" : "none";
  }
  if (this.customHandles != null) {
    for (let i = 0; i < this.customHandles.length; i++) {
      this.customHandles[i].setVisible(visible);
    }
  }
};
mxEdgeHandler2.prototype.redrawInnerBends = function(p0, pe) {
  for (let i = 1; i < this.bends.length - 1; i++) {
    if (this.bends[i] != null) {
      if (this.abspoints[i] != null) {
        const x = this.abspoints[i].x;
        const y = this.abspoints[i].y;
        const b = this.bends[i].bounds;
        this.bends[i].node.style.visibility = "visible";
        this.bends[i].bounds = new mxRectangle(Math.round(x - b.width / 2), Math.round(y - b.height / 2), b.width, b.height);
        if (this.manageLabelHandle) {
          this.checkLabelHandle(this.bends[i].bounds);
        } else if (this.handleImage == null && this.labelShape.visible && intersects(this.bends[i].bounds, this.labelShape.bounds)) {
          w = mxConstants2.HANDLE_SIZE + 3;
          h = mxConstants2.HANDLE_SIZE + 3;
          this.bends[i].bounds = new mxRectangle(Math.round(x - w / 2), Math.round(y - h / 2), w, h);
        }
        this.bends[i].redraw();
      } else {
        this.bends[i].destroy();
        this.bends[i] = null;
      }
    }
  }
};
mxEdgeHandler2.prototype.checkLabelHandle = function(b) {
  if (this.labelShape != null) {
    const b2 = this.labelShape.bounds;
    if (intersects(b, b2)) {
      if (b.getCenterY() < b2.getCenterY()) {
        b2.y = b.y + b.height;
      } else {
        b2.y = b.y - b2.height;
      }
    }
  }
};
mxEdgeHandler2.prototype.drawPreview = function() {
  try {
    if (this.isLabel) {
      const b = this.labelShape.bounds;
      const bounds = new mxRectangle(Math.round(this.label.x - b.width / 2), Math.round(this.label.y - b.height / 2), b.width, b.height);
      if (!this.labelShape.bounds.equals(bounds)) {
        this.labelShape.bounds = bounds;
        this.labelShape.redraw();
      }
    }
    if (this.shape != null && !equalPoints(this.shape.points, this.abspoints)) {
      this.shape.apply(this.state);
      this.shape.points = this.abspoints.slice();
      this.shape.scale = this.state.view.scale;
      this.shape.isDashed = this.isSelectionDashed();
      this.shape.stroke = this.getSelectionColor();
      this.shape.strokewidth = this.getSelectionStrokeWidth() / this.shape.scale / this.shape.scale;
      this.shape.isShadow = false;
      this.shape.redraw();
    }
    this.updateParentHighlight();
  } catch (e) {
  }
};
mxEdgeHandler2.prototype.refresh = function() {
  if (this.state != null) {
    this.abspoints = this.getSelectionPoints(this.state);
    this.points = [];
    if (this.bends != null) {
      this.destroyBends(this.bends);
      this.bends = this.createBends();
    }
    if (this.virtualBends != null) {
      this.destroyBends(this.virtualBends);
      this.virtualBends = this.createVirtualBends();
    }
    if (this.customHandles != null) {
      this.destroyBends(this.customHandles);
      this.customHandles = this.createCustomHandles();
    }
    if (this.labelShape != null && this.labelShape.node != null && this.labelShape.node.parentNode != null) {
      this.labelShape.node.parentNode.appendChild(this.labelShape.node);
    }
  }
};
mxEdgeHandler2.prototype.isDestroyed = function() {
  return this.shape == null;
};
mxEdgeHandler2.prototype.destroyBends = function(bends) {
  if (bends != null) {
    for (let i = 0; i < bends.length; i++) {
      if (bends[i] != null) {
        bends[i].destroy();
      }
    }
  }
};
mxEdgeHandler2.prototype.destroy = function() {
  if (this.escapeHandler != null) {
    this.state.view.graph.removeListener(this.escapeHandler);
    this.escapeHandler = null;
  }
  if (this.marker != null) {
    this.marker.destroy();
    this.marker = null;
  }
  if (this.shape != null) {
    this.shape.destroy();
    this.shape = null;
  }
  if (this.parentHighlight != null) {
    const parent2 = this.graph.model.getParent(this.state.cell);
    const pstate = this.graph.view.getState(parent2);
    if (pstate != null && pstate.parentHighlight == this.parentHighlight) {
      pstate.parentHighlight = null;
    }
    this.parentHighlight.destroy();
    this.parentHighlight = null;
  }
  if (this.labelShape != null) {
    this.labelShape.destroy();
    this.labelShape = null;
  }
  if (this.constraintHandler != null) {
    this.constraintHandler.destroy();
    this.constraintHandler = null;
  }
  this.destroyBends(this.virtualBends);
  this.virtualBends = null;
  this.destroyBends(this.customHandles);
  this.customHandles = null;
  this.destroyBends(this.bends);
  this.bends = null;
  this.removeHint();
};

// js/graph/mxElbowEdgeHandler.js
var mxElbowEdgeHandler2 = function(state2) {
  mxEdgeHandler2.call(this, state2);
};
extend(mxElbowEdgeHandler2, mxEdgeHandler2);
mxElbowEdgeHandler2.prototype.flipEnabled = true;
mxElbowEdgeHandler2.prototype.doubleClickOrientationResource = mxClient_default.language !== "none" ? "doubleClickOrientation" : "";
mxElbowEdgeHandler2.prototype.createBends = function() {
  const bends = [];
  let bend = this.createHandleShape(0);
  this.initBend(bend);
  bend.setCursor(mxConstants2.CURSOR_TERMINAL_HANDLE);
  bends.push(bend);
  bends.push(this.createVirtualBend(bind(this, function(evt) {
    if (!mxEvent2.isConsumed(evt) && this.flipEnabled) {
      this.graph.flipEdge(this.state.cell, evt);
      mxEvent2.consume(evt);
    }
  })));
  this.points.push(new mxPoint2(0, 0));
  bend = this.createHandleShape(2);
  this.initBend(bend);
  bend.setCursor(mxConstants2.CURSOR_TERMINAL_HANDLE);
  bends.push(bend);
  return bends;
};
mxElbowEdgeHandler2.prototype.createVirtualBend = function(dblClickHandler) {
  const bend = this.createHandleShape();
  this.initBend(bend, dblClickHandler);
  bend.setCursor(this.getCursorForBend());
  if (!this.graph.isCellBendable(this.state.cell)) {
    bend.node.style.display = "none";
  }
  return bend;
};
mxElbowEdgeHandler2.prototype.getCursorForBend = function() {
  const style = this.state.style;
  const edgeStyle = style[mxConstants2.STYLE_EDGE];
  const isVertical = edgeStyle === mxEdgeStyle.TopToBottom || edgeStyle === mxConstants2.EDGESTYLE_TOPTOBOTTOM || (edgeStyle === mxEdgeStyle.ElbowConnector || edgeStyle === mxConstants2.EDGESTYLE_ELBOW) && style[mxConstants2.STYLE_ELBOW] === mxConstants2.ELBOW_VERTICAL;
  return isVertical ? "row-resize" : "col-resize";
};
mxElbowEdgeHandler2.prototype.getTooltipForNode = function(node) {
  let tip = null;
  if (this.bends && this.bends[1] && (node === this.bends[1].node || node.parentNode === this.bends[1].node)) {
    tip = this.doubleClickOrientationResource;
    tip = mxResources2.get(tip) || tip;
  }
  return tip;
};
mxElbowEdgeHandler2.prototype.convertPoint = function(point, gridEnabled) {
  const view = this.graph.getView();
  const scale = view.getScale();
  const tr = view.getTranslate();
  const origin = this.state.origin;
  if (gridEnabled) {
    point.x = this.graph.snap(point.x);
    point.y = this.graph.snap(point.y);
  }
  point.x = Math.round(point.x / scale - tr.x - origin.x);
  point.y = Math.round(point.y / scale - tr.y - origin.y);
  return point;
};
mxElbowEdgeHandler2.prototype.redrawInnerBends = function(p0, pe) {
  const g = this.graph.getModel().getGeometry(this.state.cell);
  const pts = this.state.absolutePoints;
  let pt = null;
  if (pts.length > 1) {
    p0 = pts[1];
    pe = pts[pts.length - 2];
  } else if (g.points && g.points.length) {
    pt = pts[0];
  }
  if (!pt) {
    pt = new mxPoint2(p0.x + (pe.x - p0.x) / 2, p0.y + (pe.y - p0.y) / 2);
  } else {
    const view = this.graph.getView();
    pt = new mxPoint2(view.scale * (pt.x + view.translate.x + this.state.origin.x), view.scale * (pt.y + view.translate.y + this.state.origin.y));
  }
  const b = this.bends[1].bounds;
  let w2 = b.width;
  let h2 = b.height;
  let bounds = new mxRectangle(Math.round(pt.x - w2 / 2), Math.round(pt.y - h2 / 2), w2, h2);
  if (this.manageLabelHandle) {
    this.checkLabelHandle(bounds);
  } else if (!this.handleImage && this.labelShape.visible && intersects(bounds, this.labelShape.bounds)) {
    w2 = mxConstants2.HANDLE_SIZE + 3;
    h2 = mxConstants2.HANDLE_SIZE + 3;
    bounds = new mxRectangle(Math.floor(pt.x - w2 / 2), Math.floor(pt.y - h2 / 2), w2, h2);
  }
  this.bends[1].bounds = bounds;
  this.bends[1].redraw();
  if (this.manageLabelHandle) {
    this.checkLabelHandle(this.bends[1].bounds);
  }
};

// js/graph/mxEdgeSegmentHandler.js
var mxEdgeSegmentHandler = function(state2) {
  mxEdgeHandler2.call(this, state2);
};
extend(mxEdgeSegmentHandler, mxElbowEdgeHandler2);
mxEdgeSegmentHandler.prototype.getCurrentPoints = function() {
  let pts = this.state.absolutePoints;
  if (pts != null) {
    const tol = Math.max(1, this.graph.view.scale);
    if (pts.length === 2 || pts.length === 3 && (Math.abs(pts[0].x - pts[1].x) < tol && Math.abs(pts[1].x - pts[2].x) < tol || Math.abs(pts[0].y - pts[1].y) < tol && Math.abs(pts[1].y - pts[2].y) < tol)) {
      const cx = pts[0].x + (pts[pts.length - 1].x - pts[0].x) / 2;
      const cy = pts[0].y + (pts[pts.length - 1].y - pts[0].y) / 2;
      pts = [pts[0], new mxPoint2(cx, cy), new mxPoint2(cx, cy), pts[pts.length - 1]];
    }
  }
  return pts;
};
mxEdgeSegmentHandler.prototype.getPreviewPoints = function(point) {
  if (this.isSource || this.isTarget) {
    return mxElbowEdgeHandler2.prototype.getPreviewPoints.apply(this, arguments);
  }
  const pts = this.getCurrentPoints();
  let last = this.convertPoint(pts[0].clone(), false);
  const newPoint = this.convertPoint(point.clone(), false);
  let result2 = [];
  for (let i = 1; i < pts.length; i++) {
    const pt = this.convertPoint(pts[i].clone(), false);
    if (i === this.index) {
      if (Math.round(last.x - pt.x) === 0) {
        last.x = newPoint.x;
        pt.x = newPoint.x;
      }
      if (Math.round(last.y - pt.y) === 0) {
        last.y = newPoint.y;
        pt.y = newPoint.y;
      }
    }
    if (i < pts.length - 1) {
      result2.push(pt);
    }
    last = pt;
  }
  if (result2.length === 1) {
    const source = this.state.getVisibleTerminalState(true);
    const target = this.state.getVisibleTerminalState(false);
    const scale = this.state.view.getScale();
    const tr = this.state.view.getTranslate();
    const x = result2[0].x * scale + tr.x;
    const y = result2[0].y * scale + tr.y;
    if (source != null && contains(source, x, y) || target != null && contains(target, x, y)) {
      return [newPoint, newPoint];
    }
  }
  return result2;
};
mxEdgeSegmentHandler.prototype.updatePreviewState = function(edge, point, terminalState, me) {
  mxEdgeHandler2.prototype.updatePreviewState.apply(this, arguments);
  if (!this.isSource && !this.isTarget) {
    const newPoint = this.convertPoint(point.clone(), false);
    const pts = edge.absolutePoints;
    let pt0 = pts[0], pt1 = pts[1];
    let result2 = [];
    for (let i = 2; i < pts.length; i++) {
      const pt2 = pts[i];
      if ((Math.round(pt0.x - pt1.x) !== 0 || Math.round(pt1.x - pt2.x) !== 0) && (Math.round(pt0.y - pt1.y) !== 0 || Math.round(pt1.y - pt2.y) !== 0)) {
        result2.push(this.convertPoint(pt1.clone(), false));
      }
      pt0 = pt1;
      pt1 = pt2;
    }
    const source = this.state.getVisibleTerminalState(true);
    const target = this.state.getVisibleTerminalState(false);
    const rpts = this.state.absolutePoints;
    if (result2.length === 0 && (Math.round(pts[0].x - pts[pts.length - 1].x) === 0 || Math.round(pts[0].y - pts[pts.length - 1].y) === 0)) {
      result2 = [newPoint, newPoint];
    } else if (pts.length === 5 && result2.length === 2 && source != null && target != null && rpts != null && Math.round(rpts[0].x - rpts[rpts.length - 1].x) === 0) {
      const view = this.graph.getView();
      const scale = view.getScale();
      const tr = view.getTranslate();
      let y0 = view.getRoutingCenterY(source) / scale - tr.y;
      const sc = this.graph.getConnectionConstraint(edge, source, true);
      if (sc != null) {
        const pt = this.graph.getConnectionPoint(source, sc);
        if (pt != null) {
          this.convertPoint(pt, false);
          y0 = pt.y;
        }
      }
      let ye = view.getRoutingCenterY(target) / scale - tr.y;
      const tc = this.graph.getConnectionConstraint(edge, target, false);
      if (tc != null) {
        const pt = this.graph.getConnectionPoint(target, tc);
        if (pt != null) {
          this.convertPoint(pt, false);
          ye = pt.y;
        }
      }
      result2 = [new mxPoint2(newPoint.x, y0), new mxPoint2(newPoint.x, ye)];
    }
    this.points = result2;
    edge.view.updateFixedTerminalPoints(edge, source, target);
    edge.view.updatePoints(edge, this.points, source, target);
    edge.view.updateFloatingTerminalPoints(edge, source, target);
  }
};
mxEdgeSegmentHandler.prototype.connect = function(edge, terminal, isSource, isClone, me) {
  const model = this.graph.getModel();
  const geo = model.getGeometry(edge);
  let result2 = null;
  if (geo != null && geo.points != null && geo.points.length > 0) {
    const pts = this.abspoints;
    let pt0 = pts[0], pt1 = pts[1];
    result2 = [];
    for (let i = 2; i < pts.length; i++) {
      const pt2 = pts[i];
      if ((Math.round(pt0.x - pt1.x) !== 0 || Math.round(pt1.x - pt2.x) !== 0) && (Math.round(pt0.y - pt1.y) !== 0 || Math.round(pt1.y - pt2.y) !== 0)) {
        result2.push(this.convertPoint(pt1.clone(), false));
      }
      pt0 = pt1;
      pt1 = pt2;
    }
  }
  model.beginUpdate();
  try {
    if (result2 != null) {
      let newGeo = model.getGeometry(edge);
      if (newGeo != null) {
        newGeo = newGeo.clone();
        newGeo.points = result2;
        model.setGeometry(edge, newGeo);
      }
    }
    edge = mxEdgeHandler2.prototype.connect.apply(this, arguments);
  } finally {
    model.endUpdate();
  }
  return edge;
};
mxEdgeSegmentHandler.prototype.getTooltipForNode = function(node) {
  return null;
};
mxEdgeSegmentHandler.prototype.start = function(x, y, index) {
  mxEdgeHandler2.prototype.start.apply(this, arguments);
  if (this.bends != null && this.bends[index] != null && !this.isSource && !this.isTarget) {
    setOpacity(this.bends[index].node, 100);
  }
};
mxEdgeSegmentHandler.prototype.createBends = function() {
  const bends = [];
  let bend = this.createHandleShape(0);
  this.initBend(bend);
  bend.setCursor(mxConstants2.CURSOR_TERMINAL_HANDLE);
  bends.push(bend);
  const pts = this.getCurrentPoints();
  if (this.graph.isCellBendable(this.state.cell)) {
    if (this.points == null) {
      this.points = [];
    }
    for (let i = 0; i < pts.length - 1; i++) {
      bend = this.createVirtualBend();
      bends.push(bend);
      let horizontal = Math.round(pts[i].x - pts[i + 1].x) === 0;
      if (Math.round(pts[i].y - pts[i + 1].y) === 0 && i < pts.length - 2) {
        horizontal = Math.round(pts[i].x - pts[i + 2].x) === 0;
      }
      bend.setCursor(horizontal ? "col-resize" : "row-resize");
      this.points.push(new mxPoint2(0, 0));
    }
  }
  bend = this.createHandleShape(pts.length);
  this.initBend(bend);
  bend.setCursor(mxConstants2.CURSOR_TERMINAL_HANDLE);
  bends.push(bend);
  return bends;
};
mxEdgeSegmentHandler.prototype.redraw = function() {
  this.refresh();
  mxEdgeHandler2.prototype.redraw.apply(this, arguments);
};
mxEdgeSegmentHandler.prototype.redrawInnerBends = function(p0, pe) {
  if (this.graph.isCellBendable(this.state.cell)) {
    const pts = this.getCurrentPoints();
    if (pts != null && pts.length > 1) {
      let straight = false;
      if (pts.length === 4 && Math.round(pts[1].x - pts[2].x) === 0 && Math.round(pts[1].y - pts[2].y) === 0) {
        straight = true;
        if (Math.round(pts[0].y - pts[pts.length - 1].y) === 0) {
          const cx = (pts[0].x + pts[pts.length - 1].x) / 2;
          pts[1] = new mxPoint2(cx, pts[1].y);
          pts[2] = new mxPoint2(cx, pts[2].y);
        } else {
          const cy = (pts[0].y + pts[pts.length - 1].y) / 2;
          pts[1] = new mxPoint2(pts[1].x, cy);
          pts[2] = new mxPoint2(pts[2].x, cy);
        }
      }
      for (let i = 0; i < pts.length - 1; i++) {
        if (this.bends[i + 1] != null) {
          const p02 = pts[i];
          const pe2 = pts[i + 1];
          const ptMid = new mxPoint2(p02.x + (pe2.x - p02.x) / 2, p02.y + (pe2.y - p02.y) / 2);
          const b = this.bends[i + 1].bounds;
          this.bends[i + 1].bounds = new mxRectangle(Math.floor(ptMid.x - b.width / 2), Math.floor(ptMid.y - b.height / 2), b.width, b.height);
          this.bends[i + 1].redraw();
          if (this.manageLabelHandle) {
            this.checkLabelHandle(this.bends[i + 1].bounds);
          }
        }
      }
      if (straight) {
        setOpacity(this.bends[1].node, this.virtualBendOpacity);
        setOpacity(this.bends[3].node, this.virtualBendOpacity);
      }
    }
  }
};

// js/graph/mxCellEditor.js
function mxCellEditor(graph) {
  this.graph = graph;
  this.zoomHandler = bind(this, function() {
    if (this.graph.isEditing()) {
      this.resize();
    }
  });
  this.graph.view.addListener(mxEvent2.SCALE, this.zoomHandler);
  this.graph.view.addListener(mxEvent2.SCALE_AND_TRANSLATE, this.zoomHandler);
  this.changeHandler = bind(this, function(sender) {
    if (this.editingCell != null && this.graph.getView().getState(this.editingCell) == null) {
      this.stopEditing(true);
    }
  });
  this.graph.getModel().addListener(mxEvent2.CHANGE, this.changeHandler);
}
mxCellEditor.prototype.graph = null;
mxCellEditor.prototype.textarea = null;
mxCellEditor.prototype.editingCell = null;
mxCellEditor.prototype.trigger = null;
mxCellEditor.prototype.modified = false;
mxCellEditor.prototype.autoSize = true;
mxCellEditor.prototype.selectText = true;
mxCellEditor.prototype.emptyLabelText = mxClient_default.IS_FF ? "<br>" : "";
mxCellEditor.prototype.escapeCancelsEditing = true;
mxCellEditor.prototype.textNode = "";
mxCellEditor.prototype.zIndex = 5;
mxCellEditor.prototype.minResize = new mxRectangle(0, 20);
mxCellEditor.prototype.wordWrapPadding = mxClient_default.IS_QUIRKS ? 2 : !mxClient_default.IS_IE11 ? 1 : 0;
mxCellEditor.prototype.blurEnabled = false;
mxCellEditor.prototype.initialValue = null;
mxCellEditor.prototype.align = null;
mxCellEditor.prototype.init = function() {
  this.textarea = document.createElement("div");
  this.textarea.className = "mxCellEditor mxPlainTextEditor";
  this.textarea.contentEditable = true;
  if (mxClient_default.IS_GC) {
    this.textarea.style.minHeight = "1em";
  }
  this.textarea.style.position = this.isLegacyEditor() ? "absolute" : "relative";
  this.installListeners(this.textarea);
};
mxCellEditor.prototype.applyValue = function(state2, value) {
  this.graph.labelChanged(state2.cell, value, this.trigger);
};
mxCellEditor.prototype.setAlign = function(align) {
  if (this.textarea != null) {
    this.textarea.style.textAlign = align;
  }
  this.align = align;
  this.resize();
};
mxCellEditor.prototype.getInitialValue = function(state2, trigger) {
  var result2 = htmlEntities(this.graph.getEditingValue(state2.cell, trigger), false);
  if (!mxClient_default.IS_QUIRKS && document.documentMode != 8 && document.documentMode != 9 && document.documentMode != 10) {
    result2 = replaceTrailingNewlines(result2, "<div><br></div>");
  }
  return result2.replace(/\n/g, "<br>");
};
mxCellEditor.prototype.getCurrentValue = function(state2) {
  return extractTextWithWhitespace(this.textarea.childNodes);
};
mxCellEditor.prototype.isCancelEditingKeyEvent = function(evt) {
  return this.escapeCancelsEditing || mxEvent2.isShiftDown(evt) || mxEvent2.isControlDown(evt) || mxEvent2.isMetaDown(evt);
};
mxCellEditor.prototype.installListeners = function(elt) {
  mxEvent2.addListener(elt, "dragstart", bind(this, function(evt) {
    this.graph.stopEditing(false);
    mxEvent2.consume(evt);
  }));
  mxEvent2.addListener(elt, "blur", bind(this, function(evt) {
    if (this.blurEnabled) {
      this.focusLost(evt);
    }
  }));
  mxEvent2.addListener(elt, "keydown", bind(this, function(evt) {
    if (!mxEvent2.isConsumed(evt)) {
      if (this.isStopEditingEvent(evt)) {
        this.graph.stopEditing(false);
        mxEvent2.consume(evt);
      } else if (evt.keyCode == 27) {
        this.graph.stopEditing(this.isCancelEditingKeyEvent(evt));
        mxEvent2.consume(evt);
      }
    }
  }));
  const keypressHandler = bind(this, function(evt) {
    if (this.editingCell != null) {
      if (this.clearOnChange && elt.innerHTML == this.getEmptyLabelText() && (!mxClient_default.IS_FF || evt.keyCode != 8 && evt.keyCode != 46)) {
        this.clearOnChange = false;
        elt.innerHTML = "";
      }
    }
  });
  mxEvent2.addListener(elt, "keypress", keypressHandler);
  mxEvent2.addListener(elt, "paste", keypressHandler);
  const keyupHandler = bind(this, function(evt) {
    if (this.editingCell != null) {
      if (this.textarea.innerHTML.length == 0 || this.textarea.innerHTML == "<br>") {
        this.textarea.innerHTML = this.getEmptyLabelText();
        this.clearOnChange = this.textarea.innerHTML.length > 0;
      } else {
        this.clearOnChange = false;
      }
    }
  });
  mxEvent2.addListener(elt, !mxClient_default.IS_IE11 && !mxClient_default.IS_IE ? "input" : "keyup", keyupHandler);
  mxEvent2.addListener(elt, "cut", keyupHandler);
  mxEvent2.addListener(elt, "paste", keyupHandler);
  const evtName = !mxClient_default.IS_IE11 && !mxClient_default.IS_IE ? "input" : "keydown";
  const resizeHandler = bind(this, function(evt) {
    if (this.editingCell != null && this.autoSize && !mxEvent2.isConsumed(evt)) {
      if (this.resizeThread != null) {
        window.clearTimeout(this.resizeThread);
      }
      this.resizeThread = window.setTimeout(bind(this, function() {
        this.resizeThread = null;
        this.resize();
      }), 0);
    }
  });
  mxEvent2.addListener(elt, evtName, resizeHandler);
  mxEvent2.addListener(window, "resize", resizeHandler);
  if (document.documentMode >= 9) {
    mxEvent2.addListener(elt, "DOMNodeRemoved", resizeHandler);
    mxEvent2.addListener(elt, "DOMNodeInserted", resizeHandler);
  } else {
    mxEvent2.addListener(elt, "cut", resizeHandler);
    mxEvent2.addListener(elt, "paste", resizeHandler);
  }
};
mxCellEditor.prototype.isStopEditingEvent = function(evt) {
  return evt.keyCode == 113 || this.graph.isEnterStopsCellEditing() && evt.keyCode == 13 && !mxEvent2.isControlDown(evt) && !mxEvent2.isShiftDown(evt);
};
mxCellEditor.prototype.isEventSource = function(evt) {
  return mxEvent2.getSource(evt) == this.textarea;
};
mxCellEditor.prototype.resize = function() {
  const state2 = this.graph.getView().getState(this.editingCell);
  if (state2 == null) {
    this.stopEditing(true);
  } else if (this.textarea != null) {
    const isEdge = this.graph.getModel().isEdge(state2.cell);
    const scale = this.graph.getView().scale;
    let m = null;
    if (!this.autoSize || state2.style[mxConstants2.STYLE_OVERFLOW] == "fill") {
      this.bounds = this.getEditorBounds(state2);
      this.textarea.style.width = Math.round(this.bounds.width / scale) + "px";
      this.textarea.style.height = Math.round(this.bounds.height / scale) + "px";
      if (document.documentMode == 8 || mxClient_default.IS_QUIRKS) {
        this.textarea.style.left = Math.round(this.bounds.x) + "px";
        this.textarea.style.top = Math.round(this.bounds.y) + "px";
      } else {
        this.textarea.style.left = Math.max(0, Math.round(this.bounds.x + 1)) + "px";
        this.textarea.style.top = Math.max(0, Math.round(this.bounds.y + 1)) + "px";
      }
      if (this.graph.isWrapping(state2.cell) && (this.bounds.width >= 2 || this.bounds.height >= 2) && this.textarea.innerHTML != this.getEmptyLabelText()) {
        this.textarea.style.wordWrap = mxConstants2.WORD_WRAP;
        this.textarea.style.whiteSpace = "normal";
        if (state2.style[mxConstants2.STYLE_OVERFLOW] != "fill") {
          this.textarea.style.width = Math.round(this.bounds.width / scale) + this.wordWrapPadding + "px";
        }
      } else {
        this.textarea.style.whiteSpace = "nowrap";
        if (state2.style[mxConstants2.STYLE_OVERFLOW] != "fill") {
          this.textarea.style.width = "";
        }
      }
    } else {
      const lw = getValue(state2.style, mxConstants2.STYLE_LABEL_WIDTH, null);
      m = state2.text != null && this.align == null ? state2.text.margin : null;
      if (m == null) {
        m = getAlignmentAsPoint(this.align || getValue(state2.style, mxConstants2.STYLE_ALIGN, mxConstants2.ALIGN_CENTER), getValue(state2.style, mxConstants2.STYLE_VERTICAL_ALIGN, mxConstants2.ALIGN_MIDDLE));
      }
      if (isEdge) {
        this.bounds = new mxRectangle(state2.absoluteOffset.x, state2.absoluteOffset.y, 0, 0);
        if (lw != null) {
          const tmp = (parseFloat(lw) + 2) * scale;
          this.bounds.width = tmp;
          this.bounds.x += m.x * tmp;
        }
      } else {
        let bds = mxRectangle.fromRectangle(state2);
        const hpos = getValue(state2.style, mxConstants2.STYLE_LABEL_POSITION, mxConstants2.ALIGN_CENTER);
        const vpos = getValue(state2.style, mxConstants2.STYLE_VERTICAL_LABEL_POSITION, mxConstants2.ALIGN_MIDDLE);
        bds = state2.shape != null && hpos == mxConstants2.ALIGN_CENTER && vpos == mxConstants2.ALIGN_MIDDLE ? state2.shape.getLabelBounds(bds) : bds;
        if (lw != null) {
          bds.width = parseFloat(lw) * scale;
        }
        if (!state2.view.graph.cellRenderer.legacySpacing || state2.style[mxConstants2.STYLE_OVERFLOW] != "width") {
          const spacing = parseInt(state2.style[mxConstants2.STYLE_SPACING] || 2) * scale;
          const spacingTop = (parseInt(state2.style[mxConstants2.STYLE_SPACING_TOP] || 0) + mxText.prototype.baseSpacingTop) * scale + spacing;
          const spacingRight = (parseInt(state2.style[mxConstants2.STYLE_SPACING_RIGHT] || 0) + mxText.prototype.baseSpacingRight) * scale + spacing;
          const spacingBottom = (parseInt(state2.style[mxConstants2.STYLE_SPACING_BOTTOM] || 0) + mxText.prototype.baseSpacingBottom) * scale + spacing;
          const spacingLeft = (parseInt(state2.style[mxConstants2.STYLE_SPACING_LEFT] || 0) + mxText.prototype.baseSpacingLeft) * scale + spacing;
          const hpos2 = getValue(state2.style, mxConstants2.STYLE_LABEL_POSITION, mxConstants2.ALIGN_CENTER);
          const vpos2 = getValue(state2.style, mxConstants2.STYLE_VERTICAL_LABEL_POSITION, mxConstants2.ALIGN_MIDDLE);
          bds = new mxRectangle(bds.x + spacingLeft, bds.y + spacingTop, bds.width - (hpos2 == mxConstants2.ALIGN_CENTER && lw == null ? spacingLeft + spacingRight : 0), bds.height - (vpos2 == mxConstants2.ALIGN_MIDDLE ? spacingTop + spacingBottom : 0));
        }
        this.bounds = new mxRectangle(bds.x + state2.absoluteOffset.x, bds.y + state2.absoluteOffset.y, bds.width, bds.height);
      }
      if (this.graph.isWrapping(state2.cell) && (this.bounds.width >= 2 || this.bounds.height >= 2) && this.textarea.innerHTML != this.getEmptyLabelText()) {
        this.textarea.style.wordWrap = mxConstants2.WORD_WRAP;
        this.textarea.style.whiteSpace = "normal";
        const tmp = Math.round(this.bounds.width / (document.documentMode == 8 ? scale : scale)) + this.wordWrapPadding;
        if (this.textarea.style.position != "relative") {
          this.textarea.style.width = tmp + "px";
          if (this.textarea.scrollWidth > tmp) {
            this.textarea.style.width = this.textarea.scrollWidth + "px";
          }
        } else {
          this.textarea.style.maxWidth = tmp + "px";
        }
      } else {
        this.textarea.style.whiteSpace = "nowrap";
        this.textarea.style.width = "";
      }
      if (document.documentMode == 8) {
        this.textarea.style.zoom = "1";
        this.textarea.style.height = "auto";
      }
      const ow = this.textarea.scrollWidth;
      const oh = this.textarea.scrollHeight;
      if (document.documentMode == 8) {
        this.textarea.style.left = Math.max(0, Math.ceil((this.bounds.x - m.x * (this.bounds.width - (ow + 1) * scale) + ow * (scale - 1) * 0 + (m.x + 0.5) * 2) / scale)) + "px";
        this.textarea.style.top = Math.max(0, Math.ceil((this.bounds.y - m.y * (this.bounds.height - (oh + 0.5) * scale) + oh * (scale - 1) * 0 + Math.abs(m.y + 0.5) * 1) / scale)) + "px";
        this.textarea.style.width = Math.round(ow * scale) + "px";
        this.textarea.style.height = Math.round(oh * scale) + "px";
      } else if (mxClient_default.IS_QUIRKS) {
        this.textarea.style.left = Math.max(0, Math.ceil(this.bounds.x - m.x * (this.bounds.width - (ow + 1) * scale) + ow * (scale - 1) * 0 + (m.x + 0.5) * 2)) + "px";
        this.textarea.style.top = Math.max(0, Math.ceil(this.bounds.y - m.y * (this.bounds.height - (oh + 0.5) * scale) + oh * (scale - 1) * 0 + Math.abs(m.y + 0.5) * 1)) + "px";
      } else {
        this.textarea.style.left = Math.max(0, Math.round(this.bounds.x - m.x * (this.bounds.width - 2)) + 1) + "px";
        this.textarea.style.top = Math.max(0, Math.round(this.bounds.y - m.y * (this.bounds.height - 4) + (m.y == -1 ? 3 : 0)) + 1) + "px";
      }
    }
    if (mxClient_default.IS_VML) {
      this.textarea.style.zoom = scale;
    } else {
      setPrefixedStyle(this.textarea.style, "transformOrigin", "0px 0px");
      setPrefixedStyle(this.textarea.style, "transform", "scale(" + scale + "," + scale + ")" + (m == null ? "" : " translate(" + m.x * 100 + "%," + m.y * 100 + "%)"));
    }
  }
};
mxCellEditor.prototype.focusLost = function() {
  this.stopEditing(!this.graph.isInvokesStopCellEditing());
};
mxCellEditor.prototype.getBackgroundColor = function(state2) {
  return null;
};
mxCellEditor.prototype.isLegacyEditor = function() {
  if (mxClient_default.IS_VML) {
    return true;
  } else {
    let absoluteRoot = false;
    if (mxClient_default.IS_SVG) {
      const root = this.graph.view.getDrawPane().ownerSVGElement;
      if (root != null) {
        const css = getCurrentStyle(root);
        if (css != null) {
          absoluteRoot = css.position == "absolute";
        }
      }
    }
    return !absoluteRoot;
  }
};
mxCellEditor.prototype.startEditing = function(cell2, trigger) {
  this.stopEditing(true);
  this.align = null;
  if (this.textarea == null) {
    this.init();
  }
  if (this.graph.tooltipHandler != null) {
    this.graph.tooltipHandler.hideTooltip();
  }
  const state2 = this.graph.getView().getState(cell2);
  if (state2 != null) {
    const scale = this.graph.getView().scale;
    const size = getValue(state2.style, mxConstants2.STYLE_FONTSIZE, mxConstants2.DEFAULT_FONTSIZE);
    const family = getValue(state2.style, mxConstants2.STYLE_FONTFAMILY, mxConstants2.DEFAULT_FONTFAMILY);
    const color = getValue(state2.style, mxConstants2.STYLE_FONTCOLOR, "black");
    const align = getValue(state2.style, mxConstants2.STYLE_ALIGN, mxConstants2.ALIGN_LEFT);
    const bold = (getValue(state2.style, mxConstants2.STYLE_FONTSTYLE, 0) & mxConstants2.FONT_BOLD) == mxConstants2.FONT_BOLD;
    const italic = (getValue(state2.style, mxConstants2.STYLE_FONTSTYLE, 0) & mxConstants2.FONT_ITALIC) == mxConstants2.FONT_ITALIC;
    const txtDecor = [];
    if ((getValue(state2.style, mxConstants2.STYLE_FONTSTYLE, 0) & mxConstants2.FONT_UNDERLINE) == mxConstants2.FONT_UNDERLINE) {
      txtDecor.push("underline");
    }
    if ((getValue(state2.style, mxConstants2.STYLE_FONTSTYLE, 0) & mxConstants2.FONT_STRIKETHROUGH) == mxConstants2.FONT_STRIKETHROUGH) {
      txtDecor.push("line-through");
    }
    this.textarea.style.lineHeight = mxConstants2.ABSOLUTE_LINE_HEIGHT ? Math.round(size * mxConstants2.LINE_HEIGHT) + "px" : mxConstants2.LINE_HEIGHT;
    this.textarea.style.backgroundColor = this.getBackgroundColor(state2);
    this.textarea.style.textDecoration = txtDecor.join(" ");
    this.textarea.style.fontWeight = bold ? "bold" : "normal";
    this.textarea.style.fontStyle = italic ? "italic" : "";
    this.textarea.style.fontSize = Math.round(size) + "px";
    this.textarea.style.zIndex = this.zIndex;
    this.textarea.style.fontFamily = family;
    this.textarea.style.textAlign = align;
    this.textarea.style.outline = "none";
    this.textarea.style.color = color;
    let dir = this.textDirection = getValue(state2.style, mxConstants2.STYLE_TEXT_DIRECTION, mxConstants2.DEFAULT_TEXT_DIRECTION);
    if (dir == mxConstants2.TEXT_DIRECTION_AUTO) {
      if (state2 != null && state2.text != null && state2.text.dialect != mxConstants2.DIALECT_STRICTHTML && !isNode(state2.text.value)) {
        dir = state2.text.getAutoDirection();
      }
    }
    if (dir == mxConstants2.TEXT_DIRECTION_LTR || dir == mxConstants2.TEXT_DIRECTION_RTL) {
      this.textarea.setAttribute("dir", dir);
    } else {
      this.textarea.removeAttribute("dir");
    }
    this.textarea.innerHTML = this.getInitialValue(state2, trigger) || "";
    this.initialValue = this.textarea.innerHTML;
    if (this.textarea.innerHTML.length == 0 || this.textarea.innerHTML == "<br>") {
      this.textarea.innerHTML = this.getEmptyLabelText();
      this.clearOnChange = true;
    } else {
      this.clearOnChange = this.textarea.innerHTML == this.getEmptyLabelText();
    }
    this.graph.container.appendChild(this.textarea);
    this.editingCell = cell2;
    this.trigger = trigger;
    this.textNode = null;
    if (state2.text != null && this.isHideLabel(state2)) {
      this.textNode = state2.text.node;
      this.textNode.style.visibility = "hidden";
    }
    if (this.autoSize && (this.graph.model.isEdge(state2.cell) || state2.style[mxConstants2.STYLE_OVERFLOW] != "fill")) {
      window.setTimeout(bind(this, function() {
        this.resize();
      }), 0);
    }
    this.resize();
    try {
      this.textarea.focus();
      if (this.isSelectText() && this.textarea.innerHTML.length > 0 && (this.textarea.innerHTML != this.getEmptyLabelText() || !this.clearOnChange)) {
        document.execCommand("selectAll", false, null);
      }
    } catch (e) {
    }
  }
};
mxCellEditor.prototype.isSelectText = function() {
  return this.selectText;
};
mxCellEditor.prototype.clearSelection = function() {
  let selection = null;
  if (window.getSelection) {
    selection = window.getSelection();
  } else if (document.selection) {
    selection = document.selection;
  }
  if (selection != null) {
    if (selection.empty) {
      selection.empty();
    } else if (selection.removeAllRanges) {
      selection.removeAllRanges();
    }
  }
};
mxCellEditor.prototype.stopEditing = function(cancel) {
  cancel = cancel || false;
  if (this.editingCell != null) {
    if (this.textNode != null) {
      this.textNode.style.visibility = "visible";
      this.textNode = null;
    }
    const state2 = !cancel ? this.graph.view.getState(this.editingCell) : null;
    const initial = this.initialValue;
    this.initialValue = null;
    this.editingCell = null;
    this.trigger = null;
    this.bounds = null;
    this.textarea.blur();
    this.clearSelection();
    if (this.textarea.parentNode != null) {
      this.textarea.parentNode.removeChild(this.textarea);
    }
    if (this.clearOnChange && this.textarea.innerHTML == this.getEmptyLabelText()) {
      this.textarea.innerHTML = "";
      this.clearOnChange = false;
    }
    if (state2 != null && (this.textarea.innerHTML != initial || this.align != null)) {
      this.prepareTextarea();
      const value = this.getCurrentValue(state2);
      this.graph.getModel().beginUpdate();
      try {
        if (value != null) {
          this.applyValue(state2, value);
        }
        if (this.align != null) {
          this.graph.setCellStyles(mxConstants2.STYLE_ALIGN, this.align, [state2.cell]);
        }
      } finally {
        this.graph.getModel().endUpdate();
      }
    }
    mxEvent2.release(this.textarea);
    this.textarea = null;
    this.align = null;
  }
};
mxCellEditor.prototype.prepareTextarea = function() {
  if (this.textarea.lastChild != null && this.textarea.lastChild.nodeName == "BR") {
    this.textarea.removeChild(this.textarea.lastChild);
  }
};
mxCellEditor.prototype.isHideLabel = function(state2) {
  return true;
};
mxCellEditor.prototype.getMinimumSize = function(state2) {
  const scale = this.graph.getView().scale;
  return new mxRectangle(0, 0, state2.text == null ? 30 : state2.text.size * scale + 20, this.textarea.style.textAlign == "left" ? 120 : 40);
};
mxCellEditor.prototype.getEditorBounds = function(state2) {
  const isEdge = this.graph.getModel().isEdge(state2.cell);
  const scale = this.graph.getView().scale;
  const minSize = this.getMinimumSize(state2);
  const minWidth = minSize.width;
  const minHeight = minSize.height;
  let result2 = null;
  if (!isEdge && state2.view.graph.cellRenderer.legacySpacing && state2.style[mxConstants2.STYLE_OVERFLOW] == "fill") {
    result2 = state2.shape.getLabelBounds(mxRectangle.fromRectangle(state2));
  } else {
    const spacing = parseInt(state2.style[mxConstants2.STYLE_SPACING] || 0) * scale;
    const spacingTop = (parseInt(state2.style[mxConstants2.STYLE_SPACING_TOP] || 0) + mxText.prototype.baseSpacingTop) * scale + spacing;
    const spacingRight = (parseInt(state2.style[mxConstants2.STYLE_SPACING_RIGHT] || 0) + mxText.prototype.baseSpacingRight) * scale + spacing;
    const spacingBottom = (parseInt(state2.style[mxConstants2.STYLE_SPACING_BOTTOM] || 0) + mxText.prototype.baseSpacingBottom) * scale + spacing;
    const spacingLeft = (parseInt(state2.style[mxConstants2.STYLE_SPACING_LEFT] || 0) + mxText.prototype.baseSpacingLeft) * scale + spacing;
    result2 = new mxRectangle(state2.x, state2.y, Math.max(minWidth, state2.width - spacingLeft - spacingRight), Math.max(minHeight, state2.height - spacingTop - spacingBottom));
    const hpos = getValue(state2.style, mxConstants2.STYLE_LABEL_POSITION, mxConstants2.ALIGN_CENTER);
    const vpos = getValue(state2.style, mxConstants2.STYLE_VERTICAL_LABEL_POSITION, mxConstants2.ALIGN_MIDDLE);
    result2 = state2.shape != null && hpos == mxConstants2.ALIGN_CENTER && vpos == mxConstants2.ALIGN_MIDDLE ? state2.shape.getLabelBounds(result2) : result2;
    if (isEdge) {
      result2.x = state2.absoluteOffset.x;
      result2.y = state2.absoluteOffset.y;
      if (state2.text != null && state2.text.boundingBox != null) {
        if (state2.text.boundingBox.x > 0) {
          result2.x = state2.text.boundingBox.x;
        }
        if (state2.text.boundingBox.y > 0) {
          result2.y = state2.text.boundingBox.y;
        }
      }
    } else if (state2.text != null && state2.text.boundingBox != null) {
      result2.x = Math.min(result2.x, state2.text.boundingBox.x);
      result2.y = Math.min(result2.y, state2.text.boundingBox.y);
    }
    result2.x += spacingLeft;
    result2.y += spacingTop;
    if (state2.text != null && state2.text.boundingBox != null) {
      if (!isEdge) {
        result2.width = Math.max(result2.width, state2.text.boundingBox.width);
        result2.height = Math.max(result2.height, state2.text.boundingBox.height);
      } else {
        result2.width = Math.max(minWidth, state2.text.boundingBox.width);
        result2.height = Math.max(minHeight, state2.text.boundingBox.height);
      }
    }
    if (this.graph.getModel().isVertex(state2.cell)) {
      const horizontal = getValue(state2.style, mxConstants2.STYLE_LABEL_POSITION, mxConstants2.ALIGN_CENTER);
      if (horizontal == mxConstants2.ALIGN_LEFT) {
        result2.x -= state2.width;
      } else if (horizontal == mxConstants2.ALIGN_RIGHT) {
        result2.x += state2.width;
      }
      const vertical = getValue(state2.style, mxConstants2.STYLE_VERTICAL_LABEL_POSITION, mxConstants2.ALIGN_MIDDLE);
      if (vertical == mxConstants2.ALIGN_TOP) {
        result2.y -= state2.height;
      } else if (vertical == mxConstants2.ALIGN_BOTTOM) {
        result2.y += state2.height;
      }
    }
  }
  return new mxRectangle(Math.round(result2.x), Math.round(result2.y), Math.round(result2.width), Math.round(result2.height));
};
mxCellEditor.prototype.getEmptyLabelText = function(cell2) {
  return this.emptyLabelText;
};
mxCellEditor.prototype.getEditingCell = function() {
  return this.editingCell;
};
mxCellEditor.prototype.destroy = function() {
  if (this.textarea != null) {
    mxEvent2.release(this.textarea);
    if (this.textarea.parentNode != null) {
      this.textarea.parentNode.removeChild(this.textarea);
    }
    this.textarea = null;
  }
  if (this.changeHandler != null) {
    this.graph.getModel().removeListener(this.changeHandler);
    this.changeHandler = null;
  }
  if (this.zoomHandler) {
    this.graph.view.removeListener(this.zoomHandler);
    this.zoomHandler = null;
  }
};

// js/graph/mxCellOverlay.js
var mxCellOverlay = function(image, tooltip, align, verticalAlign, offset, cursor) {
  this.image = image;
  this.tooltip = tooltip;
  this.align = align != null ? align : this.align;
  this.verticalAlign = verticalAlign != null ? verticalAlign : this.verticalAlign;
  this.offset = offset != null ? offset : new mxPoint2();
  this.cursor = cursor != null ? cursor : "help";
};
mxCellOverlay.prototype = new mxEventSource();
mxCellOverlay.prototype.constructor = mxCellOverlay;
mxCellOverlay.prototype.image = null;
mxCellOverlay.prototype.tooltip = null;
mxCellOverlay.prototype.align = mxConstants2.ALIGN_RIGHT;
mxCellOverlay.prototype.verticalAlign = mxConstants2.ALIGN_BOTTOM;
mxCellOverlay.prototype.offset = null;
mxCellOverlay.prototype.cursor = null;
mxCellOverlay.prototype.defaultOverlap = 0.5;
mxCellOverlay.prototype.getBounds = function(state2) {
  const isEdge = state2.view.graph.getModel().isEdge(state2.cell);
  const s = state2.view.scale;
  let pt;
  const w2 = this.image.width;
  const h2 = this.image.height;
  if (isEdge) {
    const pts = state2.absolutePoints;
    if (pts.length % 2 === 1) {
      pt = pts[Math.floor(pts.length / 2)];
    } else {
      const idx = pts.length / 2;
      const p0 = pts[idx - 1];
      const p1 = pts[idx];
      pt = new mxPoint2(p0.x + (p1.x - p0.x) / 2, p0.y + (p1.y - p0.y) / 2);
    }
  } else {
    pt = new mxPoint2();
    if (this.align === mxConstants2.ALIGN_LEFT) {
      pt.x = state2.x;
    } else if (this.align === mxConstants2.ALIGN_CENTER) {
      pt.x = state2.x + state2.width / 2;
    } else {
      pt.x = state2.x + state2.width;
    }
    if (this.verticalAlign === mxConstants2.ALIGN_TOP) {
      pt.y = state2.y;
    } else if (this.verticalAlign === mxConstants2.ALIGN_MIDDLE) {
      pt.y = state2.y + state2.height / 2;
    } else {
      pt.y = state2.y + state2.height;
    }
  }
  return new mxRectangle(Math.round(pt.x - (w2 * this.defaultOverlap - this.offset.x) * s), Math.round(pt.y - (h2 * this.defaultOverlap - this.offset.y) * s), w2 * s, h2 * s);
};
mxCellOverlay.prototype.toString = function() {
  return this.tooltip;
};

// js/graph/mxActor.js
var mxActor = function(bounds, fill, stroke, strokewidth) {
  mxShape.call(this);
  this.bounds = bounds;
  this.fill = fill;
  this.stroke = stroke;
  this.strokewidth = strokewidth != null ? strokewidth : 1;
};
extend(mxActor, mxShape);
mxActor.prototype.paintVertexShape = function(c, x, y, w2, h2) {
  c.translate(x, y);
  c.begin();
  this.redrawPath(c, x, y, w2, h2);
  c.fillAndStroke();
};
mxActor.prototype.redrawPath = function(c, x, y, w2, h2) {
  const width = w2 / 3;
  c.moveTo(0, h2);
  c.curveTo(0, 3 * h2 / 5, 0, 2 * h2 / 5, w2 / 2, 2 * h2 / 5);
  c.curveTo(w2 / 2 - width, 2 * h2 / 5, w2 / 2 - width, 0, w2 / 2, 0);
  c.curveTo(w2 / 2 + width, 0, w2 / 2 + width, 2 * h2 / 5, w2 / 2, 2 * h2 / 5);
  c.curveTo(w2, 2 * h2 / 5, w2, 3 * h2 / 5, w2, h2);
  c.close();
};

// js/graph/mxArrow.js
var mxArrow2 = function(points, fill, stroke, strokewidth, arrowWidth, spacing, endSize) {
  mxShape.call(this);
  this.points = points;
  this.fill = fill;
  this.stroke = stroke;
  this.strokewidth = strokewidth != null ? strokewidth : 1;
  this.arrowWidth = arrowWidth != null ? arrowWidth : mxConstants2.ARROW_WIDTH;
  this.spacing = spacing != null ? spacing : mxConstants2.ARROW_SPACING;
  this.endSize = endSize != null ? endSize : mxConstants2.ARROW_SIZE;
};
extend(mxArrow2, mxShape);
mxArrow2.prototype.augmentBoundingBox = function(bbox) {
  mxShape.prototype.augmentBoundingBox.apply(this, arguments);
  const w2 = Math.max(this.arrowWidth, this.endSize);
  bbox.grow((w2 / 2 + this.strokewidth) * this.scale);
};
mxArrow2.prototype.paintEdgeShape = function(c, pts) {
  const spacing = mxConstants2.ARROW_SPACING;
  const width = mxConstants2.ARROW_WIDTH;
  const arrow = mxConstants2.ARROW_SIZE;
  const p0 = pts[0];
  const pe = pts[pts.length - 1];
  const dx = pe.x - p0.x;
  const dy = pe.y - p0.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const length = dist - 2 * spacing - arrow;
  const nx = dx / dist;
  const ny = dy / dist;
  const basex = length * nx;
  const basey = length * ny;
  const floorx = width * ny / 3;
  const floory = -width * nx / 3;
  const p0x = p0.x - floorx / 2 + spacing * nx;
  const p0y = p0.y - floory / 2 + spacing * ny;
  const p1x = p0x + floorx;
  const p1y = p0y + floory;
  const p2x = p1x + basex;
  const p2y = p1y + basey;
  const p3x = p2x + floorx;
  const p3y = p2y + floory;
  const p5x = p3x - 3 * floorx;
  const p5y = p3y - 3 * floory;
  c.begin();
  c.moveTo(p0x, p0y);
  c.lineTo(p1x, p1y);
  c.lineTo(p2x, p2y);
  c.lineTo(p3x, p3y);
  c.lineTo(pe.x - spacing * nx, pe.y - spacing * ny);
  c.lineTo(p5x, p5y);
  c.lineTo(p5x + floorx, p5y + floory);
  c.close();
  c.fillAndStroke();
};

// js/graph/mxArrowConnector.js
function mxArrowConnector(points, fill, stroke, strokewidth, arrowWidth, spacing, endSize) {
  mxShape.call(this);
  this.points = points;
  this.fill = fill;
  this.stroke = stroke;
  this.strokewidth = strokewidth != null ? strokewidth : 1;
  this.arrowWidth = arrowWidth != null ? arrowWidth : mxConstants2.ARROW_WIDTH;
  this.arrowSpacing = spacing != null ? spacing : mxConstants2.ARROW_SPACING;
  this.startSize = mxConstants2.ARROW_SIZE / 5;
  this.endSize = mxConstants2.ARROW_SIZE / 5;
}
extend(mxArrowConnector, mxShape);
mxArrowConnector.prototype.useSvgBoundingBox = true;
mxArrowConnector.prototype.isRoundable = function() {
  return true;
};
mxArrowConnector.prototype.resetStyles = function() {
  mxShape.prototype.resetStyles.apply(this, arguments);
  this.arrowSpacing = mxConstants2.ARROW_SPACING;
};
mxArrowConnector.prototype.apply = function(state2) {
  mxShape.prototype.apply.apply(this, arguments);
  if (this.style != null) {
    this.startSize = getNumber(this.style, mxConstants2.STYLE_STARTSIZE, mxConstants2.ARROW_SIZE / 5) * 3;
    this.endSize = getNumber(this.style, mxConstants2.STYLE_ENDSIZE, mxConstants2.ARROW_SIZE / 5) * 3;
  }
};
mxArrowConnector.prototype.augmentBoundingBox = function(bbox) {
  mxShape.prototype.augmentBoundingBox.apply(this, arguments);
  let w2 = this.getEdgeWidth();
  if (this.isMarkerStart()) {
    w2 = Math.max(w2, this.getStartArrowWidth());
  }
  if (this.isMarkerEnd()) {
    w2 = Math.max(w2, this.getEndArrowWidth());
  }
  bbox.grow((w2 / 2 + this.strokewidth) * this.scale);
};
mxArrowConnector.prototype.paintEdgeShape = function(c, pts) {
  let strokeWidth = this.strokewidth;
  if (this.outline) {
    strokeWidth = Math.max(1, getNumber(this.style, mxConstants2.STYLE_STROKEWIDTH, this.strokewidth));
  }
  const startWidth = this.getStartArrowWidth() + strokeWidth;
  const endWidth = this.getEndArrowWidth() + strokeWidth;
  const edgeWidth = this.outline ? this.getEdgeWidth() + strokeWidth : this.getEdgeWidth();
  const openEnded = this.isOpenEnded();
  const markerStart = this.isMarkerStart();
  const markerEnd = this.isMarkerEnd();
  const spacing = openEnded ? 0 : this.arrowSpacing + strokeWidth / 2;
  const startSize = this.startSize + strokeWidth;
  const endSize = this.endSize + strokeWidth;
  const isRounded = this.isArrowRounded();
  const pe = pts[pts.length - 1];
  let i0 = 1;
  while (i0 < pts.length - 1 && pts[i0].x == pts[0].x && pts[i0].y == pts[0].y) {
    i0++;
  }
  const dx = pts[i0].x - pts[0].x;
  const dy = pts[i0].y - pts[0].y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  if (dist == 0) {
    return;
  }
  let nx = dx / dist;
  let ny = dy / dist;
  let nx1 = nx;
  let ny1 = ny;
  let nx2, ny2;
  let orthx = edgeWidth * ny;
  let orthy = -edgeWidth * nx;
  const fns = [];
  if (isRounded) {
    c.setLineJoin("round");
  } else if (pts.length > 2) {
    c.setMiterLimit(1.42);
  }
  c.begin();
  const startNx = nx;
  const startNy = ny;
  if (markerStart && !openEnded) {
    this.paintMarker(c, pts[0].x, pts[0].y, nx, ny, startSize, startWidth, edgeWidth, spacing, true);
  } else {
    const outStartX = pts[0].x + orthx / 2 + spacing * nx;
    const outStartY = pts[0].y + orthy / 2 + spacing * ny;
    const inEndX = pts[0].x - orthx / 2 + spacing * nx;
    const inEndY = pts[0].y - orthy / 2 + spacing * ny;
    if (openEnded) {
      c.moveTo(outStartX, outStartY);
      fns.push(function() {
        c.lineTo(inEndX, inEndY);
      });
    } else {
      c.moveTo(inEndX, inEndY);
      c.lineTo(outStartX, outStartY);
    }
  }
  for (let i = 0; i < pts.length - 2; i++) {
    const pos = relativeCcw(pts[i].x, pts[i].y, pts[i + 1].x, pts[i + 1].y, pts[i + 2].x, pts[i + 2].y);
    const dx1 = pts[i + 2].x - pts[i + 1].x;
    const dy1 = pts[i + 2].y - pts[i + 1].y;
    const dist1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
    if (dist1 != 0) {
      nx1 = dx1 / dist1;
      ny1 = dy1 / dist1;
      const tmp1 = nx * nx1 + ny * ny1;
      const tmp = Math.max(Math.sqrt((tmp1 + 1) / 2), 0.04);
      nx2 = nx + nx1;
      ny2 = ny + ny1;
      const dist2 = Math.sqrt(nx2 * nx2 + ny2 * ny2);
      if (dist2 != 0) {
        nx2 = nx2 / dist2;
        ny2 = ny2 / dist2;
        const strokeWidthFactor = Math.max(tmp, Math.min(this.strokewidth / 200 + 0.04, 0.35));
        const angleFactor = pos != 0 && isRounded ? Math.max(0.1, strokeWidthFactor) : Math.max(tmp, 0.06);
        const outX = pts[i + 1].x + ny2 * edgeWidth / 2 / angleFactor;
        const outY = pts[i + 1].y - nx2 * edgeWidth / 2 / angleFactor;
        const inX = pts[i + 1].x - ny2 * edgeWidth / 2 / angleFactor;
        const inY = pts[i + 1].y + nx2 * edgeWidth / 2 / angleFactor;
        if (pos == 0 || !isRounded) {
          c.lineTo(outX, outY);
          (function(x, y) {
            fns.push(function() {
              c.lineTo(x, y);
            });
          })(inX, inY);
        } else if (pos == -1) {
          const c1x = inX + ny * edgeWidth;
          const c1y = inY - nx * edgeWidth;
          const c2x = inX + ny1 * edgeWidth;
          const c2y = inY - nx1 * edgeWidth;
          c.lineTo(c1x, c1y);
          c.quadTo(outX, outY, c2x, c2y);
          (function(x, y) {
            fns.push(function() {
              c.lineTo(x, y);
            });
          })(inX, inY);
        } else {
          c.lineTo(outX, outY);
          (function(x, y) {
            const c1x = outX - ny * edgeWidth;
            const c1y = outY + nx * edgeWidth;
            const c2x = outX - ny1 * edgeWidth;
            const c2y = outY + ny1 * edgeWidth;
            fns.push(function() {
              c.quadTo(x, y, c1x, c1y);
            });
            fns.push(function() {
              c.lineTo(c2x, c2y);
            });
          })(inX, inY);
        }
        nx = nx1;
        ny = ny1;
      }
    }
  }
  orthx = edgeWidth * ny1;
  orthy = -edgeWidth * nx1;
  if (markerEnd && !openEnded) {
    this.paintMarker(c, pe.x, pe.y, -nx, -ny, endSize, endWidth, edgeWidth, spacing, false);
  } else {
    c.lineTo(pe.x - spacing * nx1 + orthx / 2, pe.y - spacing * ny1 + orthy / 2);
    const inStartX = pe.x - spacing * nx1 - orthx / 2;
    const inStartY = pe.y - spacing * ny1 - orthy / 2;
    if (!openEnded) {
      c.lineTo(inStartX, inStartY);
    } else {
      c.moveTo(inStartX, inStartY);
      fns.splice(0, 0, function() {
        c.moveTo(inStartX, inStartY);
      });
    }
  }
  for (let i = fns.length - 1; i >= 0; i--) {
    fns[i]();
  }
  if (openEnded) {
    c.end();
    c.stroke();
  } else {
    c.close();
    c.fillAndStroke();
  }
  c.setShadow(false);
  c.setMiterLimit(4);
  if (isRounded) {
    c.setLineJoin("flat");
  }
  if (pts.length > 2) {
    c.setMiterLimit(4);
    if (markerStart && !openEnded) {
      c.begin();
      this.paintMarker(c, pts[0].x, pts[0].y, startNx, startNy, startSize, startWidth, edgeWidth, spacing, true);
      c.stroke();
      c.end();
    }
    if (markerEnd && !openEnded) {
      c.begin();
      this.paintMarker(c, pe.x, pe.y, -nx, -ny, endSize, endWidth, edgeWidth, spacing, true);
      c.stroke();
      c.end();
    }
  }
};
mxArrowConnector.prototype.paintMarker = function(c, ptX, ptY, nx, ny, size, arrowWidth, edgeWidth, spacing, initialMove) {
  const widthArrowRatio = edgeWidth / arrowWidth;
  const orthx = edgeWidth * ny / 2;
  const orthy = -edgeWidth * nx / 2;
  const spaceX = (spacing + size) * nx;
  const spaceY = (spacing + size) * ny;
  if (initialMove) {
    c.moveTo(ptX - orthx + spaceX, ptY - orthy + spaceY);
  } else {
    c.lineTo(ptX - orthx + spaceX, ptY - orthy + spaceY);
  }
  c.lineTo(ptX - orthx / widthArrowRatio + spaceX, ptY - orthy / widthArrowRatio + spaceY);
  c.lineTo(ptX + spacing * nx, ptY + spacing * ny);
  c.lineTo(ptX + orthx / widthArrowRatio + spaceX, ptY + orthy / widthArrowRatio + spaceY);
  c.lineTo(ptX + orthx + spaceX, ptY + orthy + spaceY);
};
mxArrowConnector.prototype.isArrowRounded = function() {
  return this.isRounded;
};
mxArrowConnector.prototype.getStartArrowWidth = function() {
  return mxConstants2.ARROW_WIDTH;
};
mxArrowConnector.prototype.getEndArrowWidth = function() {
  return mxConstants2.ARROW_WIDTH;
};
mxArrowConnector.prototype.getEdgeWidth = function() {
  return mxConstants2.ARROW_WIDTH / 3;
};
mxArrowConnector.prototype.isOpenEnded = function() {
  return false;
};
mxArrowConnector.prototype.isMarkerStart = function() {
  return getValue(this.style, mxConstants2.STYLE_STARTARROW, mxConstants2.NONE) != mxConstants2.NONE;
};
mxArrowConnector.prototype.isMarkerEnd = function() {
  return getValue(this.style, mxConstants2.STYLE_ENDARROW, mxConstants2.NONE) != mxConstants2.NONE;
};

// js/graph/mxCloud.js
var mxCloud = function(bounds, fill, stroke, strokewidth) {
  mxActor.call(this);
  this.bounds = bounds;
  this.fill = fill;
  this.stroke = stroke;
  this.strokewidth = strokewidth != null ? strokewidth : 1;
};
extend(mxCloud, mxActor);
mxCloud.prototype.redrawPath = function(c, x, y, w2, h2) {
  c.moveTo(0.25 * w2, 0.25 * h2);
  c.curveTo(0.05 * w2, 0.25 * h2, 0, 0.5 * h2, 0.16 * w2, 0.55 * h2);
  c.curveTo(0, 0.66 * h2, 0.18 * w2, 0.9 * h2, 0.31 * w2, 0.8 * h2);
  c.curveTo(0.4 * w2, h2, 0.7 * w2, h2, 0.8 * w2, 0.8 * h2);
  c.curveTo(w2, 0.8 * h2, w2, 0.6 * h2, 0.875 * w2, 0.5 * h2);
  c.curveTo(w2, 0.3 * h2, 0.8 * w2, 0.1 * h2, 0.625 * w2, 0.2 * h2);
  c.curveTo(0.5 * w2, 0.05 * h2, 0.3 * w2, 0.05 * h2, 0.25 * w2, 0.25 * h2);
  c.close();
};

// js/graph/mxMarker.js
var mxMarker = {
  markers: [],
  addMarker(type, funct) {
    mxMarker.markers[type] = funct;
  },
  createMarker(canvas, shape, type, pe, unitX, unitY, size, source, sw, filled) {
    const funct = mxMarker.markers[type];
    return funct != null ? funct(canvas, shape, type, pe, unitX, unitY, size, source, sw, filled) : null;
  }
};
var createArrow = (widthFactor2 = 2) => (canvas, shape, type, pe, unitX, unitY, size, source, sw, filled) => {
  const endOffsetX = unitX * sw * 1.118;
  const endOffsetY = unitY * sw * 1.118;
  unitX = unitX * (size + sw);
  unitY = unitY * (size + sw);
  const pt = pe.clone();
  pt.x -= endOffsetX;
  pt.y -= endOffsetY;
  const f = type !== mxConstants2.ARROW_CLASSIC && type !== mxConstants2.ARROW_CLASSIC_THIN ? 1 : 3 / 4;
  pe.x += -unitX * f - endOffsetX;
  pe.y += -unitY * f - endOffsetY;
  return () => {
    canvas.begin();
    canvas.moveTo(pt.x, pt.y);
    canvas.lineTo(pt.x - unitX - unitY / widthFactor2, pt.y - unitY + unitX / widthFactor2);
    if (type === mxConstants2.ARROW_CLASSIC || type === mxConstants2.ARROW_CLASSIC_THIN) {
      canvas.lineTo(pt.x - unitX * 3 / 4, pt.y - unitY * 3 / 4);
    }
    canvas.lineTo(pt.x + unitY / widthFactor2 - unitX, pt.y - unitY - unitX / widthFactor2);
    canvas.close();
    if (filled) {
      canvas.fillAndStroke();
    } else {
      canvas.stroke();
    }
  };
};
mxMarker.addMarker("classic", createArrow(2));
mxMarker.addMarker("classicThin", createArrow(3));
mxMarker.addMarker("block", createArrow(2));
mxMarker.addMarker("blockThin", createArrow(3));
var createOpenArrow = (widthFactor2 = 2) => (canvas, shape, type, pe, unitX, unitY, size, source, sw, filled) => {
  const endOffsetX = unitX * sw * 1.118;
  const endOffsetY = unitY * sw * 1.118;
  unitX = unitX * (size + sw);
  unitY = unitY * (size + sw);
  const pt = pe.clone();
  pt.x -= endOffsetX;
  pt.y -= endOffsetY;
  pe.x += -endOffsetX * 2;
  pe.y += -endOffsetY * 2;
  return () => {
    canvas.begin();
    canvas.moveTo(pt.x - unitX - unitY / widthFactor2, pt.y - unitY + unitX / widthFactor2);
    canvas.lineTo(pt.x, pt.y);
    canvas.lineTo(pt.x + unitY / widthFactor2 - unitX, pt.y - unitY - unitX / widthFactor2);
    canvas.stroke();
  };
};
mxMarker.addMarker("open", createOpenArrow(2));
mxMarker.addMarker("openThin", createOpenArrow(3));
var diamond = (canvas, shape, type, pe, unitX, unitY, size, source, sw, filled) => {
  const swFactor = type === mxConstants2.ARROW_DIAMOND ? 0.7071 : 0.9862;
  const endOffsetX = unitX * sw * swFactor;
  const endOffsetY = unitY * sw * swFactor;
  unitX = unitX * (size + sw);
  unitY = unitY * (size + sw);
  const pt = pe.clone();
  pt.x -= endOffsetX;
  pt.y -= endOffsetY;
  pe.x += -unitX - endOffsetX;
  pe.y += -unitY - endOffsetY;
  const tk = type === mxConstants2.ARROW_DIAMOND ? 2 : 3.4;
  return () => {
    canvas.begin();
    canvas.moveTo(pt.x, pt.y);
    canvas.lineTo(pt.x - unitX / 2 - unitY / tk, pt.y + unitX / tk - unitY / 2);
    canvas.lineTo(pt.x - unitX, pt.y - unitY);
    canvas.lineTo(pt.x - unitX / 2 + unitY / tk, pt.y - unitY / 2 - unitX / tk);
    canvas.close();
    if (filled) {
      canvas.fillAndStroke();
    } else {
      canvas.stroke();
    }
  };
};
mxMarker.addMarker("oval", (canvas, shape, type, pe, unitX, unitY, size, source, sw, filled) => {
  const a = size / 2;
  const pt = pe.clone();
  pe.x -= unitX * a;
  pe.y -= unitY * a;
  return () => {
    canvas.ellipse(pt.x - a, pt.y - a, size, size);
    if (filled) {
      canvas.fillAndStroke();
    } else {
      canvas.stroke();
    }
  };
});
mxMarker.addMarker("diamond", diamond);
mxMarker.addMarker("diamondThin", diamond);

// js/graph/mxConnector.js
var mxConnector = function(points, stroke, strokewidth) {
  mxPolyline.call(this, points, stroke, strokewidth);
};
extend(mxConnector, mxPolyline);
mxConnector.prototype.updateBoundingBox = function() {
  this.useSvgBoundingBox = this.style != null && this.style[mxConstants2.STYLE_CURVED] === 1;
  mxShape.prototype.updateBoundingBox.apply(this, arguments);
};
mxConnector.prototype.paintEdgeShape = function(c, pts) {
  const sourceMarker = this.createMarker(c, pts, true);
  const targetMarker = this.createMarker(c, pts, false);
  mxPolyline.prototype.paintEdgeShape.apply(this, arguments);
  c.setFillColor(this.stroke);
  c.setShadow(false);
  c.setDashed(false);
  if (sourceMarker != null) {
    sourceMarker();
  }
  if (targetMarker != null) {
    targetMarker();
  }
};
mxConnector.prototype.createMarker = function(c, pts, source) {
  let result2 = null;
  const n = pts.length;
  const type = getValue(this.style, source ? mxConstants2.STYLE_STARTARROW : mxConstants2.STYLE_ENDARROW);
  let p0 = source ? pts[1] : pts[n - 2];
  let pe = source ? pts[0] : pts[n - 1];
  if (type != null && p0 != null && pe != null) {
    let count = 1;
    while (count < n - 1 && Math.round(p0.x - pe.x) === 0 && Math.round(p0.y - pe.y) === 0) {
      p0 = source ? pts[1 + count] : pts[n - 2 - count];
      count++;
    }
    const dx = pe.x - p0.x;
    const dy = pe.y - p0.y;
    const dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));
    const unitX = dx / dist;
    const unitY = dy / dist;
    const size = getNumber(this.style, source ? mxConstants2.STYLE_STARTSIZE : mxConstants2.STYLE_ENDSIZE, mxConstants2.DEFAULT_MARKERSIZE);
    const filled = this.style[source ? mxConstants2.STYLE_STARTFILL : mxConstants2.STYLE_ENDFILL] != 0;
    result2 = mxMarker.createMarker(c, this, type, pe, unitX, unitY, size, source, this.strokewidth, filled);
  }
  return result2;
};
mxConnector.prototype.augmentBoundingBox = function(bbox) {
  mxShape.prototype.augmentBoundingBox.apply(this, arguments);
  let size = 0;
  if (getValue(this.style, mxConstants2.STYLE_STARTARROW, mxConstants2.NONE) !== mxConstants2.NONE) {
    size = getNumber(this.style, mxConstants2.STYLE_STARTSIZE, mxConstants2.DEFAULT_MARKERSIZE) + 1;
  }
  if (getValue(this.style, mxConstants2.STYLE_ENDARROW, mxConstants2.NONE) !== mxConstants2.NONE) {
    size = Math.max(size, getNumber(this.style, mxConstants2.STYLE_ENDSIZE, mxConstants2.DEFAULT_MARKERSIZE)) + 1;
  }
  bbox.grow(size * this.scale);
};
var mxSwimlane = function(bounds, fill, stroke, strokewidth) {
  mxShape.call(this, bounds, fill, stroke, strokewidth);
};
extend(mxSwimlane, mxShape);

// js/graph/mxCylinder.js
var mxCylinder = function(bounds, fill, stroke, strokewidth) {
  mxShape.call(this);
  this.bounds = bounds;
  this.fill = fill;
  this.stroke = stroke;
  this.strokewidth = strokewidth != null ? strokewidth : 1;
};
extend(mxCylinder, mxShape);
mxCylinder.prototype.maxHeight = 40;
mxCylinder.prototype.svgStrokeTolerance = 0;
mxCylinder.prototype.paintVertexShape = function(c, x, y, w2, h2) {
  c.translate(x, y);
  c.begin();
  this.redrawPath(c, x, y, w2, h2, false);
  c.fillAndStroke();
  if (!this.outline || this.style == null || getValue(this.style, mxConstants2.STYLE_BACKGROUND_OUTLINE, 0) === 0) {
    c.setShadow(false);
    c.begin();
    this.redrawPath(c, x, y, w2, h2, true);
    c.stroke();
  }
};
mxCylinder.prototype.getCylinderSize = function(x, y, w2, h2) {
  return Math.min(this.maxHeight, Math.round(h2 / 5));
};
mxCylinder.prototype.redrawPath = function(c, x, y, w2, h2, isForeground) {
  const dy = this.getCylinderSize(x, y, w2, h2);
  if (isForeground && this.fill != null || !isForeground && this.fill == null) {
    c.moveTo(0, dy);
    c.curveTo(0, 2 * dy, w2, 2 * dy, w2, dy);
    if (!isForeground) {
      c.stroke();
      c.begin();
    }
  }
  if (!isForeground) {
    c.moveTo(0, dy);
    c.curveTo(0, -dy / 3, w2, -dy / 3, w2, dy);
    c.lineTo(w2, h2 - dy);
    c.curveTo(w2, h2 + dy / 3, 0, h2 + dy / 3, 0, h2 - dy);
    c.close();
  }
};

// js/graph/mxHexagon.js
var mxHexagon = function() {
  mxActor.call(this);
};
extend(mxHexagon, mxActor);
mxHexagon.prototype.redrawPath = function(c, x, y, w2, h2) {
  const arcSize = getValue(this.style, mxConstants2.STYLE_ARCSIZE, mxConstants2.LINE_ARCSIZE) / 2;
  this.addPoints(c, [
    new mxPoint2(0.25 * w2, 0),
    new mxPoint2(0.75 * w2, 0),
    new mxPoint2(w2, 0.5 * h2),
    new mxPoint2(0.75 * w2, h2),
    new mxPoint2(0.25 * w2, h2),
    new mxPoint2(0, 0.5 * h2)
  ], this.isRounded, arcSize, true);
};

// js/graph/mxLabel.js
var mxLabel = function(bounds, fill, stroke, strokewidth) {
  mxRectangleShape.call(this, bounds, fill, stroke, strokewidth);
};
extend(mxLabel, mxRectangleShape);
mxLabel.prototype.imageSize = mxConstants2.DEFAULT_IMAGESIZE;
mxLabel.prototype.spacing = 2;
mxLabel.prototype.indicatorSize = 10;
mxLabel.prototype.indicatorSpacing = 2;
mxLabel.prototype.init = function(container) {
  mxShape.prototype.init.apply(this, arguments);
  if (this.indicatorShape != null) {
    this.indicator = new this.indicatorShape();
    this.indicator.dialect = this.dialect;
    this.indicator.init(this.node);
  }
};
mxLabel.prototype.redraw = function() {
  if (this.indicator != null) {
    this.indicator.fill = this.indicatorColor;
    this.indicator.stroke = this.indicatorStrokeColor;
    this.indicator.gradient = this.indicatorGradientColor;
    this.indicator.direction = this.indicatorDirection;
    this.indicator.redraw();
  }
  mxShape.prototype.redraw.apply(this, arguments);
};
mxLabel.prototype.isHtmlAllowed = function() {
  return mxRectangleShape.prototype.isHtmlAllowed.apply(this, arguments) && this.indicatorColor == null && this.indicatorShape == null;
};
mxLabel.prototype.paintForeground = function(c, x, y, w2, h2) {
  this.paintImage(c, x, y, w2, h2);
  this.paintIndicator(c, x, y, w2, h2);
  mxRectangleShape.prototype.paintForeground.apply(this, arguments);
};
mxLabel.prototype.paintImage = function(c, x, y, w2, h2) {
  if (this.image != null) {
    const bounds = this.getImageBounds(x, y, w2, h2);
    c.image(bounds.x, bounds.y, bounds.width, bounds.height, this.image, false, false, false);
  }
};
mxLabel.prototype.getImageBounds = function(x, y, w2, h2) {
  const align = getValue(this.style, mxConstants2.STYLE_IMAGE_ALIGN, mxConstants2.ALIGN_LEFT);
  const valign = getValue(this.style, mxConstants2.STYLE_IMAGE_VERTICAL_ALIGN, mxConstants2.ALIGN_MIDDLE);
  const width = getNumber(this.style, mxConstants2.STYLE_IMAGE_WIDTH, mxConstants2.DEFAULT_IMAGESIZE);
  const height = getNumber(this.style, mxConstants2.STYLE_IMAGE_HEIGHT, mxConstants2.DEFAULT_IMAGESIZE);
  const spacing = getNumber(this.style, mxConstants2.STYLE_SPACING, this.spacing) + 5;
  if (align == mxConstants2.ALIGN_CENTER) {
    x += (w2 - width) / 2;
  } else if (align == mxConstants2.ALIGN_RIGHT) {
    x += w2 - width - spacing;
  } else {
    x += spacing;
  }
  if (valign == mxConstants2.ALIGN_TOP) {
    y += spacing;
  } else if (valign == mxConstants2.ALIGN_BOTTOM) {
    y += h2 - height - spacing;
  } else {
    y += (h2 - height) / 2;
  }
  return new mxRectangle(x, y, width, height);
};
mxLabel.prototype.paintIndicator = function(c, x, y, w2, h2) {
  if (this.indicator != null) {
    this.indicator.bounds = this.getIndicatorBounds(x, y, w2, h2);
    this.indicator.paint(c);
  } else if (this.indicatorImage != null) {
    const bounds = this.getIndicatorBounds(x, y, w2, h2);
    c.image(bounds.x, bounds.y, bounds.width, bounds.height, this.indicatorImage, false, false, false);
  }
};
mxLabel.prototype.getIndicatorBounds = function(x, y, w2, h2) {
  const align = getValue(this.style, mxConstants2.STYLE_IMAGE_ALIGN, mxConstants2.ALIGN_LEFT);
  const valign = getValue(this.style, mxConstants2.STYLE_IMAGE_VERTICAL_ALIGN, mxConstants2.ALIGN_MIDDLE);
  const width = getNumber(this.style, mxConstants2.STYLE_INDICATOR_WIDTH, this.indicatorSize);
  const height = getNumber(this.style, mxConstants2.STYLE_INDICATOR_HEIGHT, this.indicatorSize);
  const spacing = this.spacing + 5;
  if (align == mxConstants2.ALIGN_RIGHT) {
    x += w2 - width - spacing;
  } else if (align == mxConstants2.ALIGN_CENTER) {
    x += (w2 - width) / 2;
  } else {
    x += spacing;
  }
  if (valign == mxConstants2.ALIGN_BOTTOM) {
    y += h2 - height - spacing;
  } else if (valign == mxConstants2.ALIGN_TOP) {
    y += spacing;
  } else {
    y += (h2 - height) / 2;
  }
  return new mxRectangle(x, y, width, height);
};
mxLabel.prototype.redrawHtmlShape = function() {
  mxRectangleShape.prototype.redrawHtmlShape.apply(this, arguments);
  while (this.node.hasChildNodes()) {
    this.node.removeChild(this.node.lastChild);
  }
  if (this.image != null) {
    const node = document.createElement("img");
    node.style.position = "relative";
    node.setAttribute("border", "0");
    const bounds = this.getImageBounds(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height);
    bounds.x -= this.bounds.x;
    bounds.y -= this.bounds.y;
    node.style.left = Math.round(bounds.x) + "px";
    node.style.top = Math.round(bounds.y) + "px";
    node.style.width = Math.round(bounds.width) + "px";
    node.style.height = Math.round(bounds.height) + "px";
    node.src = this.image;
    this.node.appendChild(node);
  }
};

// js/graph/mxLine.js
var mxLine = function(bounds, stroke, strokewidth, vertical) {
  mxShape.call(this);
  this.bounds = bounds;
  this.stroke = stroke;
  this.strokewidth = strokewidth != null ? strokewidth : 1;
  this.vertical = vertical != null ? vertical : this.vertical;
};
extend(mxLine, mxShape);
mxLine.prototype.vertical = false;
mxLine.prototype.paintVertexShape = function(c, x, y, w2, h2) {
  c.begin();
  if (this.vertical) {
    const mid = x + w2 / 2;
    c.moveTo(mid, y);
    c.lineTo(mid, y + h2);
  } else {
    const mid = y + h2 / 2;
    c.moveTo(x, mid);
    c.lineTo(x + w2, mid);
  }
  c.stroke();
};

// js/graph/mxRhombus.js
var mxRhombus = function(bounds, fill, stroke, strokewidth) {
  mxShape.call(this);
  this.bounds = bounds;
  this.fill = fill;
  this.stroke = stroke;
  this.strokewidth = strokewidth != null ? strokewidth : 1;
};
extend(mxRhombus, mxShape);
mxRhombus.prototype.isRoundable = function() {
  return true;
};
mxRhombus.prototype.paintVertexShape = function(c, x, y, w2, h2) {
  const hw = w2 / 2;
  const hh = h2 / 2;
  const arcSize = getValue(this.style, mxConstants2.STYLE_ARCSIZE, mxConstants2.LINE_ARCSIZE) / 2;
  c.begin();
  this.addPoints(c, [
    new mxPoint2(x + hw, y),
    new mxPoint2(x + w2, y + hh),
    new mxPoint2(x + hw, y + h2),
    new mxPoint2(x, y + hh)
  ], this.isRounded, arcSize, true);
  c.fillAndStroke();
};

// js/graph/mxStencilRegistry.js
function mxStencilRegistry() {
}
mxStencilRegistry.stencils = {};
mxStencilRegistry.addStencil = function(name, stencil) {
  mxStencilRegistry.stencils[name] = stencil;
};
mxStencilRegistry.getStencil = function(name) {
  return mxStencilRegistry.stencils[name];
};

// js/graph/mxSwimlane.js
var mxSwimlane2 = function(bounds, fill, stroke, strokewidth) {
  mxShape.call(this);
  this.bounds = bounds;
  this.fill = fill;
  this.stroke = stroke;
  this.strokewidth = strokewidth != null ? strokewidth : 1;
};
extend(mxSwimlane2, mxShape);
mxSwimlane2.prototype.imageSize = 16;
var SWIMLANE_IMAGE_SIZE = mxSwimlane2.prototype.imageSize;
var isRoundable = mxSwimlane2.prototype.isRoundable = function(c, x, y, w2, h2) {
  return true;
};
var getTitleSize = mxSwimlane2.prototype.getTitleSize = function() {
  return Math.max(0, getValue(this.style, mxConstants2.STYLE_STARTSIZE, mxConstants2.DEFAULT_STARTSIZE));
};
var getLabelBounds = mxSwimlane2.prototype.getLabelBounds = function(rect) {
  const start = this.getTitleSize();
  const bounds = new mxRectangle(rect.x, rect.y, rect.width, rect.height);
  const horizontal = this.isHorizontal();
  const flipH = getValue(this.style, mxConstants2.STYLE_FLIPH, 0) === 1;
  const flipV = getValue(this.style, mxConstants2.STYLE_FLIPV, 0) === 1;
  const shapeVertical = this.direction === mxConstants2.DIRECTION_NORTH || this.direction === mxConstants2.DIRECTION_SOUTH;
  const realHorizontal = horizontal === !shapeVertical;
  const realFlipH = !realHorizontal && flipH !== (this.direction === mxConstants2.DIRECTION_SOUTH || this.direction === mxConstants2.DIRECTION_WEST);
  const realFlipV = realHorizontal && flipV !== (this.direction === mxConstants2.DIRECTION_SOUTH || this.direction === mxConstants2.DIRECTION_WEST);
  if (!shapeVertical) {
    const tmp = Math.min(bounds.height, start * this.scale);
    if (realFlipH || realFlipV) {
      bounds.y += bounds.height - tmp;
    }
    bounds.height = tmp;
  } else {
    const tmp = Math.min(bounds.width, start * this.scale);
    if (realFlipH || realFlipV) {
      bounds.x += bounds.width - tmp;
    }
    bounds.width = tmp;
  }
  return bounds;
};
var getGradientBounds = mxSwimlane2.prototype.getGradientBounds = function(c, x, y, w2, h2) {
  let start = this.getTitleSize();
  if (this.isHorizontal()) {
    start = Math.min(start, h2);
    return new mxRectangle(x, y, w2, start);
  } else {
    start = Math.min(start, w2);
    return new mxRectangle(x, y, start, h2);
  }
};
var getSwimlaneArcSize = mxSwimlane2.prototype.getSwimlaneArcSize = function(w2, h2, start) {
  if (getValue(this.style, mxConstants2.STYLE_ABSOLUTE_ARCSIZE, 0) === "1") {
    return Math.min(w2 / 2, Math.min(h2 / 2, getValue(this.style, mxConstants2.STYLE_ARCSIZE, mxConstants2.LINE_ARCSIZE) / 2));
  } else {
    const f = getValue(this.style, mxConstants2.STYLE_ARCSIZE, mxConstants2.RECTANGLE_ROUNDING_FACTOR * 100) / 100;
    return start * f * 3;
  }
};
var isHorizontal = mxSwimlane2.prototype.isHorizontal = function() {
  return getValue(this.style, mxConstants2.STYLE_HORIZONTAL, 1) === 1;
};
var paintVertexShape = mxSwimlane2.prototype.paintVertexShape = function(c, x, y, w2, h2) {
  let start = this.getTitleSize();
  const fill = getValue(this.style, mxConstants2.STYLE_SWIMLANE_FILLCOLOR, mxConstants2.NONE);
  const swimlaneLine = getValue(this.style, mxConstants2.STYLE_SWIMLANE_LINE, 1) === 1;
  let r = 0;
  if (this.isHorizontal()) {
    start = Math.min(start, h2);
  } else {
    start = Math.min(start, w2);
  }
  c.translate(x, y);
  if (!this.isRounded) {
    this.paintSwimlane(c, x, y, w2, h2, start, fill, swimlaneLine);
  } else {
    r = this.getSwimlaneArcSize(w2, h2, start);
    r = Math.min((this.isHorizontal() ? h2 : w2) - start, Math.min(start, r));
    this.paintRoundedSwimlane(c, x, y, w2, h2, start, r, fill, swimlaneLine);
  }
  const sep = getValue(this.style, mxConstants2.STYLE_SEPARATORCOLOR, mxConstants2.NONE);
  this.paintSeparator(c, x, y, w2, h2, start, sep);
  if (this.image != null) {
    const bounds = this.getImageBounds(x, y, w2, h2);
    c.image(bounds.x - x, bounds.y - y, bounds.width, bounds.height, this.image, false, false, false);
  }
  if (this.glass) {
    c.setShadow(false);
    this.paintGlassEffect(c, 0, 0, w2, start, r);
  }
};
var paintSwimlane = mxSwimlane2.prototype.paintSwimlane = function(c, x, y, w2, h2, start, fill, swimlaneLine) {
  c.begin();
  let events = true;
  if (this.style != null) {
    events = getValue(this.style, mxConstants2.STYLE_POINTER_EVENTS, "1") === "1";
  }
  if (!events && (this.fill == null || this.fill === mxConstants2.NONE)) {
    c.pointerEvents = false;
  }
  if (this.isHorizontal()) {
    c.moveTo(0, start);
    c.lineTo(0, 0);
    c.lineTo(w2, 0);
    c.lineTo(w2, start);
    c.fillAndStroke();
    if (start < h2) {
      if (fill === mxConstants2.NONE || !events) {
        c.pointerEvents = false;
      }
      if (fill !== mxConstants2.NONE) {
        c.setFillColor(fill);
      }
      c.begin();
      c.moveTo(0, start);
      c.lineTo(0, h2);
      c.lineTo(w2, h2);
      c.lineTo(w2, start);
      fill === mxConstants2.NONE ? c.stroke() : c.fillAndStroke();
    }
  } else {
    c.moveTo(start, 0);
    c.lineTo(0, 0);
    c.lineTo(0, h2);
    c.lineTo(start, h2);
    c.fillAndStroke();
    if (start < w2) {
      if (fill === mxConstants2.NONE || !events) {
        c.pointerEvents = false;
      }
      if (fill !== mxConstants2.NONE) {
        c.setFillColor(fill);
      }
      c.begin();
      c.moveTo(start, 0);
      c.lineTo(w2, 0);
      c.lineTo(w2, h2);
      c.lineTo(start, h2);
      fill === mxConstants2.NONE ? c.stroke() : c.fillAndStroke();
    }
  }
  if (swimlaneLine) {
    this.paintDivider(c, x, y, w2, h2, start, fill === mxConstants2.NONE);
  }
};
var paintRoundedSwimlane = mxSwimlane2.prototype.paintRoundedSwimlane = function(c, x, y, w2, h2, start, r, fill, swimlaneLine) {
  c.begin();
  let events = true;
  if (this.style != null) {
    events = getValue(this.style, mxConstants2.STYLE_POINTER_EVENTS, "1") === "1";
  }
  if (!events && (this.fill == null || this.fill === mxConstants2.NONE)) {
    c.pointerEvents = false;
  }
  if (this.isHorizontal()) {
    c.moveTo(w2, start);
    c.lineTo(w2, r);
    c.quadTo(w2, 0, w2 - Math.min(w2 / 2, r), 0);
    c.lineTo(Math.min(w2 / 2, r), 0);
    c.quadTo(0, 0, 0, r);
    c.lineTo(0, start);
    c.fillAndStroke();
    if (start < h2) {
      if (fill === mxConstants2.NONE || !events) {
        c.pointerEvents = false;
      }
      if (fill !== mxConstants2.NONE) {
        c.setFillColor(fill);
      }
      c.begin();
      c.moveTo(0, start);
      c.lineTo(0, h2 - r);
      c.quadTo(0, h2, Math.min(w2 / 2, r), h2);
      c.lineTo(w2 - Math.min(w2 / 2, r), h2);
      c.quadTo(w2, h2, w2, h2 - r);
      c.lineTo(w2, start);
      fill === mxConstants2.NONE ? c.stroke() : c.fillAndStroke();
    }
  } else {
    c.moveTo(start, 0);
    c.lineTo(r, 0);
    c.quadTo(0, 0, 0, Math.min(h2 / 2, r));
    c.lineTo(0, h2 - Math.min(h2 / 2, r));
    c.quadTo(0, h2, r, h2);
    c.lineTo(start, h2);
    c.fillAndStroke();
    if (start < w2) {
      if (fill === mxConstants2.NONE || !events) {
        c.pointerEvents = false;
      }
      if (fill !== mxConstants2.NONE) {
        c.setFillColor(fill);
      }
      c.begin();
      c.moveTo(start, h2);
      c.lineTo(w2 - r, h2);
      c.quadTo(w2, h2, w2, h2 - Math.min(h2 / 2, r));
      c.lineTo(w2, Math.min(h2 / 2, r));
      c.quadTo(w2, 0, w2 - r, 0);
      c.lineTo(start, 0);
      fill === mxConstants2.NONE ? c.stroke() : c.fillAndStroke();
    }
  }
  if (swimlaneLine) {
    this.paintDivider(c, x, y, w2, h2, start, fill === mxConstants2.NONE);
  }
};
var paintDivider = mxSwimlane2.prototype.paintDivider = function(c, x, y, w2, h2, start, shadow) {
  if (!shadow) {
    c.setShadow(false);
  }
  c.begin();
  if (this.isHorizontal()) {
    c.moveTo(0, start);
    c.lineTo(w2, start);
  } else {
    c.moveTo(start, 0);
    c.lineTo(start, h2);
  }
  c.stroke();
};
var paintSeparator = mxSwimlane2.prototype.paintSeparator = function(c, x, y, w2, h2, start, color) {
  if (color !== mxConstants2.NONE) {
    c.setStrokeColor(color);
    c.setDashed(true);
    c.begin();
    if (this.isHorizontal()) {
      c.moveTo(w2, start);
      c.lineTo(w2, h2);
    } else {
      c.moveTo(start, 0);
      c.lineTo(w2, 0);
    }
    c.stroke();
    c.setDashed(false);
  }
};
var getImageBounds = mxSwimlane2.prototype.getImageBounds = function(x, y, w2, h2) {
  if (this.isHorizontal()) {
    return new mxRectangle(x + w2 - this.imageSize, y, this.imageSize, this.imageSize);
  } else {
    return new mxRectangle(x, y, this.imageSize, this.imageSize);
  }
};

// js/graph/mxTriangle.js
var mxTriangle = function() {
  mxActor.call(this);
};
extend(mxTriangle, mxActor);
mxTriangle.prototype.isRoundable = function() {
  return true;
};
mxTriangle.prototype.redrawPath = function(c, x, y, w2, h2) {
  const arcSize = getValue(this.style, mxConstants2.STYLE_ARCSIZE, mxConstants2.LINE_ARCSIZE) / 2;
  this.addPoints(c, [
    new mxPoint2(0, 0),
    new mxPoint2(w2, 0.5 * h2),
    new mxPoint2(0, h2)
  ], this.isRounded, arcSize, true);
};

// js/graph/mxCellRenderer.js
function mxCellRenderer2() {
}
mxCellRenderer2.defaultShapes = new Object();
mxCellRenderer2.prototype.defaultEdgeShape = mxConnector;
mxCellRenderer2.prototype.defaultVertexShape = mxRectangleShape;
mxCellRenderer2.prototype.defaultTextShape = mxText;
mxCellRenderer2.prototype.legacyControlPosition = true;
mxCellRenderer2.prototype.legacySpacing = true;
mxCellRenderer2.prototype.antiAlias = true;
mxCellRenderer2.prototype.minSvgStrokeWidth = 1;
mxCellRenderer2.prototype.forceControlClickHandler = false;
mxCellRenderer2.registerShape = function(key, shape) {
  mxCellRenderer2.defaultShapes[key] = shape;
};
mxCellRenderer2.registerShape(mxConstants2.SHAPE_RECTANGLE, mxRectangleShape);
mxCellRenderer2.registerShape(mxConstants2.SHAPE_ELLIPSE, mxEllipse);
mxCellRenderer2.registerShape(mxConstants2.SHAPE_RHOMBUS, mxRhombus);
mxCellRenderer2.registerShape(mxConstants2.SHAPE_CYLINDER, mxCylinder);
mxCellRenderer2.registerShape(mxConstants2.SHAPE_CONNECTOR, mxConnector);
mxCellRenderer2.registerShape(mxConstants2.SHAPE_ACTOR, mxActor);
mxCellRenderer2.registerShape(mxConstants2.SHAPE_TRIANGLE, mxTriangle);
mxCellRenderer2.registerShape(mxConstants2.SHAPE_HEXAGON, mxHexagon);
mxCellRenderer2.registerShape(mxConstants2.SHAPE_CLOUD, mxCloud);
mxCellRenderer2.registerShape(mxConstants2.SHAPE_LINE, mxLine);
mxCellRenderer2.registerShape(mxConstants2.SHAPE_ARROW, mxArrow2);
mxCellRenderer2.registerShape(mxConstants2.SHAPE_ARROW_CONNECTOR, mxArrowConnector);
mxCellRenderer2.registerShape(mxConstants2.SHAPE_DOUBLE_ELLIPSE, mxDoubleEllipse);
mxCellRenderer2.registerShape(mxConstants2.SHAPE_SWIMLANE, mxSwimlane2);
mxCellRenderer2.registerShape(mxConstants2.SHAPE_IMAGE, mxImageShape);
mxCellRenderer2.registerShape(mxConstants2.SHAPE_LABEL, mxLabel);
mxCellRenderer2.prototype.initializeShape = function(state2) {
  state2.shape.dialect = state2.view.graph.dialect;
  this.configureShape(state2);
  state2.shape.init(state2.view.getDrawPane());
};
mxCellRenderer2.prototype.createShape = function(state2) {
  let shape = null;
  if (state2.style != null) {
    const stencil = mxStencilRegistry.getStencil(state2.style[mxConstants2.STYLE_SHAPE]);
    if (stencil != null) {
      shape = new mxShape(stencil);
    } else {
      const ctor = this.getShapeConstructor(state2);
      shape = new ctor();
    }
  }
  return shape;
};
mxCellRenderer2.prototype.createIndicatorShape = function(state2) {
  state2.shape.indicatorShape = this.getShape(state2.view.graph.getIndicatorShape(state2));
};
mxCellRenderer2.prototype.getShape = function(name) {
  return name != null ? mxCellRenderer2.defaultShapes[name] : null;
};
mxCellRenderer2.prototype.getShapeConstructor = function(state2) {
  let ctor = this.getShape(state2.style[mxConstants2.STYLE_SHAPE]);
  if (ctor == null) {
    ctor = state2.view.graph.getModel().isEdge(state2.cell) ? this.defaultEdgeShape : this.defaultVertexShape;
  }
  return ctor;
};
mxCellRenderer2.prototype.configureShape = function(state2) {
  state2.shape.apply(state2);
  state2.shape.image = state2.view.graph.getImage(state2);
  state2.shape.indicatorColor = state2.view.graph.getIndicatorColor(state2);
  state2.shape.indicatorStrokeColor = state2.style[mxConstants2.STYLE_INDICATOR_STROKECOLOR];
  state2.shape.indicatorGradientColor = state2.view.graph.getIndicatorGradientColor(state2);
  state2.shape.indicatorDirection = state2.style[mxConstants2.STYLE_INDICATOR_DIRECTION];
  state2.shape.indicatorImage = state2.view.graph.getIndicatorImage(state2);
  this.postConfigureShape(state2);
};
mxCellRenderer2.prototype.postConfigureShape = function(state2) {
  if (state2.shape != null) {
    this.resolveColor(state2, "indicatorGradientColor", mxConstants2.STYLE_GRADIENTCOLOR);
    this.resolveColor(state2, "indicatorColor", mxConstants2.STYLE_FILLCOLOR);
    this.resolveColor(state2, "gradient", mxConstants2.STYLE_GRADIENTCOLOR);
    this.resolveColor(state2, "stroke", mxConstants2.STYLE_STROKECOLOR);
    this.resolveColor(state2, "fill", mxConstants2.STYLE_FILLCOLOR);
  }
};
mxCellRenderer2.prototype.checkPlaceholderStyles = function(state2) {
  if (state2.style != null) {
    const values = ["inherit", "swimlane", "indicated"];
    const styles = [
      mxConstants2.STYLE_FILLCOLOR,
      mxConstants2.STYLE_STROKECOLOR,
      mxConstants2.STYLE_GRADIENTCOLOR,
      mxConstants2.STYLE_FONTCOLOR
    ];
    for (let i = 0; i < styles.length; i++) {
      if (indexOf(values, state2.style[styles[i]]) >= 0) {
        return true;
      }
    }
  }
  return false;
};
mxCellRenderer2.prototype.resolveColor = function(state2, field, key) {
  const shape = key == mxConstants2.STYLE_FONTCOLOR ? state2.text : state2.shape;
  if (shape != null) {
    const graph = state2.view.graph;
    const value = shape[field];
    let referenced = null;
    if (value == "inherit") {
      referenced = graph.model.getParent(state2.cell);
    } else if (value == "swimlane") {
      shape[field] = key == mxConstants2.STYLE_STROKECOLOR || key == mxConstants2.STYLE_FONTCOLOR ? "#000000" : "#ffffff";
      if (graph.model.getTerminal(state2.cell, false) != null) {
        referenced = graph.model.getTerminal(state2.cell, false);
      } else {
        referenced = state2.cell;
      }
      referenced = graph.getSwimlane(referenced);
      key = graph.swimlaneIndicatorColorAttribute;
    } else if (value == "indicated" && state2.shape != null) {
      shape[field] = state2.shape.indicatorColor;
    } else if (key != mxConstants2.STYLE_FILLCOLOR && value == mxConstants2.STYLE_FILLCOLOR && state2.shape != null) {
      shape[field] = state2.style[mxConstants2.STYLE_FILLCOLOR];
    } else if (key != mxConstants2.STYLE_STROKECOLOR && value == mxConstants2.STYLE_STROKECOLOR && state2.shape != null) {
      shape[field] = state2.style[mxConstants2.STYLE_STROKECOLOR];
    }
    if (referenced != null) {
      const rstate = graph.getView().getState(referenced);
      shape[field] = null;
      if (rstate != null) {
        const rshape = key == mxConstants2.STYLE_FONTCOLOR ? rstate.text : rstate.shape;
        if (rshape != null && field != "indicatorColor") {
          shape[field] = rshape[field];
        } else {
          shape[field] = rstate.style[key];
        }
      }
    }
  }
};
mxCellRenderer2.prototype.getLabelValue = function(state2) {
  return state2.view.graph.getLabel(state2.cell);
};
mxCellRenderer2.prototype.createLabel = function(state2, value) {
  const graph = state2.view.graph;
  const isEdge = graph.getModel().isEdge(state2.cell);
  if (state2.style[mxConstants2.STYLE_FONTSIZE] > 0 || state2.style[mxConstants2.STYLE_FONTSIZE] == null) {
    const isForceHtml = graph.isHtmlLabel(state2.cell) || value != null && isNode(value);
    state2.text = new this.defaultTextShape(value, new mxRectangle(), state2.style[mxConstants2.STYLE_ALIGN] || mxConstants2.ALIGN_CENTER, graph.getVerticalAlign(state2), state2.style[mxConstants2.STYLE_FONTCOLOR], state2.style[mxConstants2.STYLE_FONTFAMILY], state2.style[mxConstants2.STYLE_FONTSIZE], state2.style[mxConstants2.STYLE_FONTSTYLE], state2.style[mxConstants2.STYLE_SPACING], state2.style[mxConstants2.STYLE_SPACING_TOP], state2.style[mxConstants2.STYLE_SPACING_RIGHT], state2.style[mxConstants2.STYLE_SPACING_BOTTOM], state2.style[mxConstants2.STYLE_SPACING_LEFT], state2.style[mxConstants2.STYLE_HORIZONTAL], state2.style[mxConstants2.STYLE_LABEL_BACKGROUNDCOLOR], state2.style[mxConstants2.STYLE_LABEL_BORDERCOLOR], graph.isWrapping(state2.cell) && graph.isHtmlLabel(state2.cell), graph.isLabelClipped(state2.cell), state2.style[mxConstants2.STYLE_OVERFLOW], state2.style[mxConstants2.STYLE_LABEL_PADDING], getValue(state2.style, mxConstants2.STYLE_TEXT_DIRECTION, mxConstants2.DEFAULT_TEXT_DIRECTION));
    state2.text.opacity = getValue(state2.style, mxConstants2.STYLE_TEXT_OPACITY, 100);
    state2.text.dialect = isForceHtml ? mxConstants2.DIALECT_STRICTHTML : state2.view.graph.dialect;
    state2.text.style = state2.style;
    state2.text.state = state2;
    this.initializeLabel(state2, state2.text);
    let forceGetCell = false;
    const getState = function(evt) {
      let result2 = state2;
      if (mxClient_default.IS_TOUCH || forceGetCell) {
        const x = mxEvent2.getClientX(evt);
        const y = mxEvent2.getClientY(evt);
        const pt = convertPoint(graph.container, x, y);
        result2 = graph.view.getState(graph.getCellAt(pt.x, pt.y));
      }
      return result2;
    };
    mxEvent2.addGestureListeners(state2.text.node, bind(this, function(evt) {
      if (this.isLabelEvent(state2, evt)) {
        graph.fireMouseEvent(mxEvent2.MOUSE_DOWN, new mxMouseEvent2(evt, state2));
        forceGetCell = graph.dialect != mxConstants2.DIALECT_SVG && mxEvent2.getSource(evt).nodeName == "IMG";
      }
    }), bind(this, function(evt) {
      if (this.isLabelEvent(state2, evt)) {
        graph.fireMouseEvent(mxEvent2.MOUSE_MOVE, new mxMouseEvent2(evt, getState(evt)));
      }
    }), bind(this, function(evt) {
      if (this.isLabelEvent(state2, evt)) {
        graph.fireMouseEvent(mxEvent2.MOUSE_UP, new mxMouseEvent2(evt, getState(evt)));
        forceGetCell = false;
      }
    }));
    if (graph.nativeDblClickEnabled) {
      mxEvent2.addListener(state2.text.node, "dblclick", bind(this, function(evt) {
        if (this.isLabelEvent(state2, evt)) {
          graph.dblClick(evt, state2.cell);
          mxEvent2.consume(evt);
        }
      }));
    }
  }
};
mxCellRenderer2.prototype.initializeLabel = function(state2, shape) {
  if (mxClient_default.IS_SVG && mxClient_default.NO_FO && shape.dialect != mxConstants2.DIALECT_SVG) {
    shape.init(state2.view.graph.container);
  } else {
    shape.init(state2.view.getDrawPane());
  }
};
mxCellRenderer2.prototype.createCellOverlays = function(state2) {
  const graph = state2.view.graph;
  const overlays = graph.getCellOverlays(state2.cell);
  let dict = null;
  if (overlays != null) {
    dict = new mxDictionary();
    for (let i = 0; i < overlays.length; i++) {
      let shape = state2.overlays != null ? state2.overlays.remove(overlays[i]) : null;
      if (shape == null) {
        const tmp = new mxImageShape(new mxRectangle(), overlays[i].image.src);
        tmp.dialect = state2.view.graph.dialect;
        tmp.preserveImageAspect = false;
        tmp.overlay = overlays[i];
        this.initializeOverlay(state2, tmp);
        this.installCellOverlayListeners(state2, overlays[i], tmp);
        if (overlays[i].cursor != null) {
          tmp.node.style.cursor = overlays[i].cursor;
        }
        dict.put(overlays[i], tmp);
      } else {
        dict.put(overlays[i], shape);
      }
    }
  }
  if (state2.overlays != null) {
    state2.overlays.visit(function(id, shape) {
      shape.destroy();
    });
  }
  state2.overlays = dict;
};
mxCellRenderer2.prototype.initializeOverlay = function(state2, overlay) {
  overlay.init(state2.view.getOverlayPane());
};
mxCellRenderer2.prototype.installCellOverlayListeners = function(state2, overlay, shape) {
  const graph = state2.view.graph;
  mxEvent2.addListener(shape.node, "click", function(evt) {
    if (graph.isEditing()) {
      graph.stopEditing(!graph.isInvokesStopCellEditing());
    }
    overlay.fireEvent(new mxEventObject2(mxEvent2.CLICK, "event", evt, "cell", state2.cell));
  });
  mxEvent2.addGestureListeners(shape.node, function(evt) {
    mxEvent2.consume(evt);
  }, function(evt) {
    graph.fireMouseEvent(mxEvent2.MOUSE_MOVE, new mxMouseEvent2(evt, state2));
  });
  if (mxClient_default.IS_TOUCH) {
    mxEvent2.addListener(shape.node, "touchend", function(evt) {
      overlay.fireEvent(new mxEventObject2(mxEvent2.CLICK, "event", evt, "cell", state2.cell));
    });
  }
};
mxCellRenderer2.prototype.createControl = function(state2) {
  const graph = state2.view.graph;
  const image = graph.getFoldingImage(state2);
  if (graph.foldingEnabled && image != null) {
    if (state2.control == null) {
      const b = new mxRectangle(0, 0, image.width, image.height);
      state2.control = new mxImageShape(b, image.src);
      state2.control.preserveImageAspect = false;
      state2.control.dialect = graph.dialect;
      this.initControl(state2, state2.control, true, this.createControlClickHandler(state2));
    }
  } else if (state2.control != null) {
    state2.control.destroy();
    state2.control = null;
  }
};
mxCellRenderer2.prototype.createControlClickHandler = function(state2) {
  const graph = state2.view.graph;
  return bind(this, function(evt) {
    if (this.forceControlClickHandler || graph.isEnabled()) {
      const collapse = !graph.isCellCollapsed(state2.cell);
      graph.foldCells(collapse, false, [state2.cell], null, evt);
      mxEvent2.consume(evt);
    }
  });
};
mxCellRenderer2.prototype.initControl = function(state2, control, handleEvents, clickHandler) {
  const graph = state2.view.graph;
  const isForceHtml = graph.isHtmlLabel(state2.cell) && mxClient_default.NO_FO && graph.dialect == mxConstants2.DIALECT_SVG;
  if (isForceHtml) {
    control.dialect = mxConstants2.DIALECT_PREFERHTML;
    control.init(graph.container);
    control.node.style.zIndex = 1;
  } else {
    control.init(state2.view.getOverlayPane());
  }
  const node = control.innerNode || control.node;
  if (clickHandler != null && !mxClient_default.IS_IOS) {
    if (graph.isEnabled()) {
      node.style.cursor = "pointer";
    }
    mxEvent2.addListener(node, "click", clickHandler);
  }
  if (handleEvents) {
    let first = null;
    mxEvent2.addGestureListeners(node, function(evt) {
      first = new mxPoint2(mxEvent2.getClientX(evt), mxEvent2.getClientY(evt));
      graph.fireMouseEvent(mxEvent2.MOUSE_DOWN, new mxMouseEvent2(evt, state2));
      mxEvent2.consume(evt);
    }, function(evt) {
      graph.fireMouseEvent(mxEvent2.MOUSE_MOVE, new mxMouseEvent2(evt, state2));
    }, function(evt) {
      graph.fireMouseEvent(mxEvent2.MOUSE_UP, new mxMouseEvent2(evt, state2));
      mxEvent2.consume(evt);
    });
    if (clickHandler != null && mxClient_default.IS_IOS) {
      node.addEventListener("touchend", function(evt) {
        if (first != null) {
          const tol = graph.tolerance;
          if (Math.abs(first.x - mxEvent2.getClientX(evt)) < tol && Math.abs(first.y - mxEvent2.getClientY(evt)) < tol) {
            clickHandler.call(clickHandler, evt);
            mxEvent2.consume(evt);
          }
        }
      }, true);
    }
  }
  return node;
};
mxCellRenderer2.prototype.isShapeEvent = function(state2, evt) {
  return true;
};
mxCellRenderer2.prototype.isLabelEvent = function(state2, evt) {
  return true;
};
mxCellRenderer2.prototype.installListeners = function(state2) {
  const graph = state2.view.graph;
  const getState = function(evt) {
    let result2 = state2;
    if (graph.dialect != mxConstants2.DIALECT_SVG && mxEvent2.getSource(evt).nodeName == "IMG" || mxClient_default.IS_TOUCH) {
      const x = mxEvent2.getClientX(evt);
      const y = mxEvent2.getClientY(evt);
      const pt = convertPoint(graph.container, x, y);
      result2 = graph.view.getState(graph.getCellAt(pt.x, pt.y));
    }
    return result2;
  };
  mxEvent2.addGestureListeners(state2.shape.node, bind(this, function(evt) {
    if (this.isShapeEvent(state2, evt)) {
      graph.fireMouseEvent(mxEvent2.MOUSE_DOWN, new mxMouseEvent2(evt, state2));
    }
  }), bind(this, function(evt) {
    if (this.isShapeEvent(state2, evt)) {
      graph.fireMouseEvent(mxEvent2.MOUSE_MOVE, new mxMouseEvent2(evt, getState(evt)));
    }
  }), bind(this, function(evt) {
    if (this.isShapeEvent(state2, evt)) {
      graph.fireMouseEvent(mxEvent2.MOUSE_UP, new mxMouseEvent2(evt, getState(evt)));
    }
  }));
  if (graph.nativeDblClickEnabled) {
    mxEvent2.addListener(state2.shape.node, "dblclick", bind(this, function(evt) {
      if (this.isShapeEvent(state2, evt)) {
        graph.dblClick(evt, state2.cell);
        mxEvent2.consume(evt);
      }
    }));
  }
};
mxCellRenderer2.prototype.redrawLabel = function(state2, forced) {
  const graph = state2.view.graph;
  const value = this.getLabelValue(state2);
  const wrapping = graph.isWrapping(state2.cell);
  const clipping = graph.isLabelClipped(state2.cell);
  const isForceHtml = state2.view.graph.isHtmlLabel(state2.cell) || value != null && isNode(value);
  const dialect = isForceHtml ? mxConstants2.DIALECT_STRICTHTML : state2.view.graph.dialect;
  const overflow = state2.style[mxConstants2.STYLE_OVERFLOW] || "visible";
  if (state2.text != null && (state2.text.wrap != wrapping || state2.text.clipped != clipping || state2.text.overflow != overflow || state2.text.dialect != dialect)) {
    state2.text.destroy();
    state2.text = null;
  }
  if (state2.text == null && value != null && (isNode(value) || value.length > 0)) {
    this.createLabel(state2, value);
  } else if (state2.text != null && (value == null || value.length == 0)) {
    state2.text.destroy();
    state2.text = null;
  }
  if (state2.text != null) {
    if (forced) {
      if (state2.text.lastValue != null && this.isTextShapeInvalid(state2, state2.text)) {
        state2.text.lastValue = null;
      }
      state2.text.resetStyles();
      state2.text.apply(state2);
      state2.text.valign = graph.getVerticalAlign(state2);
    }
    const bounds = this.getLabelBounds(state2);
    const nextScale = this.getTextScale(state2);
    this.resolveColor(state2, "color", mxConstants2.STYLE_FONTCOLOR);
    if (forced || state2.text.value != value || state2.text.isWrapping != wrapping || state2.text.overflow != overflow || state2.text.isClipping != clipping || state2.text.scale != nextScale || state2.text.dialect != dialect || state2.text.bounds == null || !state2.text.bounds.equals(bounds)) {
      state2.text.dialect = dialect;
      state2.text.value = value;
      state2.text.bounds = bounds;
      state2.text.scale = nextScale;
      state2.text.wrap = wrapping;
      state2.text.clipped = clipping;
      state2.text.overflow = overflow;
      const vis = state2.text.node.style.visibility;
      this.redrawLabelShape(state2.text);
      state2.text.node.style.visibility = vis;
    }
  }
};
mxCellRenderer2.prototype.isTextShapeInvalid = function(state2, shape) {
  function check(property2, stylename, defaultValue) {
    let result2 = false;
    if (stylename == "spacingTop" || stylename == "spacingRight" || stylename == "spacingBottom" || stylename == "spacingLeft") {
      result2 = parseFloat(shape[property2]) - parseFloat(shape.spacing) != (state2.style[stylename] || defaultValue);
    } else {
      result2 = shape[property2] != (state2.style[stylename] || defaultValue);
    }
    return result2;
  }
  ;
  return check("fontStyle", mxConstants2.STYLE_FONTSTYLE, mxConstants2.DEFAULT_FONTSTYLE) || check("family", mxConstants2.STYLE_FONTFAMILY, mxConstants2.DEFAULT_FONTFAMILY) || check("size", mxConstants2.STYLE_FONTSIZE, mxConstants2.DEFAULT_FONTSIZE) || check("color", mxConstants2.STYLE_FONTCOLOR, "black") || check("align", mxConstants2.STYLE_ALIGN, "") || check("valign", mxConstants2.STYLE_VERTICAL_ALIGN, "") || check("spacing", mxConstants2.STYLE_SPACING, 2) || check("spacingTop", mxConstants2.STYLE_SPACING_TOP, 0) || check("spacingRight", mxConstants2.STYLE_SPACING_RIGHT, 0) || check("spacingBottom", mxConstants2.STYLE_SPACING_BOTTOM, 0) || check("spacingLeft", mxConstants2.STYLE_SPACING_LEFT, 0) || check("horizontal", mxConstants2.STYLE_HORIZONTAL, true) || check("background", mxConstants2.STYLE_LABEL_BACKGROUNDCOLOR) || check("border", mxConstants2.STYLE_LABEL_BORDERCOLOR) || check("opacity", mxConstants2.STYLE_TEXT_OPACITY, 100) || check("textDirection", mxConstants2.STYLE_TEXT_DIRECTION, mxConstants2.DEFAULT_TEXT_DIRECTION);
};
mxCellRenderer2.prototype.redrawLabelShape = function(shape) {
  shape.redraw();
};
mxCellRenderer2.prototype.getTextScale = function(state2) {
  return state2.view.scale;
};
mxCellRenderer2.prototype.getLabelBounds = function(state2) {
  const graph = state2.view.graph;
  const scale = state2.view.scale;
  const isEdge = graph.getModel().isEdge(state2.cell);
  let bounds = new mxRectangle(state2.absoluteOffset.x, state2.absoluteOffset.y);
  if (isEdge) {
    const spacing = state2.text.getSpacing();
    bounds.x += spacing.x * scale;
    bounds.y += spacing.y * scale;
    const geo = graph.getCellGeometry(state2.cell);
    if (geo != null) {
      bounds.width = Math.max(0, geo.width * scale);
      bounds.height = Math.max(0, geo.height * scale);
    }
  } else {
    if (state2.text.isPaintBoundsInverted()) {
      let tmp = bounds.x;
      bounds.x = bounds.y;
      bounds.y = tmp;
    }
    bounds.x += state2.x;
    bounds.y += state2.y;
    bounds.width = Math.max(1, state2.width);
    bounds.height = Math.max(1, state2.height);
  }
  if (state2.text.isPaintBoundsInverted()) {
    const t = (state2.width - state2.height) / 2;
    bounds.x += t;
    bounds.y -= t;
    let tmp = bounds.width;
    bounds.width = bounds.height;
    bounds.height = tmp;
  }
  if (state2.shape != null) {
    const hpos = getValue(state2.style, mxConstants2.STYLE_LABEL_POSITION, mxConstants2.ALIGN_CENTER);
    const vpos = getValue(state2.style, mxConstants2.STYLE_VERTICAL_LABEL_POSITION, mxConstants2.ALIGN_MIDDLE);
    if (hpos == mxConstants2.ALIGN_CENTER && vpos == mxConstants2.ALIGN_MIDDLE) {
      bounds = state2.shape.getLabelBounds(bounds);
    }
  }
  const lw = getValue(state2.style, mxConstants2.STYLE_LABEL_WIDTH, null);
  if (lw != null) {
    bounds.width = parseFloat(lw) * scale;
  }
  if (!isEdge) {
    this.rotateLabelBounds(state2, bounds);
  }
  return bounds;
};
mxCellRenderer2.prototype.rotateLabelBounds = function(state2, bounds) {
  bounds.y -= state2.text.margin.y * bounds.height;
  bounds.x -= state2.text.margin.x * bounds.width;
  if (!this.legacySpacing || state2.style[mxConstants2.STYLE_OVERFLOW] != "fill" && state2.style[mxConstants2.STYLE_OVERFLOW] != "width") {
    const s = state2.view.scale;
    const spacing = state2.text.getSpacing();
    bounds.x += spacing.x * s;
    bounds.y += spacing.y * s;
    const hpos = getValue(state2.style, mxConstants2.STYLE_LABEL_POSITION, mxConstants2.ALIGN_CENTER);
    const vpos = getValue(state2.style, mxConstants2.STYLE_VERTICAL_LABEL_POSITION, mxConstants2.ALIGN_MIDDLE);
    const lw = getValue(state2.style, mxConstants2.STYLE_LABEL_WIDTH, null);
    bounds.width = Math.max(0, bounds.width - (hpos == mxConstants2.ALIGN_CENTER && lw == null ? state2.text.spacingLeft * s + state2.text.spacingRight * s : 0));
    bounds.height = Math.max(0, bounds.height - (vpos == mxConstants2.ALIGN_MIDDLE ? state2.text.spacingTop * s + state2.text.spacingBottom * s : 0));
  }
  const theta = state2.text.getTextRotation();
  if (theta != 0 && state2 != null && state2.view.graph.model.isVertex(state2.cell)) {
    const cx = state2.getCenterX();
    const cy = state2.getCenterY();
    if (bounds.x != cx || bounds.y != cy) {
      const rad = theta * (Math.PI / 180);
      const pt = getRotatedPoint(new mxPoint2(bounds.x, bounds.y), Math.cos(rad), Math.sin(rad), new mxPoint2(cx, cy));
      bounds.x = pt.x;
      bounds.y = pt.y;
    }
  }
};
mxCellRenderer2.prototype.redrawCellOverlays = function(state2, forced) {
  this.createCellOverlays(state2);
  if (state2.overlays != null) {
    const rot = mod(getValue(state2.style, mxConstants2.STYLE_ROTATION, 0), 90);
    const rad = toRadians(rot);
    const cos = Math.cos(rad);
    const sin = Math.sin(rad);
    state2.overlays.visit(function(id, shape) {
      const bounds = shape.overlay.getBounds(state2);
      if (!state2.view.graph.getModel().isEdge(state2.cell)) {
        if (state2.shape != null && rot != 0) {
          let cx = bounds.getCenterX();
          let cy = bounds.getCenterY();
          const point = getRotatedPoint(new mxPoint2(cx, cy), cos, sin, new mxPoint2(state2.getCenterX(), state2.getCenterY()));
          cx = point.x;
          cy = point.y;
          bounds.x = Math.round(cx - bounds.width / 2);
          bounds.y = Math.round(cy - bounds.height / 2);
        }
      }
      if (forced || shape.bounds == null || shape.scale != state2.view.scale || !shape.bounds.equals(bounds)) {
        shape.bounds = bounds;
        shape.scale = state2.view.scale;
        shape.redraw();
      }
    });
  }
};
mxCellRenderer2.prototype.redrawControl = function(state2, forced) {
  const image = state2.view.graph.getFoldingImage(state2);
  if (state2.control != null && image != null) {
    const bounds = this.getControlBounds(state2, image.width, image.height);
    const r = this.legacyControlPosition ? getValue(state2.style, mxConstants2.STYLE_ROTATION, 0) : state2.shape.getTextRotation();
    const s = state2.view.scale;
    if (forced || state2.control.scale != s || !state2.control.bounds.equals(bounds) || state2.control.rotation != r) {
      state2.control.rotation = r;
      state2.control.bounds = bounds;
      state2.control.scale = s;
      state2.control.redraw();
    }
  }
};
mxCellRenderer2.prototype.getControlBounds = function(state2, w2, h2) {
  if (state2.control != null) {
    const s = state2.view.scale;
    let cx = state2.getCenterX();
    let cy = state2.getCenterY();
    if (!state2.view.graph.getModel().isEdge(state2.cell)) {
      cx = state2.x + w2 * s;
      cy = state2.y + h2 * s;
      if (state2.shape != null) {
        let rot = state2.shape.getShapeRotation();
        if (this.legacyControlPosition) {
          rot = getValue(state2.style, mxConstants2.STYLE_ROTATION, 0);
        } else {
          if (state2.shape.isPaintBoundsInverted()) {
            const t = (state2.width - state2.height) / 2;
            cx += t;
            cy -= t;
          }
        }
        if (rot != 0) {
          const rad = toRadians(rot);
          const cos = Math.cos(rad);
          const sin = Math.sin(rad);
          const point = getRotatedPoint(new mxPoint2(cx, cy), cos, sin, new mxPoint2(state2.getCenterX(), state2.getCenterY()));
          cx = point.x;
          cy = point.y;
        }
      }
    }
    return state2.view.graph.getModel().isEdge(state2.cell) ? new mxRectangle(Math.round(cx - w2 / 2 * s), Math.round(cy - h2 / 2 * s), Math.round(w2 * s), Math.round(h2 * s)) : new mxRectangle(Math.round(cx - w2 / 2 * s), Math.round(cy - h2 / 2 * s), Math.round(w2 * s), Math.round(h2 * s));
  }
  return null;
};
mxCellRenderer2.prototype.insertStateAfter = function(state2, node, htmlNode) {
  const shapes = this.getShapesForState(state2);
  for (let i = 0; i < shapes.length; i++) {
    if (shapes[i] != null && shapes[i].node != null) {
      const html = shapes[i].node.parentNode != state2.view.getDrawPane() && shapes[i].node.parentNode != state2.view.getOverlayPane();
      const temp2 = html ? htmlNode : node;
      if (temp2 != null && temp2.nextSibling != shapes[i].node) {
        if (temp2.nextSibling == null) {
          temp2.parentNode.appendChild(shapes[i].node);
        } else {
          temp2.parentNode.insertBefore(shapes[i].node, temp2.nextSibling);
        }
      } else if (temp2 == null) {
        if (shapes[i].node.parentNode == state2.view.graph.container) {
          let canvas = state2.view.canvas;
          while (canvas != null && canvas.parentNode != state2.view.graph.container) {
            canvas = canvas.parentNode;
          }
          if (canvas != null && canvas.nextSibling != null) {
            if (canvas.nextSibling != shapes[i].node) {
              shapes[i].node.parentNode.insertBefore(shapes[i].node, canvas.nextSibling);
            }
          } else {
            shapes[i].node.parentNode.appendChild(shapes[i].node);
          }
        } else if (shapes[i].node.parentNode != null && shapes[i].node.parentNode.firstChild != null && shapes[i].node.parentNode.firstChild != shapes[i].node) {
          shapes[i].node.parentNode.insertBefore(shapes[i].node, shapes[i].node.parentNode.firstChild);
        }
      }
      if (html) {
        htmlNode = shapes[i].node;
      } else {
        node = shapes[i].node;
      }
    }
  }
  return [node, htmlNode];
};
mxCellRenderer2.prototype.getShapesForState = function(state2) {
  return [state2.shape, state2.text, state2.control];
};
mxCellRenderer2.prototype.redraw = function(state2, force, rendering) {
  const shapeChanged = this.redrawShape(state2, force, rendering);
  if (state2.shape != null && (rendering == null || rendering)) {
    this.redrawLabel(state2, shapeChanged);
    this.redrawCellOverlays(state2, shapeChanged);
    this.redrawControl(state2, shapeChanged);
  }
};
mxCellRenderer2.prototype.redrawShape = function(state2, force, rendering) {
  const model = state2.view.graph.model;
  let shapeChanged = false;
  if (state2.shape != null && state2.shape.style != null && state2.style != null && state2.shape.style[mxConstants2.STYLE_SHAPE] != state2.style[mxConstants2.STYLE_SHAPE]) {
    state2.shape.destroy();
    state2.shape = null;
  }
  if (state2.shape == null && state2.view.graph.container != null && state2.cell != state2.view.currentRoot && (model.isVertex(state2.cell) || model.isEdge(state2.cell))) {
    state2.shape = this.createShape(state2);
    if (state2.shape != null) {
      state2.shape.minSvgStrokeWidth = this.minSvgStrokeWidth;
      state2.shape.antiAlias = this.antiAlias;
      this.createIndicatorShape(state2);
      this.initializeShape(state2);
      this.createCellOverlays(state2);
      this.installListeners(state2);
      state2.view.graph.selectionCellsHandler.updateHandler(state2);
    }
  } else if (!force && state2.shape != null && (!equalEntries(state2.shape.style, state2.style) || this.checkPlaceholderStyles(state2))) {
    state2.shape.resetStyles();
    this.configureShape(state2);
    state2.view.graph.selectionCellsHandler.updateHandler(state2);
    force = true;
  }
  if (state2.shape != null && state2.shape.indicatorShape != this.getShape(state2.view.graph.getIndicatorShape(state2))) {
    if (state2.shape.indicator != null) {
      state2.shape.indicator.destroy();
      state2.shape.indicator = null;
    }
    this.createIndicatorShape(state2);
    if (state2.shape.indicatorShape != null) {
      state2.shape.indicator = new state2.shape.indicatorShape();
      state2.shape.indicator.dialect = state2.shape.dialect;
      state2.shape.indicator.init(state2.node);
      force = true;
    }
  }
  if (state2.shape != null) {
    this.createControl(state2);
    if (force || this.isShapeInvalid(state2, state2.shape)) {
      if (state2.absolutePoints != null) {
        state2.shape.points = state2.absolutePoints.slice();
        state2.shape.bounds = null;
      } else {
        state2.shape.points = null;
        state2.shape.bounds = new mxRectangle(state2.x, state2.y, state2.width, state2.height);
      }
      state2.shape.scale = state2.view.scale;
      if (rendering == null || rendering) {
        this.doRedrawShape(state2);
      } else {
        state2.shape.updateBoundingBox();
      }
      shapeChanged = true;
    }
  }
  return shapeChanged;
};
mxCellRenderer2.prototype.doRedrawShape = function(state2) {
  state2.shape.redraw();
};
mxCellRenderer2.prototype.isShapeInvalid = function(state2, shape) {
  return shape.bounds == null || shape.scale != state2.view.scale || state2.absolutePoints == null && !shape.bounds.equals(state2) || state2.absolutePoints != null && !equalPoints(shape.points, state2.absolutePoints);
};
mxCellRenderer2.prototype.destroy = function(state2) {
  if (state2.shape != null) {
    if (state2.text != null) {
      state2.text.destroy();
      state2.text = null;
    }
    if (state2.overlays != null) {
      state2.overlays.visit(function(id, shape) {
        shape.destroy();
      });
      state2.overlays = null;
    }
    if (state2.control != null) {
      state2.control.destroy();
      state2.control = null;
    }
    state2.shape.destroy();
    state2.shape = null;
  }
};

// js/graph/mxSelectionChange.js
var mxSelectionChange = function(selectionModel, added, removed) {
  this.selectionModel = selectionModel;
  this.added = added != null ? added.slice() : null;
  this.removed = removed != null ? removed.slice() : null;
};
mxSelectionChange.prototype.execute = function() {
  const t0 = mxLog.enter("mxSelectionChange.execute");
  window.status = mxResources2.get(this.selectionModel.updatingSelectionResource) || this.selectionModel.updatingSelectionResource;
  if (this.removed != null) {
    for (let i = 0; i < this.removed.length; i++) {
      this.selectionModel.cellRemoved(this.removed[i]);
    }
  }
  if (this.added != null) {
    for (let i = 0; i < this.added.length; i++) {
      this.selectionModel.cellAdded(this.added[i]);
    }
  }
  let tmp = this.added;
  this.added = this.removed;
  this.removed = tmp;
  window.status = mxResources2.get(this.selectionModel.doneResource) || this.selectionModel.doneResource;
  mxLog.leave("mxSelectionChange.execute", t0);
  this.selectionModel.fireEvent(new mxEventObject2(mxEvent2.CHANGE, "added", this.added, "removed", this.removed));
};

// js/graph/mxGraphSelectionModel.js
var mxGraphSelectionModel = function(graph) {
  this.graph = graph;
  this.cells = [];
};
mxGraphSelectionModel.prototype = new mxEventSource();
mxGraphSelectionModel.prototype.constructor = mxGraphSelectionModel;
mxGraphSelectionModel.prototype.doneResource = mxClient_default.language !== "none" ? "done" : "";
mxGraphSelectionModel.prototype.updatingSelectionResource = mxClient_default.language !== "none" ? "updatingSelection" : "";
mxGraphSelectionModel.prototype.graph = null;
mxGraphSelectionModel.prototype.singleSelection = false;
mxGraphSelectionModel.prototype.isSingleSelection = function() {
  return this.singleSelection;
};
mxGraphSelectionModel.prototype.setSingleSelection = function(singleSelection) {
  this.singleSelection = singleSelection;
};
mxGraphSelectionModel.prototype.isSelected = function(cell2) {
  if (cell2 != null) {
    return indexOf(this.cells, cell2) >= 0;
  }
  return false;
};
mxGraphSelectionModel.prototype.isEmpty = function() {
  return this.cells.length === 0;
};
mxGraphSelectionModel.prototype.clear = function() {
  this.changeSelection(null, this.cells);
};
mxGraphSelectionModel.prototype.setCell = function(cell2) {
  if (cell2 != null) {
    this.setCells([cell2]);
  }
};
mxGraphSelectionModel.prototype.setCells = function(cells) {
  if (cells != null) {
    if (this.singleSelection) {
      cells = [this.getFirstSelectableCell(cells)];
    }
    const tmp = [];
    for (let i = 0; i < cells.length; i++) {
      if (this.graph.isCellSelectable(cells[i])) {
        tmp.push(cells[i]);
      }
    }
    this.changeSelection(tmp, this.cells);
  }
};
mxGraphSelectionModel.prototype.getFirstSelectableCell = function(cells) {
  if (cells != null) {
    for (let i = 0; i < cells.length; i++) {
      if (this.graph.isCellSelectable(cells[i])) {
        return cells[i];
      }
    }
  }
  return null;
};
mxGraphSelectionModel.prototype.addCell = function(cell2) {
  if (cell2 != null) {
    this.addCells([cell2]);
  }
};
mxGraphSelectionModel.prototype.addCells = function(cells) {
  if (cells != null) {
    let remove2 = null;
    if (this.singleSelection) {
      remove2 = this.cells;
      cells = [this.getFirstSelectableCell(cells)];
    }
    const tmp = [];
    for (let i = 0; i < cells.length; i++) {
      if (!this.isSelected(cells[i]) && this.graph.isCellSelectable(cells[i])) {
        tmp.push(cells[i]);
      }
    }
    this.changeSelection(tmp, remove2);
  }
};
mxGraphSelectionModel.prototype.removeCell = function(cell2) {
  if (cell2 != null) {
    this.removeCells([cell2]);
  }
};
mxGraphSelectionModel.prototype.removeCells = function(cells) {
  if (cells != null) {
    const tmp = [];
    for (let i = 0; i < cells.length; i++) {
      if (this.isSelected(cells[i])) {
        tmp.push(cells[i]);
      }
    }
    this.changeSelection(null, tmp);
  }
};
mxGraphSelectionModel.prototype.changeSelection = function(added, removed) {
  if (added != null && added.length > 0 && added[0] != null || removed != null && removed.length > 0 && removed[0] != null) {
    const change = new mxSelectionChange(this, added, removed);
    change.execute();
    const edit = new mxUndoableEdit(this, false);
    edit.add(change);
    this.fireEvent(new mxEventObject2(mxEvent2.UNDO, "edit", edit));
  }
};
mxGraphSelectionModel.prototype.cellAdded = function(cell2) {
  if (cell2 != null && !this.isSelected(cell2)) {
    this.cells.push(cell2);
  }
};
mxGraphSelectionModel.prototype.cellRemoved = function(cell2) {
  if (cell2 != null) {
    const index = indexOf(this.cells, cell2);
    if (index >= 0) {
      this.cells.splice(index, 1);
    }
  }
};

// js/graph/mxCurrentRootChange.js
function mxCurrentRootChange(view, root) {
  this.view = view;
  this.root = root;
  this.previous = root;
  this.isUp = root == null;
  if (!this.isUp) {
    let tmp = this.view.currentRoot;
    const model = this.view.graph.getModel();
    while (tmp != null) {
      if (tmp == root) {
        this.isUp = true;
        break;
      }
      tmp = model.getParent(tmp);
    }
  }
}
mxCurrentRootChange.prototype.execute = function() {
  let tmp = this.view.currentRoot;
  this.view.currentRoot = this.previous;
  this.previous = tmp;
  const translate = this.view.graph.getTranslateForRoot(this.view.currentRoot);
  if (translate != null) {
    this.view.translate = new mxPoint2(-translate.x, -translate.y);
  }
  if (this.isUp) {
    this.view.clear(this.view.currentRoot, true);
    this.view.validate();
  } else {
    this.view.refresh();
  }
  const name = this.isUp ? mxEvent2.UP : mxEvent2.DOWN;
  this.view.fireEvent(new mxEventObject2(name, "root", this.view.currentRoot, "previous", this.previous));
  this.isUp = !this.isUp;
};

// js/graph/mxPerimeter.js
var RectanglePerimeter = function(bounds, vertex, next, orthogonal) {
  let cx = bounds.getCenterX();
  let cy = bounds.getCenterY();
  let dx = next.x - cx;
  let dy = next.y - cy;
  let alpha = Math.atan2(dy, dx);
  const p = new mxPoint2(0, 0);
  const pi = Math.PI;
  const pi2 = Math.PI / 2;
  const beta = pi2 - alpha;
  const t = Math.atan2(bounds.height, bounds.width);
  if (alpha < -pi + t || alpha > pi - t) {
    p.x = bounds.x;
    p.y = cy - bounds.width * Math.tan(alpha) / 2;
  } else if (alpha < -t) {
    p.y = bounds.y;
    p.x = cx - bounds.height * Math.tan(beta) / 2;
  } else if (alpha < t) {
    p.x = bounds.x + bounds.width;
    p.y = cy + bounds.width * Math.tan(alpha) / 2;
  } else {
    p.y = bounds.y + bounds.height;
    p.x = cx + bounds.height * Math.tan(beta) / 2;
  }
  if (orthogonal) {
    if (next.x >= bounds.x && next.x <= bounds.x + bounds.width) {
      p.x = next.x;
    } else if (next.y >= bounds.y && next.y <= bounds.y + bounds.height) {
      p.y = next.y;
    }
    if (next.x < bounds.x) {
      p.x = bounds.x;
    } else if (next.x > bounds.x + bounds.width) {
      p.x = bounds.x + bounds.width;
    }
    if (next.y < bounds.y) {
      p.y = bounds.y;
    } else if (next.y > bounds.y + bounds.height) {
      p.y = bounds.y + bounds.height;
    }
  }
  return p;
};
var EllipsePerimeter = function(bounds, vertex, next, orthogonal) {
  const x = bounds.x;
  const y = bounds.y;
  const a = bounds.width / 2;
  const b = bounds.height / 2;
  let cx = x + a;
  let cy = y + b;
  const px = next.x;
  const py = next.y;
  const dx = parseInt(px - cx);
  const dy = parseInt(py - cy);
  if (dx == 0 && dy != 0) {
    return new mxPoint2(cx, cy + b * dy / Math.abs(dy));
  } else if (dx == 0 && dy == 0) {
    return new mxPoint2(px, py);
  }
  if (orthogonal) {
    if (py >= y && py <= y + bounds.height) {
      const ty = py - cy;
      let tx = Math.sqrt(a * a * (1 - ty * ty / (b * b))) || 0;
      if (px <= x) {
        tx = -tx;
      }
      return new mxPoint2(cx + tx, py);
    }
    if (px >= x && px <= x + bounds.width) {
      const tx = px - cx;
      let ty = Math.sqrt(b * b * (1 - tx * tx / (a * a))) || 0;
      if (py <= y) {
        ty = -ty;
      }
      return new mxPoint2(px, cy + ty);
    }
  }
  const d = dy / dx;
  const h2 = cy - d * cx;
  const e = a * a * d * d + b * b;
  const f = -2 * cx * e;
  const g = a * a * d * d * cx * cx + b * b * cx * cx - a * a * b * b;
  const det = Math.sqrt(f * f - 4 * e * g);
  const xout1 = (-f + det) / (2 * e);
  const xout2 = (-f - det) / (2 * e);
  const yout1 = d * xout1 + h2;
  const yout2 = d * xout2 + h2;
  const dist1 = Math.sqrt(Math.pow(xout1 - px, 2) + Math.pow(yout1 - py, 2));
  const dist2 = Math.sqrt(Math.pow(xout2 - px, 2) + Math.pow(yout2 - py, 2));
  let xout = 0;
  let yout = 0;
  if (dist1 < dist2) {
    xout = xout1;
    yout = yout1;
  } else {
    xout = xout2;
    yout = yout2;
  }
  return new mxPoint2(xout, yout);
};
var RhombusPerimeter = function(bounds, vertex, next, orthogonal) {
  const x = bounds.x;
  const y = bounds.y;
  const w2 = bounds.width;
  const h2 = bounds.height;
  let cx = x + w2 / 2;
  let cy = y + h2 / 2;
  const px = next.x;
  const py = next.y;
  if (cx == px) {
    if (cy > py) {
      return new mxPoint2(cx, y);
    } else {
      return new mxPoint2(cx, y + h2);
    }
  } else if (cy == py) {
    if (cx > px) {
      return new mxPoint2(x, cy);
    } else {
      return new mxPoint2(x + w2, cy);
    }
  }
  let tx = cx;
  let ty = cy;
  if (orthogonal) {
    if (px >= x && px <= x + w2) {
      tx = px;
    } else if (py >= y && py <= y + h2) {
      ty = py;
    }
  }
  if (px < cx) {
    if (py < cy) {
      return intersection(px, py, tx, ty, cx, y, x, cy);
    } else {
      return intersection(px, py, tx, ty, cx, y + h2, x, cy);
    }
  } else if (py < cy) {
    return intersection(px, py, tx, ty, cx, y, x + w2, cy);
  } else {
    return intersection(px, py, tx, ty, cx, y + h2, x + w2, cy);
  }
};
var TrianglePerimeter = function(bounds, vertex, next, orthogonal) {
  const direction = vertex != null ? vertex.style[mxConstants2.STYLE_DIRECTION] : null;
  const vertical = direction == mxConstants2.DIRECTION_NORTH || direction == mxConstants2.DIRECTION_SOUTH;
  const x = bounds.x;
  const y = bounds.y;
  const w2 = bounds.width;
  const h2 = bounds.height;
  let cx = x + w2 / 2;
  let cy = y + h2 / 2;
  let start = new mxPoint2(x, y);
  let corner = new mxPoint2(x + w2, cy);
  let end = new mxPoint2(x, y + h2);
  if (direction == mxConstants2.DIRECTION_NORTH) {
    start = end;
    corner = new mxPoint2(cx, y);
    end = new mxPoint2(x + w2, y + h2);
  } else if (direction == mxConstants2.DIRECTION_SOUTH) {
    corner = new mxPoint2(cx, y + h2);
    end = new mxPoint2(x + w2, y);
  } else if (direction == mxConstants2.DIRECTION_WEST) {
    start = new mxPoint2(x + w2, y);
    corner = new mxPoint2(x, cy);
    end = new mxPoint2(x + w2, y + h2);
  }
  let dx = next.x - cx;
  let dy = next.y - cy;
  const alpha = vertical ? Math.atan2(dx, dy) : Math.atan2(dy, dx);
  const t = vertical ? Math.atan2(w2, h2) : Math.atan2(h2, w2);
  let base = false;
  if (direction == mxConstants2.DIRECTION_NORTH || direction == mxConstants2.DIRECTION_WEST) {
    base = alpha > -t && alpha < t;
  } else {
    base = alpha < -Math.PI + t || alpha > Math.PI - t;
  }
  let result2 = null;
  if (base) {
    if (orthogonal && (vertical && next.x >= start.x && next.x <= end.x || !vertical && next.y >= start.y && next.y <= end.y)) {
      if (vertical) {
        result2 = new mxPoint2(next.x, start.y);
      } else {
        result2 = new mxPoint2(start.x, next.y);
      }
    } else {
      if (direction == mxConstants2.DIRECTION_NORTH) {
        result2 = new mxPoint2(x + w2 / 2 + h2 * Math.tan(alpha) / 2, y + h2);
      } else if (direction == mxConstants2.DIRECTION_SOUTH) {
        result2 = new mxPoint2(x + w2 / 2 - h2 * Math.tan(alpha) / 2, y);
      } else if (direction == mxConstants2.DIRECTION_WEST) {
        result2 = new mxPoint2(x + w2, y + h2 / 2 + w2 * Math.tan(alpha) / 2);
      } else {
        result2 = new mxPoint2(x, y + h2 / 2 - w2 * Math.tan(alpha) / 2);
      }
    }
  } else {
    if (orthogonal) {
      const pt = new mxPoint2(cx, cy);
      if (next.y >= y && next.y <= y + h2) {
        pt.x = vertical ? cx : direction == mxConstants2.DIRECTION_WEST ? x + w2 : x;
        pt.y = next.y;
      } else if (next.x >= x && next.x <= x + w2) {
        pt.x = next.x;
        pt.y = !vertical ? cy : direction == mxConstants2.DIRECTION_NORTH ? y + h2 : y;
      }
      dx = next.x - pt.x;
      dy = next.y - pt.y;
      cx = pt.x;
      cy = pt.y;
    }
    if (vertical && next.x <= x + w2 / 2 || !vertical && next.y <= y + h2 / 2) {
      result2 = intersection(next.x, next.y, cx, cy, start.x, start.y, corner.x, corner.y);
    } else {
      result2 = intersection(next.x, next.y, cx, cy, corner.x, corner.y, end.x, end.y);
    }
  }
  if (result2 == null) {
    result2 = new mxPoint2(cx, cy);
  }
  return result2;
};
var HexagonPerimeter = function(bounds, vertex, next, orthogonal) {
  const x = bounds.x;
  const y = bounds.y;
  const w2 = bounds.width;
  const h2 = bounds.height;
  let cx = bounds.getCenterX();
  let cy = bounds.getCenterY();
  const px = next.x;
  const py = next.y;
  const dx = px - cx;
  const dy = py - cy;
  const alpha = -Math.atan2(dy, dx);
  const pi = Math.PI;
  const pi2 = Math.PI / 2;
  let result2 = new mxPoint2(cx, cy);
  const direction = vertex != null ? getValue(vertex.style, mxConstants2.STYLE_DIRECTION, mxConstants2.DIRECTION_EAST) : mxConstants2.DIRECTION_EAST;
  const vertical = direction == mxConstants2.DIRECTION_NORTH || direction == mxConstants2.DIRECTION_SOUTH;
  let a = new mxPoint2();
  let b = new mxPoint2();
  if (px < x && py < y || px < x && py > y + h2 || px > x + w2 && py < y || px > x + w2 && py > y + h2) {
    orthogonal = false;
  }
  if (orthogonal) {
    if (vertical) {
      if (px == cx) {
        if (py <= y) {
          return new mxPoint2(cx, y);
        } else if (py >= y + h2) {
          return new mxPoint2(cx, y + h2);
        }
      } else if (px < x) {
        if (py == y + h2 / 4) {
          return new mxPoint2(x, y + h2 / 4);
        } else if (py == y + 3 * h2 / 4) {
          return new mxPoint2(x, y + 3 * h2 / 4);
        }
      } else if (px > x + w2) {
        if (py == y + h2 / 4) {
          return new mxPoint2(x + w2, y + h2 / 4);
        } else if (py == y + 3 * h2 / 4) {
          return new mxPoint2(x + w2, y + 3 * h2 / 4);
        }
      } else if (px == x) {
        if (py < cy) {
          return new mxPoint2(x, y + h2 / 4);
        } else if (py > cy) {
          return new mxPoint2(x, y + 3 * h2 / 4);
        }
      } else if (px == x + w2) {
        if (py < cy) {
          return new mxPoint2(x + w2, y + h2 / 4);
        } else if (py > cy) {
          return new mxPoint2(x + w2, y + 3 * h2 / 4);
        }
      }
      if (py == y) {
        return new mxPoint2(cx, y);
      } else if (py == y + h2) {
        return new mxPoint2(cx, y + h2);
      }
      if (px < cx) {
        if (py > y + h2 / 4 && py < y + 3 * h2 / 4) {
          a = new mxPoint2(x, y);
          b = new mxPoint2(x, y + h2);
        } else if (py < y + h2 / 4) {
          a = new mxPoint2(x - Math.floor(0.5 * w2), y + Math.floor(0.5 * h2));
          b = new mxPoint2(x + w2, y - Math.floor(0.25 * h2));
        } else if (py > y + 3 * h2 / 4) {
          a = new mxPoint2(x - Math.floor(0.5 * w2), y + Math.floor(0.5 * h2));
          b = new mxPoint2(x + w2, y + Math.floor(1.25 * h2));
        }
      } else if (px > cx) {
        if (py > y + h2 / 4 && py < y + 3 * h2 / 4) {
          a = new mxPoint2(x + w2, y);
          b = new mxPoint2(x + w2, y + h2);
        } else if (py < y + h2 / 4) {
          a = new mxPoint2(x, y - Math.floor(0.25 * h2));
          b = new mxPoint2(x + Math.floor(1.5 * w2), y + Math.floor(0.5 * h2));
        } else if (py > y + 3 * h2 / 4) {
          a = new mxPoint2(x + Math.floor(1.5 * w2), y + Math.floor(0.5 * h2));
          b = new mxPoint2(x, y + Math.floor(1.25 * h2));
        }
      }
    } else {
      if (py == cy) {
        if (px <= x) {
          return new mxPoint2(x, y + h2 / 2);
        } else if (px >= x + w2) {
          return new mxPoint2(x + w2, y + h2 / 2);
        }
      } else if (py < y) {
        if (px == x + w2 / 4) {
          return new mxPoint2(x + w2 / 4, y);
        } else if (px == x + 3 * w2 / 4) {
          return new mxPoint2(x + 3 * w2 / 4, y);
        }
      } else if (py > y + h2) {
        if (px == x + w2 / 4) {
          return new mxPoint2(x + w2 / 4, y + h2);
        } else if (px == x + 3 * w2 / 4) {
          return new mxPoint2(x + 3 * w2 / 4, y + h2);
        }
      } else if (py == y) {
        if (px < cx) {
          return new mxPoint2(x + w2 / 4, y);
        } else if (px > cx) {
          return new mxPoint2(x + 3 * w2 / 4, y);
        }
      } else if (py == y + h2) {
        if (px < cx) {
          return new mxPoint2(x + w2 / 4, y + h2);
        } else if (py > cy) {
          return new mxPoint2(x + 3 * w2 / 4, y + h2);
        }
      }
      if (px == x) {
        return new mxPoint2(x, cy);
      } else if (px == x + w2) {
        return new mxPoint2(x + w2, cy);
      }
      if (py < cy) {
        if (px > x + w2 / 4 && px < x + 3 * w2 / 4) {
          a = new mxPoint2(x, y);
          b = new mxPoint2(x + w2, y);
        } else if (px < x + w2 / 4) {
          a = new mxPoint2(x - Math.floor(0.25 * w2), y + h2);
          b = new mxPoint2(x + Math.floor(0.5 * w2), y - Math.floor(0.5 * h2));
        } else if (px > x + 3 * w2 / 4) {
          a = new mxPoint2(x + Math.floor(0.5 * w2), y - Math.floor(0.5 * h2));
          b = new mxPoint2(x + Math.floor(1.25 * w2), y + h2);
        }
      } else if (py > cy) {
        if (px > x + w2 / 4 && px < x + 3 * w2 / 4) {
          a = new mxPoint2(x, y + h2);
          b = new mxPoint2(x + w2, y + h2);
        } else if (px < x + w2 / 4) {
          a = new mxPoint2(x - Math.floor(0.25 * w2), y);
          b = new mxPoint2(x + Math.floor(0.5 * w2), y + Math.floor(1.5 * h2));
        } else if (px > x + 3 * w2 / 4) {
          a = new mxPoint2(x + Math.floor(0.5 * w2), y + Math.floor(1.5 * h2));
          b = new mxPoint2(x + Math.floor(1.25 * w2), y);
        }
      }
    }
    let tx = cx;
    let ty = cy;
    if (px >= x && px <= x + w2) {
      tx = px;
      if (py < cy) {
        ty = y + h2;
      } else {
        ty = y;
      }
    } else if (py >= y && py <= y + h2) {
      ty = py;
      if (px < cx) {
        tx = x + w2;
      } else {
        tx = x;
      }
    }
    result2 = intersection(tx, ty, next.x, next.y, a.x, a.y, b.x, b.y);
  } else {
    if (vertical) {
      const beta = Math.atan2(h2 / 4, w2 / 2);
      if (alpha == beta) {
        return new mxPoint2(x + w2, y + Math.floor(0.25 * h2));
      } else if (alpha == pi2) {
        return new mxPoint2(x + Math.floor(0.5 * w2), y);
      } else if (alpha == pi - beta) {
        return new mxPoint2(x, y + Math.floor(0.25 * h2));
      } else if (alpha == -beta) {
        return new mxPoint2(x + w2, y + Math.floor(0.75 * h2));
      } else if (alpha == -pi2) {
        return new mxPoint2(x + Math.floor(0.5 * w2), y + h2);
      } else if (alpha == -pi + beta) {
        return new mxPoint2(x, y + Math.floor(0.75 * h2));
      }
      if (alpha < beta && alpha > -beta) {
        a = new mxPoint2(x + w2, y);
        b = new mxPoint2(x + w2, y + h2);
      } else if (alpha > beta && alpha < pi2) {
        a = new mxPoint2(x, y - Math.floor(0.25 * h2));
        b = new mxPoint2(x + Math.floor(1.5 * w2), y + Math.floor(0.5 * h2));
      } else if (alpha > pi2 && alpha < pi - beta) {
        a = new mxPoint2(x - Math.floor(0.5 * w2), y + Math.floor(0.5 * h2));
        b = new mxPoint2(x + w2, y - Math.floor(0.25 * h2));
      } else if (alpha > pi - beta && alpha <= pi || alpha < -pi + beta && alpha >= -pi) {
        a = new mxPoint2(x, y);
        b = new mxPoint2(x, y + h2);
      } else if (alpha < -beta && alpha > -pi2) {
        a = new mxPoint2(x + Math.floor(1.5 * w2), y + Math.floor(0.5 * h2));
        b = new mxPoint2(x, y + Math.floor(1.25 * h2));
      } else if (alpha < -pi2 && alpha > -pi + beta) {
        a = new mxPoint2(x - Math.floor(0.5 * w2), y + Math.floor(0.5 * h2));
        b = new mxPoint2(x + w2, y + Math.floor(1.25 * h2));
      }
    } else {
      const beta = Math.atan2(h2 / 2, w2 / 4);
      if (alpha == beta) {
        return new mxPoint2(x + Math.floor(0.75 * w2), y);
      } else if (alpha == pi - beta) {
        return new mxPoint2(x + Math.floor(0.25 * w2), y);
      } else if (alpha == pi || alpha == -pi) {
        return new mxPoint2(x, y + Math.floor(0.5 * h2));
      } else if (alpha == 0) {
        return new mxPoint2(x + w2, y + Math.floor(0.5 * h2));
      } else if (alpha == -beta) {
        return new mxPoint2(x + Math.floor(0.75 * w2), y + h2);
      } else if (alpha == -pi + beta) {
        return new mxPoint2(x + Math.floor(0.25 * w2), y + h2);
      }
      if (alpha > 0 && alpha < beta) {
        a = new mxPoint2(x + Math.floor(0.5 * w2), y - Math.floor(0.5 * h2));
        b = new mxPoint2(x + Math.floor(1.25 * w2), y + h2);
      } else if (alpha > beta && alpha < pi - beta) {
        a = new mxPoint2(x, y);
        b = new mxPoint2(x + w2, y);
      } else if (alpha > pi - beta && alpha < pi) {
        a = new mxPoint2(x - Math.floor(0.25 * w2), y + h2);
        b = new mxPoint2(x + Math.floor(0.5 * w2), y - Math.floor(0.5 * h2));
      } else if (alpha < 0 && alpha > -beta) {
        a = new mxPoint2(x + Math.floor(0.5 * w2), y + Math.floor(1.5 * h2));
        b = new mxPoint2(x + Math.floor(1.25 * w2), y);
      } else if (alpha < -beta && alpha > -pi + beta) {
        a = new mxPoint2(x, y + h2);
        b = new mxPoint2(x + w2, y + h2);
      } else if (alpha < -pi + beta && alpha > -pi) {
        a = new mxPoint2(x - Math.floor(0.25 * w2), y);
        b = new mxPoint2(x + Math.floor(0.5 * w2), y + Math.floor(1.5 * h2));
      }
    }
    result2 = intersection(cx, cy, next.x, next.y, a.x, a.y, b.x, b.y);
  }
  if (result2 == null) {
    return new mxPoint2(cx, cy);
  }
  return result2;
};

// js/graph/mxStyleRegistry.js
var mxStyleRegistry2 = {
  values: {},
  putValue: function(name, obj) {
    mxStyleRegistry2.values[name] = obj;
  },
  getValue: function(name) {
    return mxStyleRegistry2.values[name];
  },
  getName: function(value) {
    for (let key in mxStyleRegistry2.values) {
      if (mxStyleRegistry2.values[key] === value) {
        return key;
      }
    }
    return null;
  }
};
mxStyleRegistry2.putValue(mxConstants2.EDGESTYLE_ELBOW, mxEdgeStyle.ElbowConnector);
mxStyleRegistry2.putValue(mxConstants2.EDGESTYLE_ENTITY_RELATION, mxEdgeStyle.EntityRelation);
mxStyleRegistry2.putValue(mxConstants2.EDGESTYLE_LOOP, mxEdgeStyle.Loop);
mxStyleRegistry2.putValue(mxConstants2.EDGESTYLE_SIDETOSIDE, mxEdgeStyle.SideToSide);
mxStyleRegistry2.putValue(mxConstants2.EDGESTYLE_TOPTOBOTTOM, mxEdgeStyle.TopToBottom);
mxStyleRegistry2.putValue(mxConstants2.EDGESTYLE_ORTHOGONAL, mxEdgeStyle.OrthConnector);
mxStyleRegistry2.putValue(mxConstants2.EDGESTYLE_SEGMENT, mxEdgeStyle.SegmentConnector);
mxStyleRegistry2.putValue(mxConstants2.PERIMETER_ELLIPSE, EllipsePerimeter);
mxStyleRegistry2.putValue(mxConstants2.PERIMETER_RECTANGLE, RectanglePerimeter);
mxStyleRegistry2.putValue(mxConstants2.PERIMETER_RHOMBUS, RhombusPerimeter);
mxStyleRegistry2.putValue(mxConstants2.PERIMETER_TRIANGLE, TrianglePerimeter);
mxStyleRegistry2.putValue(mxConstants2.PERIMETER_HEXAGON, HexagonPerimeter);

// js/graph/mxGraphView.js
function mxGraphView(graph) {
  this.graph = graph;
  this.translate = new mxPoint2();
  this.graphBounds = new mxRectangle();
  this.states = new mxDictionary();
}
mxGraphView.prototype = new mxEventSource();
mxGraphView.prototype.constructor = mxGraphView;
mxGraphView.prototype.EMPTY_POINT = new mxPoint2();
mxGraphView.prototype.doneResource = mxClient2.language != "none" ? "done" : "";
mxGraphView.prototype.updatingDocumentResource = mxClient2.language != "none" ? "updatingDocument" : "";
mxGraphView.prototype.allowEval = false;
mxGraphView.prototype.captureDocumentGesture = true;
mxGraphView.prototype.optimizeVmlReflows = true;
mxGraphView.prototype.rendering = true;
mxGraphView.prototype.graph = null;
mxGraphView.prototype.currentRoot = null;
mxGraphView.prototype.graphBounds = null;
mxGraphView.prototype.scale = 1;
mxGraphView.prototype.translate = null;
mxGraphView.prototype.states = null;
mxGraphView.prototype.updateStyle = false;
mxGraphView.prototype.lastNode = null;
mxGraphView.prototype.lastHtmlNode = null;
mxGraphView.prototype.lastForegroundNode = null;
mxGraphView.prototype.lastForegroundHtmlNode = null;
mxGraphView.prototype.getGraphBounds = function() {
  return this.graphBounds;
};
mxGraphView.prototype.setGraphBounds = function(value) {
  this.graphBounds = value;
};
mxGraphView.prototype.getBounds = function(cells) {
  let result2 = null;
  if (cells != null && cells.length > 0) {
    const model = this.graph.getModel();
    for (let i = 0; i < cells.length; i++) {
      if (model.isVertex(cells[i]) || model.isEdge(cells[i])) {
        const state2 = this.getState(cells[i]);
        if (state2 != null) {
          if (result2 == null) {
            result2 = mxRectangle.fromRectangle(state2);
          } else {
            result2.add(state2);
          }
        }
      }
    }
  }
  return result2;
};
mxGraphView.prototype.setCurrentRoot = function(root) {
  if (this.currentRoot != root) {
    const change = new mxCurrentRootChange(this, root);
    change.execute();
    const edit = new mxUndoableEdit(this, true);
    edit.add(change);
    this.fireEvent(new mxEventObject2(mxEvent2.UNDO, "edit", edit));
    this.graph.sizeDidChange();
  }
  return root;
};
mxGraphView.prototype.scaleAndTranslate = function(scale, dx, dy) {
  const previousScale = this.scale;
  const previousTranslate = new mxPoint2(this.translate.x, this.translate.y);
  if (this.scale != scale || this.translate.x != dx || this.translate.y != dy) {
    this.scale = scale;
    this.translate.x = dx;
    this.translate.y = dy;
    if (this.isEventsEnabled()) {
      this.viewStateChanged();
    }
  }
  this.fireEvent(new mxEventObject2(mxEvent2.SCALE_AND_TRANSLATE, "scale", scale, "previousScale", previousScale, "translate", this.translate, "previousTranslate", previousTranslate));
};
mxGraphView.prototype.getScale = function() {
  return this.scale;
};
mxGraphView.prototype.setScale = function(value) {
  const previousScale = this.scale;
  if (this.scale != value) {
    this.scale = value;
    if (this.isEventsEnabled()) {
      this.viewStateChanged();
    }
  }
  this.fireEvent(new mxEventObject2(mxEvent2.SCALE, "scale", value, "previousScale", previousScale));
};
mxGraphView.prototype.getTranslate = function() {
  return this.translate;
};
mxGraphView.prototype.setTranslate = function(dx, dy) {
  const previousTranslate = new mxPoint2(this.translate.x, this.translate.y);
  if (this.translate.x != dx || this.translate.y != dy) {
    this.translate.x = dx;
    this.translate.y = dy;
    if (this.isEventsEnabled()) {
      this.viewStateChanged();
    }
  }
  this.fireEvent(new mxEventObject2(mxEvent2.TRANSLATE, "translate", this.translate, "previousTranslate", previousTranslate));
};
mxGraphView.prototype.viewStateChanged = function() {
  this.revalidate();
  this.graph.sizeDidChange();
};
mxGraphView.prototype.refresh = function() {
  if (this.currentRoot != null) {
    this.clear();
  }
  this.revalidate();
};
mxGraphView.prototype.revalidate = function() {
  this.invalidate();
  this.validate();
};
mxGraphView.prototype.clear = function(cell2, force, recurse) {
  const model = this.graph.getModel();
  cell2 = cell2 || model.getRoot();
  force = force != null ? force : false;
  recurse = recurse != null ? recurse : true;
  this.removeState(cell2);
  if (recurse && (force || cell2 != this.currentRoot)) {
    const childCount = model.getChildCount(cell2);
    for (let i = 0; i < childCount; i++) {
      this.clear(model.getChildAt(cell2, i), force);
    }
  } else {
    this.invalidate(cell2);
  }
};
mxGraphView.prototype.invalidate = function(cell2, recurse, includeEdges) {
  const model = this.graph.getModel();
  cell2 = cell2 || model.getRoot();
  recurse = recurse != null ? recurse : true;
  includeEdges = includeEdges != null ? includeEdges : true;
  const state2 = this.getState(cell2);
  if (state2 != null) {
    state2.invalid = true;
  }
  if (!cell2.invalidating) {
    cell2.invalidating = true;
    if (recurse) {
      const childCount = model.getChildCount(cell2);
      for (let i = 0; i < childCount; i++) {
        const child = model.getChildAt(cell2, i);
        this.invalidate(child, recurse, includeEdges);
      }
    }
    if (includeEdges) {
      const edgeCount = model.getEdgeCount(cell2);
      for (let i = 0; i < edgeCount; i++) {
        this.invalidate(model.getEdgeAt(cell2, i), recurse, includeEdges);
      }
    }
    delete cell2.invalidating;
  }
};
mxGraphView.prototype.validate = function(cell2) {
  const t0 = mxLog.enter("mxGraphView.validate");
  window.status = mxResources2.get(this.updatingDocumentResource) || this.updatingDocumentResource;
  this.resetValidationState();
  let prevDisplay = null;
  if (this.optimizeVmlReflows && this.canvas != null && this.textDiv == null && (document.documentMode == 8 && !mxClient2.IS_EM || mxClient2.IS_QUIRKS)) {
    this.placeholder = document.createElement("div");
    this.placeholder.style.position = "absolute";
    this.placeholder.style.width = this.canvas.clientWidth + "px";
    this.placeholder.style.height = this.canvas.clientHeight + "px";
    this.canvas.parentNode.appendChild(this.placeholder);
    prevDisplay = this.drawPane.style.display;
    this.canvas.style.display = "none";
    this.textDiv = document.createElement("div");
    this.textDiv.style.position = "absolute";
    this.textDiv.style.whiteSpace = "nowrap";
    this.textDiv.style.visibility = "hidden";
    this.textDiv.style.display = mxClient2.IS_QUIRKS ? "inline" : "inline-block";
    this.textDiv.style.zoom = "1";
    document.body.appendChild(this.textDiv);
  }
  const graphBounds = this.getBoundingBox(this.validateCellState(this.validateCell(cell2 || (this.currentRoot != null ? this.currentRoot : this.graph.getModel().getRoot()))));
  this.setGraphBounds(graphBounds != null ? graphBounds : this.getEmptyBounds());
  this.validateBackground();
  if (prevDisplay != null) {
    this.canvas.style.display = prevDisplay;
    this.textDiv.parentNode.removeChild(this.textDiv);
    if (this.placeholder != null) {
      this.placeholder.parentNode.removeChild(this.placeholder);
    }
    this.textDiv = null;
  }
  this.resetValidationState();
  window.status = mxResources2.get(this.doneResource) || this.doneResource;
  mxLog.leave("mxGraphView.validate", t0);
};
mxGraphView.prototype.getEmptyBounds = function() {
  return new mxRectangle(this.translate.x * this.scale, this.translate.y * this.scale);
};
mxGraphView.prototype.getBoundingBox = function(state2, recurse) {
  recurse = recurse != null ? recurse : true;
  let bbox = null;
  if (state2 != null) {
    if (state2.shape != null && state2.shape.boundingBox != null) {
      bbox = state2.shape.boundingBox.clone();
    }
    if (state2.text != null && state2.text.boundingBox != null) {
      if (bbox != null) {
        bbox.add(state2.text.boundingBox);
      } else {
        bbox = state2.text.boundingBox.clone();
      }
    }
    if (recurse) {
      const model = this.graph.getModel();
      const childCount = model.getChildCount(state2.cell);
      for (let i = 0; i < childCount; i++) {
        const bounds = this.getBoundingBox(this.getState(model.getChildAt(state2.cell, i)));
        if (bounds != null) {
          if (bbox == null) {
            bbox = bounds;
          } else {
            bbox.add(bounds);
          }
        }
      }
    }
  }
  return bbox;
};
mxGraphView.prototype.createBackgroundPageShape = function(bounds) {
  return new mxRectangleShape(bounds, "white", "black");
};
mxGraphView.prototype.validateBackground = function() {
  this.validateBackgroundImage();
  this.validateBackgroundPage();
};
mxGraphView.prototype.validateBackgroundImage = function() {
  var bg = this.graph.getBackgroundImage();
  if (bg != null) {
    if (this.backgroundImage == null || this.backgroundImage.image != bg.src) {
      if (this.backgroundImage != null) {
        this.backgroundImage.destroy();
      }
      var bounds = new mxRectangle(0, 0, 1, 1);
      this.backgroundImage = new mxImageShape(bounds, bg.src);
      this.backgroundImage.dialect = this.graph.dialect;
      this.backgroundImage.init(this.backgroundPane);
      this.backgroundImage.redraw();
      if (document.documentMode == 8 && !mxClient2.IS_EM) {
        mxEvent2.addGestureListeners(this.backgroundImage.node, bind(this, function(evt) {
          this.graph.fireMouseEvent(mxEvent2.MOUSE_DOWN, new mxMouseEvent2(evt));
        }), bind(this, function(evt) {
          this.graph.fireMouseEvent(mxEvent2.MOUSE_MOVE, new mxMouseEvent2(evt));
        }), bind(this, function(evt) {
          this.graph.fireMouseEvent(mxEvent2.MOUSE_UP, new mxMouseEvent2(evt));
        }));
      }
    }
    this.redrawBackgroundImage(this.backgroundImage, bg);
  } else if (this.backgroundImage != null) {
    this.backgroundImage.destroy();
    this.backgroundImage = null;
  }
};
mxGraphView.prototype.validateBackgroundPage = function() {
  if (this.graph.pageVisible) {
    var bounds = this.getBackgroundPageBounds();
    if (this.backgroundPageShape == null) {
      this.backgroundPageShape = this.createBackgroundPageShape(bounds);
      this.backgroundPageShape.scale = this.scale;
      this.backgroundPageShape.isShadow = true;
      this.backgroundPageShape.dialect = this.graph.dialect;
      this.backgroundPageShape.init(this.backgroundPane);
      this.backgroundPageShape.redraw();
      if (this.graph.nativeDblClickEnabled) {
        mxEvent2.addListener(this.backgroundPageShape.node, "dblclick", bind(this, function(evt) {
          this.graph.dblClick(evt);
        }));
      }
      mxEvent2.addGestureListeners(this.backgroundPageShape.node, bind(this, function(evt) {
        this.graph.fireMouseEvent(mxEvent2.MOUSE_DOWN, new mxMouseEvent2(evt));
      }), bind(this, function(evt) {
        if (this.graph.tooltipHandler != null && this.graph.tooltipHandler.isHideOnHover()) {
          this.graph.tooltipHandler.hide();
        }
        if (this.graph.isMouseDown && !mxEvent2.isConsumed(evt)) {
          this.graph.fireMouseEvent(mxEvent2.MOUSE_MOVE, new mxMouseEvent2(evt));
        }
      }), bind(this, function(evt) {
        this.graph.fireMouseEvent(mxEvent2.MOUSE_UP, new mxMouseEvent2(evt));
      }));
    } else {
      this.backgroundPageShape.scale = this.scale;
      this.backgroundPageShape.bounds = bounds;
      this.backgroundPageShape.redraw();
    }
  } else if (this.backgroundPageShape != null) {
    this.backgroundPageShape.destroy();
    this.backgroundPageShape = null;
  }
};
mxGraphView.prototype.getBackgroundPageBounds = function() {
  const fmt = this.graph.pageFormat;
  const ps = this.scale * this.graph.pageScale;
  const bounds = new mxRectangle(this.scale * this.translate.x, this.scale * this.translate.y, fmt.width * ps, fmt.height * ps);
  return bounds;
};
mxGraphView.prototype.redrawBackgroundImage = function(backgroundImage, bg) {
  backgroundImage.scale = this.scale;
  backgroundImage.bounds.x = this.scale * this.translate.x;
  backgroundImage.bounds.y = this.scale * this.translate.y;
  backgroundImage.bounds.width = this.scale * bg.width;
  backgroundImage.bounds.height = this.scale * bg.height;
  backgroundImage.redraw();
};
mxGraphView.prototype.validateCell = function(cell2, visible) {
  visible = visible != null ? visible : true;
  if (cell2 != null) {
    visible = visible && this.graph.isCellVisible(cell2);
    const state2 = this.getState(cell2, visible);
    if (state2 != null && !visible) {
      this.removeState(cell2);
    } else {
      const model = this.graph.getModel();
      const childCount = model.getChildCount(cell2);
      for (let i = 0; i < childCount; i++) {
        this.validateCell(model.getChildAt(cell2, i), visible && (!this.isCellCollapsed(cell2) || cell2 == this.currentRoot));
      }
    }
  }
  return cell2;
};
mxGraphView.prototype.validateCellState = function(cell2, recurse) {
  recurse = recurse != null ? recurse : true;
  let state2 = null;
  if (cell2 != null) {
    state2 = this.getState(cell2);
    if (state2 != null) {
      const model = this.graph.getModel();
      if (state2.invalid) {
        state2.invalid = false;
        if (state2.style == null || state2.invalidStyle) {
          state2.style = this.graph.getCellStyle(state2.cell);
          state2.invalidStyle = false;
        }
        if (cell2 != this.currentRoot) {
          this.validateCellState(model.getParent(cell2), false);
        }
        state2.setVisibleTerminalState(this.validateCellState(this.getVisibleTerminal(cell2, true), false), true);
        state2.setVisibleTerminalState(this.validateCellState(this.getVisibleTerminal(cell2, false), false), false);
        this.updateCellState(state2);
        if (cell2 != this.currentRoot && !state2.invalid) {
          this.graph.cellRenderer.redraw(state2, false, this.isRendering());
          state2.updateCachedBounds();
        }
      }
      if (recurse && !state2.invalid) {
        if (state2.shape != null) {
          this.stateValidated(state2);
        }
        const childCount = model.getChildCount(cell2);
        for (let i = 0; i < childCount; i++) {
          this.validateCellState(model.getChildAt(cell2, i));
        }
      }
    }
  }
  return state2;
};
mxGraphView.prototype.updateCellState = function(state2) {
  state2.absoluteOffset.x = 0;
  state2.absoluteOffset.y = 0;
  state2.origin.x = 0;
  state2.origin.y = 0;
  state2.length = 0;
  if (state2.cell != this.currentRoot) {
    const model = this.graph.getModel();
    const pState = this.getState(model.getParent(state2.cell));
    if (pState != null && pState.cell != this.currentRoot) {
      state2.origin.x += pState.origin.x;
      state2.origin.y += pState.origin.y;
    }
    const offset = this.graph.getChildOffsetForCell(state2.cell);
    if (offset != null) {
      state2.origin.x += offset.x;
      state2.origin.y += offset.y;
    }
    const geo = this.graph.getCellGeometry(state2.cell);
    if (geo != null) {
      if (!model.isEdge(state2.cell)) {
        const offset2 = geo.offset != null ? geo.offset : this.EMPTY_POINT;
        if (geo.relative && pState != null) {
          if (model.isEdge(pState.cell)) {
            const origin = this.getPoint(pState, geo);
            if (origin != null) {
              state2.origin.x += origin.x / this.scale - pState.origin.x - this.translate.x;
              state2.origin.y += origin.y / this.scale - pState.origin.y - this.translate.y;
            }
          } else {
            state2.origin.x += geo.x * pState.unscaledWidth + offset2.x;
            state2.origin.y += geo.y * pState.unscaledHeight + offset2.y;
          }
        } else {
          state2.absoluteOffset.x = this.scale * offset2.x;
          state2.absoluteOffset.y = this.scale * offset2.y;
          state2.origin.x += geo.x;
          state2.origin.y += geo.y;
        }
      }
      state2.x = this.scale * (this.translate.x + state2.origin.x);
      state2.y = this.scale * (this.translate.y + state2.origin.y);
      state2.width = this.scale * geo.width;
      state2.unscaledWidth = geo.width;
      state2.height = this.scale * geo.height;
      state2.unscaledHeight = geo.height;
      if (model.isVertex(state2.cell)) {
        this.updateVertexState(state2, geo);
      }
      if (model.isEdge(state2.cell)) {
        this.updateEdgeState(state2, geo);
      }
    }
  }
  state2.updateCachedBounds();
};
mxGraphView.prototype.isCellCollapsed = function(cell2) {
  return this.graph.isCellCollapsed(cell2);
};
mxGraphView.prototype.updateVertexState = function(state2, geo) {
  const model = this.graph.getModel();
  const pState = this.getState(model.getParent(state2.cell));
  if (geo.relative && pState != null && !model.isEdge(pState.cell)) {
    const alpha = toRadians(pState.style[mxConstants2.STYLE_ROTATION] || "0");
    if (alpha != 0) {
      const cos = Math.cos(alpha);
      const sin = Math.sin(alpha);
      const ct = new mxPoint2(state2.getCenterX(), state2.getCenterY());
      const cx = new mxPoint2(pState.getCenterX(), pState.getCenterY());
      const pt = getRotatedPoint(ct, cos, sin, cx);
      state2.x = pt.x - state2.width / 2;
      state2.y = pt.y - state2.height / 2;
    }
  }
  this.updateVertexLabelOffset(state2);
};
mxGraphView.prototype.updateEdgeState = function(state2, geo) {
  const source = state2.getVisibleTerminalState(true);
  const target = state2.getVisibleTerminalState(false);
  if (this.graph.model.getTerminal(state2.cell, true) != null && source == null || source == null && geo.getTerminalPoint(true) == null || this.graph.model.getTerminal(state2.cell, false) != null && target == null || target == null && geo.getTerminalPoint(false) == null) {
    this.clear(state2.cell, true);
  } else {
    this.updateFixedTerminalPoints(state2, source, target);
    this.updatePoints(state2, geo.points, source, target);
    this.updateFloatingTerminalPoints(state2, source, target);
    const pts = state2.absolutePoints;
    if (state2.cell != this.currentRoot && (pts == null || pts.length < 2 || pts[0] == null || pts[pts.length - 1] == null)) {
      this.clear(state2.cell, true);
    } else {
      this.updateEdgeBounds(state2);
      this.updateEdgeLabelOffset(state2);
    }
  }
};
mxGraphView.prototype.updateVertexLabelOffset = function(state2) {
  const h2 = getValue(state2.style, mxConstants2.STYLE_LABEL_POSITION, mxConstants2.ALIGN_CENTER);
  if (h2 == mxConstants2.ALIGN_LEFT) {
    let lw = getValue(state2.style, mxConstants2.STYLE_LABEL_WIDTH, null);
    if (lw != null) {
      lw *= this.scale;
    } else {
      lw = state2.width;
    }
    state2.absoluteOffset.x -= lw;
  } else if (h2 == mxConstants2.ALIGN_RIGHT) {
    state2.absoluteOffset.x += state2.width;
  } else if (h2 == mxConstants2.ALIGN_CENTER) {
    const lw = getValue(state2.style, mxConstants2.STYLE_LABEL_WIDTH, null);
    if (lw != null) {
      const align = getValue(state2.style, mxConstants2.STYLE_ALIGN, mxConstants2.ALIGN_CENTER);
      let dx = 0;
      if (align == mxConstants2.ALIGN_CENTER) {
        dx = 0.5;
      } else if (align == mxConstants2.ALIGN_RIGHT) {
        dx = 1;
      }
      if (dx != 0) {
        state2.absoluteOffset.x -= (lw * this.scale - state2.width) * dx;
      }
    }
  }
  const v = getValue(state2.style, mxConstants2.STYLE_VERTICAL_LABEL_POSITION, mxConstants2.ALIGN_MIDDLE);
  if (v == mxConstants2.ALIGN_TOP) {
    state2.absoluteOffset.y -= state2.height;
  } else if (v == mxConstants2.ALIGN_BOTTOM) {
    state2.absoluteOffset.y += state2.height;
  }
};
mxGraphView.prototype.resetValidationState = function() {
  this.lastNode = null;
  this.lastHtmlNode = null;
  this.lastForegroundNode = null;
  this.lastForegroundHtmlNode = null;
};
mxGraphView.prototype.stateValidated = function(state2) {
  const fg = this.graph.getModel().isEdge(state2.cell) && this.graph.keepEdgesInForeground || this.graph.getModel().isVertex(state2.cell) && this.graph.keepEdgesInBackground;
  const htmlNode = fg ? this.lastForegroundHtmlNode || this.lastHtmlNode : this.lastHtmlNode;
  const node = fg ? this.lastForegroundNode || this.lastNode : this.lastNode;
  const result2 = this.graph.cellRenderer.insertStateAfter(state2, node, htmlNode);
  if (fg) {
    this.lastForegroundHtmlNode = result2[1];
    this.lastForegroundNode = result2[0];
  } else {
    this.lastHtmlNode = result2[1];
    this.lastNode = result2[0];
  }
};
mxGraphView.prototype.updateFixedTerminalPoints = function(edge, source, target) {
  this.updateFixedTerminalPoint(edge, source, true, this.graph.getConnectionConstraint(edge, source, true));
  this.updateFixedTerminalPoint(edge, target, false, this.graph.getConnectionConstraint(edge, target, false));
};
mxGraphView.prototype.updateFixedTerminalPoint = function(edge, terminal, source, constraint) {
  edge.setAbsoluteTerminalPoint(this.getFixedTerminalPoint(edge, terminal, source, constraint), source);
};
mxGraphView.prototype.getFixedTerminalPoint = function(edge, terminal, source, constraint) {
  let pt = null;
  if (constraint != null) {
    pt = this.graph.getConnectionPoint(terminal, constraint, false);
  }
  if (pt == null && terminal == null) {
    const s = this.scale;
    const tr = this.translate;
    const orig = edge.origin;
    const geo = this.graph.getCellGeometry(edge.cell);
    pt = geo.getTerminalPoint(source);
    if (pt != null) {
      pt = new mxPoint2(s * (tr.x + pt.x + orig.x), s * (tr.y + pt.y + orig.y));
    }
  }
  return pt;
};
mxGraphView.prototype.updateBoundsFromStencil = function(state2) {
  let previous = null;
  if (state2 != null && state2.shape != null && state2.shape.stencil != null && state2.shape.stencil.aspect == "fixed") {
    previous = mxRectangle.fromRectangle(state2);
    const asp = state2.shape.stencil.computeAspect(state2.style, state2.x, state2.y, state2.width, state2.height);
    state2.setRect(asp.x, asp.y, state2.shape.stencil.w0 * asp.width, state2.shape.stencil.h0 * asp.height);
  }
  return previous;
};
mxGraphView.prototype.updatePoints = function(edge, points, source, target) {
  if (edge != null) {
    const pts = [];
    pts.push(edge.absolutePoints[0]);
    const edgeStyle = this.getEdgeStyle(edge, points, source, target);
    if (edgeStyle != null) {
      const src = this.getTerminalPort(edge, source, true);
      const trg = this.getTerminalPort(edge, target, false);
      const srcBounds = this.updateBoundsFromStencil(src);
      const trgBounds = this.updateBoundsFromStencil(trg);
      edgeStyle(edge, src, trg, points, pts);
      if (srcBounds != null) {
        src.setRect(srcBounds.x, srcBounds.y, srcBounds.width, srcBounds.height);
      }
      if (trgBounds != null) {
        trg.setRect(trgBounds.x, trgBounds.y, trgBounds.width, trgBounds.height);
      }
    } else if (points != null) {
      for (let i = 0; i < points.length; i++) {
        if (points[i] != null) {
          const pt = clone(points[i]);
          pts.push(this.transformControlPoint(edge, pt));
        }
      }
    }
    const tmp = edge.absolutePoints;
    pts.push(tmp[tmp.length - 1]);
    edge.absolutePoints = pts;
  }
};
mxGraphView.prototype.transformControlPoint = function(state2, pt, ignoreScale) {
  if (state2 != null && pt != null) {
    const orig = state2.origin;
    const scale = ignoreScale ? 1 : this.scale;
    return new mxPoint2(scale * (pt.x + this.translate.x + orig.x), scale * (pt.y + this.translate.y + orig.y));
  }
  return null;
};
mxGraphView.prototype.isLoopStyleEnabled = function(edge, points, source, target) {
  const sc = this.graph.getConnectionConstraint(edge, source, true);
  const tc = this.graph.getConnectionConstraint(edge, target, false);
  if ((points == null || points.length < 2) && (!getValue(edge.style, mxConstants2.STYLE_ORTHOGONAL_LOOP, false) || (sc == null || sc.point == null) && (tc == null || tc.point == null))) {
    return source != null && source == target;
  }
  return false;
};
mxGraphView.prototype.getEdgeStyle = function(edge, points, source, target) {
  let edgeStyle = this.isLoopStyleEnabled(edge, points, source, target) ? getValue(edge.style, mxConstants2.STYLE_LOOP, this.graph.defaultLoopStyle) : !getValue(edge.style, mxConstants2.STYLE_NOEDGESTYLE, false) ? edge.style[mxConstants2.STYLE_EDGE] : null;
  if (typeof edgeStyle == "string") {
    let tmp = mxStyleRegistry2.getValue(edgeStyle);
    if (tmp == null && this.isAllowEval()) {
      tmp = (void 0)(edgeStyle);
    }
    edgeStyle = tmp;
  }
  if (typeof edgeStyle == "function") {
    return edgeStyle;
  }
  return null;
};
mxGraphView.prototype.updateFloatingTerminalPoints = function(state2, source, target) {
  const pts = state2.absolutePoints;
  const p0 = pts[0];
  const pe = pts[pts.length - 1];
  if (pe == null && target != null) {
    this.updateFloatingTerminalPoint(state2, target, source, false);
  }
  if (p0 == null && source != null) {
    this.updateFloatingTerminalPoint(state2, source, target, true);
  }
};
mxGraphView.prototype.updateFloatingTerminalPoint = function(edge, start, end, source) {
  edge.setAbsoluteTerminalPoint(this.getFloatingTerminalPoint(edge, start, end, source), source);
};
mxGraphView.prototype.getFloatingTerminalPoint = function(edge, start, end, source) {
  start = this.getTerminalPort(edge, start, source);
  let next = this.getNextPoint(edge, end, source);
  const orth = this.graph.isOrthogonal(edge);
  const alpha = toRadians(Number(start.style[mxConstants2.STYLE_ROTATION] || "0"));
  const center = new mxPoint2(start.getCenterX(), start.getCenterY());
  if (alpha != 0) {
    const cos = Math.cos(-alpha);
    const sin = Math.sin(-alpha);
    next = getRotatedPoint(next, cos, sin, center);
  }
  let border = parseFloat(edge.style[mxConstants2.STYLE_PERIMETER_SPACING] || 0);
  border += parseFloat(edge.style[source ? mxConstants2.STYLE_SOURCE_PERIMETER_SPACING : mxConstants2.STYLE_TARGET_PERIMETER_SPACING] || 0);
  let pt = this.getPerimeterPoint(start, next, alpha == 0 && orth, border);
  if (alpha != 0) {
    const cos = Math.cos(alpha);
    const sin = Math.sin(alpha);
    pt = getRotatedPoint(pt, cos, sin, center);
  }
  return pt;
};
mxGraphView.prototype.getTerminalPort = function(state2, terminal, source) {
  const key = source ? mxConstants2.STYLE_SOURCE_PORT : mxConstants2.STYLE_TARGET_PORT;
  const id = getValue(state2.style, key);
  if (id != null) {
    const tmp = this.getState(this.graph.getModel().getCell(id));
    if (tmp != null) {
      terminal = tmp;
    }
  }
  return terminal;
};
mxGraphView.prototype.getPerimeterPoint = function(terminal, next, orthogonal, border) {
  let point = null;
  if (terminal != null) {
    const perimeter = this.getPerimeterFunction(terminal);
    if (perimeter != null && next != null) {
      const bounds = this.getPerimeterBounds(terminal, border);
      if (bounds.width > 0 || bounds.height > 0) {
        point = new mxPoint2(next.x, next.y);
        let flipH = false;
        let flipV = false;
        if (this.graph.model.isVertex(terminal.cell)) {
          flipH = getValue(terminal.style, mxConstants2.STYLE_FLIPH, 0) == 1;
          flipV = getValue(terminal.style, mxConstants2.STYLE_FLIPV, 0) == 1;
          if (terminal.shape != null && terminal.shape.stencil != null) {
            flipH = getValue(terminal.style, "stencilFlipH", 0) == 1 || flipH;
            flipV = getValue(terminal.style, "stencilFlipV", 0) == 1 || flipV;
          }
          if (flipH) {
            point.x = 2 * bounds.getCenterX() - point.x;
          }
          if (flipV) {
            point.y = 2 * bounds.getCenterY() - point.y;
          }
        }
        point = perimeter(bounds, terminal, point, orthogonal);
        if (point != null) {
          if (flipH) {
            point.x = 2 * bounds.getCenterX() - point.x;
          }
          if (flipV) {
            point.y = 2 * bounds.getCenterY() - point.y;
          }
        }
      }
    }
    if (point == null) {
      point = this.getPoint(terminal);
    }
  }
  return point;
};
mxGraphView.prototype.getRoutingCenterX = function(state2) {
  const f = state2.style != null ? parseFloat(state2.style[mxConstants2.STYLE_ROUTING_CENTER_X]) || 0 : 0;
  return state2.getCenterX() + f * state2.width;
};
mxGraphView.prototype.getRoutingCenterY = function(state2) {
  const f = state2.style != null ? parseFloat(state2.style[mxConstants2.STYLE_ROUTING_CENTER_Y]) || 0 : 0;
  return state2.getCenterY() + f * state2.height;
};
mxGraphView.prototype.getPerimeterBounds = function(terminal, border) {
  border = border != null ? border : 0;
  if (terminal != null) {
    border += parseFloat(terminal.style[mxConstants2.STYLE_PERIMETER_SPACING] || 0);
  }
  return terminal.getPerimeterBounds(border * this.scale);
};
mxGraphView.prototype.getPerimeterFunction = function(state2) {
  let perimeter = state2.style[mxConstants2.STYLE_PERIMETER];
  if (typeof perimeter == "string") {
    let tmp = mxStyleRegistry2.getValue(perimeter);
    if (tmp == null && this.isAllowEval()) {
      tmp = (void 0)(perimeter);
    }
    perimeter = tmp;
  }
  if (typeof perimeter == "function") {
    return perimeter;
  }
  return null;
};
mxGraphView.prototype.getNextPoint = function(edge, opposite, source) {
  const pts = edge.absolutePoints;
  let point = null;
  if (pts != null && pts.length >= 2) {
    const count = pts.length;
    point = pts[source ? Math.min(1, count - 1) : Math.max(0, count - 2)];
  }
  if (point == null && opposite != null) {
    point = new mxPoint2(opposite.getCenterX(), opposite.getCenterY());
  }
  return point;
};
mxGraphView.prototype.getVisibleTerminal = function(edge, source) {
  const model = this.graph.getModel();
  let result2 = model.getTerminal(edge, source);
  let best = result2;
  while (result2 != null && result2 != this.currentRoot) {
    if (!this.graph.isCellVisible(best) || this.isCellCollapsed(result2)) {
      best = result2;
    }
    result2 = model.getParent(result2);
  }
  if (best != null && (!model.contains(best) || model.getParent(best) == model.getRoot() || best == this.currentRoot)) {
    best = null;
  }
  return best;
};
mxGraphView.prototype.updateEdgeBounds = function(state2) {
  const points = state2.absolutePoints;
  const p0 = points[0];
  const pe = points[points.length - 1];
  if (p0.x != pe.x || p0.y != pe.y) {
    const dx = pe.x - p0.x;
    const dy = pe.y - p0.y;
    state2.terminalDistance = Math.sqrt(dx * dx + dy * dy);
  } else {
    state2.terminalDistance = 0;
  }
  let length = 0;
  const segments = [];
  let pt = p0;
  if (pt != null) {
    let minX = pt.x;
    let minY = pt.y;
    let maxX = minX;
    let maxY = minY;
    for (let i = 1; i < points.length; i++) {
      const tmp = points[i];
      if (tmp != null) {
        const dx = pt.x - tmp.x;
        const dy = pt.y - tmp.y;
        const segment = Math.sqrt(dx * dx + dy * dy);
        segments.push(segment);
        length += segment;
        pt = tmp;
        minX = Math.min(pt.x, minX);
        minY = Math.min(pt.y, minY);
        maxX = Math.max(pt.x, maxX);
        maxY = Math.max(pt.y, maxY);
      }
    }
    state2.length = length;
    state2.segments = segments;
    const markerSize = 1;
    state2.x = minX;
    state2.y = minY;
    state2.width = Math.max(markerSize, maxX - minX);
    state2.height = Math.max(markerSize, maxY - minY);
  }
};
mxGraphView.prototype.getPoint = function(state2, geometry) {
  let x = state2.getCenterX();
  let y = state2.getCenterY();
  if (state2.segments != null && (geometry == null || geometry.relative)) {
    const gx = geometry != null ? geometry.x / 2 : 0;
    const pointCount = state2.absolutePoints.length;
    const dist = Math.round((gx + 0.5) * state2.length);
    let segment = state2.segments[0];
    let length = 0;
    let index = 1;
    while (dist >= Math.round(length + segment) && index < pointCount - 1) {
      length += segment;
      segment = state2.segments[index++];
    }
    const factor = segment == 0 ? 0 : (dist - length) / segment;
    const p0 = state2.absolutePoints[index - 1];
    const pe = state2.absolutePoints[index];
    if (p0 != null && pe != null) {
      let gy = 0;
      let offsetX = 0;
      let offsetY = 0;
      if (geometry != null) {
        gy = geometry.y;
        const offset = geometry.offset;
        if (offset != null) {
          offsetX = offset.x;
          offsetY = offset.y;
        }
      }
      const dx = pe.x - p0.x;
      const dy = pe.y - p0.y;
      const nx = segment == 0 ? 0 : dy / segment;
      const ny = segment == 0 ? 0 : dx / segment;
      x = p0.x + dx * factor + (nx * gy + offsetX) * this.scale;
      y = p0.y + dy * factor - (ny * gy - offsetY) * this.scale;
    }
  } else if (geometry != null) {
    const offset = geometry.offset;
    if (offset != null) {
      x += offset.x;
      y += offset.y;
    }
  }
  return new mxPoint2(x, y);
};
mxGraphView.prototype.getRelativePoint = function(edgeState, x, y) {
  const model = this.graph.getModel();
  const geometry = model.getGeometry(edgeState.cell);
  if (geometry != null) {
    const pointCount = edgeState.absolutePoints.length;
    if (geometry.relative && pointCount > 1) {
      const totalLength = edgeState.length;
      const segments = edgeState.segments;
      let p0 = edgeState.absolutePoints[0];
      let pe = edgeState.absolutePoints[1];
      let minDist = ptSegDistSq(p0.x, p0.y, pe.x, pe.y, x, y);
      let index = 0;
      let tmp = 0;
      let length = 0;
      for (let i = 2; i < pointCount; i++) {
        tmp += segments[i - 2];
        pe = edgeState.absolutePoints[i];
        const dist = ptSegDistSq(p0.x, p0.y, pe.x, pe.y, x, y);
        if (dist <= minDist) {
          minDist = dist;
          index = i - 1;
          length = tmp;
        }
        p0 = pe;
      }
      const seg = segments[index];
      p0 = edgeState.absolutePoints[index];
      pe = edgeState.absolutePoints[index + 1];
      const x2 = p0.x;
      const y2 = p0.y;
      const x1 = pe.x;
      const y1 = pe.y;
      let px = x;
      let py = y;
      const xSegment = x2 - x1;
      const ySegment = y2 - y1;
      px -= x1;
      py -= y1;
      let projlenSq = 0;
      px = xSegment - px;
      py = ySegment - py;
      const dotprod = px * xSegment + py * ySegment;
      if (dotprod <= 0) {
        projlenSq = 0;
      } else {
        projlenSq = dotprod * dotprod / (xSegment * xSegment + ySegment * ySegment);
      }
      let projlen = Math.sqrt(projlenSq);
      if (projlen > seg) {
        projlen = seg;
      }
      let yDistance = Math.sqrt(ptSegDistSq(p0.x, p0.y, pe.x, pe.y, x, y));
      const direction = relativeCcw(p0.x, p0.y, pe.x, pe.y, x, y);
      if (direction == -1) {
        yDistance = -yDistance;
      }
      return new mxPoint2((totalLength / 2 - length - projlen) / totalLength * -2, yDistance / this.scale);
    }
  }
  return new mxPoint2();
};
mxGraphView.prototype.updateEdgeLabelOffset = function(state2) {
  const points = state2.absolutePoints;
  state2.absoluteOffset.x = state2.getCenterX();
  state2.absoluteOffset.y = state2.getCenterY();
  if (points != null && points.length > 0 && state2.segments != null) {
    const geometry = this.graph.getCellGeometry(state2.cell);
    if (geometry.relative) {
      const offset = this.getPoint(state2, geometry);
      if (offset != null) {
        state2.absoluteOffset = offset;
      }
    } else {
      const p0 = points[0];
      const pe = points[points.length - 1];
      if (p0 != null && pe != null) {
        const dx = pe.x - p0.x;
        const dy = pe.y - p0.y;
        let x0 = 0;
        let y0 = 0;
        const off = geometry.offset;
        if (off != null) {
          x0 = off.x;
          y0 = off.y;
        }
        const x = p0.x + dx / 2 + x0 * this.scale;
        const y = p0.y + dy / 2 + y0 * this.scale;
        state2.absoluteOffset.x = x;
        state2.absoluteOffset.y = y;
      }
    }
  }
};
mxGraphView.prototype.getState = function(cell2, create2) {
  create2 = create2 || false;
  let state2 = null;
  if (cell2 != null) {
    state2 = this.states.get(cell2);
    if (create2 && (state2 == null || this.updateStyle) && this.graph.isCellVisible(cell2)) {
      if (state2 == null) {
        state2 = this.createState(cell2);
        this.states.put(cell2, state2);
      } else {
        state2.style = this.graph.getCellStyle(cell2);
      }
    }
  }
  return state2;
};
mxGraphView.prototype.isRendering = function() {
  return this.rendering;
};
mxGraphView.prototype.setRendering = function(value) {
  this.rendering = value;
};
mxGraphView.prototype.isAllowEval = function() {
  return this.allowEval;
};
mxGraphView.prototype.setAllowEval = function(value) {
  this.allowEval = value;
};
mxGraphView.prototype.getStates = function() {
  return this.states;
};
mxGraphView.prototype.setStates = function(value) {
  this.states = value;
};
mxGraphView.prototype.getCellStates = function(cells) {
  if (cells == null) {
    return this.states;
  } else {
    const result2 = [];
    for (let i = 0; i < cells.length; i++) {
      const state2 = this.getState(cells[i]);
      if (state2 != null) {
        result2.push(state2);
      }
    }
    return result2;
  }
};
mxGraphView.prototype.removeState = function(cell2) {
  let state2 = null;
  if (cell2 != null) {
    state2 = this.states.remove(cell2);
    if (state2 != null) {
      this.graph.cellRenderer.destroy(state2);
      state2.invalid = true;
      state2.destroy();
    }
  }
  return state2;
};
mxGraphView.prototype.createState = function(cell2) {
  return new mxCellState(this, cell2, this.graph.getCellStyle(cell2));
};
mxGraphView.prototype.getCanvas = function() {
  return this.canvas;
};
mxGraphView.prototype.getBackgroundPane = function() {
  return this.backgroundPane;
};
mxGraphView.prototype.getDrawPane = function() {
  return this.drawPane;
};
mxGraphView.prototype.getOverlayPane = function() {
  return this.overlayPane;
};
mxGraphView.prototype.getDecoratorPane = function() {
  return this.decoratorPane;
};
mxGraphView.prototype.isContainerEvent = function(evt) {
  const source = mxEvent2.getSource(evt);
  return source == this.graph.container || source.parentNode == this.backgroundPane || source.parentNode != null && source.parentNode.parentNode == this.backgroundPane || source == this.canvas.parentNode || source == this.canvas || source == this.backgroundPane || source == this.drawPane || source == this.overlayPane || source == this.decoratorPane;
};
mxGraphView.prototype.isScrollEvent = function(evt) {
  const offset = getOffset(this.graph.container);
  const pt = new mxPoint2(evt.clientX - offset.x, evt.clientY - offset.y);
  const outWidth = this.graph.container.offsetWidth;
  const inWidth = this.graph.container.clientWidth;
  if (outWidth > inWidth && pt.x > inWidth + 2 && pt.x <= outWidth) {
    return true;
  }
  const outHeight = this.graph.container.offsetHeight;
  const inHeight = this.graph.container.clientHeight;
  if (outHeight > inHeight && pt.y > inHeight + 2 && pt.y <= outHeight) {
    return true;
  }
  return false;
};
mxGraphView.prototype.init = function() {
  this.installListeners();
  const graph = this.graph;
  if (graph.dialect == mxConstants2.DIALECT_SVG) {
    this.createSvg();
  } else if (graph.dialect == mxConstants2.DIALECT_VML) {
    this.createVml();
  } else {
    this.createHtml();
  }
};
mxGraphView.prototype.installListeners = function() {
  const graph = this.graph;
  const container = graph.container;
  if (container != null) {
    if (mxClient2.IS_TOUCH) {
      mxEvent2.addListener(container, "gesturestart", bind(this, function(evt) {
        graph.fireGestureEvent(evt);
        mxEvent2.consume(evt);
      }));
      mxEvent2.addListener(container, "gesturechange", bind(this, function(evt) {
        graph.fireGestureEvent(evt);
        mxEvent2.consume(evt);
      }));
      mxEvent2.addListener(container, "gestureend", bind(this, function(evt) {
        graph.fireGestureEvent(evt);
        mxEvent2.consume(evt);
      }));
    }
    let pointerId = null;
    mxEvent2.addGestureListeners(container, bind(this, function(evt) {
      if (this.isContainerEvent(evt) && (!mxClient2.IS_IE && !mxClient2.IS_IE11 && !mxClient2.IS_GC && !mxClient2.IS_OP && !mxClient2.IS_SF || !this.isScrollEvent(evt))) {
        graph.fireMouseEvent(mxEvent2.MOUSE_DOWN, new mxMouseEvent2(evt));
        pointerId = evt.pointerId;
      }
    }), bind(this, function(evt) {
      if (this.isContainerEvent(evt) && (pointerId == null || evt.pointerId == pointerId)) {
        graph.fireMouseEvent(mxEvent2.MOUSE_MOVE, new mxMouseEvent2(evt));
      }
    }), bind(this, function(evt) {
      if (this.isContainerEvent(evt)) {
        graph.fireMouseEvent(mxEvent2.MOUSE_UP, new mxMouseEvent2(evt));
      }
      pointerId = null;
    }));
    mxEvent2.addListener(container, "dblclick", bind(this, function(evt) {
      if (this.isContainerEvent(evt)) {
        graph.dblClick(evt);
      }
    }));
    const getState = function(evt) {
      let state2 = null;
      if (mxClient2.IS_TOUCH) {
        const x = mxEvent2.getClientX(evt);
        const y = mxEvent2.getClientY(evt);
        const pt = convertPoint(container, x, y);
        state2 = graph.view.getState(graph.getCellAt(pt.x, pt.y));
      }
      return state2;
    };
    graph.addMouseListener({
      mouseDown: function(sender, me) {
        graph.popupMenuHandler.hideMenu();
      },
      mouseMove: function() {
      },
      mouseUp: function() {
      }
    });
    this.moveHandler = bind(this, function(evt) {
      if (graph.tooltipHandler != null && graph.tooltipHandler.isHideOnHover()) {
        graph.tooltipHandler.hide();
      }
      if (this.captureDocumentGesture && graph.isMouseDown && graph.container != null && !this.isContainerEvent(evt) && graph.container.style.display != "none" && graph.container.style.visibility != "hidden" && !mxEvent2.isConsumed(evt)) {
        graph.fireMouseEvent(mxEvent2.MOUSE_MOVE, new mxMouseEvent2(evt, getState(evt)));
      }
    });
    this.endHandler = bind(this, function(evt) {
      if (this.captureDocumentGesture && graph.isMouseDown && graph.container != null && !this.isContainerEvent(evt) && graph.container.style.display != "none" && graph.container.style.visibility != "hidden") {
        graph.fireMouseEvent(mxEvent2.MOUSE_UP, new mxMouseEvent2(evt));
      }
    });
    mxEvent2.addGestureListeners(document, null, this.moveHandler, this.endHandler);
  }
};
mxGraphView.prototype.createHtml = function() {
  const container = this.graph.container;
  if (container != null) {
    this.canvas = this.createHtmlPane("100%", "100%");
    this.canvas.style.overflow = "hidden";
    this.backgroundPane = this.createHtmlPane("1px", "1px");
    this.drawPane = this.createHtmlPane("1px", "1px");
    this.overlayPane = this.createHtmlPane("1px", "1px");
    this.decoratorPane = this.createHtmlPane("1px", "1px");
    this.canvas.appendChild(this.backgroundPane);
    this.canvas.appendChild(this.drawPane);
    this.canvas.appendChild(this.overlayPane);
    this.canvas.appendChild(this.decoratorPane);
    container.appendChild(this.canvas);
    this.updateContainerStyle(container);
    if (mxClient2.IS_QUIRKS) {
      const onResize = bind(this, function(evt) {
        const bounds = this.getGraphBounds();
        const width = bounds.x + bounds.width + this.graph.border;
        const height = bounds.y + bounds.height + this.graph.border;
        this.updateHtmlCanvasSize(width, height);
      });
      mxEvent2.addListener(window, "resize", onResize);
    }
  }
};
mxGraphView.prototype.updateHtmlCanvasSize = function(width, height) {
  if (this.graph.container != null) {
    const ow = this.graph.container.offsetWidth;
    const oh = this.graph.container.offsetHeight;
    if (ow < width) {
      this.canvas.style.width = width + "px";
    } else {
      this.canvas.style.width = "100%";
    }
    if (oh < height) {
      this.canvas.style.height = height + "px";
    } else {
      this.canvas.style.height = "100%";
    }
  }
};
mxGraphView.prototype.createHtmlPane = function(width, height) {
  const pane = document.createElement("DIV");
  if (width != null && height != null) {
    pane.style.position = "absolute";
    pane.style.left = "0px";
    pane.style.top = "0px";
    pane.style.width = width;
    pane.style.height = height;
  } else {
    pane.style.position = "relative";
  }
  return pane;
};
mxGraphView.prototype.createVml = function() {
  const container = this.graph.container;
  if (container != null) {
    const width = container.offsetWidth;
    const height = container.offsetHeight;
    this.canvas = this.createVmlPane(width, height);
    this.canvas.style.overflow = "hidden";
    this.backgroundPane = this.createVmlPane(width, height);
    this.drawPane = this.createVmlPane(width, height);
    this.overlayPane = this.createVmlPane(width, height);
    this.decoratorPane = this.createVmlPane(width, height);
    this.canvas.appendChild(this.backgroundPane);
    this.canvas.appendChild(this.drawPane);
    this.canvas.appendChild(this.overlayPane);
    this.canvas.appendChild(this.decoratorPane);
    container.appendChild(this.canvas);
  }
};
mxGraphView.prototype.createVmlPane = function(width, height) {
  const pane = document.createElement(mxClient2.VML_PREFIX + ":group");
  pane.style.position = "absolute";
  pane.style.left = "0px";
  pane.style.top = "0px";
  pane.style.width = width + "px";
  pane.style.height = height + "px";
  pane.setAttribute("coordsize", width + "," + height);
  pane.setAttribute("coordorigin", "0,0");
  return pane;
};
mxGraphView.prototype.createSvg = function() {
  const container = this.graph.container;
  this.canvas = document.createElementNS(mxConstants2.NS_SVG, "g");
  this.backgroundPane = document.createElementNS(mxConstants2.NS_SVG, "g");
  this.canvas.appendChild(this.backgroundPane);
  this.drawPane = document.createElementNS(mxConstants2.NS_SVG, "g");
  this.canvas.appendChild(this.drawPane);
  this.overlayPane = document.createElementNS(mxConstants2.NS_SVG, "g");
  this.canvas.appendChild(this.overlayPane);
  this.decoratorPane = document.createElementNS(mxConstants2.NS_SVG, "g");
  this.canvas.appendChild(this.decoratorPane);
  const root = document.createElementNS(mxConstants2.NS_SVG, "svg");
  root.style.left = "0px";
  root.style.top = "0px";
  root.style.width = "100%";
  root.style.height = "100%";
  root.style.display = "block";
  root.appendChild(this.canvas);
  if (mxClient2.IS_IE || mxClient2.IS_IE11) {
    root.style.overflow = "hidden";
  }
  if (container != null) {
    container.appendChild(root);
    this.updateContainerStyle(container);
  }
};
mxGraphView.prototype.updateContainerStyle = function(container) {
  const style = getCurrentStyle(container);
  if (style != null && style.position == "static") {
    container.style.position = "relative";
  }
  if (mxClient2.IS_POINTER) {
    container.style.touchAction = "none";
  }
};
mxGraphView.prototype.destroy = function() {
  let root = this.canvas != null ? this.canvas.ownerSVGElement : null;
  if (root == null) {
    root = this.canvas;
  }
  if (root != null && root.parentNode != null) {
    this.clear(this.currentRoot, true);
    mxEvent2.removeGestureListeners(document, null, this.moveHandler, this.endHandler);
    mxEvent2.release(this.graph.container);
    root.parentNode.removeChild(root);
    this.moveHandler = null;
    this.endHandler = null;
    this.canvas = null;
    this.backgroundPane = null;
    this.drawPane = null;
    this.overlayPane = null;
    this.decoratorPane = null;
  }
};

// js/graph/mxPanningHandler.js
var mxPanningHandler = function(graph) {
  if (graph != null) {
    this.graph = graph;
    this.graph.addMouseListener(this);
    this.forcePanningHandler = bind(this, function(sender, evt) {
      const evtName = evt.getProperty("eventName");
      const me = evt.getProperty("event");
      if (evtName === mxEvent2.MOUSE_DOWN && this.isForcePanningEvent(me)) {
        this.start(me);
        this.active = true;
        this.fireEvent(new mxEventObject2(mxEvent2.PAN_START, "event", me));
        me.consume();
      }
    });
    this.graph.addListener(mxEvent2.FIRE_MOUSE_EVENT, this.forcePanningHandler);
    this.gestureHandler = bind(this, function(sender, eo) {
      if (this.isPinchEnabled()) {
        const evt = eo.getProperty("event");
        if (!mxEvent2.isConsumed(evt) && evt.type === "gesturestart") {
          this.initialScale = this.graph.view.scale;
          if (!this.active && this.mouseDownEvent != null) {
            this.start(this.mouseDownEvent);
            this.mouseDownEvent = null;
          }
        } else if (evt.type === "gestureend" && this.initialScale != null) {
          this.initialScale = null;
        }
        if (this.initialScale != null) {
          this.zoomGraph(evt);
        }
      }
    });
    this.graph.addListener(mxEvent2.GESTURE, this.gestureHandler);
    this.mouseUpListener = bind(this, function() {
      if (this.active) {
        this.reset();
      }
    });
    mxEvent2.addListener(document, "mouseup", this.mouseUpListener);
  }
};
mxPanningHandler.prototype = new mxEventSource();
mxPanningHandler.prototype.constructor = mxPanningHandler;
mxPanningHandler.prototype.graph = null;
mxPanningHandler.prototype.useLeftButtonForPanning = false;
mxPanningHandler.prototype.usePopupTrigger = true;
mxPanningHandler.prototype.ignoreCell = false;
mxPanningHandler.prototype.previewEnabled = true;
mxPanningHandler.prototype.useGrid = false;
mxPanningHandler.prototype.panningEnabled = true;
mxPanningHandler.prototype.pinchEnabled = true;
mxPanningHandler.prototype.maxScale = 8;
mxPanningHandler.prototype.minScale = 0.01;
mxPanningHandler.prototype.dx = null;
mxPanningHandler.prototype.dy = null;
mxPanningHandler.prototype.startX = 0;
mxPanningHandler.prototype.startY = 0;
mxPanningHandler.prototype.isActive = function() {
  return this.active || this.initialScale != null;
};
mxPanningHandler.prototype.isPanningEnabled = function() {
  return this.panningEnabled;
};
mxPanningHandler.prototype.setPanningEnabled = function(value) {
  this.panningEnabled = value;
};
mxPanningHandler.prototype.isPinchEnabled = function() {
  return this.pinchEnabled;
};
mxPanningHandler.prototype.setPinchEnabled = function(value) {
  this.pinchEnabled = value;
};
mxPanningHandler.prototype.isPanningTrigger = function(me) {
  const evt = me.getEvent();
  return this.useLeftButtonForPanning && me.getState() == null && mxEvent2.isLeftMouseButton(evt) || mxEvent2.isControlDown(evt) && mxEvent2.isShiftDown(evt) || this.usePopupTrigger && mxEvent2.isPopupTrigger(evt);
};
mxPanningHandler.prototype.isForcePanningEvent = function(me) {
  return this.ignoreCell || mxEvent2.isMultiTouchEvent(me.getEvent());
};
mxPanningHandler.prototype.mouseDown = function(sender, me) {
  this.mouseDownEvent = me;
  if (!me.isConsumed() && this.isPanningEnabled() && !this.active && this.isPanningTrigger(me)) {
    this.start(me);
    this.consumePanningTrigger(me);
  }
};
mxPanningHandler.prototype.start = function(me) {
  this.dx0 = -this.graph.container.scrollLeft;
  this.dy0 = -this.graph.container.scrollTop;
  this.startX = me.getX();
  this.startY = me.getY();
  this.dx = null;
  this.dy = null;
  this.panningTrigger = true;
};
mxPanningHandler.prototype.consumePanningTrigger = function(me) {
  me.consume();
};
mxPanningHandler.prototype.mouseMove = function(sender, me) {
  this.dx = me.getX() - this.startX;
  this.dy = me.getY() - this.startY;
  if (this.active) {
    if (this.previewEnabled) {
      if (this.useGrid) {
        this.dx = this.graph.snap(this.dx);
        this.dy = this.graph.snap(this.dy);
      }
      this.graph.panGraph(this.dx + this.dx0, this.dy + this.dy0);
    }
    this.fireEvent(new mxEventObject2(mxEvent2.PAN, "event", me));
  } else if (this.panningTrigger) {
    const tmp = this.active;
    this.active = Math.abs(this.dx) > this.graph.tolerance || Math.abs(this.dy) > this.graph.tolerance;
    if (!tmp && this.active) {
      this.fireEvent(new mxEventObject2(mxEvent2.PAN_START, "event", me));
    }
  }
  if (this.active || this.panningTrigger) {
    me.consume();
  }
};
mxPanningHandler.prototype.mouseUp = function(sender, me) {
  if (this.active) {
    if (this.dx != null && this.dy != null) {
      if (!this.graph.useScrollbarsForPanning || !hasScrollbars(this.graph.container)) {
        const scale = this.graph.getView().scale;
        const t = this.graph.getView().translate;
        this.graph.panGraph(0, 0);
        this.panGraph(t.x + this.dx / scale, t.y + this.dy / scale);
      }
      me.consume();
    }
    this.fireEvent(new mxEventObject2(mxEvent2.PAN_END, "event", me));
  }
  this.reset();
};
mxPanningHandler.prototype.zoomGraph = function(evt) {
  let value = Math.round(this.initialScale * evt.scale * 100) / 100;
  if (this.minScale != null) {
    value = Math.max(this.minScale, value);
  }
  if (this.maxScale != null) {
    value = Math.min(this.maxScale, value);
  }
  if (this.graph.view.scale !== value) {
    this.graph.zoomTo(value);
    mxEvent2.consume(evt);
  }
};
mxPanningHandler.prototype.reset = function() {
  this.panningTrigger = false;
  this.mouseDownEvent = null;
  this.active = false;
  this.dx = null;
  this.dy = null;
};
mxPanningHandler.prototype.panGraph = function(dx, dy) {
  this.graph.getView().setTranslate(dx, dy);
};
mxPanningHandler.prototype.destroy = function() {
  this.graph.removeMouseListener(this);
  this.graph.removeListener(this.forcePanningHandler);
  this.graph.removeListener(this.gestureHandler);
  mxEvent2.removeListener(document, "mouseup", this.mouseUpListener);
};

// js/graph/mxPanningManager.js
function mxPanningManager(graph) {
  this.thread = null;
  this.active = false;
  this.tdx = 0;
  this.tdy = 0;
  this.t0x = 0;
  this.t0y = 0;
  this.dx = 0;
  this.dy = 0;
  this.scrollbars = false;
  this.scrollLeft = 0;
  this.scrollTop = 0;
  const mouseListener = {
    mouseDown: function(sender, me) {
    },
    mouseMove: function(sender, me) {
    },
    mouseUp: bind(this, function(sender, me) {
      if (this.active) {
        this.stop();
      }
    })
  };
  this.mouseListener = mouseListener;
  graph.addMouseListener(this.mouseListener);
  this.mouseUpListener = bind(this, function() {
    if (this.active) {
      this.stop();
    }
  });
  mxEvent2.addListener(document, "mouseup", this.mouseUpListener);
  const createThread = bind(this, function() {
    this.scrollbars = hasScrollbars(graph.container);
    this.scrollLeft = graph.container.scrollLeft;
    this.scrollTop = graph.container.scrollTop;
    return window.setInterval(bind(this, function() {
      this.tdx -= this.dx;
      this.tdy -= this.dy;
      if (this.scrollbars) {
        const left = -graph.container.scrollLeft - Math.ceil(this.dx);
        const top = -graph.container.scrollTop - Math.ceil(this.dy);
        graph.panGraph(left, top);
        graph.panDx = this.scrollLeft - graph.container.scrollLeft;
        graph.panDy = this.scrollTop - graph.container.scrollTop;
        graph.fireEvent(new mxEventObject2(mxEvent2.PAN));
      } else {
        graph.panGraph(this.getDx(), this.getDy());
      }
    }), this.delay);
  });
  this.isActive = function() {
    return this.active;
  };
  this.getDx = function() {
    return Math.round(this.tdx);
  };
  this.getDy = function() {
    return Math.round(this.tdy);
  };
  this.start = function() {
    this.t0x = graph.view.translate.x;
    this.t0y = graph.view.translate.y;
    this.active = true;
  };
  this.panTo = function(x, y, w2 = 0, h2 = 0) {
    if (!this.active) {
      this.start();
    }
    this.scrollLeft = graph.container.scrollLeft;
    this.scrollTop = graph.container.scrollTop;
    const c = graph.container;
    let dx = x + w2 - c.scrollLeft - c.clientWidth;
    if (dx < 0 && Math.abs(dx) < this.border) {
      dx = this.border + dx;
    } else if (this.handleMouseOut) {
      dx = Math.max(dx, 0);
    } else {
      dx = 0;
    }
    if (dx === 0) {
      dx = x - c.scrollLeft;
      if (dx > 0 && dx < this.border) {
        dx = dx - this.border;
      } else if (this.handleMouseOut) {
        dx = Math.min(0, dx);
      } else {
        dx = 0;
      }
    }
    let dy = y + h2 - c.scrollTop - c.clientHeight;
    if (dy < 0 && Math.abs(dy) < this.border) {
      dy = this.border + dy;
    } else if (this.handleMouseOut) {
      dy = Math.max(dy, 0);
    } else {
      dy = 0;
    }
    if (dy === 0) {
      dy = y - c.scrollTop;
      if (dy > 0 && dy < this.border) {
        dy = dy - this.border;
      } else if (this.handleMouseOut) {
        dy = Math.min(0, dy);
      } else {
        dy = 0;
      }
    }
    this.dx = dx * this.damper;
    this.dy = dy * this.damper;
    if (this.dx !== 0 || this.dy !== 0) {
      if (this.thread == null) {
        this.thread = createThread();
      }
    } else if (this.thread != null) {
      window.clearInterval(this.thread);
      this.thread = null;
    }
  };
  this.stop = function() {
    if (this.active) {
      this.active = false;
      if (this.thread != null) {
        window.clearInterval(this.thread);
        this.thread = null;
      }
      this.tdx = 0;
      this.tdy = 0;
      if (!this.scrollbars) {
        const px = graph.panDx;
        const py = graph.panDy;
        if (px !== 0 || py !== 0) {
          graph.panGraph(0, 0);
          graph.view.setTranslate(this.t0x + px / graph.view.scale, this.t0y + py / graph.view.scale);
        }
      } else {
        graph.panDx = 0;
        graph.panDy = 0;
        graph.fireEvent(new mxEventObject2(mxEvent2.PAN));
      }
    }
  };
  this.destroy = function() {
    graph.removeMouseListener(this.mouseListener);
    mxEvent2.removeListener(document, "mouseup", this.mouseUpListener);
  };
}
mxPanningManager.prototype.damper = 1 / 6;
mxPanningManager.prototype.delay = 10;
mxPanningManager.prototype.handleMouseOut = true;
mxPanningManager.prototype.border = 0;

// js/graph/mxPopupMenu.js
function mxPopupMenu(factoryMethod) {
  this.factoryMethod = factoryMethod;
  if (factoryMethod != null) {
    this.init();
  }
}
mxPopupMenu.prototype = new mxEventSource();
mxPopupMenu.prototype.constructor = mxPopupMenu;
mxPopupMenu.prototype.submenuImage = mxClient_default.imageBasePath + "/submenu.gif";
mxPopupMenu.prototype.zIndex = 10006;
mxPopupMenu.prototype.factoryMethod = null;
mxPopupMenu.prototype.useLeftButtonForPopup = false;
mxPopupMenu.prototype.enabled = true;
mxPopupMenu.prototype.itemCount = 0;
mxPopupMenu.prototype.autoExpand = false;
mxPopupMenu.prototype.smartSeparators = false;
mxPopupMenu.prototype.labels = true;
mxPopupMenu.prototype.init = function() {
  this.table = document.createElement("table");
  this.table.className = "mxPopupMenu";
  this.tbody = document.createElement("tbody");
  this.table.appendChild(this.tbody);
  this.div = document.createElement("div");
  this.div.className = "mxPopupMenu";
  this.div.style.display = "inline";
  this.div.style.zIndex = this.zIndex;
  this.div.appendChild(this.table);
  mxEvent2.disableContextMenu(this.div);
};
mxPopupMenu.prototype.isEnabled = function() {
  return this.enabled;
};
mxPopupMenu.prototype.setEnabled = function(enabled) {
  this.enabled = enabled;
};
mxPopupMenu.prototype.isPopupTrigger = function(me) {
  return me.isPopupTrigger() || this.useLeftButtonForPopup && mxEvent2.isLeftMouseButton(me.getEvent());
};
mxPopupMenu.prototype.addItem = function(title, image, funct, parent2, iconCls, enabled, active, noHover) {
  parent2 = parent2 || this;
  this.itemCount++;
  if (parent2.willAddSeparator) {
    if (parent2.containsItems) {
      this.addSeparator(parent2, true);
    }
    parent2.willAddSeparator = false;
  }
  parent2.containsItems = true;
  const tr = document.createElement("tr");
  tr.className = "mxPopupMenuItem";
  const col1 = document.createElement("td");
  col1.className = "mxPopupMenuIcon";
  if (image != null) {
    const img = document.createElement("img");
    img.src = image;
    col1.appendChild(img);
  } else if (iconCls != null) {
    const div = document.createElement("div");
    div.className = iconCls;
    col1.appendChild(div);
  }
  tr.appendChild(col1);
  if (this.labels) {
    const col2 = document.createElement("td");
    col2.className = "mxPopupMenuItem" + (enabled != null && !enabled ? " mxDisabled" : "");
    write(col2, title);
    col2.align = "left";
    tr.appendChild(col2);
    const col3 = document.createElement("td");
    col3.className = "mxPopupMenuItem" + (enabled != null && !enabled ? " mxDisabled" : "");
    col3.style.paddingRight = "6px";
    col3.style.textAlign = "right";
    tr.appendChild(col3);
    if (parent2.div == null) {
      this.createSubmenu(parent2);
    }
  }
  parent2.tbody.appendChild(tr);
  if (active != false && enabled != false) {
    let currentSelection = null;
    mxEvent2.addGestureListeners(tr, bind(this, function(evt) {
      this.eventReceiver = tr;
      if (parent2.activeRow != tr && parent2.activeRow != parent2) {
        if (parent2.activeRow != null && parent2.activeRow.div.parentNode != null) {
          this.hideSubmenu(parent2);
        }
        if (tr.div != null) {
          this.showSubmenu(parent2, tr);
          parent2.activeRow = tr;
        }
      }
      if (document.selection != null && (mxClient_default.IS_QUIRKS || document.documentMode == 8)) {
        currentSelection = document.selection.createRange();
      }
      mxEvent2.consume(evt);
    }), bind(this, function(evt) {
      if (parent2.activeRow != tr && parent2.activeRow != parent2) {
        if (parent2.activeRow != null && parent2.activeRow.div.parentNode != null) {
          this.hideSubmenu(parent2);
        }
        if (this.autoExpand && tr.div != null) {
          this.showSubmenu(parent2, tr);
          parent2.activeRow = tr;
        }
      }
      if (!noHover) {
        tr.className = "mxPopupMenuItemHover";
      }
    }), bind(this, function(evt) {
      if (this.eventReceiver == tr) {
        if (parent2.activeRow != tr) {
          this.hideMenu();
        }
        if (currentSelection != null) {
          try {
            currentSelection.select();
          } catch (e) {
          }
          currentSelection = null;
        }
        if (funct != null) {
          funct(evt);
        }
      }
      this.eventReceiver = null;
      mxEvent2.consume(evt);
    }));
    if (!noHover) {
      mxEvent2.addListener(tr, "mouseout", bind(this, function(evt) {
        tr.className = "mxPopupMenuItem";
      }));
    }
  }
  return tr;
};
mxPopupMenu.prototype.addCheckmark = function(item, img) {
  const td = item.firstChild.nextSibling;
  td.style.backgroundImage = "url('" + img + "')";
  td.style.backgroundRepeat = "no-repeat";
  td.style.backgroundPosition = "2px 50%";
};
mxPopupMenu.prototype.createSubmenu = function(parent2) {
  parent2.table = document.createElement("table");
  parent2.table.className = "mxPopupMenu";
  parent2.tbody = document.createElement("tbody");
  parent2.table.appendChild(parent2.tbody);
  parent2.div = document.createElement("div");
  parent2.div.className = "mxPopupMenu";
  parent2.div.style.position = "absolute";
  parent2.div.style.display = "inline";
  parent2.div.style.zIndex = this.zIndex;
  parent2.div.appendChild(parent2.table);
  const img = document.createElement("img");
  img.setAttribute("src", this.submenuImage);
  const td = parent2.firstChild.nextSibling.nextSibling;
  td.appendChild(img);
};
mxPopupMenu.prototype.showSubmenu = function(parent2, row) {
  if (row.div != null) {
    row.div.style.left = parent2.div.offsetLeft + row.offsetLeft + row.offsetWidth - 1 + "px";
    row.div.style.top = parent2.div.offsetTop + row.offsetTop + "px";
    document.body.appendChild(row.div);
    const left = parseInt(row.div.offsetLeft);
    const width = parseInt(row.div.offsetWidth);
    const offset = getDocumentScrollOrigin(document);
    const b = document.body;
    const d = document.documentElement;
    const right = offset.x + (b.clientWidth || d.clientWidth);
    if (left + width > right) {
      row.div.style.left = Math.max(0, parent2.div.offsetLeft - width + (mxClient_default.IS_IE ? 6 : -6)) + "px";
    }
    fit(row.div);
  }
};
mxPopupMenu.prototype.addSeparator = function(parent2, force) {
  parent2 = parent2 || this;
  if (this.smartSeparators && !force) {
    parent2.willAddSeparator = true;
  } else if (parent2.tbody != null) {
    parent2.willAddSeparator = false;
    const tr = document.createElement("tr");
    const col1 = document.createElement("td");
    col1.className = "mxPopupMenuIcon";
    col1.style.padding = "0 0 0 0px";
    tr.appendChild(col1);
    const col2 = document.createElement("td");
    col2.style.padding = "0 0 0 0px";
    col2.setAttribute("colSpan", "2");
    const hr = document.createElement("hr");
    hr.setAttribute("size", "1");
    col2.appendChild(hr);
    tr.appendChild(col2);
    parent2.tbody.appendChild(tr);
  }
};
mxPopupMenu.prototype.popup = function(x, y, cell2, evt) {
  if (this.div != null && this.tbody != null && this.factoryMethod != null) {
    this.div.style.left = x + "px";
    this.div.style.top = y + "px";
    while (this.tbody.firstChild != null) {
      mxEvent2.release(this.tbody.firstChild);
      this.tbody.removeChild(this.tbody.firstChild);
    }
    this.itemCount = 0;
    this.factoryMethod(this, cell2, evt);
    if (this.itemCount > 0) {
      this.showMenu();
      this.fireEvent(new mxEventObject2(mxEvent2.SHOW));
    }
  }
};
mxPopupMenu.prototype.isMenuShowing = function() {
  return this.div != null && this.div.parentNode == document.body;
};
mxPopupMenu.prototype.showMenu = function() {
  if (document.documentMode >= 9) {
    this.div.style.filter = "none";
  }
  document.body.appendChild(this.div);
  fit(this.div);
};
mxPopupMenu.prototype.hideMenu = function() {
  if (this.div != null) {
    if (this.div.parentNode != null) {
      this.div.parentNode.removeChild(this.div);
    }
    this.hideSubmenu(this);
    this.containsItems = false;
    this.fireEvent(new mxEventObject2(mxEvent2.HIDE));
  }
};
mxPopupMenu.prototype.hideSubmenu = function(parent2) {
  if (parent2.activeRow != null) {
    this.hideSubmenu(parent2.activeRow);
    if (parent2.activeRow.div.parentNode != null) {
      parent2.activeRow.div.parentNode.removeChild(parent2.activeRow.div);
    }
    parent2.activeRow = null;
  }
};
mxPopupMenu.prototype.destroy = function() {
  if (this.div != null) {
    mxEvent2.release(this.div);
    if (this.div.parentNode != null) {
      this.div.parentNode.removeChild(this.div);
    }
    this.div = null;
  }
};

// js/graph/mxPopupMenuHandler.js
var mxPopupMenuHandler = function(graph, factoryMethod) {
  if (graph != null) {
    this.graph = graph;
    this.factoryMethod = factoryMethod;
    this.graph.addMouseListener(this);
    this.gestureHandler = bind(this, (sender, eo) => {
      this.inTolerance = false;
    });
    this.graph.addListener(mxEvent2.GESTURE, this.gestureHandler);
    this.init();
  }
};
mxPopupMenuHandler.prototype = new mxPopupMenu();
mxPopupMenuHandler.prototype.constructor = mxPopupMenuHandler;
mxPopupMenuHandler.prototype.graph = null;
mxPopupMenuHandler.prototype.selectOnPopup = true;
mxPopupMenuHandler.prototype.clearSelectionOnBackground = true;
mxPopupMenuHandler.prototype.triggerX = null;
mxPopupMenuHandler.prototype.triggerY = null;
mxPopupMenuHandler.prototype.screenX = null;
mxPopupMenuHandler.prototype.screenY = null;
mxPopupMenuHandler.prototype.init = function() {
  mxPopupMenu.prototype.init.apply(this);
  mxEvent2.addGestureListeners(this.div, bind(this, (evt) => {
    this.graph.tooltipHandler.hide();
  }));
};
mxPopupMenuHandler.prototype.isSelectOnPopup = function(me) {
  return this.selectOnPopup;
};
mxPopupMenuHandler.prototype.mouseDown = function(sender, me) {
  if (this.isEnabled() && !mxEvent2.isMultiTouchEvent(me.getEvent())) {
    this.hideMenu();
    this.triggerX = me.getGraphX();
    this.triggerY = me.getGraphY();
    this.screenX = mxEvent2.getMainEvent(me.getEvent()).screenX;
    this.screenY = mxEvent2.getMainEvent(me.getEvent()).screenY;
    this.popupTrigger = this.isPopupTrigger(me);
    this.inTolerance = true;
  }
};
mxPopupMenuHandler.prototype.mouseMove = function(sender, me) {
  if (this.inTolerance && this.screenX != null && this.screenY != null) {
    const mainEvent = mxEvent2.getMainEvent(me.getEvent());
    if (Math.abs(mainEvent.screenX - this.screenX) > this.graph.tolerance || Math.abs(mainEvent.screenY - this.screenY) > this.graph.tolerance) {
      this.inTolerance = false;
    }
  }
};
mxPopupMenuHandler.prototype.mouseUp = function(sender, me) {
  if (this.popupTrigger && this.inTolerance && this.triggerX != null && this.triggerY != null) {
    const cell2 = this.getCellForPopupEvent(me);
    if (this.graph.isEnabled() && this.isSelectOnPopup(me) && cell2 != null && !this.graph.isCellSelected(cell2)) {
      this.graph.setSelectionCell(cell2);
    } else if (this.clearSelectionOnBackground && cell2 == null) {
      this.graph.clearSelection();
    }
    this.graph.tooltipHandler.hide();
    const origin = getScrollOrigin();
    this.popup(me.getX() + origin.x + 1, me.getY() + origin.y + 1, cell2, me.getEvent());
    me.consume();
  }
  this.popupTrigger = false;
  this.inTolerance = false;
};
mxPopupMenuHandler.prototype.getCellForPopupEvent = function(me) {
  return me.getCell();
};
mxPopupMenuHandler.prototype.destroy = function() {
  this.graph.removeMouseListener(this);
  this.graph.removeListener(this.gestureHandler);
  mxPopupMenu.prototype.destroy.apply(this);
};

// js/graph/mxSelectionCellsHandler.js
function mxSelectionCellsHandler(graph) {
  mxEventSource.call(this);
  this.graph = graph;
  this.handlers = new mxDictionary();
  this.graph.addMouseListener(this);
  this.refreshHandler = bind(this, function(sender, evt) {
    if (this.isEnabled()) {
      this.refresh();
    }
  });
  this.graph.getSelectionModel().addListener(mxEvent2.CHANGE, this.refreshHandler);
  this.graph.getModel().addListener(mxEvent2.CHANGE, this.refreshHandler);
  this.graph.getView().addListener(mxEvent2.SCALE, this.refreshHandler);
  this.graph.getView().addListener(mxEvent2.TRANSLATE, this.refreshHandler);
  this.graph.getView().addListener(mxEvent2.SCALE_AND_TRANSLATE, this.refreshHandler);
  this.graph.getView().addListener(mxEvent2.DOWN, this.refreshHandler);
  this.graph.getView().addListener(mxEvent2.UP, this.refreshHandler);
}
extend(mxSelectionCellsHandler, mxEventSource);
mxSelectionCellsHandler.prototype.graph = null;
mxSelectionCellsHandler.prototype.enabled = true;
mxSelectionCellsHandler.prototype.refreshHandler = null;
mxSelectionCellsHandler.prototype.maxHandlers = 100;
mxSelectionCellsHandler.prototype.handlers = null;
mxSelectionCellsHandler.prototype.isEnabled = function() {
  return this.enabled;
};
mxSelectionCellsHandler.prototype.setEnabled = function(value) {
  this.enabled = value;
};
mxSelectionCellsHandler.prototype.getHandler = function(cell2) {
  return this.handlers.get(cell2);
};
mxSelectionCellsHandler.prototype.isHandled = function(cell2) {
  return this.getHandler(cell2) != null;
};
mxSelectionCellsHandler.prototype.reset = function() {
  this.handlers.visit(function(key, handler) {
    handler.reset.apply(handler);
  });
};
mxSelectionCellsHandler.prototype.getHandledSelectionCells = function() {
  return this.graph.getSelectionCells();
};
mxSelectionCellsHandler.prototype.refresh = function() {
  const oldHandlers = this.handlers;
  this.handlers = new mxDictionary();
  const tmp = sortCells(this.getHandledSelectionCells(), false);
  for (let i = 0; i < tmp.length; i++) {
    const state2 = this.graph.view.getState(tmp[i]);
    if (state2 != null) {
      let handler = oldHandlers.remove(tmp[i]);
      if (handler != null) {
        if (handler.state != state2) {
          handler.destroy();
          handler = null;
        } else if (!this.isHandlerActive(handler)) {
          if (handler.refresh != null) {
            handler.refresh();
          }
          handler.redraw();
        }
      }
      if (handler != null) {
        this.handlers.put(tmp[i], handler);
      }
    }
  }
  oldHandlers.visit(bind(this, function(key, handler) {
    this.fireEvent(new mxEventObject2(mxEvent2.REMOVE, "state", handler.state));
    handler.destroy();
  }));
  for (let i = 0; i < tmp.length; i++) {
    const state2 = this.graph.view.getState(tmp[i]);
    if (state2 != null) {
      let handler = this.handlers.get(tmp[i]);
      if (handler == null) {
        handler = this.graph.createHandler(state2);
        this.fireEvent(new mxEventObject2(mxEvent2.ADD, "state", state2));
        this.handlers.put(tmp[i], handler);
      } else {
        handler.updateParentHighlight();
      }
    }
  }
};
mxSelectionCellsHandler.prototype.isHandlerActive = function(handler) {
  return handler.index != null;
};
mxSelectionCellsHandler.prototype.updateHandler = function(state2) {
  let handler = this.handlers.remove(state2.cell);
  if (handler != null) {
    const index = handler.index;
    const x = handler.startX;
    const y = handler.startY;
    handler.destroy();
    handler = this.graph.createHandler(state2);
    if (handler != null) {
      this.handlers.put(state2.cell, handler);
      if (index != null && x != null && y != null) {
        handler.start(x, y, index);
      }
    }
  }
};
mxSelectionCellsHandler.prototype.mouseDown = function(sender, me) {
  if (this.graph.isEnabled() && this.isEnabled()) {
    const args = [sender, me];
    this.handlers.visit(function(key, handler) {
      handler.mouseDown.apply(handler, args);
    });
  }
};
mxSelectionCellsHandler.prototype.mouseMove = function(sender, me) {
  if (this.graph.isEnabled() && this.isEnabled()) {
    const args = [sender, me];
    this.handlers.visit(function(key, handler) {
      handler.mouseMove.apply(handler, args);
    });
  }
};
mxSelectionCellsHandler.prototype.mouseUp = function(sender, me) {
  if (this.graph.isEnabled() && this.isEnabled()) {
    const args = [sender, me];
    this.handlers.visit(function(key, handler) {
      handler.mouseUp.apply(handler, args);
    });
  }
};
mxSelectionCellsHandler.prototype.destroy = function() {
  this.graph.removeMouseListener(this);
  if (this.refreshHandler != null) {
    this.graph.getSelectionModel().removeListener(this.refreshHandler);
    this.graph.getModel().removeListener(this.refreshHandler);
    this.graph.getView().removeListener(this.refreshHandler);
    this.refreshHandler = null;
  }
};

// js/graph/mxStylesheet.js
function mxStylesheet() {
  this.styles = {};
  this.putDefaultVertexStyle(this.createDefaultVertexStyle());
  this.putDefaultEdgeStyle(this.createDefaultEdgeStyle());
}
mxStylesheet.prototype.styles;
mxStylesheet.prototype.createDefaultVertexStyle = function() {
  const style = {};
  style[mxConstants2.STYLE_SHAPE] = mxConstants2.SHAPE_RECTANGLE;
  style[mxConstants2.STYLE_PERIMETER] = RectanglePerimeter;
  style[mxConstants2.STYLE_VERTICAL_ALIGN] = mxConstants2.ALIGN_MIDDLE;
  style[mxConstants2.STYLE_ALIGN] = mxConstants2.ALIGN_CENTER;
  style[mxConstants2.STYLE_FILLCOLOR] = "#C3D9FF";
  style[mxConstants2.STYLE_STROKECOLOR] = "#6482B9";
  style[mxConstants2.STYLE_FONTCOLOR] = "#774400";
  return style;
};
mxStylesheet.prototype.createDefaultEdgeStyle = function() {
  const style = {};
  style[mxConstants2.STYLE_SHAPE] = mxConstants2.SHAPE_CONNECTOR;
  style[mxConstants2.STYLE_ENDARROW] = mxConstants2.ARROW_CLASSIC;
  style[mxConstants2.STYLE_VERTICAL_ALIGN] = mxConstants2.ALIGN_MIDDLE;
  style[mxConstants2.STYLE_ALIGN] = mxConstants2.ALIGN_CENTER;
  style[mxConstants2.STYLE_STROKECOLOR] = "#6482B9";
  style[mxConstants2.STYLE_FONTCOLOR] = "#446299";
  return style;
};
mxStylesheet.prototype.putDefaultVertexStyle = function(style) {
  this.putCellStyle("defaultVertex", style);
};
mxStylesheet.prototype.putDefaultEdgeStyle = function(style) {
  this.putCellStyle("defaultEdge", style);
};
mxStylesheet.prototype.getDefaultVertexStyle = function() {
  return this.styles["defaultVertex"];
};
mxStylesheet.prototype.getDefaultEdgeStyle = function() {
  return this.styles["defaultEdge"];
};
mxStylesheet.prototype.putCellStyle = function(name, style) {
  this.styles[name] = style;
};
mxStylesheet.prototype.getCellStyle = function(name, defaultStyle) {
  let style = defaultStyle;
  if (name != null && name.length > 0) {
    const pairs = name.split(";");
    if (style != null && name.charAt(0) !== ";") {
      style = clone(style);
    } else {
      style = {};
    }
    for (let i = 0; i < pairs.length; i++) {
      const tmp = pairs[i];
      const pos = tmp.indexOf("=");
      if (pos >= 0) {
        const key = tmp.substring(0, pos);
        const value = tmp.substring(pos + 1);
        if (value === mxConstants2.NONE) {
          delete style[key];
        } else if (isNumeric(value)) {
          style[key] = parseFloat(value);
        } else {
          style[key] = value;
        }
      } else {
        const tmpStyle = this.styles[tmp];
        if (tmpStyle != null) {
          for (const k in tmpStyle) {
            style[k] = tmpStyle[k];
          }
        }
      }
    }
  }
  return style;
};

// js/graph/mxTooltipHandler.js
var TOOLTIP_ZINDEX = 10005;
var IGNORE_TOUCH_EVENTS = true;
var HIDE_ON_HOVER = false;
var DEFAULT_ENABLED = true;
var mxTooltipHandler = function(graph, delay) {
  if (graph != null) {
    this.graph = graph;
    this.delay = delay || 500;
    this.graph.addMouseListener(this);
  }
};
mxTooltipHandler.prototype.zIndex = TOOLTIP_ZINDEX;
mxTooltipHandler.prototype.graph = null;
mxTooltipHandler.prototype.delay = null;
mxTooltipHandler.prototype.ignoreTouchEvents = IGNORE_TOUCH_EVENTS;
mxTooltipHandler.prototype.hideOnHover = HIDE_ON_HOVER;
mxTooltipHandler.prototype.destroyed = false;
mxTooltipHandler.prototype.enabled = DEFAULT_ENABLED;
var isEnabled = function() {
  return this.enabled;
};
mxTooltipHandler.prototype.isEnabled = isEnabled;
var setEnabled = function(enabled) {
  this.enabled = enabled;
};
mxTooltipHandler.prototype.setEnabled = setEnabled;
var isHideOnHover = function() {
  return this.hideOnHover;
};
mxTooltipHandler.prototype.isHideOnHover = isHideOnHover;
var setHideOnHover = function(value) {
  this.hideOnHover = value;
};
mxTooltipHandler.prototype.setHideOnHover = setHideOnHover;
var init = function() {
  if (document.body != null) {
    this.div = document.createElement("div");
    this.div.className = "mxTooltip";
    this.div.style.visibility = "hidden";
    document.body.appendChild(this.div);
    mxEvent2.addGestureListeners(this.div, bind(this, (evt) => {
      const source = mxEvent2.getSource(evt);
      if (source.nodeName !== "A") {
        this.hideTooltip();
      }
    }));
  }
};
mxTooltipHandler.prototype.init = init;
var getStateForEvent = function(me) {
  return me.getState();
};
mxTooltipHandler.prototype.getStateForEvent = getStateForEvent;
var mouseDown = function(sender, me) {
  this.reset(me, false);
  this.hideTooltip();
};
mxTooltipHandler.prototype.mouseDown = mouseDown;
var mouseMove = function(sender, me) {
  if (me.getX() !== this.lastX || me.getY() !== this.lastY) {
    this.reset(me, true);
    const state2 = this.getStateForEvent(me);
    if (this.isHideOnHover() || state2 !== this.state || me.getSource() !== this.node && (!this.stateSource || state2 != null && this.stateSource === (me.isSource(state2.shape) || !me.isSource(state2.text)))) {
      this.hideTooltip();
    }
  }
  this.lastX = me.getX();
  this.lastY = me.getY();
};
mxTooltipHandler.prototype.mouseMove = mouseMove;
var mouseUp = function(sender, me) {
  this.reset(me, true);
  this.hideTooltip();
};
mxTooltipHandler.prototype.mouseUp = mouseUp;
var resetTimer = function() {
  if (this.thread != null) {
    window.clearTimeout(this.thread);
    this.thread = null;
  }
};
mxTooltipHandler.prototype.resetTimer = resetTimer;
var reset = function(me, restart, state2) {
  if (!this.ignoreTouchEvents || mxEvent2.isMouseEvent(me.getEvent())) {
    this.resetTimer();
    state2 = state2 != null ? state2 : this.getStateForEvent(me);
    if (restart && this.isEnabled() && state2 != null && (this.div == null || this.div.style.visibility === "hidden")) {
      const node = me.getSource();
      const x = me.getX();
      const y = me.getY();
      const stateSource = me.isSource(state2.shape) || me.isSource(state2.text);
      this.thread = window.setTimeout(bind(this, () => {
        if (!this.graph.isEditing() && !this.graph.popupMenuHandler.isMenuShowing() && !this.graph.isMouseDown) {
          const tip = this.graph.getTooltip(state2, node, x, y);
          this.show(tip, x, y);
          this.state = state2;
          this.node = node;
          this.stateSource = stateSource;
        }
      }), this.delay);
    }
  }
};
mxTooltipHandler.prototype.reset = reset;
var hide2 = function() {
  this.resetTimer();
  this.hideTooltip();
};
mxTooltipHandler.prototype.hide = hide2;
var hideTooltip = function() {
  if (this.div != null) {
    this.div.style.visibility = "hidden";
    this.div.innerHTML = "";
  }
};
mxTooltipHandler.prototype.hideTooltip = hideTooltip;
var show2 = function(tip, x, y) {
  if (!this.destroyed && tip != null && tip.length > 0) {
    if (this.div == null) {
      this.init();
    }
    const origin = getScrollOrigin();
    this.div.style.zIndex = this.zIndex;
    this.div.style.left = x + origin.x + "px";
    this.div.style.top = y + mxConstants2.TOOLTIP_VERTICAL_OFFSET + origin.y + "px";
    if (!isNode(tip)) {
      this.div.innerHTML = tip.replace(/\n/g, "<br>");
    } else {
      this.div.innerHTML = "";
      this.div.appendChild(tip);
    }
    this.div.style.visibility = "";
    fit(this.div);
  }
};
mxTooltipHandler.prototype.show = show2;
var destroy3 = function() {
  if (!this.destroyed) {
    this.graph.removeMouseListener(this);
    mxEvent2.release(this.div);
    if (this.div != null && this.div.parentNode != null) {
      this.div.parentNode.removeChild(this.div);
    }
    this.destroyed = true;
    this.div = null;
  }
};
mxTooltipHandler.prototype.destroy = destroy3;

// js/graph/mxGraph.js
function mxGraph2(container, model, renderHint, stylesheet) {
  this.mouseListeners = null;
  this.renderHint = renderHint;
  if (mxClient_default.IS_SVG) {
    this.dialect = mxConstants2.DIALECT_SVG;
  } else if (renderHint == mxConstants2.RENDERING_HINT_EXACT && mxClient_default.IS_VML) {
    this.dialect = mxConstants2.DIALECT_VML;
  } else if (renderHint == mxConstants2.RENDERING_HINT_FASTEST) {
    this.dialect = mxConstants2.DIALECT_STRICTHTML;
  } else if (renderHint == mxConstants2.RENDERING_HINT_FASTER) {
    this.dialect = mxConstants2.DIALECT_PREFERHTML;
  } else {
    this.dialect = mxConstants2.DIALECT_MIXEDHTML;
  }
  this.model = model != null ? model : new mxGraphModel2();
  this.multiplicities = [];
  this.imageBundles = [];
  this.cellRenderer = this.createCellRenderer();
  this.setSelectionModel(this.createSelectionModel());
  this.setStylesheet(stylesheet != null ? stylesheet : this.createStylesheet());
  this.view = this.createGraphView();
  this.graphModelChangeListener = bind(this, function(sender, evt) {
    this.graphModelChanged(evt.getProperty("edit").changes);
  });
  this.model.addListener(mxEvent2.CHANGE, this.graphModelChangeListener);
  this.createHandlers();
  if (container != null) {
    this.init(container);
  }
  this.view.revalidate();
}
if (typeof mxLoadResources !== "undefined" && mxLoadResources) {
  mxResources2.add(mxClient_default.basePath + "/resources/graph");
} else {
  mxClient_default.defaultBundles.push(mxClient_default.basePath + "/resources/graph");
}
mxGraph2.prototype = new mxEventSource();
mxGraph2.prototype.constructor = mxGraph2;
mxGraph2.prototype.mouseListeners = null;
mxGraph2.prototype.isMouseDown = false;
mxGraph2.prototype.model = null;
mxGraph2.prototype.view = null;
mxGraph2.prototype.stylesheet = null;
mxGraph2.prototype.selectionModel = null;
mxGraph2.prototype.cellEditor = null;
mxGraph2.prototype.cellRenderer = null;
mxGraph2.prototype.multiplicities = null;
mxGraph2.prototype.renderHint = null;
mxGraph2.prototype.dialect = null;
mxGraph2.prototype.gridSize = 10;
mxGraph2.prototype.gridEnabled = true;
mxGraph2.prototype.portsEnabled = true;
mxGraph2.prototype.nativeDblClickEnabled = true;
mxGraph2.prototype.doubleTapEnabled = true;
mxGraph2.prototype.doubleTapTimeout = 500;
mxGraph2.prototype.doubleTapTolerance = 25;
mxGraph2.prototype.lastTouchY = 0;
mxGraph2.prototype.lastTouchX = 0;
mxGraph2.prototype.lastTouchTime = 0;
mxGraph2.prototype.tapAndHoldEnabled = true;
mxGraph2.prototype.tapAndHoldDelay = 500;
mxGraph2.prototype.tapAndHoldInProgress = false;
mxGraph2.prototype.tapAndHoldValid = false;
mxGraph2.prototype.initialTouchX = 0;
mxGraph2.prototype.initialTouchY = 0;
mxGraph2.prototype.tolerance = 4;
mxGraph2.prototype.defaultOverlap = 0.5;
mxGraph2.prototype.defaultParent = null;
mxGraph2.prototype.alternateEdgeStyle = null;
mxGraph2.prototype.backgroundImage = null;
mxGraph2.prototype.pageVisible = false;
mxGraph2.prototype.pageBreaksVisible = false;
mxGraph2.prototype.pageBreakColor = "gray";
mxGraph2.prototype.pageBreakDashed = true;
mxGraph2.prototype.minPageBreakDist = 20;
mxGraph2.prototype.preferPageSize = false;
mxGraph2.prototype.pageFormat = mxConstants2.PAGE_FORMAT_A4_PORTRAIT;
mxGraph2.prototype.pageScale = 1.5;
mxGraph2.prototype.enabled = true;
mxGraph2.prototype.escapeEnabled = true;
mxGraph2.prototype.invokesStopCellEditing = true;
mxGraph2.prototype.enterStopsCellEditing = false;
mxGraph2.prototype.useScrollbarsForPanning = true;
mxGraph2.prototype.exportEnabled = true;
mxGraph2.prototype.importEnabled = true;
mxGraph2.prototype.cellsLocked = false;
mxGraph2.prototype.cellsCloneable = true;
mxGraph2.prototype.foldingEnabled = true;
mxGraph2.prototype.cellsEditable = true;
mxGraph2.prototype.cellsDeletable = true;
mxGraph2.prototype.cellsMovable = true;
mxGraph2.prototype.edgeLabelsMovable = true;
mxGraph2.prototype.vertexLabelsMovable = false;
mxGraph2.prototype.dropEnabled = false;
mxGraph2.prototype.splitEnabled = true;
mxGraph2.prototype.cellsResizable = true;
mxGraph2.prototype.cellsBendable = true;
mxGraph2.prototype.cellsSelectable = true;
mxGraph2.prototype.cellsDisconnectable = true;
mxGraph2.prototype.autoSizeCells = false;
mxGraph2.prototype.autoSizeCellsOnAdd = false;
mxGraph2.prototype.autoScroll = true;
mxGraph2.prototype.ignoreScrollbars = false;
mxGraph2.prototype.translateToScrollPosition = false;
mxGraph2.prototype.timerAutoScroll = false;
mxGraph2.prototype.allowAutoPanning = false;
mxGraph2.prototype.autoExtend = true;
mxGraph2.prototype.maximumGraphBounds = null;
mxGraph2.prototype.minimumGraphSize = null;
mxGraph2.prototype.minimumContainerSize = null;
mxGraph2.prototype.maximumContainerSize = null;
mxGraph2.prototype.resizeContainer = false;
mxGraph2.prototype.border = 0;
mxGraph2.prototype.keepEdgesInForeground = false;
mxGraph2.prototype.keepEdgesInBackground = false;
mxGraph2.prototype.allowNegativeCoordinates = true;
mxGraph2.prototype.constrainChildren = true;
mxGraph2.prototype.constrainRelativeChildren = false;
mxGraph2.prototype.extendParents = true;
mxGraph2.prototype.extendParentsOnAdd = false;
mxGraph2.prototype.extendParentsOnMove = false;
mxGraph2.prototype.recursiveResize = false;
mxGraph2.prototype.collapseToPreferredSize = true;
mxGraph2.prototype.zoomFactor = 1.2;
mxGraph2.prototype.keepSelectionVisibleOnZoom = false;
mxGraph2.prototype.centerZoom = true;
mxGraph2.prototype.resetViewOnRootChange = true;
mxGraph2.prototype.resetEdgesOnResize = false;
mxGraph2.prototype.resetEdgesOnMove = false;
mxGraph2.prototype.resetEdgesOnConnect = true;
mxGraph2.prototype.allowLoops = false;
mxGraph2.prototype.defaultLoopStyle = mxEdgeStyle.Loop;
mxGraph2.prototype.multigraph = true;
mxGraph2.prototype.connectableEdges = false;
mxGraph2.prototype.allowDanglingEdges = true;
mxGraph2.prototype.cloneInvalidEdges = false;
mxGraph2.prototype.disconnectOnMove = true;
mxGraph2.prototype.labelsVisible = true;
mxGraph2.prototype.htmlLabels = false;
mxGraph2.prototype.swimlaneSelectionEnabled = true;
mxGraph2.prototype.swimlaneNesting = true;
mxGraph2.prototype.swimlaneIndicatorColorAttribute = mxConstants2.STYLE_FILLCOLOR;
mxGraph2.prototype.imageBundles = null;
mxGraph2.prototype.minFitScale = 0.1;
mxGraph2.prototype.maxFitScale = 8;
mxGraph2.prototype.panDx = 0;
mxGraph2.prototype.panDy = 0;
mxGraph2.prototype.collapsedImage = new mxImage2(mxClient_default.imageBasePath + "/collapsed.gif", 9, 9);
mxGraph2.prototype.expandedImage = new mxImage2(mxClient_default.imageBasePath + "/expanded.gif", 9, 9);
mxGraph2.prototype.warningImage = new mxImage2(mxClient_default.imageBasePath + "/warning" + (mxClient_default.IS_MAC ? ".png" : ".gif"), 16, 16);
mxGraph2.prototype.alreadyConnectedResource = mxClient_default.language != "none" ? "alreadyConnected" : "";
mxGraph2.prototype.containsValidationErrorsResource = mxClient_default.language != "none" ? "containsValidationErrors" : "";
mxGraph2.prototype.collapseExpandResource = mxClient_default.language != "none" ? "collapse-expand" : "";
mxGraph2.prototype.init = function(container) {
  this.container = container;
  this.cellEditor = this.createCellEditor();
  this.view.init();
  this.sizeDidChange();
  mxEvent2.addListener(container, "mouseleave", bind(this, function(evt) {
    if (this.tooltipHandler != null && this.tooltipHandler.div != null && this.tooltipHandler.div != evt.relatedTarget) {
      this.tooltipHandler.hide();
    }
  }));
  if (mxClient_default.IS_IE) {
    mxEvent2.addListener(window, "unload", bind(this, function() {
      this.destroy();
    }));
    mxEvent2.addListener(container, "selectstart", bind(this, function(evt) {
      return this.isEditing() || !this.isMouseDown && !mxEvent2.isShiftDown(evt);
    }));
  }
  if (document.documentMode == 8) {
    container.insertAdjacentHTML("beforeend", "<" + mxClient_default.VML_PREFIX + ':group style="DISPLAY: none;"></' + mxClient_default.VML_PREFIX + ":group>");
  }
};
mxGraph2.prototype.createHandlers = function() {
  this.tooltipHandler = this.createTooltipHandler();
  this.tooltipHandler.setEnabled(false);
  this.selectionCellsHandler = this.createSelectionCellsHandler();
  this.connectionHandler = this.createConnectionHandler();
  this.connectionHandler.setEnabled(false);
  this.graphHandler = this.createGraphHandler();
  this.panningHandler = this.createPanningHandler();
  this.panningHandler.panningEnabled = false;
  this.popupMenuHandler = this.createPopupMenuHandler();
};
mxGraph2.prototype.createTooltipHandler = function() {
  return new mxTooltipHandler(this);
};
mxGraph2.prototype.createSelectionCellsHandler = function() {
  return new mxSelectionCellsHandler(this);
};
mxGraph2.prototype.createConnectionHandler = function() {
  return new mxConnectionHandler(this);
};
mxGraph2.prototype.createGraphHandler = function() {
  return new mxGraphHandler(this);
};
mxGraph2.prototype.createPanningHandler = function() {
  return new mxPanningHandler(this);
};
mxGraph2.prototype.createPopupMenuHandler = function() {
  return new mxPopupMenuHandler(this);
};
mxGraph2.prototype.createSelectionModel = function() {
  return new mxGraphSelectionModel(this);
};
mxGraph2.prototype.createStylesheet = function() {
  return new mxStylesheet();
};
mxGraph2.prototype.createGraphView = function() {
  return new mxGraphView(this);
};
mxGraph2.prototype.createCellRenderer = function() {
  return new mxCellRenderer2();
};
mxGraph2.prototype.createCellEditor = function() {
  return new mxCellEditor(this);
};
mxGraph2.prototype.getModel = function() {
  return this.model;
};
mxGraph2.prototype.getView = function() {
  return this.view;
};
mxGraph2.prototype.getStylesheet = function() {
  return this.stylesheet;
};
mxGraph2.prototype.setStylesheet = function(stylesheet) {
  this.stylesheet = stylesheet;
};
mxGraph2.prototype.getSelectionModel = function() {
  return this.selectionModel;
};
mxGraph2.prototype.setSelectionModel = function(selectionModel) {
  this.selectionModel = selectionModel;
};
mxGraph2.prototype.getSelectionCellsForChanges = function(changes, ignoreFn) {
  const dict = new mxDictionary();
  const cells = [];
  const addCell = bind(this, function(cell2) {
    if (!dict.get(cell2) && this.model.contains(cell2)) {
      if (this.model.isEdge(cell2) || this.model.isVertex(cell2)) {
        dict.put(cell2, true);
        cells.push(cell2);
      } else {
        const childCount = this.model.getChildCount(cell2);
        for (let i = 0; i < childCount; i++) {
          addCell(this.model.getChildAt(cell2, i));
        }
      }
    }
  });
  for (let i = 0; i < changes.length; i++) {
    const change = changes[i];
    if (change.constructor != mxRootChange && (ignoreFn == null || !ignoreFn(change))) {
      let cell2 = null;
      if (change instanceof mxChildChange2) {
        cell2 = change.child;
      } else if (change.cell != null && change.cell instanceof mxCell) {
        cell2 = change.cell;
      }
      if (cell2 != null) {
        addCell(cell2);
      }
    }
  }
  return cells;
};
mxGraph2.prototype.graphModelChanged = function(changes) {
  for (let i = 0; i < changes.length; i++) {
    this.processChange(changes[i]);
  }
  this.updateSelection();
  this.view.validate();
  this.sizeDidChange();
};
mxGraph2.prototype.updateSelection = function() {
  const cells = this.getSelectionCells();
  const removed = [];
  for (let i = 0; i < cells.length; i++) {
    if (!this.model.contains(cells[i]) || !this.isCellVisible(cells[i])) {
      removed.push(cells[i]);
    } else {
      let par = this.model.getParent(cells[i]);
      while (par != null && par != this.view.currentRoot) {
        if (this.isCellCollapsed(par) || !this.isCellVisible(par)) {
          removed.push(cells[i]);
          break;
        }
        par = this.model.getParent(par);
      }
    }
  }
  this.removeSelectionCells(removed);
};
mxGraph2.prototype.processChange = function(change) {
  if (change instanceof mxRootChange) {
    this.clearSelection();
    this.setDefaultParent(null);
    this.removeStateForCell(change.previous);
    if (this.resetViewOnRootChange) {
      this.view.scale = 1;
      this.view.translate.x = 0;
      this.view.translate.y = 0;
    }
    this.fireEvent(new mxEventObject2(mxEvent2.ROOT));
  } else if (change instanceof mxChildChange2) {
    const newParent = this.model.getParent(change.child);
    this.view.invalidate(change.child, true, true);
    if (!this.model.contains(newParent) || this.isCellCollapsed(newParent)) {
      this.view.invalidate(change.child, true, true);
      this.removeStateForCell(change.child);
      if (this.view.currentRoot == change.child) {
        this.home();
      }
    }
    if (newParent != change.previous) {
      if (newParent != null) {
        this.view.invalidate(newParent, false, false);
      }
      if (change.previous != null) {
        this.view.invalidate(change.previous, false, false);
      }
    }
  } else if (change instanceof mxTerminalChange || change instanceof mxGeometryChange) {
    if (change instanceof mxTerminalChange || (change.previous == null && change.geometry != null || change.previous != null && !change.previous.equals(change.geometry))) {
      this.view.invalidate(change.cell);
    }
  } else if (change instanceof mxValueChange) {
    this.view.invalidate(change.cell, false, false);
  } else if (change instanceof mxStyleChange) {
    this.view.invalidate(change.cell, true, true);
    const state2 = this.view.getState(change.cell);
    if (state2 != null) {
      state2.invalidStyle = true;
    }
  } else if (change.cell != null && change.cell instanceof mxCell) {
    this.removeStateForCell(change.cell);
  }
};
mxGraph2.prototype.removeStateForCell = function(cell2) {
  const childCount = this.model.getChildCount(cell2);
  for (let i = 0; i < childCount; i++) {
    this.removeStateForCell(this.model.getChildAt(cell2, i));
  }
  this.view.invalidate(cell2, false, true);
  this.view.removeState(cell2);
};
mxGraph2.prototype.addCellOverlay = function(cell2, overlay) {
  if (cell2.overlays == null) {
    cell2.overlays = [];
  }
  cell2.overlays.push(overlay);
  const state2 = this.view.getState(cell2);
  if (state2 != null) {
    this.cellRenderer.redraw(state2);
  }
  this.fireEvent(new mxEventObject2(mxEvent2.ADD_OVERLAY, "cell", cell2, "overlay", overlay));
  return overlay;
};
mxGraph2.prototype.getCellOverlays = function(cell2) {
  return cell2.overlays;
};
mxGraph2.prototype.removeCellOverlay = function(cell2, overlay) {
  if (overlay == null) {
    this.removeCellOverlays(cell2);
  } else {
    const index = indexOf(cell2.overlays, overlay);
    if (index >= 0) {
      cell2.overlays.splice(index, 1);
      if (cell2.overlays.length == 0) {
        cell2.overlays = null;
      }
      const state2 = this.view.getState(cell2);
      if (state2 != null) {
        this.cellRenderer.redraw(state2);
      }
      this.fireEvent(new mxEventObject2(mxEvent2.REMOVE_OVERLAY, "cell", cell2, "overlay", overlay));
    } else {
      overlay = null;
    }
  }
  return overlay;
};
mxGraph2.prototype.removeCellOverlays = function(cell2) {
  const overlays = cell2.overlays;
  if (overlays != null) {
    cell2.overlays = null;
    const state2 = this.view.getState(cell2);
    if (state2 != null) {
      this.cellRenderer.redraw(state2);
    }
    for (let i = 0; i < overlays.length; i++) {
      this.fireEvent(new mxEventObject2(mxEvent2.REMOVE_OVERLAY, "cell", cell2, "overlay", overlays[i]));
    }
  }
  return overlays;
};
mxGraph2.prototype.clearCellOverlays = function(cell2) {
  cell2 = cell2 != null ? cell2 : this.model.getRoot();
  this.removeCellOverlays(cell2);
  const childCount = this.model.getChildCount(cell2);
  for (let i = 0; i < childCount; i++) {
    const child = this.model.getChildAt(cell2, i);
    this.clearCellOverlays(child);
  }
};
mxGraph2.prototype.setCellWarning = function(cell2, warning, img, isSelect) {
  if (warning != null && warning.length > 0) {
    img = img != null ? img : this.warningImage;
    const overlay = new mxCellOverlay(img, "<font color=red>" + warning + "</font>");
    if (isSelect) {
      overlay.addListener(mxEvent2.CLICK, bind(this, function(sender, evt) {
        if (this.isEnabled()) {
          this.setSelectionCell(cell2);
        }
      }));
    }
    return this.addCellOverlay(cell2, overlay);
  } else {
    this.removeCellOverlays(cell2);
  }
  return null;
};
mxGraph2.prototype.startEditing = function(evt) {
  this.startEditingAtCell(null, evt);
};
mxGraph2.prototype.startEditingAtCell = function(cell2, evt) {
  if (evt == null || !mxEvent2.isMultiTouchEvent(evt)) {
    if (cell2 == null) {
      cell2 = this.getSelectionCell();
      if (cell2 != null && !this.isCellEditable(cell2)) {
        cell2 = null;
      }
    }
    if (cell2 != null) {
      this.fireEvent(new mxEventObject2(mxEvent2.START_EDITING, "cell", cell2, "event", evt));
      this.cellEditor.startEditing(cell2, evt);
      this.fireEvent(new mxEventObject2(mxEvent2.EDITING_STARTED, "cell", cell2, "event", evt));
    }
  }
};
mxGraph2.prototype.getEditingValue = function(cell2, evt) {
  return this.convertValueToString(cell2);
};
mxGraph2.prototype.stopEditing = function(cancel) {
  this.cellEditor.stopEditing(cancel);
  this.fireEvent(new mxEventObject2(mxEvent2.EDITING_STOPPED, "cancel", cancel));
};
mxGraph2.prototype.labelChanged = function(cell2, value, evt) {
  this.model.beginUpdate();
  try {
    const old = cell2.value;
    this.cellLabelChanged(cell2, value, this.isAutoSizeCell(cell2));
    this.fireEvent(new mxEventObject2(mxEvent2.LABEL_CHANGED, "cell", cell2, "value", value, "old", old, "event", evt));
  } finally {
    this.model.endUpdate();
  }
  return cell2;
};
mxGraph2.prototype.cellLabelChanged = function(cell2, value, autoSize) {
  this.model.beginUpdate();
  try {
    this.model.setValue(cell2, value);
    if (autoSize) {
      this.cellSizeUpdated(cell2, false);
    }
  } finally {
    this.model.endUpdate();
  }
};
mxGraph2.prototype.escape = function(evt) {
  this.fireEvent(new mxEventObject2(mxEvent2.ESCAPE, "event", evt));
};
mxGraph2.prototype.click = function(me) {
  const evt = me.getEvent();
  let cell2 = me.getCell();
  const mxe = new mxEventObject2(mxEvent2.CLICK, "event", evt, "cell", cell2);
  if (me.isConsumed()) {
    mxe.consume();
  }
  this.fireEvent(mxe);
  if (this.isEnabled() && !mxEvent2.isConsumed(evt) && !mxe.isConsumed()) {
    if (cell2 != null) {
      if (this.isTransparentClickEvent(evt)) {
        let active = false;
        const tmp = this.getCellAt(me.graphX, me.graphY, null, null, null, bind(this, function(state2) {
          const selected = this.isCellSelected(state2.cell);
          active = active || selected;
          return !active || selected || state2.cell != cell2 && this.model.isAncestor(state2.cell, cell2);
        }));
        if (tmp != null) {
          cell2 = tmp;
        }
      }
    } else if (this.isSwimlaneSelectionEnabled()) {
      cell2 = this.getSwimlaneAt(me.getGraphX(), me.getGraphY());
      if (cell2 != null && (!this.isToggleEvent(evt) || !mxEvent2.isAltDown(evt))) {
        let temp2 = cell2;
        const swimlanes = [];
        while (temp2 != null) {
          temp2 = this.model.getParent(temp2);
          const state2 = this.view.getState(temp2);
          if (this.isSwimlane(temp2) && state2 != null) {
            swimlanes.push(temp2);
          }
        }
        if (swimlanes.length > 0) {
          swimlanes.reverse();
          swimlanes.splice(0, 0, cell2);
          swimlanes.push(cell2);
          for (let i = 0; i < swimlanes.length - 1; i++) {
            if (this.isCellSelected(swimlanes[i])) {
              cell2 = swimlanes[this.isToggleEvent(evt) ? i : i + 1];
            }
          }
        }
      }
    }
    if (cell2 != null) {
      this.selectCellForEvent(cell2, evt);
    } else if (!this.isToggleEvent(evt)) {
      this.clearSelection();
    }
  }
};
mxGraph2.prototype.isSiblingSelected = function(cell2) {
  const model = this.model;
  const parent2 = model.getParent(cell2);
  const childCount = model.getChildCount(parent2);
  for (let i = 0; i < childCount; i++) {
    const child = model.getChildAt(parent2, i);
    if (cell2 != child && this.isCellSelected(child)) {
      return true;
    }
  }
  return false;
};
mxGraph2.prototype.dblClick = function(evt, cell2) {
  const mxe = new mxEventObject2(mxEvent2.DOUBLE_CLICK, "event", evt, "cell", cell2);
  this.fireEvent(mxe);
  if (this.isEnabled() && !mxEvent2.isConsumed(evt) && !mxe.isConsumed() && cell2 != null && this.isCellEditable(cell2) && !this.isEditing(cell2)) {
    this.startEditingAtCell(cell2, evt);
    mxEvent2.consume(evt);
  }
};
mxGraph2.prototype.tapAndHold = function(me) {
  const evt = me.getEvent();
  const mxe = new mxEventObject2(mxEvent2.TAP_AND_HOLD, "event", evt, "cell", me.getCell());
  this.fireEvent(mxe);
  if (mxe.isConsumed()) {
    this.panningHandler.panningTrigger = false;
  }
  if (this.isEnabled() && !mxEvent2.isConsumed(evt) && !mxe.isConsumed() && this.connectionHandler.isEnabled()) {
    const state2 = this.view.getState(this.connectionHandler.marker.getCell(me));
    if (state2 != null) {
      this.connectionHandler.marker.currentColor = this.connectionHandler.marker.validColor;
      this.connectionHandler.marker.markedState = state2;
      this.connectionHandler.marker.mark();
      this.connectionHandler.first = new mxPoint2(me.getGraphX(), me.getGraphY());
      this.connectionHandler.edgeState = this.connectionHandler.createEdgeState(me);
      this.connectionHandler.previous = state2;
      this.connectionHandler.fireEvent(new mxEventObject2(mxEvent2.START, "state", this.connectionHandler.previous));
    }
  }
};
mxGraph2.prototype.scrollPointToVisible = function(x, y, extend2, border) {
  if (!this.timerAutoScroll && (this.ignoreScrollbars || hasScrollbars(this.container))) {
    const c = this.container;
    border = border != null ? border : 20;
    if (x >= c.scrollLeft && y >= c.scrollTop && x <= c.scrollLeft + c.clientWidth && y <= c.scrollTop + c.clientHeight) {
      let dx = c.scrollLeft + c.clientWidth - x;
      if (dx < border) {
        const old = c.scrollLeft;
        c.scrollLeft += border - dx;
        if (extend2 && old == c.scrollLeft) {
          if (this.dialect == mxConstants2.DIALECT_SVG) {
            const root = this.view.getDrawPane().ownerSVGElement;
            const width = this.container.scrollWidth + border - dx;
            root.style.width = width + "px";
          } else {
            const width = Math.max(c.clientWidth, c.scrollWidth) + border - dx;
            const canvas = this.view.getCanvas();
            canvas.style.width = width + "px";
          }
          c.scrollLeft += border - dx;
        }
      } else {
        dx = x - c.scrollLeft;
        if (dx < border) {
          c.scrollLeft -= border - dx;
        }
      }
      let dy = c.scrollTop + c.clientHeight - y;
      if (dy < border) {
        const old = c.scrollTop;
        c.scrollTop += border - dy;
        if (old == c.scrollTop && extend2) {
          if (this.dialect == mxConstants2.DIALECT_SVG) {
            const root = this.view.getDrawPane().ownerSVGElement;
            const height = this.container.scrollHeight + border - dy;
            root.style.height = height + "px";
          } else {
            const height = Math.max(c.clientHeight, c.scrollHeight) + border - dy;
            const canvas = this.view.getCanvas();
            canvas.style.height = height + "px";
          }
          c.scrollTop += border - dy;
        }
      } else {
        dy = y - c.scrollTop;
        if (dy < border) {
          c.scrollTop -= border - dy;
        }
      }
    }
  } else if (this.allowAutoPanning && !this.panningHandler.isActive()) {
    if (this.panningManager == null) {
      this.panningManager = this.createPanningManager();
    }
    this.panningManager.panTo(x + this.panDx, y + this.panDy);
  }
};
mxGraph2.prototype.createPanningManager = function() {
  return new mxPanningManager(this);
};
mxGraph2.prototype.getBorderSizes = function() {
  const css = getCurrentStyle(this.container);
  return new mxRectangle(parseCssNumber(css.paddingLeft) + (css.borderLeftStyle != "none" ? parseCssNumber(css.borderLeftWidth) : 0), parseCssNumber(css.paddingTop) + (css.borderTopStyle != "none" ? parseCssNumber(css.borderTopWidth) : 0), parseCssNumber(css.paddingRight) + (css.borderRightStyle != "none" ? parseCssNumber(css.borderRightWidth) : 0), parseCssNumber(css.paddingBottom) + (css.borderBottomStyle != "none" ? parseCssNumber(css.borderBottomWidth) : 0));
};
mxGraph2.prototype.getPreferredPageSize = function(bounds, width, height) {
  const scale = this.view.scale;
  const tr = this.view.translate;
  const fmt = this.pageFormat;
  const ps = this.pageScale;
  const page = new mxRectangle(0, 0, Math.ceil(fmt.width * ps), Math.ceil(fmt.height * ps));
  const hCount = this.pageBreaksVisible ? Math.ceil(width / page.width) : 1;
  const vCount = this.pageBreaksVisible ? Math.ceil(height / page.height) : 1;
  return new mxRectangle(0, 0, hCount * page.width + 2 + tr.x, vCount * page.height + 2 + tr.y);
};
mxGraph2.prototype.fit = function(border, keepOrigin, margin, enabled, ignoreWidth, ignoreHeight, maxHeight) {
  if (this.container != null) {
    border = border != null ? border : this.getBorder();
    keepOrigin = keepOrigin != null ? keepOrigin : false;
    margin = margin != null ? margin : 0;
    enabled = enabled != null ? enabled : true;
    ignoreWidth = ignoreWidth != null ? ignoreWidth : false;
    ignoreHeight = ignoreHeight != null ? ignoreHeight : false;
    const cssBorder = this.getBorderSizes();
    let w1 = this.container.offsetWidth - cssBorder.x - cssBorder.width - 1;
    let h1 = maxHeight != null ? maxHeight : this.container.offsetHeight - cssBorder.y - cssBorder.height - 1;
    let bounds = this.view.getGraphBounds();
    if (bounds.width > 0 && bounds.height > 0) {
      if (keepOrigin && bounds.x != null && bounds.y != null) {
        bounds = bounds.clone();
        bounds.width += bounds.x;
        bounds.height += bounds.y;
        bounds.x = 0;
        bounds.y = 0;
      }
      const s = this.view.scale;
      let w2 = bounds.width / s;
      let h2 = bounds.height / s;
      if (this.backgroundImage != null) {
        w2 = Math.max(w2, this.backgroundImage.width - bounds.x / s);
        h2 = Math.max(h2, this.backgroundImage.height - bounds.y / s);
      }
      const b = (keepOrigin ? border : 2 * border) + margin + 1;
      w1 -= b;
      h1 -= b;
      let s2 = ignoreWidth ? h1 / h2 : ignoreHeight ? w1 / w2 : Math.min(w1 / w2, h1 / h2);
      if (this.minFitScale != null) {
        s2 = Math.max(s2, this.minFitScale);
      }
      if (this.maxFitScale != null) {
        s2 = Math.min(s2, this.maxFitScale);
      }
      if (enabled) {
        if (!keepOrigin) {
          if (!hasScrollbars(this.container)) {
            const x0 = bounds.x != null ? Math.floor(this.view.translate.x - bounds.x / s + border / s2 + margin / 2) : border;
            const y0 = bounds.y != null ? Math.floor(this.view.translate.y - bounds.y / s + border / s2 + margin / 2) : border;
            this.view.scaleAndTranslate(s2, x0, y0);
          } else {
            this.view.setScale(s2);
            const b2 = this.getGraphBounds();
            if (b2.x != null) {
              this.container.scrollLeft = b2.x;
            }
            if (b2.y != null) {
              this.container.scrollTop = b2.y;
            }
          }
        } else if (this.view.scale != s2) {
          this.view.setScale(s2);
        }
      } else {
        return s2;
      }
    }
  }
  return this.view.scale;
};
mxGraph2.prototype.sizeDidChange = function() {
  const bounds = this.getGraphBounds();
  if (this.container != null) {
    const border = this.getBorder();
    let width = Math.max(0, bounds.x) + bounds.width + 2 * border;
    let height = Math.max(0, bounds.y) + bounds.height + 2 * border;
    if (this.minimumContainerSize != null) {
      width = Math.max(width, this.minimumContainerSize.width);
      height = Math.max(height, this.minimumContainerSize.height);
    }
    if (this.resizeContainer) {
      this.doResizeContainer(width, height);
    }
    if (this.preferPageSize || !mxClient_default.IS_IE && this.pageVisible) {
      const size = this.getPreferredPageSize(bounds, Math.max(1, width), Math.max(1, height));
      if (size != null) {
        width = size.width * this.view.scale;
        height = size.height * this.view.scale;
      }
    }
    if (this.minimumGraphSize != null) {
      width = Math.max(width, this.minimumGraphSize.width * this.view.scale);
      height = Math.max(height, this.minimumGraphSize.height * this.view.scale);
    }
    width = Math.ceil(width);
    height = Math.ceil(height);
    if (this.dialect == mxConstants2.DIALECT_SVG) {
      const root = this.view.getDrawPane().ownerSVGElement;
      if (root != null) {
        root.style.minWidth = Math.max(1, width) + "px";
        root.style.minHeight = Math.max(1, height) + "px";
        root.style.width = "100%";
        root.style.height = "100%";
      }
    } else {
      if (mxClient_default.IS_QUIRKS) {
        this.view.updateHtmlCanvasSize(Math.max(1, width), Math.max(1, height));
      } else {
        this.view.canvas.style.minWidth = Math.max(1, width) + "px";
        this.view.canvas.style.minHeight = Math.max(1, height) + "px";
      }
    }
    this.updatePageBreaks(this.pageBreaksVisible, width, height);
  }
  this.fireEvent(new mxEventObject2(mxEvent2.SIZE, "bounds", bounds));
};
mxGraph2.prototype.doResizeContainer = function(width, height) {
  if (this.maximumContainerSize != null) {
    width = Math.min(this.maximumContainerSize.width, width);
    height = Math.min(this.maximumContainerSize.height, height);
  }
  this.container.style.width = Math.ceil(width) + "px";
  this.container.style.height = Math.ceil(height) + "px";
};
mxGraph2.prototype.updatePageBreaks = function(visible, width, height) {
  const scale = this.view.scale;
  const tr = this.view.translate;
  const fmt = this.pageFormat;
  const ps = scale * this.pageScale;
  const bounds = new mxRectangle(0, 0, fmt.width * ps, fmt.height * ps);
  const gb = mxRectangle.fromRectangle(this.getGraphBounds());
  gb.width = Math.max(1, gb.width);
  gb.height = Math.max(1, gb.height);
  bounds.x = Math.floor((gb.x - tr.x * scale) / bounds.width) * bounds.width + tr.x * scale;
  bounds.y = Math.floor((gb.y - tr.y * scale) / bounds.height) * bounds.height + tr.y * scale;
  gb.width = Math.ceil((gb.width + (gb.x - bounds.x)) / bounds.width) * bounds.width;
  gb.height = Math.ceil((gb.height + (gb.y - bounds.y)) / bounds.height) * bounds.height;
  visible = visible && Math.min(bounds.width, bounds.height) > this.minPageBreakDist;
  const horizontalCount = visible ? Math.ceil(gb.height / bounds.height) + 1 : 0;
  const verticalCount = visible ? Math.ceil(gb.width / bounds.width) + 1 : 0;
  const right = (verticalCount - 1) * bounds.width;
  const bottom = (horizontalCount - 1) * bounds.height;
  if (this.horizontalPageBreaks == null && horizontalCount > 0) {
    this.horizontalPageBreaks = [];
  }
  if (this.verticalPageBreaks == null && verticalCount > 0) {
    this.verticalPageBreaks = [];
  }
  const drawPageBreaks = bind(this, function(breaks) {
    if (breaks != null) {
      const count = breaks == this.horizontalPageBreaks ? horizontalCount : verticalCount;
      for (let i = 0; i <= count; i++) {
        const pts = breaks == this.horizontalPageBreaks ? [
          new mxPoint2(Math.round(bounds.x), Math.round(bounds.y + i * bounds.height)),
          new mxPoint2(Math.round(bounds.x + right), Math.round(bounds.y + i * bounds.height))
        ] : [
          new mxPoint2(Math.round(bounds.x + i * bounds.width), Math.round(bounds.y)),
          new mxPoint2(Math.round(bounds.x + i * bounds.width), Math.round(bounds.y + bottom))
        ];
        if (breaks[i] != null) {
          breaks[i].points = pts;
          breaks[i].redraw();
        } else {
          const pageBreak = new mxPolyline(pts, this.pageBreakColor);
          pageBreak.dialect = this.dialect;
          pageBreak.pointerEvents = false;
          pageBreak.isDashed = this.pageBreakDashed;
          pageBreak.init(this.view.backgroundPane);
          pageBreak.redraw();
          breaks[i] = pageBreak;
        }
      }
      for (let i = count; i < breaks.length; i++) {
        breaks[i].destroy();
      }
      breaks.splice(count, breaks.length - count);
    }
  });
  drawPageBreaks(this.horizontalPageBreaks);
  drawPageBreaks(this.verticalPageBreaks);
};
mxGraph2.prototype.getCurrentCellStyle = function(cell2, ignoreState) {
  const state2 = ignoreState ? null : this.view.getState(cell2);
  return state2 != null ? state2.style : this.getCellStyle(cell2);
};
mxGraph2.prototype.getCellStyle = function(cell2) {
  const stylename = this.model.getStyle(cell2);
  let style = null;
  if (this.model.isEdge(cell2)) {
    style = this.stylesheet.getDefaultEdgeStyle();
  } else {
    style = this.stylesheet.getDefaultVertexStyle();
  }
  if (stylename != null) {
    style = this.postProcessCellStyle(this.stylesheet.getCellStyle(stylename, style));
  }
  if (style == null) {
    style = new Object();
  }
  return style;
};
mxGraph2.prototype.postProcessCellStyle = function(style) {
  if (style != null) {
    const key = style[mxConstants2.STYLE_IMAGE];
    let image = this.getImageFromBundles(key);
    if (image != null) {
      style[mxConstants2.STYLE_IMAGE] = image;
    } else {
      image = key;
    }
    if (image != null && image.substring(0, 11) == "data:image/") {
      if (image.substring(0, 20) == "data:image/svg+xml,<") {
        image = image.substring(0, 19) + encodeURIComponent(image.substring(19));
      } else if (image.substring(0, 22) != "data:image/svg+xml,%3C") {
        const comma = image.indexOf(",");
        if (comma > 0 && image.substring(comma - 7, comma + 1) != ";base64,") {
          image = image.substring(0, comma) + ";base64," + image.substring(comma + 1);
        }
      }
      style[mxConstants2.STYLE_IMAGE] = image;
    }
  }
  return style;
};
mxGraph2.prototype.setCellStyle = function(style, cells) {
  cells = cells || this.getSelectionCells();
  if (cells != null) {
    this.model.beginUpdate();
    try {
      for (let i = 0; i < cells.length; i++) {
        this.model.setStyle(cells[i], style);
      }
    } finally {
      this.model.endUpdate();
    }
  }
};
mxGraph2.prototype.toggleCellStyle = function(key, defaultValue, cell2) {
  cell2 = cell2 || this.getSelectionCell();
  return this.toggleCellStyles(key, defaultValue, [cell2]);
};
mxGraph2.prototype.toggleCellStyles = function(key, defaultValue, cells) {
  defaultValue = defaultValue != null ? defaultValue : false;
  cells = cells || this.getSelectionCells();
  let value = null;
  if (cells != null && cells.length > 0) {
    const style = this.getCurrentCellStyle(cells[0]);
    value = getValue(style, key, defaultValue) ? 0 : 1;
    this.setCellStyles(key, value, cells);
  }
  return value;
};
mxGraph2.prototype.setCellStyles = function(key, value, cells) {
  cells = cells || this.getSelectionCells();
  setCellStyles(this.model, cells, key, value);
};
mxGraph2.prototype.toggleCellStyleFlags = function(key, flag, cells) {
  this.setCellStyleFlags(key, flag, null, cells);
};
mxGraph2.prototype.setCellStyleFlags = function(key, flag, value, cells) {
  cells = cells || this.getSelectionCells();
  if (cells != null && cells.length > 0) {
    if (value == null) {
      const style = this.getCurrentCellStyle(cells[0]);
      const current2 = parseInt(style[key] || 0);
      value = !((current2 & flag) == flag);
    }
    setCellStyleFlags(this.model, cells, key, flag, value);
  }
};
mxGraph2.prototype.alignCells = function(align, cells, param) {
  if (cells == null) {
    cells = this.getSelectionCells();
  }
  if (cells != null && cells.length > 1) {
    if (param == null) {
      for (let i = 0; i < cells.length; i++) {
        const state2 = this.view.getState(cells[i]);
        if (state2 != null && !this.model.isEdge(cells[i])) {
          if (param == null) {
            if (align == mxConstants2.ALIGN_CENTER) {
              param = state2.x + state2.width / 2;
              break;
            } else if (align == mxConstants2.ALIGN_RIGHT) {
              param = state2.x + state2.width;
            } else if (align == mxConstants2.ALIGN_TOP) {
              param = state2.y;
            } else if (align == mxConstants2.ALIGN_MIDDLE) {
              param = state2.y + state2.height / 2;
              break;
            } else if (align == mxConstants2.ALIGN_BOTTOM) {
              param = state2.y + state2.height;
            } else {
              param = state2.x;
            }
          } else {
            if (align == mxConstants2.ALIGN_RIGHT) {
              param = Math.max(param, state2.x + state2.width);
            } else if (align == mxConstants2.ALIGN_TOP) {
              param = Math.min(param, state2.y);
            } else if (align == mxConstants2.ALIGN_BOTTOM) {
              param = Math.max(param, state2.y + state2.height);
            } else {
              param = Math.min(param, state2.x);
            }
          }
        }
      }
    }
    if (param != null) {
      const s = this.view.scale;
      this.model.beginUpdate();
      try {
        for (let i = 0; i < cells.length; i++) {
          const state2 = this.view.getState(cells[i]);
          if (state2 != null) {
            let geo = this.getCellGeometry(cells[i]);
            if (geo != null && !this.model.isEdge(cells[i])) {
              geo = geo.clone();
              if (align == mxConstants2.ALIGN_CENTER) {
                geo.x += (param - state2.x - state2.width / 2) / s;
              } else if (align == mxConstants2.ALIGN_RIGHT) {
                geo.x += (param - state2.x - state2.width) / s;
              } else if (align == mxConstants2.ALIGN_TOP) {
                geo.y += (param - state2.y) / s;
              } else if (align == mxConstants2.ALIGN_MIDDLE) {
                geo.y += (param - state2.y - state2.height / 2) / s;
              } else if (align == mxConstants2.ALIGN_BOTTOM) {
                geo.y += (param - state2.y - state2.height) / s;
              } else {
                geo.x += (param - state2.x) / s;
              }
              this.resizeCell(cells[i], geo);
            }
          }
        }
        this.fireEvent(new mxEventObject2(mxEvent2.ALIGN_CELLS, "align", align, "cells", cells));
      } finally {
        this.model.endUpdate();
      }
    }
  }
  return cells;
};
mxGraph2.prototype.flipEdge = function(edge) {
  if (edge != null && this.alternateEdgeStyle != null) {
    this.model.beginUpdate();
    try {
      const style = this.model.getStyle(edge);
      if (style == null || style.length == 0) {
        this.model.setStyle(edge, this.alternateEdgeStyle);
      } else {
        this.model.setStyle(edge, null);
      }
      this.resetEdge(edge);
      this.fireEvent(new mxEventObject2(mxEvent2.FLIP_EDGE, "edge", edge));
    } finally {
      this.model.endUpdate();
    }
  }
  return edge;
};
mxGraph2.prototype.addImageBundle = function(bundle) {
  this.imageBundles.push(bundle);
};
mxGraph2.prototype.removeImageBundle = function(bundle) {
  const tmp = [];
  for (let i = 0; i < this.imageBundles.length; i++) {
    if (this.imageBundles[i] != bundle) {
      tmp.push(this.imageBundles[i]);
    }
  }
  this.imageBundles = tmp;
};
mxGraph2.prototype.getImageFromBundles = function(key) {
  if (key != null) {
    for (let i = 0; i < this.imageBundles.length; i++) {
      const image = this.imageBundles[i].getImage(key);
      if (image != null) {
        return image;
      }
    }
  }
  return null;
};
mxGraph2.prototype.orderCells = function(back, cells) {
  if (cells == null) {
    cells = sortCells(this.getSelectionCells(), true);
  }
  this.model.beginUpdate();
  try {
    this.cellsOrdered(cells, back);
    this.fireEvent(new mxEventObject2(mxEvent2.ORDER_CELLS, "back", back, "cells", cells));
  } finally {
    this.model.endUpdate();
  }
  return cells;
};
mxGraph2.prototype.cellsOrdered = function(cells, back) {
  if (cells != null) {
    this.model.beginUpdate();
    try {
      for (let i = 0; i < cells.length; i++) {
        const parent2 = this.model.getParent(cells[i]);
        if (back) {
          this.model.add(parent2, cells[i], i);
        } else {
          this.model.add(parent2, cells[i], this.model.getChildCount(parent2) - 1);
        }
      }
      this.fireEvent(new mxEventObject2(mxEvent2.CELLS_ORDERED, "back", back, "cells", cells));
    } finally {
      this.model.endUpdate();
    }
  }
};
mxGraph2.prototype.groupCells = function(group, border, cells) {
  if (cells == null) {
    cells = sortCells(this.getSelectionCells(), true);
  }
  cells = this.getCellsForGroup(cells);
  if (group == null) {
    group = this.createGroupCell(cells);
  }
  const bounds = this.getBoundsForGroup(group, cells, border);
  if (cells.length > 1 && bounds != null) {
    let parent2 = this.model.getParent(group);
    if (parent2 == null) {
      parent2 = this.model.getParent(cells[0]);
    }
    this.model.beginUpdate();
    try {
      if (this.getCellGeometry(group) == null) {
        this.model.setGeometry(group, new mxGeometry());
      }
      let index = this.model.getChildCount(parent2);
      this.cellsAdded([group], parent2, index, null, null, false, false, false);
      index = this.model.getChildCount(group);
      this.cellsAdded(cells, group, index, null, null, false, false, false);
      this.cellsMoved(cells, -bounds.x, -bounds.y, false, false, false);
      this.cellsResized([group], [bounds], false);
      this.fireEvent(new mxEventObject2(mxEvent2.GROUP_CELLS, "group", group, "border", border, "cells", cells));
    } finally {
      this.model.endUpdate();
    }
  }
  return group;
};
mxGraph2.prototype.getCellsForGroup = function(cells) {
  const result2 = [];
  if (cells != null && cells.length > 0) {
    const parent2 = this.model.getParent(cells[0]);
    result2.push(cells[0]);
    for (let i = 1; i < cells.length; i++) {
      if (this.model.getParent(cells[i]) == parent2) {
        result2.push(cells[i]);
      }
    }
  }
  return result2;
};
mxGraph2.prototype.getBoundsForGroup = function(group, children, border) {
  let result2 = this.getBoundingBoxFromGeometry(children, true);
  if (result2 != null) {
    if (this.isSwimlane(group)) {
      const size = this.getStartSize(group);
      result2.x -= size.width;
      result2.y -= size.height;
      result2.width += size.width;
      result2.height += size.height;
    }
    if (border != null) {
      result2.x -= border;
      result2.y -= border;
      result2.width += 2 * border;
      result2.height += 2 * border;
    }
  }
  return result2;
};
mxGraph2.prototype.createGroupCell = function(cells) {
  const group = new mxCell("");
  group.setVertex(true);
  group.setConnectable(false);
  return group;
};
mxGraph2.prototype.ungroupCells = function(cells) {
  let result2 = [];
  if (cells == null) {
    cells = this.getCellsForUngroup();
  }
  if (cells != null && cells.length > 0) {
    this.model.beginUpdate();
    try {
      for (let i = 0; i < cells.length; i++) {
        let children = this.model.getChildren(cells[i]);
        if (children != null && children.length > 0) {
          children = children.slice();
          const parent2 = this.model.getParent(cells[i]);
          const index = this.model.getChildCount(parent2);
          this.cellsAdded(children, parent2, index, null, null, true);
          result2 = result2.concat(children);
          for (let j = 0; j < children.length; j++) {
            const state2 = this.view.getState(children[j]);
            let geo = this.getCellGeometry(children[j]);
            if (state2 != null && geo != null && geo.relative) {
              geo = geo.clone();
              geo.x = state2.origin.x;
              geo.y = state2.origin.y;
              geo.relative = false;
              this.model.setGeometry(children[j], geo);
            }
          }
        }
      }
      this.removeCellsAfterUngroup(cells);
      this.fireEvent(new mxEventObject2(mxEvent2.UNGROUP_CELLS, "cells", cells));
    } finally {
      this.model.endUpdate();
    }
  }
  return result2;
};
mxGraph2.prototype.getCellsForUngroup = function() {
  const cells = this.getSelectionCells();
  const tmp = [];
  for (let i = 0; i < cells.length; i++) {
    if (this.model.isVertex(cells[i]) && this.model.getChildCount(cells[i]) > 0) {
      tmp.push(cells[i]);
    }
  }
  return tmp;
};
mxGraph2.prototype.removeCellsAfterUngroup = function(cells) {
  this.cellsRemoved(this.addAllEdges(cells));
};
mxGraph2.prototype.removeCellsFromParent = function(cells) {
  if (cells == null) {
    cells = this.getSelectionCells();
  }
  this.model.beginUpdate();
  try {
    const parent2 = this.getDefaultParent();
    const index = this.model.getChildCount(parent2);
    this.cellsAdded(cells, parent2, index, null, null, true);
    this.fireEvent(new mxEventObject2(mxEvent2.REMOVE_CELLS_FROM_PARENT, "cells", cells));
  } finally {
    this.model.endUpdate();
  }
  return cells;
};
mxGraph2.prototype.updateGroupBounds = function(cells, border, moveGroup, topBorder, rightBorder, bottomBorder, leftBorder) {
  if (cells == null) {
    cells = this.getSelectionCells();
  }
  border = border != null ? border : 0;
  moveGroup = moveGroup != null ? moveGroup : false;
  topBorder = topBorder != null ? topBorder : 0;
  rightBorder = rightBorder != null ? rightBorder : 0;
  bottomBorder = bottomBorder != null ? bottomBorder : 0;
  leftBorder = leftBorder != null ? leftBorder : 0;
  this.model.beginUpdate();
  try {
    for (let i = cells.length - 1; i >= 0; i--) {
      let geo = this.getCellGeometry(cells[i]);
      if (geo != null) {
        const children = this.getChildCells(cells[i]);
        if (children != null && children.length > 0) {
          const bounds = this.getBoundingBoxFromGeometry(children, true);
          if (bounds != null && bounds.width > 0 && bounds.height > 0) {
            const size = this.isSwimlane(cells[i]) ? this.getActualStartSize(cells[i], true) : new mxRectangle();
            geo = geo.clone();
            if (moveGroup) {
              geo.x = Math.round(geo.x + bounds.x - border - size.x - leftBorder);
              geo.y = Math.round(geo.y + bounds.y - border - size.y - topBorder);
            }
            geo.width = Math.round(bounds.width + 2 * border + size.x + leftBorder + rightBorder + size.width);
            geo.height = Math.round(bounds.height + 2 * border + size.y + topBorder + bottomBorder + size.height);
            this.model.setGeometry(cells[i], geo);
            this.moveCells(children, border + size.x - bounds.x + leftBorder, border + size.y - bounds.y + topBorder);
          }
        }
      }
    }
  } finally {
    this.model.endUpdate();
  }
  return cells;
};
mxGraph2.prototype.getBoundingBox = function(cells) {
  let result2 = null;
  if (cells != null && cells.length > 0) {
    for (let i = 0; i < cells.length; i++) {
      if (this.model.isVertex(cells[i]) || this.model.isEdge(cells[i])) {
        const bbox = this.view.getBoundingBox(this.view.getState(cells[i]), true);
        if (bbox != null) {
          if (result2 == null) {
            result2 = mxRectangle.fromRectangle(bbox);
          } else {
            result2.add(bbox);
          }
        }
      }
    }
  }
  return result2;
};
mxGraph2.prototype.cloneCell = function(cell2, allowInvalidEdges, mapping, keepPosition) {
  return this.cloneCells([cell2], allowInvalidEdges, mapping, keepPosition)[0];
};
mxGraph2.prototype.cloneCells = function(cells, allowInvalidEdges, mapping, keepPosition) {
  allowInvalidEdges = allowInvalidEdges != null ? allowInvalidEdges : true;
  let clones = null;
  if (cells != null) {
    const dict = new mxDictionary();
    const tmp = [];
    for (let i = 0; i < cells.length; i++) {
      dict.put(cells[i], true);
      tmp.push(cells[i]);
    }
    if (tmp.length > 0) {
      const scale = this.view.scale;
      const trans = this.view.translate;
      clones = this.model.cloneCells(cells, true, mapping);
      for (let i = 0; i < cells.length; i++) {
        if (!allowInvalidEdges && this.model.isEdge(clones[i]) && this.getEdgeValidationError(clones[i], this.model.getTerminal(clones[i], true), this.model.getTerminal(clones[i], false)) != null) {
          clones[i] = null;
        } else {
          const g = this.model.getGeometry(clones[i]);
          if (g != null) {
            const state2 = this.view.getState(cells[i]);
            const pstate = this.view.getState(this.model.getParent(cells[i]));
            if (state2 != null && pstate != null) {
              const dx = keepPosition ? 0 : pstate.origin.x;
              const dy = keepPosition ? 0 : pstate.origin.y;
              if (this.model.isEdge(clones[i])) {
                const pts = state2.absolutePoints;
                if (pts != null) {
                  let src = this.model.getTerminal(cells[i], true);
                  while (src != null && !dict.get(src)) {
                    src = this.model.getParent(src);
                  }
                  if (src == null && pts[0] != null) {
                    g.setTerminalPoint(new mxPoint2(pts[0].x / scale - trans.x, pts[0].y / scale - trans.y), true);
                  }
                  let trg = this.model.getTerminal(cells[i], false);
                  while (trg != null && !dict.get(trg)) {
                    trg = this.model.getParent(trg);
                  }
                  const n = pts.length - 1;
                  if (trg == null && pts[n] != null) {
                    g.setTerminalPoint(new mxPoint2(pts[n].x / scale - trans.x, pts[n].y / scale - trans.y), false);
                  }
                  const points = g.points;
                  if (points != null) {
                    for (let j = 0; j < points.length; j++) {
                      points[j].x += dx;
                      points[j].y += dy;
                    }
                  }
                }
              } else {
                g.translate(dx, dy);
              }
            }
          }
        }
      }
    } else {
      clones = [];
    }
  }
  return clones;
};
mxGraph2.prototype.insertVertex = function(parent2, id, value, x, y, width, height, style, relative) {
  const vertex = this.createVertex(parent2, id, value, x, y, width, height, style, relative);
  return this.addCell(vertex, parent2);
};
mxGraph2.prototype.createVertex = function(parent2, id, value, x, y, width, height, style, relative) {
  const geometry = new mxGeometry(x, y, width, height);
  geometry.relative = relative != null ? relative : false;
  const vertex = new mxCell(value, geometry, style);
  vertex.setId(id);
  vertex.setVertex(true);
  vertex.setConnectable(true);
  return vertex;
};
mxGraph2.prototype.insertEdge = function(parent2, id, value, source, target, style) {
  const edge = this.createEdge(parent2, id, value, source, target, style);
  return this.addEdge(edge, parent2, source, target);
};
mxGraph2.prototype.createEdge = function(parent2, id, value, source, target, style) {
  const edge = new mxCell(value, new mxGeometry(), style);
  edge.setId(id);
  edge.setEdge(true);
  edge.geometry.relative = true;
  return edge;
};
mxGraph2.prototype.addEdge = function(edge, parent2, source, target, index) {
  return this.addCell(edge, parent2, index, source, target);
};
mxGraph2.prototype.addCell = function(cell2, parent2, index, source, target) {
  return this.addCells([cell2], parent2, index, source, target)[0];
};
mxGraph2.prototype.addCells = function(cells, parent2, index, source, target, absolute) {
  if (parent2 == null) {
    parent2 = this.getDefaultParent();
  }
  if (index == null) {
    index = this.model.getChildCount(parent2);
  }
  this.model.beginUpdate();
  try {
    this.cellsAdded(cells, parent2, index, source, target, absolute != null ? absolute : false, true);
    this.fireEvent(new mxEventObject2(mxEvent2.ADD_CELLS, "cells", cells, "parent", parent2, "index", index, "source", source, "target", target));
  } finally {
    this.model.endUpdate();
  }
  return cells;
};
mxGraph2.prototype.cellsAdded = function(cells, parent2, index, source, target, absolute, constrain, extend2) {
  if (cells != null && parent2 != null && index != null) {
    this.model.beginUpdate();
    try {
      const parentState = absolute ? this.view.getState(parent2) : null;
      const o1 = parentState != null ? parentState.origin : null;
      const zero = new mxPoint2(0, 0);
      for (let i = 0; i < cells.length; i++) {
        if (cells[i] == null) {
          index--;
        } else {
          const previous = this.model.getParent(cells[i]);
          if (o1 != null && cells[i] != parent2 && parent2 != previous) {
            const oldState = this.view.getState(previous);
            const o2 = oldState != null ? oldState.origin : zero;
            let geo = this.model.getGeometry(cells[i]);
            if (geo != null) {
              const dx = o2.x - o1.x;
              const dy = o2.y - o1.y;
              geo = geo.clone();
              geo.translate(dx, dy);
              if (!geo.relative && this.model.isVertex(cells[i]) && !this.isAllowNegativeCoordinates()) {
                geo.x = Math.max(0, geo.x);
                geo.y = Math.max(0, geo.y);
              }
              this.model.setGeometry(cells[i], geo);
            }
          }
          if (parent2 == previous && index + i > this.model.getChildCount(parent2)) {
            index--;
          }
          this.model.add(parent2, cells[i], index + i);
          if (this.autoSizeCellsOnAdd) {
            this.autoSizeCell(cells[i], true);
          }
          if ((extend2 == null || extend2) && this.isExtendParentsOnAdd(cells[i]) && this.isExtendParent(cells[i])) {
            this.extendParent(cells[i]);
          }
          if (constrain == null || constrain) {
            this.constrainChild(cells[i]);
          }
          if (source != null) {
            this.cellConnected(cells[i], source, true);
          }
          if (target != null) {
            this.cellConnected(cells[i], target, false);
          }
        }
      }
      this.fireEvent(new mxEventObject2(mxEvent2.CELLS_ADDED, "cells", cells, "parent", parent2, "index", index, "source", source, "target", target, "absolute", absolute));
    } finally {
      this.model.endUpdate();
    }
  }
};
mxGraph2.prototype.autoSizeCell = function(cell2, recurse) {
  recurse = recurse != null ? recurse : true;
  if (recurse) {
    const childCount = this.model.getChildCount(cell2);
    for (let i = 0; i < childCount; i++) {
      this.autoSizeCell(this.model.getChildAt(cell2, i));
    }
  }
  if (this.getModel().isVertex(cell2) && this.isAutoSizeCell(cell2)) {
    this.updateCellSize(cell2);
  }
};
mxGraph2.prototype.removeCells = function(cells, includeEdges) {
  includeEdges = includeEdges != null ? includeEdges : true;
  if (cells == null) {
    cells = this.getDeletableCells(this.getSelectionCells());
  }
  if (includeEdges) {
    cells = this.getDeletableCells(this.addAllEdges(cells));
  } else {
    cells = cells.slice();
    const edges = this.getDeletableCells(this.getAllEdges(cells));
    const dict = new mxDictionary();
    for (let i = 0; i < cells.length; i++) {
      dict.put(cells[i], true);
    }
    for (let i = 0; i < edges.length; i++) {
      if (this.view.getState(edges[i]) == null && !dict.get(edges[i])) {
        dict.put(edges[i], true);
        cells.push(edges[i]);
      }
    }
  }
  this.model.beginUpdate();
  try {
    this.cellsRemoved(cells);
    this.fireEvent(new mxEventObject2(mxEvent2.REMOVE_CELLS, "cells", cells, "includeEdges", includeEdges));
  } finally {
    this.model.endUpdate();
  }
  return cells;
};
mxGraph2.prototype.cellsRemoved = function(cells) {
  if (cells != null && cells.length > 0) {
    const scale = this.view.scale;
    const tr = this.view.translate;
    this.model.beginUpdate();
    try {
      const dict = new mxDictionary();
      for (let i = 0; i < cells.length; i++) {
        dict.put(cells[i], true);
      }
      for (let i = 0; i < cells.length; i++) {
        const edges = this.getAllEdges([cells[i]]);
        const disconnectTerminal = bind(this, function(edge, source) {
          let geo = this.model.getGeometry(edge);
          if (geo != null) {
            let terminal = this.model.getTerminal(edge, source);
            let connected = false;
            let tmp = terminal;
            while (tmp != null) {
              if (cells[i] == tmp) {
                connected = true;
                break;
              }
              tmp = this.model.getParent(tmp);
            }
            if (connected) {
              geo = geo.clone();
              const state2 = this.view.getState(edge);
              if (state2 != null && state2.absolutePoints != null) {
                const pts = state2.absolutePoints;
                const n = source ? 0 : pts.length - 1;
                geo.setTerminalPoint(new mxPoint2(pts[n].x / scale - tr.x - state2.origin.x, pts[n].y / scale - tr.y - state2.origin.y), source);
              } else {
                const tstate = this.view.getState(terminal);
                if (tstate != null) {
                  geo.setTerminalPoint(new mxPoint2(tstate.getCenterX() / scale - tr.x, tstate.getCenterY() / scale - tr.y), source);
                }
              }
              this.model.setGeometry(edge, geo);
              this.model.setTerminal(edge, null, source);
            }
          }
        });
        for (let j = 0; j < edges.length; j++) {
          if (!dict.get(edges[j])) {
            dict.put(edges[j], true);
            disconnectTerminal(edges[j], true);
            disconnectTerminal(edges[j], false);
          }
        }
        this.model.remove(cells[i]);
      }
      this.fireEvent(new mxEventObject2(mxEvent2.CELLS_REMOVED, "cells", cells));
    } finally {
      this.model.endUpdate();
    }
  }
};
mxGraph2.prototype.splitEdge = function(edge, cells, newEdge, dx, dy, x, y, parent2) {
  dx = dx || 0;
  dy = dy || 0;
  parent2 = parent2 != null ? parent2 : this.model.getParent(edge);
  const source = this.model.getTerminal(edge, true);
  this.model.beginUpdate();
  try {
    if (newEdge == null) {
      newEdge = this.cloneCell(edge);
      const state2 = this.view.getState(edge);
      let geo = this.getCellGeometry(newEdge);
      if (geo != null && geo.points != null && state2 != null) {
        const t = this.view.translate;
        const s = this.view.scale;
        const idx = findNearestSegment(state2, (dx + t.x) * s, (dy + t.y) * s);
        geo.points = geo.points.slice(0, idx);
        geo = this.getCellGeometry(edge);
        if (geo != null && geo.points != null) {
          geo = geo.clone();
          geo.points = geo.points.slice(idx);
          this.model.setGeometry(edge, geo);
        }
      }
    }
    this.cellsMoved(cells, dx, dy, false, false);
    this.cellsAdded(cells, parent2, this.model.getChildCount(parent2), null, null, true);
    this.cellsAdded([newEdge], parent2, this.model.getChildCount(parent2), source, cells[0], false);
    this.cellConnected(edge, cells[0], true);
    this.fireEvent(new mxEventObject2(mxEvent2.SPLIT_EDGE, "edge", edge, "cells", cells, "newEdge", newEdge, "dx", dx, "dy", dy));
  } finally {
    this.model.endUpdate();
  }
  return newEdge;
};
mxGraph2.prototype.toggleCells = function(show3, cells, includeEdges) {
  if (cells == null) {
    cells = this.getSelectionCells();
  }
  if (includeEdges) {
    cells = this.addAllEdges(cells);
  }
  this.model.beginUpdate();
  try {
    this.cellsToggled(cells, show3);
    this.fireEvent(new mxEventObject2(mxEvent2.TOGGLE_CELLS, "show", show3, "cells", cells, "includeEdges", includeEdges));
  } finally {
    this.model.endUpdate();
  }
  return cells;
};
mxGraph2.prototype.cellsToggled = function(cells, show3) {
  if (cells != null && cells.length > 0) {
    this.model.beginUpdate();
    try {
      for (let i = 0; i < cells.length; i++) {
        this.model.setVisible(cells[i], show3);
      }
    } finally {
      this.model.endUpdate();
    }
  }
};
mxGraph2.prototype.foldCells = function(collapse, recurse, cells, checkFoldable, evt) {
  recurse = recurse != null ? recurse : false;
  if (cells == null) {
    cells = this.getFoldableCells(this.getSelectionCells(), collapse);
  }
  this.stopEditing(false);
  this.model.beginUpdate();
  try {
    this.cellsFolded(cells, collapse, recurse, checkFoldable);
    this.fireEvent(new mxEventObject2(mxEvent2.FOLD_CELLS, "collapse", collapse, "recurse", recurse, "cells", cells));
  } finally {
    this.model.endUpdate();
  }
  return cells;
};
mxGraph2.prototype.cellsFolded = function(cells, collapse, recurse, checkFoldable) {
  if (cells != null && cells.length > 0) {
    this.model.beginUpdate();
    try {
      for (let i = 0; i < cells.length; i++) {
        if ((!checkFoldable || this.isCellFoldable(cells[i], collapse)) && collapse != this.isCellCollapsed(cells[i])) {
          this.model.setCollapsed(cells[i], collapse);
          this.swapBounds(cells[i], collapse);
          if (this.isExtendParent(cells[i])) {
            this.extendParent(cells[i]);
          }
          if (recurse) {
            const children = this.model.getChildren(cells[i]);
            this.cellsFolded(children, collapse, recurse);
          }
          this.constrainChild(cells[i]);
        }
      }
      this.fireEvent(new mxEventObject2(mxEvent2.CELLS_FOLDED, "cells", cells, "collapse", collapse, "recurse", recurse));
    } finally {
      this.model.endUpdate();
    }
  }
};
mxGraph2.prototype.swapBounds = function(cell2, willCollapse) {
  if (cell2 != null) {
    let geo = this.model.getGeometry(cell2);
    if (geo != null) {
      geo = geo.clone();
      this.updateAlternateBounds(cell2, geo, willCollapse);
      geo.swap();
      this.model.setGeometry(cell2, geo);
    }
  }
};
mxGraph2.prototype.updateAlternateBounds = function(cell2, geo, willCollapse) {
  if (cell2 != null && geo != null) {
    const style = this.getCurrentCellStyle(cell2);
    if (geo.alternateBounds == null) {
      let bounds = geo;
      if (this.collapseToPreferredSize) {
        const tmp = this.getPreferredSizeForCell(cell2);
        if (tmp != null) {
          bounds = tmp;
          const startSize = getValue(style, mxConstants2.STYLE_STARTSIZE);
          if (startSize > 0) {
            bounds.height = Math.max(bounds.height, startSize);
          }
        }
      }
      geo.alternateBounds = new mxRectangle(0, 0, bounds.width, bounds.height);
    }
    if (geo.alternateBounds != null) {
      geo.alternateBounds.x = geo.x;
      geo.alternateBounds.y = geo.y;
      const alpha = toRadians(style[mxConstants2.STYLE_ROTATION] || 0);
      if (alpha != 0) {
        const dx = geo.alternateBounds.getCenterX() - geo.getCenterX();
        const dy = geo.alternateBounds.getCenterY() - geo.getCenterY();
        const cos = Math.cos(alpha);
        const sin = Math.sin(alpha);
        const dx2 = cos * dx - sin * dy;
        const dy2 = sin * dx + cos * dy;
        geo.alternateBounds.x += dx2 - dx;
        geo.alternateBounds.y += dy2 - dy;
      }
    }
  }
};
mxGraph2.prototype.center = function(horizontal, vertical, cx, cy) {
  horizontal = horizontal != null ? horizontal : true;
  vertical = vertical != null ? vertical : true;
  cx = cx != null ? cx : 0.5;
  cy = cy != null ? cy : 0.5;
  const hasScrollbars2 = hasScrollbars(this.container);
  const padding = 2 * this.getBorder();
  const cw = this.container.clientWidth - padding;
  const ch = this.container.clientHeight - padding;
  const bounds = this.getGraphBounds();
  const t = this.view.translate;
  const s = this.view.scale;
  let dx = horizontal ? cw - bounds.width : 0;
  let dy = vertical ? ch - bounds.height : 0;
  if (!hasScrollbars2) {
    this.view.setTranslate(horizontal ? Math.floor(t.x - bounds.x * s + dx * cx / s) : t.x, vertical ? Math.floor(t.y - bounds.y * s + dy * cy / s) : t.y);
  } else {
    bounds.x -= t.x;
    bounds.y -= t.y;
    const sw = this.container.scrollWidth;
    const sh = this.container.scrollHeight;
    if (sw > cw) {
      dx = 0;
    }
    if (sh > ch) {
      dy = 0;
    }
    this.view.setTranslate(Math.floor(dx / 2 - bounds.x), Math.floor(dy / 2 - bounds.y));
    this.container.scrollLeft = (sw - cw) / 2;
    this.container.scrollTop = (sh - ch) / 2;
  }
};
mxGraph2.prototype.addAllEdges = function(cells) {
  const allCells = cells.slice();
  return removeDuplicates(allCells.concat(this.getAllEdges(cells)));
};
mxGraph2.prototype.getAllEdges = function(cells) {
  let edges = [];
  if (cells != null) {
    for (let i = 0; i < cells.length; i++) {
      const edgeCount = this.model.getEdgeCount(cells[i]);
      for (let j = 0; j < edgeCount; j++) {
        edges.push(this.model.getEdgeAt(cells[i], j));
      }
      const children = this.model.getChildren(cells[i]);
      edges = edges.concat(this.getAllEdges(children));
    }
  }
  return edges;
};
mxGraph2.prototype.updateCellSize = function(cell2, ignoreChildren) {
  ignoreChildren = ignoreChildren != null ? ignoreChildren : false;
  this.model.beginUpdate();
  try {
    this.cellSizeUpdated(cell2, ignoreChildren);
    this.fireEvent(new mxEventObject2(mxEvent2.UPDATE_CELL_SIZE, "cell", cell2, "ignoreChildren", ignoreChildren));
  } finally {
    this.model.endUpdate();
  }
  return cell2;
};
mxGraph2.prototype.cellSizeUpdated = function(cell2, ignoreChildren) {
  if (cell2 != null) {
    this.model.beginUpdate();
    try {
      const size = this.getPreferredSizeForCell(cell2);
      let geo = this.model.getGeometry(cell2);
      if (size != null && geo != null) {
        const collapsed = this.isCellCollapsed(cell2);
        geo = geo.clone();
        if (this.isSwimlane(cell2)) {
          const style = this.getCellStyle(cell2);
          let cellStyle = this.model.getStyle(cell2);
          if (cellStyle == null) {
            cellStyle = "";
          }
          if (getValue(style, mxConstants2.STYLE_HORIZONTAL, true)) {
            cellStyle = setStyle(cellStyle, mxConstants2.STYLE_STARTSIZE, size.height + 8);
            if (collapsed) {
              geo.height = size.height + 8;
            }
            geo.width = size.width;
          } else {
            cellStyle = setStyle(cellStyle, mxConstants2.STYLE_STARTSIZE, size.width + 8);
            if (collapsed) {
              geo.width = size.width + 8;
            }
            geo.height = size.height;
          }
          this.model.setStyle(cell2, cellStyle);
        } else {
          const state2 = this.view.createState(cell2);
          const align = state2.style[mxConstants2.STYLE_ALIGN] || mxConstants2.ALIGN_CENTER;
          if (align == mxConstants2.ALIGN_RIGHT) {
            geo.x += geo.width - size.width;
          } else if (align == mxConstants2.ALIGN_CENTER) {
            geo.x += Math.round((geo.width - size.width) / 2);
          }
          const valign = this.getVerticalAlign(state2);
          if (valign == mxConstants2.ALIGN_BOTTOM) {
            geo.y += geo.height - size.height;
          } else if (valign == mxConstants2.ALIGN_MIDDLE) {
            geo.y += Math.round((geo.height - size.height) / 2);
          }
          geo.width = size.width;
          geo.height = size.height;
        }
        if (!ignoreChildren && !collapsed) {
          const bounds = this.view.getBounds(this.model.getChildren(cell2));
          if (bounds != null) {
            const tr = this.view.translate;
            const scale = this.view.scale;
            const width = (bounds.x + bounds.width) / scale - geo.x - tr.x;
            const height = (bounds.y + bounds.height) / scale - geo.y - tr.y;
            geo.width = Math.max(geo.width, width);
            geo.height = Math.max(geo.height, height);
          }
        }
        this.cellsResized([cell2], [geo], false);
      }
    } finally {
      this.model.endUpdate();
    }
  }
};
mxGraph2.prototype.getPreferredSizeForCell = function(cell2, textWidth) {
  let result2 = null;
  if (cell2 != null) {
    const state2 = this.view.createState(cell2);
    const style = state2.style;
    if (!this.model.isEdge(cell2)) {
      const fontSize = style[mxConstants2.STYLE_FONTSIZE] || mxConstants2.DEFAULT_FONTSIZE;
      let dx = 0;
      let dy = 0;
      if (this.getImage(state2) != null || style[mxConstants2.STYLE_IMAGE] != null) {
        if (style[mxConstants2.STYLE_SHAPE] == mxConstants2.SHAPE_LABEL) {
          if (style[mxConstants2.STYLE_VERTICAL_ALIGN] == mxConstants2.ALIGN_MIDDLE) {
            dx += parseFloat(style[mxConstants2.STYLE_IMAGE_WIDTH]) || mxLabel.prototype.imageSize;
          }
          if (style[mxConstants2.STYLE_ALIGN] != mxConstants2.ALIGN_CENTER) {
            dy += parseFloat(style[mxConstants2.STYLE_IMAGE_HEIGHT]) || mxLabel.prototype.imageSize;
          }
        }
      }
      dx += 2 * (style[mxConstants2.STYLE_SPACING] || 0);
      dx += style[mxConstants2.STYLE_SPACING_LEFT] || 0;
      dx += style[mxConstants2.STYLE_SPACING_RIGHT] || 0;
      dy += 2 * (style[mxConstants2.STYLE_SPACING] || 0);
      dy += style[mxConstants2.STYLE_SPACING_TOP] || 0;
      dy += style[mxConstants2.STYLE_SPACING_BOTTOM] || 0;
      const image = this.getFoldingImage(state2);
      if (image != null) {
        dx += image.width + 8;
      }
      let value = this.cellRenderer.getLabelValue(state2);
      if (value != null && value.length > 0) {
        if (!this.isHtmlLabel(state2.cell)) {
          value = htmlEntities(value, false);
        }
        value = value.replace(/\n/g, "<br>");
        const size = getSizeForString(value, fontSize, style[mxConstants2.STYLE_FONTFAMILY], textWidth, style[mxConstants2.STYLE_FONTSTYLE]);
        let width = size.width + dx;
        let height = size.height + dy;
        if (!getValue(style, mxConstants2.STYLE_HORIZONTAL, true)) {
          const tmp = height;
          height = width;
          width = tmp;
        }
        if (this.gridEnabled) {
          width = this.snap(width + this.gridSize / 2);
          height = this.snap(height + this.gridSize / 2);
        }
        result2 = new mxRectangle(0, 0, width, height);
      } else {
        const gs2 = 4 * this.gridSize;
        result2 = new mxRectangle(0, 0, gs2, gs2);
      }
    }
  }
  return result2;
};
mxGraph2.prototype.resizeCell = function(cell2, bounds, recurse) {
  return this.resizeCells([cell2], [bounds], recurse)[0];
};
mxGraph2.prototype.resizeCells = function(cells, bounds, recurse) {
  recurse = recurse != null ? recurse : this.isRecursiveResize();
  this.model.beginUpdate();
  try {
    const prev = this.cellsResized(cells, bounds, recurse);
    this.fireEvent(new mxEventObject2(mxEvent2.RESIZE_CELLS, "cells", cells, "bounds", bounds, "previous", prev));
  } finally {
    this.model.endUpdate();
  }
  return cells;
};
mxGraph2.prototype.cellsResized = function(cells, bounds, recurse) {
  recurse = recurse != null ? recurse : false;
  const prev = [];
  if (cells != null && bounds != null && cells.length == bounds.length) {
    this.model.beginUpdate();
    try {
      for (let i = 0; i < cells.length; i++) {
        prev.push(this.cellResized(cells[i], bounds[i], false, recurse));
        if (this.isExtendParent(cells[i])) {
          this.extendParent(cells[i]);
        }
        this.constrainChild(cells[i]);
      }
      if (this.resetEdgesOnResize) {
        this.resetEdges(cells);
      }
      this.fireEvent(new mxEventObject2(mxEvent2.CELLS_RESIZED, "cells", cells, "bounds", bounds, "previous", prev));
    } finally {
      this.model.endUpdate();
    }
  }
  return prev;
};
mxGraph2.prototype.cellResized = function(cell2, bounds, ignoreRelative, recurse) {
  const prev = this.model.getGeometry(cell2);
  if (prev != null && (prev.x != bounds.x || prev.y != bounds.y || prev.width != bounds.width || prev.height != bounds.height)) {
    let geo = prev.clone();
    if (!ignoreRelative && geo.relative) {
      const offset = geo.offset;
      if (offset != null) {
        offset.x += bounds.x - geo.x;
        offset.y += bounds.y - geo.y;
      }
    } else {
      geo.x = bounds.x;
      geo.y = bounds.y;
    }
    geo.width = bounds.width;
    geo.height = bounds.height;
    if (!geo.relative && this.model.isVertex(cell2) && !this.isAllowNegativeCoordinates()) {
      geo.x = Math.max(0, geo.x);
      geo.y = Math.max(0, geo.y);
    }
    this.model.beginUpdate();
    try {
      if (recurse) {
        this.resizeChildCells(cell2, geo);
      }
      this.model.setGeometry(cell2, geo);
      this.constrainChildCells(cell2);
    } finally {
      this.model.endUpdate();
    }
  }
  return prev;
};
mxGraph2.prototype.resizeChildCells = function(cell2, newGeo) {
  const geo = this.model.getGeometry(cell2);
  const dx = geo.width != 0 ? newGeo.width / geo.width : 1;
  const dy = geo.height != 0 ? newGeo.height / geo.height : 1;
  const childCount = this.model.getChildCount(cell2);
  for (let i = 0; i < childCount; i++) {
    this.scaleCell(this.model.getChildAt(cell2, i), dx, dy, true);
  }
};
mxGraph2.prototype.constrainChildCells = function(cell2) {
  const childCount = this.model.getChildCount(cell2);
  for (let i = 0; i < childCount; i++) {
    this.constrainChild(this.model.getChildAt(cell2, i));
  }
};
mxGraph2.prototype.scaleCell = function(cell2, dx, dy, recurse) {
  let geo = this.model.getGeometry(cell2);
  if (geo != null) {
    const style = this.getCurrentCellStyle(cell2);
    geo = geo.clone();
    const x = geo.x;
    const y = geo.y;
    const w2 = geo.width;
    const h2 = geo.height;
    geo.scale(dx, dy, style[mxConstants2.STYLE_ASPECT] == "fixed");
    if (style[mxConstants2.STYLE_RESIZE_WIDTH] == "1") {
      geo.width = w2 * dx;
    } else if (style[mxConstants2.STYLE_RESIZE_WIDTH] == "0") {
      geo.width = w2;
    }
    if (style[mxConstants2.STYLE_RESIZE_HEIGHT] == "1") {
      geo.height = h2 * dy;
    } else if (style[mxConstants2.STYLE_RESIZE_HEIGHT] == "0") {
      geo.height = h2;
    }
    if (!this.isCellMovable(cell2)) {
      geo.x = x;
      geo.y = y;
    }
    if (!this.isCellResizable(cell2)) {
      geo.width = w2;
      geo.height = h2;
    }
    if (this.model.isVertex(cell2)) {
      this.cellResized(cell2, geo, true, recurse);
    } else {
      this.model.setGeometry(cell2, geo);
    }
  }
};
mxGraph2.prototype.extendParent = function(cell2) {
  if (cell2 != null) {
    const parent2 = this.model.getParent(cell2);
    let p = this.getCellGeometry(parent2);
    if (parent2 != null && p != null && !this.isCellCollapsed(parent2)) {
      const geo = this.getCellGeometry(cell2);
      if (geo != null && !geo.relative && (p.width < geo.x + geo.width || p.height < geo.y + geo.height)) {
        p = p.clone();
        p.width = Math.max(p.width, geo.x + geo.width);
        p.height = Math.max(p.height, geo.y + geo.height);
        this.cellsResized([parent2], [p], false);
      }
    }
  }
};
mxGraph2.prototype.importCells = function(cells, dx, dy, target, evt, mapping) {
  return this.moveCells(cells, dx, dy, true, target, evt, mapping);
};
mxGraph2.prototype.moveCells = function(cells, dx, dy, clone3, target, evt, mapping) {
  dx = dx != null ? dx : 0;
  dy = dy != null ? dy : 0;
  clone3 = clone3 != null ? clone3 : false;
  if (cells != null && (dx != 0 || dy != 0 || clone3 || target != null)) {
    cells = this.model.getTopmostCells(cells);
    const origCells = cells;
    this.model.beginUpdate();
    try {
      const dict = new mxDictionary();
      for (let i = 0; i < cells.length; i++) {
        dict.put(cells[i], true);
      }
      const isSelected = bind(this, function(cell2) {
        while (cell2 != null) {
          if (dict.get(cell2)) {
            return true;
          }
          cell2 = this.model.getParent(cell2);
        }
        return false;
      });
      const checked = [];
      for (let i = 0; i < cells.length; i++) {
        const geo = this.getCellGeometry(cells[i]);
        const parent2 = this.model.getParent(cells[i]);
        if (geo == null || !geo.relative || !this.model.isEdge(parent2) || !isSelected(this.model.getTerminal(parent2, true)) && !isSelected(this.model.getTerminal(parent2, false))) {
          checked.push(cells[i]);
        }
      }
      cells = checked;
      if (clone3) {
        cells = this.cloneCells(cells, this.isCloneInvalidEdges(), mapping);
        if (target == null) {
          target = this.getDefaultParent();
        }
      }
      const previous = this.isAllowNegativeCoordinates();
      if (target != null) {
        this.setAllowNegativeCoordinates(true);
      }
      this.cellsMoved(cells, dx, dy, !clone3 && this.isDisconnectOnMove() && this.isAllowDanglingEdges(), target == null, this.isExtendParentsOnMove() && target == null);
      this.setAllowNegativeCoordinates(previous);
      if (target != null) {
        const index = this.model.getChildCount(target);
        this.cellsAdded(cells, target, index, null, null, true);
        if (clone3) {
          for (let i = 0; i < cells.length; i++) {
            const geo = this.getCellGeometry(cells[i]);
            const parent2 = this.model.getParent(origCells[i]);
            if (geo != null && geo.relative && this.model.isEdge(parent2) && this.model.contains(parent2)) {
              this.model.add(parent2, cells[i]);
            }
          }
        }
      }
      this.fireEvent(new mxEventObject2(mxEvent2.MOVE_CELLS, "cells", cells, "dx", dx, "dy", dy, "clone", clone3, "target", target, "event", evt));
    } finally {
      this.model.endUpdate();
    }
  }
  return cells;
};
mxGraph2.prototype.cellsMoved = function(cells, dx, dy, disconnect, constrain, extend2) {
  if (cells != null && (dx != 0 || dy != 0)) {
    extend2 = extend2 != null ? extend2 : false;
    this.model.beginUpdate();
    try {
      if (disconnect) {
        this.disconnectGraph(cells);
      }
      for (let i = 0; i < cells.length; i++) {
        this.translateCell(cells[i], dx, dy);
        if (extend2 && this.isExtendParent(cells[i])) {
          this.extendParent(cells[i]);
        } else if (constrain) {
          this.constrainChild(cells[i]);
        }
      }
      if (this.resetEdgesOnMove) {
        this.resetEdges(cells);
      }
      this.fireEvent(new mxEventObject2(mxEvent2.CELLS_MOVED, "cells", cells, "dx", dx, "dy", dy, "disconnect", disconnect));
    } finally {
      this.model.endUpdate();
    }
  }
};
mxGraph2.prototype.translateCell = function(cell2, dx, dy) {
  let geo = this.model.getGeometry(cell2);
  if (geo != null) {
    dx = parseFloat(dx);
    dy = parseFloat(dy);
    geo = geo.clone();
    geo.translate(dx, dy);
    if (!geo.relative && this.model.isVertex(cell2) && !this.isAllowNegativeCoordinates()) {
      geo.x = Math.max(0, parseFloat(geo.x));
      geo.y = Math.max(0, parseFloat(geo.y));
    }
    if (geo.relative && !this.model.isEdge(cell2)) {
      const parent2 = this.model.getParent(cell2);
      let angle = 0;
      if (this.model.isVertex(parent2)) {
        const style = this.getCurrentCellStyle(parent2);
        angle = getValue(style, mxConstants2.STYLE_ROTATION, 0);
      }
      if (angle != 0) {
        const rad = toRadians(-angle);
        const cos = Math.cos(rad);
        const sin = Math.sin(rad);
        const pt = getRotatedPoint(new mxPoint2(dx, dy), cos, sin, new mxPoint2(0, 0));
        dx = pt.x;
        dy = pt.y;
      }
      if (geo.offset == null) {
        geo.offset = new mxPoint2(dx, dy);
      } else {
        geo.offset.x = parseFloat(geo.offset.x) + dx;
        geo.offset.y = parseFloat(geo.offset.y) + dy;
      }
    }
    this.model.setGeometry(cell2, geo);
  }
};
mxGraph2.prototype.getCellContainmentArea = function(cell2) {
  if (cell2 != null && !this.model.isEdge(cell2)) {
    const parent2 = this.model.getParent(cell2);
    if (parent2 != null && parent2 != this.getDefaultParent()) {
      const g = this.model.getGeometry(parent2);
      if (g != null) {
        let x = 0;
        let y = 0;
        let w2 = g.width;
        let h2 = g.height;
        if (this.isSwimlane(parent2)) {
          const size = this.getStartSize(parent2);
          const style = this.getCurrentCellStyle(parent2);
          const dir = getValue(style, mxConstants2.STYLE_DIRECTION, mxConstants2.DIRECTION_EAST);
          const flipH = getValue(style, mxConstants2.STYLE_FLIPH, 0) == 1;
          const flipV = getValue(style, mxConstants2.STYLE_FLIPV, 0) == 1;
          if (dir == mxConstants2.DIRECTION_SOUTH || dir == mxConstants2.DIRECTION_NORTH) {
            const tmp = size.width;
            size.width = size.height;
            size.height = tmp;
          }
          if (dir == mxConstants2.DIRECTION_EAST && !flipV || dir == mxConstants2.DIRECTION_NORTH && !flipH || dir == mxConstants2.DIRECTION_WEST && flipV || dir == mxConstants2.DIRECTION_SOUTH && flipH) {
            x = size.width;
            y = size.height;
          }
          w2 -= size.width;
          h2 -= size.height;
        }
        return new mxRectangle(x, y, w2, h2);
      }
    }
  }
  return null;
};
mxGraph2.prototype.getMaximumGraphBounds = function() {
  return this.maximumGraphBounds;
};
mxGraph2.prototype.constrainChild = function(cell2, sizeFirst) {
  sizeFirst = sizeFirst != null ? sizeFirst : true;
  if (cell2 != null) {
    let geo = this.getCellGeometry(cell2);
    if (geo != null && (this.isConstrainRelativeChildren() || !geo.relative)) {
      const parent2 = this.model.getParent(cell2);
      const pgeo = this.getCellGeometry(parent2);
      let max = this.getMaximumGraphBounds();
      if (max != null) {
        const off = this.getBoundingBoxFromGeometry([parent2], false);
        if (off != null) {
          max = mxRectangle.fromRectangle(max);
          max.x -= off.x;
          max.y -= off.y;
        }
      }
      if (this.isConstrainChild(cell2)) {
        let tmp = this.getCellContainmentArea(cell2);
        if (tmp != null) {
          const overlap = this.getOverlap(cell2);
          if (overlap > 0) {
            tmp = mxRectangle.fromRectangle(tmp);
            tmp.x -= tmp.width * overlap;
            tmp.y -= tmp.height * overlap;
            tmp.width += 2 * tmp.width * overlap;
            tmp.height += 2 * tmp.height * overlap;
          }
          if (max == null) {
            max = tmp;
          } else {
            max = mxRectangle.fromRectangle(max);
            max.intersect(tmp);
          }
        }
      }
      if (max != null) {
        const cells = [cell2];
        if (!this.isCellCollapsed(cell2)) {
          const desc = this.model.getDescendants(cell2);
          for (let i = 0; i < desc.length; i++) {
            if (this.isCellVisible(desc[i])) {
              cells.push(desc[i]);
            }
          }
        }
        const bbox = this.getBoundingBoxFromGeometry(cells, false);
        if (bbox != null) {
          geo = geo.clone();
          let dx = 0;
          if (geo.width > max.width) {
            dx = geo.width - max.width;
            geo.width -= dx;
          }
          if (bbox.x + bbox.width > max.x + max.width) {
            dx -= bbox.x + bbox.width - max.x - max.width - dx;
          }
          let dy = 0;
          if (geo.height > max.height) {
            dy = geo.height - max.height;
            geo.height -= dy;
          }
          if (bbox.y + bbox.height > max.y + max.height) {
            dy -= bbox.y + bbox.height - max.y - max.height - dy;
          }
          if (bbox.x < max.x) {
            dx -= bbox.x - max.x;
          }
          if (bbox.y < max.y) {
            dy -= bbox.y - max.y;
          }
          if (dx != 0 || dy != 0) {
            if (geo.relative) {
              if (geo.offset == null) {
                geo.offset = new mxPoint2();
              }
              geo.offset.x += dx;
              geo.offset.y += dy;
            } else {
              geo.x += dx;
              geo.y += dy;
            }
          }
          this.model.setGeometry(cell2, geo);
        }
      }
    }
  }
};
mxGraph2.prototype.resetEdges = function(cells) {
  if (cells != null) {
    const dict = new mxDictionary();
    for (let i = 0; i < cells.length; i++) {
      dict.put(cells[i], true);
    }
    this.model.beginUpdate();
    try {
      for (let i = 0; i < cells.length; i++) {
        const edges = this.model.getEdges(cells[i]);
        if (edges != null) {
          for (let j = 0; j < edges.length; j++) {
            const state2 = this.view.getState(edges[j]);
            const source = state2 != null ? state2.getVisibleTerminal(true) : this.view.getVisibleTerminal(edges[j], true);
            const target = state2 != null ? state2.getVisibleTerminal(false) : this.view.getVisibleTerminal(edges[j], false);
            if (!dict.get(source) || !dict.get(target)) {
              this.resetEdge(edges[j]);
            }
          }
        }
        this.resetEdges(this.model.getChildren(cells[i]));
      }
    } finally {
      this.model.endUpdate();
    }
  }
};
mxGraph2.prototype.resetEdge = function(edge) {
  let geo = this.model.getGeometry(edge);
  if (geo != null && geo.points != null && geo.points.length > 0) {
    geo = geo.clone();
    geo.points = [];
    this.model.setGeometry(edge, geo);
  }
  return edge;
};
mxGraph2.prototype.getOutlineConstraint = function(point, terminalState, me) {
  if (terminalState.shape != null) {
    const bounds = this.view.getPerimeterBounds(terminalState);
    const direction = terminalState.style[mxConstants2.STYLE_DIRECTION];
    if (direction == mxConstants2.DIRECTION_NORTH || direction == mxConstants2.DIRECTION_SOUTH) {
      bounds.x += bounds.width / 2 - bounds.height / 2;
      bounds.y += bounds.height / 2 - bounds.width / 2;
      const tmp = bounds.width;
      bounds.width = bounds.height;
      bounds.height = tmp;
    }
    const alpha = toRadians(terminalState.shape.getShapeRotation());
    if (alpha != 0) {
      const cos = Math.cos(-alpha);
      const sin = Math.sin(-alpha);
      const ct = new mxPoint2(bounds.getCenterX(), bounds.getCenterY());
      point = getRotatedPoint(point, cos, sin, ct);
    }
    let sx = 1;
    let sy = 1;
    let dx = 0;
    let dy = 0;
    if (this.getModel().isVertex(terminalState.cell)) {
      let flipH = terminalState.style[mxConstants2.STYLE_FLIPH];
      let flipV = terminalState.style[mxConstants2.STYLE_FLIPV];
      if (terminalState.shape != null && terminalState.shape.stencil != null) {
        flipH = getValue(terminalState.style, "stencilFlipH", 0) == 1 || flipH;
        flipV = getValue(terminalState.style, "stencilFlipV", 0) == 1 || flipV;
      }
      if (direction == mxConstants2.DIRECTION_NORTH || direction == mxConstants2.DIRECTION_SOUTH) {
        const tmp = flipH;
        flipH = flipV;
        flipV = tmp;
      }
      if (flipH) {
        sx = -1;
        dx = -bounds.width;
      }
      if (flipV) {
        sy = -1;
        dy = -bounds.height;
      }
    }
    point = new mxPoint2((point.x - bounds.x) * sx - dx + bounds.x, (point.y - bounds.y) * sy - dy + bounds.y);
    const x = bounds.width == 0 ? 0 : Math.round((point.x - bounds.x) * 1e3 / bounds.width) / 1e3;
    const y = bounds.height == 0 ? 0 : Math.round((point.y - bounds.y) * 1e3 / bounds.height) / 1e3;
    return new mxConnectionConstraint2(new mxPoint2(x, y), false);
  }
  return null;
};
mxGraph2.prototype.getAllConnectionConstraints = function(terminal, source) {
  if (terminal != null && terminal.shape != null && terminal.shape.stencil != null) {
    return terminal.shape.stencil.constraints;
  }
  return null;
};
mxGraph2.prototype.getConnectionConstraint = function(edge, terminal, source) {
  let point = null;
  const x = edge.style[source ? mxConstants2.STYLE_EXIT_X : mxConstants2.STYLE_ENTRY_X];
  if (x != null) {
    const y = edge.style[source ? mxConstants2.STYLE_EXIT_Y : mxConstants2.STYLE_ENTRY_Y];
    if (y != null) {
      point = new mxPoint2(parseFloat(x), parseFloat(y));
    }
  }
  let perimeter = false;
  let dx = 0, dy = 0;
  if (point != null) {
    perimeter = getValue(edge.style, source ? mxConstants2.STYLE_EXIT_PERIMETER : mxConstants2.STYLE_ENTRY_PERIMETER, true);
    dx = parseFloat(edge.style[source ? mxConstants2.STYLE_EXIT_DX : mxConstants2.STYLE_ENTRY_DX]);
    dy = parseFloat(edge.style[source ? mxConstants2.STYLE_EXIT_DY : mxConstants2.STYLE_ENTRY_DY]);
    dx = isFinite(dx) ? dx : 0;
    dy = isFinite(dy) ? dy : 0;
  }
  return new mxConnectionConstraint2(point, perimeter, null, dx, dy);
};
mxGraph2.prototype.setConnectionConstraint = function(edge, terminal, source, constraint) {
  if (constraint != null) {
    this.model.beginUpdate();
    try {
      if (constraint == null || constraint.point == null) {
        this.setCellStyles(source ? mxConstants2.STYLE_EXIT_X : mxConstants2.STYLE_ENTRY_X, null, [edge]);
        this.setCellStyles(source ? mxConstants2.STYLE_EXIT_Y : mxConstants2.STYLE_ENTRY_Y, null, [edge]);
        this.setCellStyles(source ? mxConstants2.STYLE_EXIT_DX : mxConstants2.STYLE_ENTRY_DX, null, [edge]);
        this.setCellStyles(source ? mxConstants2.STYLE_EXIT_DY : mxConstants2.STYLE_ENTRY_DY, null, [edge]);
        this.setCellStyles(source ? mxConstants2.STYLE_EXIT_PERIMETER : mxConstants2.STYLE_ENTRY_PERIMETER, null, [edge]);
      } else if (constraint.point != null) {
        this.setCellStyles(source ? mxConstants2.STYLE_EXIT_X : mxConstants2.STYLE_ENTRY_X, constraint.point.x, [edge]);
        this.setCellStyles(source ? mxConstants2.STYLE_EXIT_Y : mxConstants2.STYLE_ENTRY_Y, constraint.point.y, [edge]);
        this.setCellStyles(source ? mxConstants2.STYLE_EXIT_DX : mxConstants2.STYLE_ENTRY_DX, constraint.dx, [edge]);
        this.setCellStyles(source ? mxConstants2.STYLE_EXIT_DY : mxConstants2.STYLE_ENTRY_DY, constraint.dy, [edge]);
        if (!constraint.perimeter) {
          this.setCellStyles(source ? mxConstants2.STYLE_EXIT_PERIMETER : mxConstants2.STYLE_ENTRY_PERIMETER, "0", [edge]);
        } else {
          this.setCellStyles(source ? mxConstants2.STYLE_EXIT_PERIMETER : mxConstants2.STYLE_ENTRY_PERIMETER, null, [edge]);
        }
      }
    } finally {
      this.model.endUpdate();
    }
  }
};
mxGraph2.prototype.getConnectionPoint = function(vertex, constraint, round) {
  round = round != null ? round : true;
  let point = null;
  if (vertex != null && constraint.point != null) {
    const bounds = this.view.getPerimeterBounds(vertex);
    const cx = new mxPoint2(bounds.getCenterX(), bounds.getCenterY());
    const direction = vertex.style[mxConstants2.STYLE_DIRECTION];
    let r1 = 0;
    if (direction != null && getValue(vertex.style, mxConstants2.STYLE_ANCHOR_POINT_DIRECTION, 1) == 1) {
      if (direction == mxConstants2.DIRECTION_NORTH) {
        r1 += 270;
      } else if (direction == mxConstants2.DIRECTION_WEST) {
        r1 += 180;
      } else if (direction == mxConstants2.DIRECTION_SOUTH) {
        r1 += 90;
      }
      if (direction == mxConstants2.DIRECTION_NORTH || direction == mxConstants2.DIRECTION_SOUTH) {
        bounds.rotate90();
      }
    }
    const scale = this.view.scale;
    point = new mxPoint2(bounds.x + constraint.point.x * bounds.width + constraint.dx * scale, bounds.y + constraint.point.y * bounds.height + constraint.dy * scale);
    let r2 = vertex.style[mxConstants2.STYLE_ROTATION] || 0;
    if (constraint.perimeter) {
      if (r1 != 0) {
        let cos = 0;
        let sin = 0;
        if (r1 == 90) {
          sin = 1;
        } else if (r1 == 180) {
          cos = -1;
        } else if (r1 == 270) {
          sin = -1;
        }
        point = getRotatedPoint(point, cos, sin, cx);
      }
      point = this.view.getPerimeterPoint(vertex, point, false);
    } else {
      r2 += r1;
      if (this.getModel().isVertex(vertex.cell)) {
        let flipH = vertex.style[mxConstants2.STYLE_FLIPH] == 1;
        let flipV = vertex.style[mxConstants2.STYLE_FLIPV] == 1;
        if (vertex.shape != null && vertex.shape.stencil != null) {
          flipH = getValue(vertex.style, "stencilFlipH", 0) == 1 || flipH;
          flipV = getValue(vertex.style, "stencilFlipV", 0) == 1 || flipV;
        }
        if (direction == mxConstants2.DIRECTION_NORTH || direction == mxConstants2.DIRECTION_SOUTH) {
          const temp2 = flipH;
          flipH = flipV;
          flipV = temp2;
        }
        if (flipH) {
          point.x = 2 * bounds.getCenterX() - point.x;
        }
        if (flipV) {
          point.y = 2 * bounds.getCenterY() - point.y;
        }
      }
    }
    if (r2 != 0 && point != null) {
      const rad = toRadians(r2);
      const cos = Math.cos(rad);
      const sin = Math.sin(rad);
      point = getRotatedPoint(point, cos, sin, cx);
    }
  }
  if (round && point != null) {
    point.x = Math.round(point.x);
    point.y = Math.round(point.y);
  }
  return point;
};
mxGraph2.prototype.connectCell = function(edge, terminal, source, constraint) {
  this.model.beginUpdate();
  try {
    const previous = this.model.getTerminal(edge, source);
    this.cellConnected(edge, terminal, source, constraint);
    this.fireEvent(new mxEventObject2(mxEvent2.CONNECT_CELL, "edge", edge, "terminal", terminal, "source", source, "previous", previous));
  } finally {
    this.model.endUpdate();
  }
  return edge;
};
mxGraph2.prototype.cellConnected = function(edge, terminal, source, constraint) {
  if (edge != null) {
    this.model.beginUpdate();
    try {
      const previous = this.model.getTerminal(edge, source);
      this.setConnectionConstraint(edge, terminal, source, constraint);
      if (this.isPortsEnabled()) {
        let id = null;
        if (this.isPort(terminal)) {
          id = terminal.getId();
          terminal = this.getTerminalForPort(terminal, source);
        }
        const key = source ? mxConstants2.STYLE_SOURCE_PORT : mxConstants2.STYLE_TARGET_PORT;
        this.setCellStyles(key, id, [edge]);
      }
      this.model.setTerminal(edge, terminal, source);
      if (this.resetEdgesOnConnect) {
        this.resetEdge(edge);
      }
      this.fireEvent(new mxEventObject2(mxEvent2.CELL_CONNECTED, "edge", edge, "terminal", terminal, "source", source, "previous", previous));
    } finally {
      this.model.endUpdate();
    }
  }
};
mxGraph2.prototype.disconnectGraph = function(cells) {
  if (cells != null) {
    this.model.beginUpdate();
    try {
      const scale = this.view.scale;
      const tr = this.view.translate;
      const dict = new mxDictionary();
      for (let i = 0; i < cells.length; i++) {
        dict.put(cells[i], true);
      }
      for (let i = 0; i < cells.length; i++) {
        if (this.model.isEdge(cells[i])) {
          let geo = this.model.getGeometry(cells[i]);
          if (geo != null) {
            const state2 = this.view.getState(cells[i]);
            const pstate = this.view.getState(this.model.getParent(cells[i]));
            if (state2 != null && pstate != null) {
              geo = geo.clone();
              const dx = -pstate.origin.x;
              const dy = -pstate.origin.y;
              const pts = state2.absolutePoints;
              let src = this.model.getTerminal(cells[i], true);
              if (src != null && this.isCellDisconnectable(cells[i], src, true)) {
                while (src != null && !dict.get(src)) {
                  src = this.model.getParent(src);
                }
                if (src == null) {
                  geo.setTerminalPoint(new mxPoint2(pts[0].x / scale - tr.x + dx, pts[0].y / scale - tr.y + dy), true);
                  this.model.setTerminal(cells[i], null, true);
                }
              }
              let trg = this.model.getTerminal(cells[i], false);
              if (trg != null && this.isCellDisconnectable(cells[i], trg, false)) {
                while (trg != null && !dict.get(trg)) {
                  trg = this.model.getParent(trg);
                }
                if (trg == null) {
                  const n = pts.length - 1;
                  geo.setTerminalPoint(new mxPoint2(pts[n].x / scale - tr.x + dx, pts[n].y / scale - tr.y + dy), false);
                  this.model.setTerminal(cells[i], null, false);
                }
              }
              this.model.setGeometry(cells[i], geo);
            }
          }
        }
      }
    } finally {
      this.model.endUpdate();
    }
  }
};
mxGraph2.prototype.getCurrentRoot = function() {
  return this.view.currentRoot;
};
mxGraph2.prototype.getTranslateForRoot = function(cell2) {
  return null;
};
mxGraph2.prototype.isPort = function(cell2) {
  return false;
};
mxGraph2.prototype.getTerminalForPort = function(cell2, source) {
  return this.model.getParent(cell2);
};
mxGraph2.prototype.getChildOffsetForCell = function(cell2) {
  return null;
};
mxGraph2.prototype.enterGroup = function(cell2) {
  cell2 = cell2 || this.getSelectionCell();
  if (cell2 != null && this.isValidRoot(cell2)) {
    this.view.setCurrentRoot(cell2);
    this.clearSelection();
  }
};
mxGraph2.prototype.exitGroup = function() {
  const root = this.model.getRoot();
  const current2 = this.getCurrentRoot();
  if (current2 != null) {
    let next = this.model.getParent(current2);
    while (next != root && !this.isValidRoot(next) && this.model.getParent(next) != root) {
      next = this.model.getParent(next);
    }
    if (next == root || this.model.getParent(next) == root) {
      this.view.setCurrentRoot(null);
    } else {
      this.view.setCurrentRoot(next);
    }
    const state2 = this.view.getState(current2);
    if (state2 != null) {
      this.setSelectionCell(current2);
    }
  }
};
mxGraph2.prototype.home = function() {
  const current2 = this.getCurrentRoot();
  if (current2 != null) {
    this.view.setCurrentRoot(null);
    const state2 = this.view.getState(current2);
    if (state2 != null) {
      this.setSelectionCell(current2);
    }
  }
};
mxGraph2.prototype.isValidRoot = function(cell2) {
  return cell2 != null;
};
mxGraph2.prototype.getGraphBounds = function() {
  return this.view.getGraphBounds();
};
mxGraph2.prototype.getCellBounds = function(cell2, includeEdges, includeDescendants) {
  let cells = [cell2];
  if (includeEdges) {
    cells = cells.concat(this.model.getEdges(cell2));
  }
  let result2 = this.view.getBounds(cells);
  if (includeDescendants) {
    const childCount = this.model.getChildCount(cell2);
    for (let i = 0; i < childCount; i++) {
      const tmp = this.getCellBounds(this.model.getChildAt(cell2, i), includeEdges, true);
      if (result2 != null) {
        result2.add(tmp);
      } else {
        result2 = tmp;
      }
    }
  }
  return result2;
};
mxGraph2.prototype.getBoundingBoxFromGeometry = function(cells, includeEdges) {
  includeEdges = includeEdges != null ? includeEdges : false;
  let result2 = null;
  if (cells != null) {
    for (let i = 0; i < cells.length; i++) {
      if (includeEdges || this.model.isVertex(cells[i])) {
        const geo = this.getCellGeometry(cells[i]);
        if (geo != null) {
          let bbox = null;
          if (this.model.isEdge(cells[i])) {
            let tmp = null;
            const addPoint = function(pt) {
              if (pt != null) {
                if (tmp == null) {
                  tmp = new mxRectangle(pt.x, pt.y, 0, 0);
                } else {
                  tmp.add(new mxRectangle(pt.x, pt.y, 0, 0));
                }
              }
            };
            if (this.model.getTerminal(cells[i], true) == null) {
              addPoint(geo.getTerminalPoint(true));
            }
            if (this.model.getTerminal(cells[i], false) == null) {
              addPoint(geo.getTerminalPoint(false));
            }
            const pts = geo.points;
            if (pts != null) {
              for (let j = 0; j < pts.length; j++) {
                addPoint(pts[j]);
              }
            }
            bbox = tmp;
          } else {
            const parent2 = this.model.getParent(cells[i]);
            if (geo.relative) {
              if (this.model.isVertex(parent2) && parent2 != this.view.currentRoot) {
                const tmp = this.getBoundingBoxFromGeometry([parent2], false);
                if (tmp != null) {
                  bbox = new mxRectangle(geo.x * tmp.width, geo.y * tmp.height, geo.width, geo.height);
                  if (indexOf(cells, parent2) >= 0) {
                    bbox.x += tmp.x;
                    bbox.y += tmp.y;
                  }
                }
              }
            } else {
              bbox = mxRectangle.fromRectangle(geo);
              if (this.model.isVertex(parent2) && indexOf(cells, parent2) >= 0) {
                const tmp = this.getBoundingBoxFromGeometry([parent2], false);
                if (tmp != null) {
                  bbox.x += tmp.x;
                  bbox.y += tmp.y;
                }
              }
            }
            if (bbox != null && geo.offset != null) {
              bbox.x += geo.offset.x;
              bbox.y += geo.offset.y;
            }
            const style = this.getCurrentCellStyle(cells[i]);
            if (bbox != null) {
              const angle = getValue(style, mxConstants2.STYLE_ROTATION, 0);
              if (angle != 0) {
                bbox = getBoundingBox(bbox, angle);
              }
            }
          }
          if (bbox != null) {
            if (result2 == null) {
              result2 = mxRectangle.fromRectangle(bbox);
            } else {
              result2.add(bbox);
            }
          }
        }
      }
    }
  }
  return result2;
};
mxGraph2.prototype.refresh = function(cell2) {
  this.view.clear(cell2, cell2 == null);
  this.view.validate();
  this.sizeDidChange();
  this.fireEvent(new mxEventObject2(mxEvent2.REFRESH));
};
mxGraph2.prototype.snap = function(value) {
  if (this.gridEnabled) {
    value = Math.round(value / this.gridSize) * this.gridSize;
  }
  return value;
};
mxGraph2.prototype.snapDelta = function(delta, bounds, ignoreGrid, ignoreHorizontal, ignoreVertical) {
  const t = this.view.translate;
  const s = this.view.scale;
  if (!ignoreGrid && this.gridEnabled) {
    const tol = this.gridSize * s * 0.5;
    if (!ignoreHorizontal) {
      const tx = bounds.x - (this.snap(bounds.x / s - t.x) + t.x) * s;
      if (Math.abs(delta.x - tx) < tol) {
        delta.x = 0;
      } else {
        delta.x = this.snap(delta.x / s) * s - tx;
      }
    }
    if (!ignoreVertical) {
      const ty = bounds.y - (this.snap(bounds.y / s - t.y) + t.y) * s;
      if (Math.abs(delta.y - ty) < tol) {
        delta.y = 0;
      } else {
        delta.y = this.snap(delta.y / s) * s - ty;
      }
    }
  } else {
    const tol = 0.5 * s;
    if (!ignoreHorizontal) {
      const tx = bounds.x - (Math.round(bounds.x / s - t.x) + t.x) * s;
      if (Math.abs(delta.x - tx) < tol) {
        delta.x = 0;
      } else {
        delta.x = Math.round(delta.x / s) * s - tx;
      }
    }
    if (!ignoreVertical) {
      const ty = bounds.y - (Math.round(bounds.y / s - t.y) + t.y) * s;
      if (Math.abs(delta.y - ty) < tol) {
        delta.y = 0;
      } else {
        delta.y = Math.round(delta.y / s) * s - ty;
      }
    }
  }
  return delta;
};
mxGraph2.prototype.panGraph = function(dx, dy) {
  if (this.useScrollbarsForPanning && hasScrollbars(this.container)) {
    this.container.scrollLeft = -dx;
    this.container.scrollTop = -dy;
  } else {
    const canvas = this.view.getCanvas();
    if (this.dialect == mxConstants2.DIALECT_SVG) {
      if (dx == 0 && dy == 0) {
        if (mxClient_default.IS_IE) {
          canvas.setAttribute("transform", "translate(" + dx + "," + dy + ")");
        } else {
          canvas.removeAttribute("transform");
        }
        if (this.shiftPreview1 != null) {
          let child = this.shiftPreview1.firstChild;
          while (child != null) {
            const next = child.nextSibling;
            this.container.appendChild(child);
            child = next;
          }
          if (this.shiftPreview1.parentNode != null) {
            this.shiftPreview1.parentNode.removeChild(this.shiftPreview1);
          }
          this.shiftPreview1 = null;
          this.container.appendChild(canvas.parentNode);
          child = this.shiftPreview2.firstChild;
          while (child != null) {
            const next = child.nextSibling;
            this.container.appendChild(child);
            child = next;
          }
          if (this.shiftPreview2.parentNode != null) {
            this.shiftPreview2.parentNode.removeChild(this.shiftPreview2);
          }
          this.shiftPreview2 = null;
        }
      } else {
        canvas.setAttribute("transform", "translate(" + dx + "," + dy + ")");
        if (this.shiftPreview1 == null) {
          this.shiftPreview1 = document.createElement("div");
          this.shiftPreview1.style.position = "absolute";
          this.shiftPreview1.style.overflow = "visible";
          this.shiftPreview2 = document.createElement("div");
          this.shiftPreview2.style.position = "absolute";
          this.shiftPreview2.style.overflow = "visible";
          let current2 = this.shiftPreview1;
          let child = this.container.firstChild;
          while (child != null) {
            const next = child.nextSibling;
            if (child != canvas.parentNode) {
              current2.appendChild(child);
            } else {
              current2 = this.shiftPreview2;
            }
            child = next;
          }
          if (this.shiftPreview1.firstChild != null) {
            this.container.insertBefore(this.shiftPreview1, canvas.parentNode);
          }
          if (this.shiftPreview2.firstChild != null) {
            this.container.appendChild(this.shiftPreview2);
          }
        }
        this.shiftPreview1.style.left = dx + "px";
        this.shiftPreview1.style.top = dy + "px";
        this.shiftPreview2.style.left = dx + "px";
        this.shiftPreview2.style.top = dy + "px";
      }
    } else {
      canvas.style.left = dx + "px";
      canvas.style.top = dy + "px";
    }
    this.panDx = dx;
    this.panDy = dy;
    this.fireEvent(new mxEventObject2(mxEvent2.PAN));
  }
};
mxGraph2.prototype.zoomIn = function() {
  this.zoom(this.zoomFactor);
};
mxGraph2.prototype.zoomOut = function() {
  this.zoom(1 / this.zoomFactor);
};
mxGraph2.prototype.zoomActual = function() {
  if (this.view.scale == 1) {
    this.view.setTranslate(0, 0);
  } else {
    this.view.translate.x = 0;
    this.view.translate.y = 0;
    this.view.setScale(1);
  }
};
mxGraph2.prototype.zoomTo = function(scale, center) {
  this.zoom(scale / this.view.scale, center);
};
mxGraph2.prototype.zoom = function(factor, center) {
  center = center != null ? center : this.centerZoom;
  const scale = Math.round(this.view.scale * factor * 100) / 100;
  const state2 = this.view.getState(this.getSelectionCell());
  factor = scale / this.view.scale;
  if (this.keepSelectionVisibleOnZoom && state2 != null) {
    const rect = new mxRectangle(state2.x * factor, state2.y * factor, state2.width * factor, state2.height * factor);
    this.view.scale = scale;
    if (!this.scrollRectToVisible(rect)) {
      this.view.revalidate();
      this.view.setScale(scale);
    }
  } else {
    const hasScrollbars2 = hasScrollbars(this.container);
    if (center && !hasScrollbars2) {
      let dx = this.container.offsetWidth;
      let dy = this.container.offsetHeight;
      if (factor > 1) {
        const f = (factor - 1) / (scale * 2);
        dx *= -f;
        dy *= -f;
      } else {
        const f = (1 / factor - 1) / (this.view.scale * 2);
        dx *= f;
        dy *= f;
      }
      this.view.scaleAndTranslate(scale, this.view.translate.x + dx, this.view.translate.y + dy);
    } else {
      const tx = this.view.translate.x;
      const ty = this.view.translate.y;
      const sl = this.container.scrollLeft;
      const st = this.container.scrollTop;
      this.view.setScale(scale);
      if (hasScrollbars2) {
        let dx = 0;
        let dy = 0;
        if (center) {
          dx = this.container.offsetWidth * (factor - 1) / 2;
          dy = this.container.offsetHeight * (factor - 1) / 2;
        }
        this.container.scrollLeft = (this.view.translate.x - tx) * this.view.scale + Math.round(sl * factor + dx);
        this.container.scrollTop = (this.view.translate.y - ty) * this.view.scale + Math.round(st * factor + dy);
      }
    }
  }
};
mxGraph2.prototype.zoomToRect = function(rect) {
  const scaleX = this.container.clientWidth / rect.width;
  const scaleY = this.container.clientHeight / rect.height;
  const aspectFactor = scaleX / scaleY;
  rect.x = Math.max(0, rect.x);
  rect.y = Math.max(0, rect.y);
  let rectRight = Math.min(this.container.scrollWidth, rect.x + rect.width);
  let rectBottom = Math.min(this.container.scrollHeight, rect.y + rect.height);
  rect.width = rectRight - rect.x;
  rect.height = rectBottom - rect.y;
  if (aspectFactor < 1) {
    const newHeight = rect.height / aspectFactor;
    const deltaHeightBuffer = (newHeight - rect.height) / 2;
    rect.height = newHeight;
    const upperBuffer = Math.min(rect.y, deltaHeightBuffer);
    rect.y = rect.y - upperBuffer;
    rectBottom = Math.min(this.container.scrollHeight, rect.y + rect.height);
    rect.height = rectBottom - rect.y;
  } else {
    const newWidth = rect.width * aspectFactor;
    const deltaWidthBuffer = (newWidth - rect.width) / 2;
    rect.width = newWidth;
    const leftBuffer = Math.min(rect.x, deltaWidthBuffer);
    rect.x = rect.x - leftBuffer;
    rectRight = Math.min(this.container.scrollWidth, rect.x + rect.width);
    rect.width = rectRight - rect.x;
  }
  const scale = this.container.clientWidth / rect.width;
  const newScale = this.view.scale * scale;
  if (!hasScrollbars(this.container)) {
    this.view.scaleAndTranslate(newScale, this.view.translate.x - rect.x / this.view.scale, this.view.translate.y - rect.y / this.view.scale);
  } else {
    this.view.setScale(newScale);
    this.container.scrollLeft = Math.round(rect.x * scale);
    this.container.scrollTop = Math.round(rect.y * scale);
  }
};
mxGraph2.prototype.scrollCellToVisible = function(cell2, center) {
  const x = -this.view.translate.x;
  const y = -this.view.translate.y;
  const state2 = this.view.getState(cell2);
  if (state2 != null) {
    let bounds = new mxRectangle(x + state2.x, y + state2.y, state2.width, state2.height);
    if (center && this.container != null) {
      const w2 = this.container.clientWidth;
      const h2 = this.container.clientHeight;
      bounds.x = bounds.getCenterX() - w2 / 2;
      bounds.width = w2;
      bounds.y = bounds.getCenterY() - h2 / 2;
      bounds.height = h2;
    }
    const tr = new mxPoint2(this.view.translate.x, this.view.translate.y);
    if (this.scrollRectToVisible(bounds)) {
      const tr2 = new mxPoint2(this.view.translate.x, this.view.translate.y);
      this.view.translate.x = tr.x;
      this.view.translate.y = tr.y;
      this.view.setTranslate(tr2.x, tr2.y);
    }
  }
};
mxGraph2.prototype.scrollRectToVisible = function(rect) {
  let isChanged = false;
  if (rect != null) {
    const w2 = this.container.offsetWidth;
    const h2 = this.container.offsetHeight;
    const widthLimit = Math.min(w2, rect.width);
    const heightLimit = Math.min(h2, rect.height);
    if (hasScrollbars(this.container)) {
      const c = this.container;
      rect.x += this.view.translate.x;
      rect.y += this.view.translate.y;
      let dx = c.scrollLeft - rect.x;
      const ddx = Math.max(dx - c.scrollLeft, 0);
      if (dx > 0) {
        c.scrollLeft -= dx + 2;
      } else {
        dx = rect.x + widthLimit - c.scrollLeft - c.clientWidth;
        if (dx > 0) {
          c.scrollLeft += dx + 2;
        }
      }
      let dy = c.scrollTop - rect.y;
      const ddy = Math.max(0, dy - c.scrollTop);
      if (dy > 0) {
        c.scrollTop -= dy + 2;
      } else {
        dy = rect.y + heightLimit - c.scrollTop - c.clientHeight;
        if (dy > 0) {
          c.scrollTop += dy + 2;
        }
      }
      if (!this.useScrollbarsForPanning && (ddx != 0 || ddy != 0)) {
        this.view.setTranslate(ddx, ddy);
      }
    } else {
      const x = -this.view.translate.x;
      const y = -this.view.translate.y;
      const s = this.view.scale;
      if (rect.x + widthLimit > x + w2) {
        this.view.translate.x -= (rect.x + widthLimit - w2 - x) / s;
        isChanged = true;
      }
      if (rect.y + heightLimit > y + h2) {
        this.view.translate.y -= (rect.y + heightLimit - h2 - y) / s;
        isChanged = true;
      }
      if (rect.x < x) {
        this.view.translate.x += (x - rect.x) / s;
        isChanged = true;
      }
      if (rect.y < y) {
        this.view.translate.y += (y - rect.y) / s;
        isChanged = true;
      }
      if (isChanged) {
        this.view.refresh();
        if (this.selectionCellsHandler != null) {
          this.selectionCellsHandler.refresh();
        }
      }
    }
  }
  return isChanged;
};
mxGraph2.prototype.getCellGeometry = function(cell2) {
  return this.model.getGeometry(cell2);
};
mxGraph2.prototype.isCellVisible = function(cell2) {
  return this.model.isVisible(cell2);
};
mxGraph2.prototype.isCellCollapsed = function(cell2) {
  return this.model.isCollapsed(cell2);
};
mxGraph2.prototype.isCellConnectable = function(cell2) {
  return this.model.isConnectable(cell2);
};
mxGraph2.prototype.isOrthogonal = function(edge) {
  const orthogonal = edge.style[mxConstants2.STYLE_ORTHOGONAL];
  if (orthogonal != null) {
    return orthogonal;
  }
  const tmp = this.view.getEdgeStyle(edge);
  return tmp == mxEdgeStyle.SegmentConnector || tmp == mxEdgeStyle.ElbowConnector || tmp == mxEdgeStyle.SideToSide || tmp == mxEdgeStyle.TopToBottom || tmp == mxEdgeStyle.EntityRelation || tmp == mxEdgeStyle.OrthConnector;
};
mxGraph2.prototype.isLoop = function(state2) {
  const src = state2.getVisibleTerminalState(true);
  const trg = state2.getVisibleTerminalState(false);
  return src != null && src == trg;
};
mxGraph2.prototype.isCloneEvent = function(evt) {
  return mxEvent2.isControlDown(evt);
};
mxGraph2.prototype.isTransparentClickEvent = function(evt) {
  return false;
};
mxGraph2.prototype.isToggleEvent = function(evt) {
  return mxClient_default.IS_MAC ? mxEvent2.isMetaDown(evt) : mxEvent2.isControlDown(evt);
};
mxGraph2.prototype.isGridEnabledEvent = function(evt) {
  return evt != null && !mxEvent2.isAltDown(evt);
};
mxGraph2.prototype.isConstrainedEvent = function(evt) {
  return mxEvent2.isShiftDown(evt);
};
mxGraph2.prototype.isIgnoreTerminalEvent = function(evt) {
  return false;
};
mxGraph2.prototype.validationAlert = function(message) {
  alert2(message);
};
mxGraph2.prototype.isEdgeValid = function(edge, source, target) {
  return this.getEdgeValidationError(edge, source, target) == null;
};
mxGraph2.prototype.getEdgeValidationError = function(edge, source, target) {
  if (edge != null && !this.isAllowDanglingEdges() && (source == null || target == null)) {
    return "";
  }
  if (edge != null && this.model.getTerminal(edge, true) == null && this.model.getTerminal(edge, false) == null) {
    return null;
  }
  if (!this.allowLoops && source == target && source != null) {
    return "";
  }
  if (!this.isValidConnection(source, target)) {
    return "";
  }
  if (source != null && target != null) {
    let error2 = "";
    if (!this.multigraph) {
      const tmp = this.model.getEdgesBetween(source, target, true);
      if (tmp.length > 1 || tmp.length == 1 && tmp[0] != edge) {
        error2 += (mxResources2.get(this.alreadyConnectedResource) || this.alreadyConnectedResource) + "\n";
      }
    }
    const sourceOut = this.model.getDirectedEdgeCount(source, true, edge);
    const targetIn = this.model.getDirectedEdgeCount(target, false, edge);
    if (this.multiplicities != null) {
      for (let i = 0; i < this.multiplicities.length; i++) {
        const err2 = this.multiplicities[i].check(this, edge, source, target, sourceOut, targetIn);
        if (err2 != null) {
          error2 += err2;
        }
      }
    }
    const err = this.validateEdge(edge, source, target);
    if (err != null) {
      error2 += err;
    }
    return error2.length > 0 ? error2 : null;
  }
  return this.allowDanglingEdges ? null : "";
};
mxGraph2.prototype.validateEdge = function(edge, source, target) {
  return null;
};
mxGraph2.prototype.validateGraph = function(cell2, context) {
  cell2 = cell2 != null ? cell2 : this.model.getRoot();
  context = context != null ? context : new Object();
  let isValid = true;
  const childCount = this.model.getChildCount(cell2);
  for (let i = 0; i < childCount; i++) {
    const tmp = this.model.getChildAt(cell2, i);
    let ctx = context;
    if (this.isValidRoot(tmp)) {
      ctx = new Object();
    }
    const warn = this.validateGraph(tmp, ctx);
    if (warn != null) {
      this.setCellWarning(tmp, warn.replace(/\n/g, "<br>"));
    } else {
      this.setCellWarning(tmp, null);
    }
    isValid = isValid && warn == null;
  }
  let warning = "";
  if (this.isCellCollapsed(cell2) && !isValid) {
    warning += (mxResources2.get(this.containsValidationErrorsResource) || this.containsValidationErrorsResource) + "\n";
  }
  if (this.model.isEdge(cell2)) {
    warning += this.getEdgeValidationError(cell2, this.model.getTerminal(cell2, true), this.model.getTerminal(cell2, false)) || "";
  } else {
    warning += this.getCellValidationError(cell2) || "";
  }
  const err = this.validateCell(cell2, context);
  if (err != null) {
    warning += err;
  }
  if (this.model.getParent(cell2) == null) {
    this.view.validate();
  }
  return warning.length > 0 || !isValid ? warning : null;
};
mxGraph2.prototype.getCellValidationError = function(cell2) {
  const outCount = this.model.getDirectedEdgeCount(cell2, true);
  const inCount = this.model.getDirectedEdgeCount(cell2, false);
  const value = this.model.getValue(cell2);
  let error2 = "";
  if (this.multiplicities != null) {
    for (let i = 0; i < this.multiplicities.length; i++) {
      const rule = this.multiplicities[i];
      if (rule.source && isNode(value, rule.type, rule.attr, rule.value) && (outCount > rule.max || outCount < rule.min)) {
        error2 += rule.countError + "\n";
      } else if (!rule.source && isNode(value, rule.type, rule.attr, rule.value) && (inCount > rule.max || inCount < rule.min)) {
        error2 += rule.countError + "\n";
      }
    }
  }
  return error2.length > 0 ? error2 : null;
};
mxGraph2.prototype.validateCell = function(cell2, context) {
  return null;
};
mxGraph2.prototype.getBackgroundImage = function() {
  return this.backgroundImage;
};
mxGraph2.prototype.setBackgroundImage = function(image) {
  this.backgroundImage = image;
};
mxGraph2.prototype.getFoldingImage = function(state2) {
  if (state2 != null && this.foldingEnabled && !this.getModel().isEdge(state2.cell)) {
    const tmp = this.isCellCollapsed(state2.cell);
    if (this.isCellFoldable(state2.cell, !tmp)) {
      return tmp ? this.collapsedImage : this.expandedImage;
    }
  }
  return null;
};
mxGraph2.prototype.convertValueToString = function(cell2) {
  const value = this.model.getValue(cell2);
  if (value != null) {
    if (isNode(value)) {
      return value.nodeName;
    } else if (typeof value.toString == "function") {
      return value.toString();
    }
  }
  return "";
};
mxGraph2.prototype.getLabel = function(cell2) {
  let result2 = "";
  if (this.labelsVisible && cell2 != null) {
    const style = this.getCurrentCellStyle(cell2);
    if (!getValue(style, mxConstants2.STYLE_NOLABEL, false)) {
      result2 = this.convertValueToString(cell2);
    }
  }
  return result2;
};
mxGraph2.prototype.isHtmlLabel = function(cell2) {
  return this.isHtmlLabels();
};
mxGraph2.prototype.isHtmlLabels = function() {
  return this.htmlLabels;
};
mxGraph2.prototype.setHtmlLabels = function(value) {
  this.htmlLabels = value;
};
mxGraph2.prototype.isWrapping = function(cell2) {
  return this.getCurrentCellStyle(cell2)[mxConstants2.STYLE_WHITE_SPACE] == "wrap";
};
mxGraph2.prototype.isLabelClipped = function(cell2) {
  return this.getCurrentCellStyle(cell2)[mxConstants2.STYLE_OVERFLOW] == "hidden";
};
mxGraph2.prototype.getTooltip = function(state2, node, x, y) {
  let tip = null;
  if (state2 != null) {
    if (state2.control != null && (node == state2.control.node || node.parentNode == state2.control.node)) {
      tip = this.collapseExpandResource;
      tip = htmlEntities(mxResources2.get(tip) || tip).replace(/\\n/g, "<br>");
    }
    if (tip == null && state2.overlays != null) {
      state2.overlays.visit(function(id, shape) {
        if (tip == null && (node == shape.node || node.parentNode == shape.node)) {
          tip = shape.overlay.toString();
        }
      });
    }
    if (tip == null) {
      const handler = this.selectionCellsHandler.getHandler(state2.cell);
      if (handler != null && typeof handler.getTooltipForNode == "function") {
        tip = handler.getTooltipForNode(node);
      }
    }
    if (tip == null) {
      tip = this.getTooltipForCell(state2.cell);
    }
  }
  return tip;
};
mxGraph2.prototype.getTooltipForCell = function(cell2) {
  let tip = null;
  if (cell2 != null && cell2.getTooltip != null) {
    tip = cell2.getTooltip();
  } else {
    tip = this.convertValueToString(cell2);
  }
  return tip;
};
mxGraph2.prototype.getLinkForCell = function(cell2) {
  return null;
};
mxGraph2.prototype.getCursorForMouseEvent = function(me) {
  return this.getCursorForCell(me.getCell());
};
mxGraph2.prototype.getCursorForCell = function(cell2) {
  return null;
};
mxGraph2.prototype.getStartSize = function(swimlane, ignoreState) {
  const result2 = new mxRectangle();
  const style = this.getCurrentCellStyle(swimlane, ignoreState);
  const size = parseInt(getValue(style, mxConstants2.STYLE_STARTSIZE, mxConstants2.DEFAULT_STARTSIZE));
  if (getValue(style, mxConstants2.STYLE_HORIZONTAL, true)) {
    result2.height = size;
  } else {
    result2.width = size;
  }
  return result2;
};
mxGraph2.prototype.getSwimlaneDirection = function(style) {
  const dir = getValue(style, mxConstants2.STYLE_DIRECTION, mxConstants2.DIRECTION_EAST);
  const flipH = getValue(style, mxConstants2.STYLE_FLIPH, 0) == 1;
  const flipV = getValue(style, mxConstants2.STYLE_FLIPV, 0) == 1;
  const h2 = getValue(style, mxConstants2.STYLE_HORIZONTAL, true);
  let n = h2 ? 0 : 3;
  if (dir == mxConstants2.DIRECTION_NORTH) {
    n--;
  } else if (dir == mxConstants2.DIRECTION_WEST) {
    n += 2;
  } else if (dir == mxConstants2.DIRECTION_SOUTH) {
    n += 1;
  }
  const mod2 = mod(n, 2);
  if (flipH && mod2 == 1) {
    n += 2;
  }
  if (flipV && mod2 == 0) {
    n += 2;
  }
  return [
    mxConstants2.DIRECTION_NORTH,
    mxConstants2.DIRECTION_EAST,
    mxConstants2.DIRECTION_SOUTH,
    mxConstants2.DIRECTION_WEST
  ][mod(n, 4)];
};
mxGraph2.prototype.getActualStartSize = function(swimlane, ignoreState) {
  const result2 = new mxRectangle();
  if (this.isSwimlane(swimlane, ignoreState)) {
    const style = this.getCurrentCellStyle(swimlane, ignoreState);
    const size = parseInt(getValue(style, mxConstants2.STYLE_STARTSIZE, mxConstants2.DEFAULT_STARTSIZE));
    const dir = this.getSwimlaneDirection(style);
    if (dir == mxConstants2.DIRECTION_NORTH) {
      result2.y = size;
    } else if (dir == mxConstants2.DIRECTION_WEST) {
      result2.x = size;
    } else if (dir == mxConstants2.DIRECTION_SOUTH) {
      result2.height = size;
    } else {
      result2.width = size;
    }
  }
  return result2;
};
mxGraph2.prototype.getImage = function(state2) {
  return state2 != null && state2.style != null ? state2.style[mxConstants2.STYLE_IMAGE] : null;
};
mxGraph2.prototype.isTransparentState = function(state2) {
  let result2 = false;
  if (state2 != null) {
    const stroke = getValue(state2.style, mxConstants2.STYLE_STROKECOLOR, mxConstants2.NONE);
    const fill = getValue(state2.style, mxConstants2.STYLE_FILLCOLOR, mxConstants2.NONE);
    result2 = stroke == mxConstants2.NONE && fill == mxConstants2.NONE && this.getImage(state2) == null;
  }
  return result2;
};
mxGraph2.prototype.getVerticalAlign = function(state2) {
  return state2 != null && state2.style != null ? state2.style[mxConstants2.STYLE_VERTICAL_ALIGN] || mxConstants2.ALIGN_MIDDLE : null;
};
mxGraph2.prototype.getIndicatorColor = function(state2) {
  return state2 != null && state2.style != null ? state2.style[mxConstants2.STYLE_INDICATOR_COLOR] : null;
};
mxGraph2.prototype.getIndicatorGradientColor = function(state2) {
  return state2 != null && state2.style != null ? state2.style[mxConstants2.STYLE_INDICATOR_GRADIENTCOLOR] : null;
};
mxGraph2.prototype.getIndicatorShape = function(state2) {
  return state2 != null && state2.style != null ? state2.style[mxConstants2.STYLE_INDICATOR_SHAPE] : null;
};
mxGraph2.prototype.getIndicatorImage = function(state2) {
  return state2 != null && state2.style != null ? state2.style[mxConstants2.STYLE_INDICATOR_IMAGE] : null;
};
mxGraph2.prototype.getBorder = function() {
  return this.border;
};
mxGraph2.prototype.setBorder = function(value) {
  this.border = value;
};
mxGraph2.prototype.isSwimlane = function(cell2, ignoreState) {
  if (cell2 != null && this.model.getParent(cell2) != this.model.getRoot() && !this.model.isEdge(cell2)) {
    return this.getCurrentCellStyle(cell2, ignoreState)[mxConstants2.STYLE_SHAPE] == mxConstants2.SHAPE_SWIMLANE;
  }
  return false;
};
mxGraph2.prototype.isResizeContainer = function() {
  return this.resizeContainer;
};
mxGraph2.prototype.setResizeContainer = function(value) {
  this.resizeContainer = value;
};
mxGraph2.prototype.isEnabled = function() {
  return this.enabled;
};
mxGraph2.prototype.setEnabled = function(value) {
  this.enabled = value;
};
mxGraph2.prototype.isEscapeEnabled = function() {
  return this.escapeEnabled;
};
mxGraph2.prototype.setEscapeEnabled = function(value) {
  this.escapeEnabled = value;
};
mxGraph2.prototype.isInvokesStopCellEditing = function() {
  return this.invokesStopCellEditing;
};
mxGraph2.prototype.setInvokesStopCellEditing = function(value) {
  this.invokesStopCellEditing = value;
};
mxGraph2.prototype.isEnterStopsCellEditing = function() {
  return this.enterStopsCellEditing;
};
mxGraph2.prototype.setEnterStopsCellEditing = function(value) {
  this.enterStopsCellEditing = value;
};
mxGraph2.prototype.isCellLocked = function(cell2) {
  const geometry = this.model.getGeometry(cell2);
  return this.isCellsLocked() || geometry != null && this.model.isVertex(cell2) && geometry.relative;
};
mxGraph2.prototype.isCellsLocked = function() {
  return this.cellsLocked;
};
mxGraph2.prototype.setCellsLocked = function(value) {
  this.cellsLocked = value;
};
mxGraph2.prototype.getCloneableCells = function(cells) {
  return this.model.filterCells(cells, bind(this, function(cell2) {
    return this.isCellCloneable(cell2);
  }));
};
mxGraph2.prototype.isCellCloneable = function(cell2) {
  const style = this.getCurrentCellStyle(cell2);
  return this.isCellsCloneable() && style[mxConstants2.STYLE_CLONEABLE] != 0;
};
mxGraph2.prototype.isCellsCloneable = function() {
  return this.cellsCloneable;
};
mxGraph2.prototype.setCellsCloneable = function(value) {
  this.cellsCloneable = value;
};
mxGraph2.prototype.getExportableCells = function(cells) {
  return this.model.filterCells(cells, bind(this, function(cell2) {
    return this.canExportCell(cell2);
  }));
};
mxGraph2.prototype.canExportCell = function(cell2) {
  return this.exportEnabled;
};
mxGraph2.prototype.getImportableCells = function(cells) {
  return this.model.filterCells(cells, bind(this, function(cell2) {
    return this.canImportCell(cell2);
  }));
};
mxGraph2.prototype.canImportCell = function(cell2) {
  return this.importEnabled;
};
mxGraph2.prototype.isCellSelectable = function(cell2) {
  return this.isCellsSelectable();
};
mxGraph2.prototype.isCellsSelectable = function() {
  return this.cellsSelectable;
};
mxGraph2.prototype.setCellsSelectable = function(value) {
  this.cellsSelectable = value;
};
mxGraph2.prototype.getDeletableCells = function(cells) {
  return this.model.filterCells(cells, bind(this, function(cell2) {
    return this.isCellDeletable(cell2);
  }));
};
mxGraph2.prototype.isCellDeletable = function(cell2) {
  const style = this.getCurrentCellStyle(cell2);
  return this.isCellsDeletable() && style[mxConstants2.STYLE_DELETABLE] != 0;
};
mxGraph2.prototype.isCellsDeletable = function() {
  return this.cellsDeletable;
};
mxGraph2.prototype.setCellsDeletable = function(value) {
  this.cellsDeletable = value;
};
mxGraph2.prototype.isLabelMovable = function(cell2) {
  return !this.isCellLocked(cell2) && (this.model.isEdge(cell2) && this.edgeLabelsMovable || this.model.isVertex(cell2) && this.vertexLabelsMovable);
};
mxGraph2.prototype.isCellRotatable = function(cell2) {
  const style = this.getCurrentCellStyle(cell2);
  return style[mxConstants2.STYLE_ROTATABLE] != 0;
};
mxGraph2.prototype.getMovableCells = function(cells) {
  return this.model.filterCells(cells, bind(this, function(cell2) {
    return this.isCellMovable(cell2);
  }));
};
mxGraph2.prototype.isCellMovable = function(cell2) {
  const style = this.getCurrentCellStyle(cell2);
  return this.isCellsMovable() && !this.isCellLocked(cell2) && style[mxConstants2.STYLE_MOVABLE] != 0;
};
mxGraph2.prototype.isCellsMovable = function() {
  return this.cellsMovable;
};
mxGraph2.prototype.setCellsMovable = function(value) {
  this.cellsMovable = value;
};
mxGraph2.prototype.isGridEnabled = function() {
  return this.gridEnabled;
};
mxGraph2.prototype.setGridEnabled = function(value) {
  this.gridEnabled = value;
};
mxGraph2.prototype.isPortsEnabled = function() {
  return this.portsEnabled;
};
mxGraph2.prototype.setPortsEnabled = function(value) {
  this.portsEnabled = value;
};
mxGraph2.prototype.getGridSize = function() {
  return this.gridSize;
};
mxGraph2.prototype.setGridSize = function(value) {
  this.gridSize = value;
};
mxGraph2.prototype.getTolerance = function() {
  return this.tolerance;
};
mxGraph2.prototype.setTolerance = function(value) {
  this.tolerance = value;
};
mxGraph2.prototype.isVertexLabelsMovable = function() {
  return this.vertexLabelsMovable;
};
mxGraph2.prototype.setVertexLabelsMovable = function(value) {
  this.vertexLabelsMovable = value;
};
mxGraph2.prototype.isEdgeLabelsMovable = function() {
  return this.edgeLabelsMovable;
};
mxGraph2.prototype.setEdgeLabelsMovable = function(value) {
  this.edgeLabelsMovable = value;
};
mxGraph2.prototype.isSwimlaneNesting = function() {
  return this.swimlaneNesting;
};
mxGraph2.prototype.setSwimlaneNesting = function(value) {
  this.swimlaneNesting = value;
};
mxGraph2.prototype.isSwimlaneSelectionEnabled = function() {
  return this.swimlaneSelectionEnabled;
};
mxGraph2.prototype.setSwimlaneSelectionEnabled = function(value) {
  this.swimlaneSelectionEnabled = value;
};
mxGraph2.prototype.isMultigraph = function() {
  return this.multigraph;
};
mxGraph2.prototype.setMultigraph = function(value) {
  this.multigraph = value;
};
mxGraph2.prototype.isAllowLoops = function() {
  return this.allowLoops;
};
mxGraph2.prototype.setAllowDanglingEdges = function(value) {
  this.allowDanglingEdges = value;
};
mxGraph2.prototype.isAllowDanglingEdges = function() {
  return this.allowDanglingEdges;
};
mxGraph2.prototype.setConnectableEdges = function(value) {
  this.connectableEdges = value;
};
mxGraph2.prototype.isConnectableEdges = function() {
  return this.connectableEdges;
};
mxGraph2.prototype.setCloneInvalidEdges = function(value) {
  this.cloneInvalidEdges = value;
};
mxGraph2.prototype.isCloneInvalidEdges = function() {
  return this.cloneInvalidEdges;
};
mxGraph2.prototype.setAllowLoops = function(value) {
  this.allowLoops = value;
};
mxGraph2.prototype.isDisconnectOnMove = function() {
  return this.disconnectOnMove;
};
mxGraph2.prototype.setDisconnectOnMove = function(value) {
  this.disconnectOnMove = value;
};
mxGraph2.prototype.isDropEnabled = function() {
  return this.dropEnabled;
};
mxGraph2.prototype.setDropEnabled = function(value) {
  this.dropEnabled = value;
};
mxGraph2.prototype.isSplitEnabled = function() {
  return this.splitEnabled;
};
mxGraph2.prototype.setSplitEnabled = function(value) {
  this.splitEnabled = value;
};
mxGraph2.prototype.isCellResizable = function(cell2) {
  const style = this.getCurrentCellStyle(cell2);
  return this.isCellsResizable() && !this.isCellLocked(cell2) && getValue(style, mxConstants2.STYLE_RESIZABLE, "1") != "0";
};
mxGraph2.prototype.isCellsResizable = function() {
  return this.cellsResizable;
};
mxGraph2.prototype.setCellsResizable = function(value) {
  this.cellsResizable = value;
};
mxGraph2.prototype.isTerminalPointMovable = function(cell2, source) {
  return true;
};
mxGraph2.prototype.isCellBendable = function(cell2) {
  const style = this.getCurrentCellStyle(cell2);
  return this.isCellsBendable() && !this.isCellLocked(cell2) && style[mxConstants2.STYLE_BENDABLE] != 0;
};
mxGraph2.prototype.isCellsBendable = function() {
  return this.cellsBendable;
};
mxGraph2.prototype.setCellsBendable = function(value) {
  this.cellsBendable = value;
};
mxGraph2.prototype.isCellEditable = function(cell2) {
  const style = this.getCurrentCellStyle(cell2);
  return this.isCellsEditable() && !this.isCellLocked(cell2) && style[mxConstants2.STYLE_EDITABLE] != 0;
};
mxGraph2.prototype.isCellsEditable = function() {
  return this.cellsEditable;
};
mxGraph2.prototype.setCellsEditable = function(value) {
  this.cellsEditable = value;
};
mxGraph2.prototype.isCellDisconnectable = function(cell2, terminal, source) {
  return this.isCellsDisconnectable() && !this.isCellLocked(cell2);
};
mxGraph2.prototype.isCellsDisconnectable = function() {
  return this.cellsDisconnectable;
};
mxGraph2.prototype.setCellsDisconnectable = function(value) {
  this.cellsDisconnectable = value;
};
mxGraph2.prototype.isValidSource = function(cell2) {
  return cell2 == null && this.allowDanglingEdges || cell2 != null && (!this.model.isEdge(cell2) || this.connectableEdges) && this.isCellConnectable(cell2);
};
mxGraph2.prototype.isValidTarget = function(cell2) {
  return this.isValidSource(cell2);
};
mxGraph2.prototype.isValidConnection = function(source, target) {
  return this.isValidSource(source) && this.isValidTarget(target);
};
mxGraph2.prototype.setConnectable = function(connectable) {
  this.connectionHandler.setEnabled(connectable);
};
mxGraph2.prototype.isConnectable = function() {
  return this.connectionHandler.isEnabled();
};
mxGraph2.prototype.setTooltips = function(enabled) {
  this.tooltipHandler.setEnabled(enabled);
};
mxGraph2.prototype.setPanning = function(enabled) {
  this.panningHandler.panningEnabled = enabled;
};
mxGraph2.prototype.isEditing = function(cell2) {
  if (this.cellEditor != null) {
    const editingCell = this.cellEditor.getEditingCell();
    return cell2 == null ? editingCell != null : cell2 == editingCell;
  }
  return false;
};
mxGraph2.prototype.isAutoSizeCell = function(cell2) {
  const style = this.getCurrentCellStyle(cell2);
  return this.isAutoSizeCells() || style[mxConstants2.STYLE_AUTOSIZE] == 1;
};
mxGraph2.prototype.isAutoSizeCells = function() {
  return this.autoSizeCells;
};
mxGraph2.prototype.setAutoSizeCells = function(value) {
  this.autoSizeCells = value;
};
mxGraph2.prototype.isExtendParent = function(cell2) {
  return !this.getModel().isEdge(cell2) && this.isExtendParents();
};
mxGraph2.prototype.isExtendParents = function() {
  return this.extendParents;
};
mxGraph2.prototype.setExtendParents = function(value) {
  this.extendParents = value;
};
mxGraph2.prototype.isExtendParentsOnAdd = function(cell2) {
  return this.extendParentsOnAdd;
};
mxGraph2.prototype.setExtendParentsOnAdd = function(value) {
  this.extendParentsOnAdd = value;
};
mxGraph2.prototype.isExtendParentsOnMove = function() {
  return this.extendParentsOnMove;
};
mxGraph2.prototype.setExtendParentsOnMove = function(value) {
  this.extendParentsOnMove = value;
};
mxGraph2.prototype.isRecursiveResize = function(state2) {
  return this.recursiveResize;
};
mxGraph2.prototype.setRecursiveResize = function(value) {
  this.recursiveResize = value;
};
mxGraph2.prototype.isConstrainChild = function(cell2) {
  return this.isConstrainChildren() && !this.getModel().isEdge(this.getModel().getParent(cell2));
};
mxGraph2.prototype.isConstrainChildren = function() {
  return this.constrainChildren;
};
mxGraph2.prototype.setConstrainChildren = function(value) {
  this.constrainChildren = value;
};
mxGraph2.prototype.isConstrainRelativeChildren = function() {
  return this.constrainRelativeChildren;
};
mxGraph2.prototype.setConstrainRelativeChildren = function(value) {
  this.constrainRelativeChildren = value;
};
mxGraph2.prototype.isAllowNegativeCoordinates = function() {
  return this.allowNegativeCoordinates;
};
mxGraph2.prototype.setAllowNegativeCoordinates = function(value) {
  this.allowNegativeCoordinates = value;
};
mxGraph2.prototype.getOverlap = function(cell2) {
  return this.isAllowOverlapParent(cell2) ? this.defaultOverlap : 0;
};
mxGraph2.prototype.isAllowOverlapParent = function(cell2) {
  return false;
};
mxGraph2.prototype.getFoldableCells = function(cells, collapse) {
  return this.model.filterCells(cells, bind(this, function(cell2) {
    return this.isCellFoldable(cell2, collapse);
  }));
};
mxGraph2.prototype.isCellFoldable = function(cell2, collapse) {
  const style = this.getCurrentCellStyle(cell2);
  return this.model.getChildCount(cell2) > 0 && style[mxConstants2.STYLE_FOLDABLE] != 0;
};
mxGraph2.prototype.isValidDropTarget = function(cell2, cells, evt) {
  return cell2 != null && (this.isSplitEnabled() && this.isSplitTarget(cell2, cells, evt) || !this.model.isEdge(cell2) && (this.isSwimlane(cell2) || this.model.getChildCount(cell2) > 0 && !this.isCellCollapsed(cell2)));
};
mxGraph2.prototype.isSplitTarget = function(target, cells, evt) {
  if (this.model.isEdge(target) && cells != null && cells.length == 1 && this.isCellConnectable(cells[0]) && this.getEdgeValidationError(target, this.model.getTerminal(target, true), cells[0]) == null) {
    const src = this.model.getTerminal(target, true);
    const trg = this.model.getTerminal(target, false);
    return !this.model.isAncestor(cells[0], src) && !this.model.isAncestor(cells[0], trg);
  }
  return false;
};
mxGraph2.prototype.getDropTarget = function(cells, evt, cell2, clone3) {
  if (!this.isSwimlaneNesting()) {
    for (let i = 0; i < cells.length; i++) {
      if (this.isSwimlane(cells[i])) {
        return null;
      }
    }
  }
  const pt = convertPoint(this.container, mxEvent2.getClientX(evt), mxEvent2.getClientY(evt));
  pt.x -= this.panDx;
  pt.y -= this.panDy;
  const swimlane = this.getSwimlaneAt(pt.x, pt.y);
  if (cell2 == null) {
    cell2 = swimlane;
  } else if (swimlane != null) {
    let tmp = this.model.getParent(swimlane);
    while (tmp != null && this.isSwimlane(tmp) && tmp != cell2) {
      tmp = this.model.getParent(tmp);
    }
    if (tmp == cell2) {
      cell2 = swimlane;
    }
  }
  while (cell2 != null && !this.isValidDropTarget(cell2, cells, evt) && !this.model.isLayer(cell2)) {
    cell2 = this.model.getParent(cell2);
  }
  if (clone3 == null || !clone3) {
    let parent2 = cell2;
    while (parent2 != null && indexOf(cells, parent2) < 0) {
      parent2 = this.model.getParent(parent2);
    }
  }
  return !this.model.isLayer(cell2) && parent == null ? cell2 : null;
};
mxGraph2.prototype.getDefaultParent = function() {
  let parent2 = this.getCurrentRoot();
  if (parent2 == null) {
    parent2 = this.defaultParent;
    if (parent2 == null) {
      const root = this.model.getRoot();
      parent2 = this.model.getChildAt(root, 0);
    }
  }
  return parent2;
};
mxGraph2.prototype.setDefaultParent = function(cell2) {
  this.defaultParent = cell2;
};
mxGraph2.prototype.getSwimlane = function(cell2) {
  while (cell2 != null && !this.isSwimlane(cell2)) {
    cell2 = this.model.getParent(cell2);
  }
  return cell2;
};
mxGraph2.prototype.getSwimlaneAt = function(x, y, parent2) {
  if (parent2 == null) {
    parent2 = this.getCurrentRoot();
    if (parent2 == null) {
      parent2 = this.model.getRoot();
    }
  }
  if (parent2 != null) {
    const childCount = this.model.getChildCount(parent2);
    for (let i = 0; i < childCount; i++) {
      const child = this.model.getChildAt(parent2, i);
      if (child != null) {
        const result2 = this.getSwimlaneAt(x, y, child);
        if (result2 != null) {
          return result2;
        } else if (this.isCellVisible(child) && this.isSwimlane(child)) {
          const state2 = this.view.getState(child);
          if (this.intersects(state2, x, y)) {
            return child;
          }
        }
      }
    }
  }
  return null;
};
mxGraph2.prototype.getCellAt = function(x, y, parent2, vertices, edges, ignoreFn) {
  vertices = vertices != null ? vertices : true;
  edges = edges != null ? edges : true;
  if (parent2 == null) {
    parent2 = this.getCurrentRoot();
    if (parent2 == null) {
      parent2 = this.getModel().getRoot();
    }
  }
  if (parent2 != null) {
    const childCount = this.model.getChildCount(parent2);
    for (let i = childCount - 1; i >= 0; i--) {
      const cell2 = this.model.getChildAt(parent2, i);
      const result2 = this.getCellAt(x, y, cell2, vertices, edges, ignoreFn);
      if (result2 != null) {
        return result2;
      } else if (this.isCellVisible(cell2) && (edges && this.model.isEdge(cell2) || vertices && this.model.isVertex(cell2))) {
        const state2 = this.view.getState(cell2);
        if (state2 != null && (ignoreFn == null || !ignoreFn(state2, x, y)) && this.intersects(state2, x, y)) {
          return cell2;
        }
      }
    }
  }
  return null;
};
mxGraph2.prototype.intersects = function(state2, x, y) {
  if (state2 != null) {
    const pts = state2.absolutePoints;
    if (pts != null) {
      const t2 = this.tolerance * this.tolerance;
      let pt = pts[0];
      for (let i = 1; i < pts.length; i++) {
        const next = pts[i];
        const dist = ptSegDistSq(pt.x, pt.y, next.x, next.y, x, y);
        if (dist <= t2) {
          return true;
        }
        pt = next;
      }
    } else {
      const alpha = toRadians(getValue(state2.style, mxConstants2.STYLE_ROTATION) || 0);
      if (alpha != 0) {
        const cos = Math.cos(-alpha);
        const sin = Math.sin(-alpha);
        const cx = new mxPoint2(state2.getCenterX(), state2.getCenterY());
        const pt = getRotatedPoint(new mxPoint2(x, y), cos, sin, cx);
        x = pt.x;
        y = pt.y;
      }
      if (contains(state2, x, y)) {
        return true;
      }
    }
  }
  return false;
};
mxGraph2.prototype.hitsSwimlaneContent = function(swimlane, x, y) {
  const state2 = this.getView().getState(swimlane);
  const size = this.getStartSize(swimlane);
  if (state2 != null) {
    const scale = this.getView().getScale();
    x -= state2.x;
    y -= state2.y;
    if (size.width > 0 && x > 0 && x > size.width * scale) {
      return true;
    } else if (size.height > 0 && y > 0 && y > size.height * scale) {
      return true;
    }
  }
  return false;
};
mxGraph2.prototype.getChildVertices = function(parent2) {
  return this.getChildCells(parent2, true, false);
};
mxGraph2.prototype.getChildEdges = function(parent2) {
  return this.getChildCells(parent2, false, true);
};
mxGraph2.prototype.getChildCells = function(parent2, vertices, edges) {
  parent2 = parent2 != null ? parent2 : this.getDefaultParent();
  vertices = vertices != null ? vertices : false;
  edges = edges != null ? edges : false;
  const cells = this.model.getChildCells(parent2, vertices, edges);
  const result2 = [];
  for (let i = 0; i < cells.length; i++) {
    if (this.isCellVisible(cells[i])) {
      result2.push(cells[i]);
    }
  }
  return result2;
};
mxGraph2.prototype.getConnections = function(cell2, parent2) {
  return this.getEdges(cell2, parent2, true, true, false);
};
mxGraph2.prototype.getIncomingEdges = function(cell2, parent2) {
  return this.getEdges(cell2, parent2, true, false, false);
};
mxGraph2.prototype.getOutgoingEdges = function(cell2, parent2) {
  return this.getEdges(cell2, parent2, false, true, false);
};
mxGraph2.prototype.getEdges = function(cell2, parent2, incoming, outgoing, includeLoops, recurse) {
  incoming = incoming != null ? incoming : true;
  outgoing = outgoing != null ? outgoing : true;
  includeLoops = includeLoops != null ? includeLoops : true;
  recurse = recurse != null ? recurse : false;
  let edges = [];
  const isCollapsed = this.isCellCollapsed(cell2);
  const childCount = this.model.getChildCount(cell2);
  for (let i = 0; i < childCount; i++) {
    const child = this.model.getChildAt(cell2, i);
    if (isCollapsed || !this.isCellVisible(child)) {
      edges = edges.concat(this.model.getEdges(child, incoming, outgoing));
    }
  }
  edges = edges.concat(this.model.getEdges(cell2, incoming, outgoing));
  const result2 = [];
  for (let i = 0; i < edges.length; i++) {
    const state2 = this.view.getState(edges[i]);
    const source = state2 != null ? state2.getVisibleTerminal(true) : this.view.getVisibleTerminal(edges[i], true);
    const target = state2 != null ? state2.getVisibleTerminal(false) : this.view.getVisibleTerminal(edges[i], false);
    if (includeLoops && source == target || source != target && (incoming && target == cell2 && (parent2 == null || this.isValidAncestor(source, parent2, recurse)) || outgoing && source == cell2 && (parent2 == null || this.isValidAncestor(target, parent2, recurse)))) {
      result2.push(edges[i]);
    }
  }
  return result2;
};
mxGraph2.prototype.isValidAncestor = function(cell2, parent2, recurse) {
  return recurse ? this.model.isAncestor(parent2, cell2) : this.model.getParent(cell2) == parent2;
};
mxGraph2.prototype.getOpposites = function(edges, terminal, sources, targets) {
  sources = sources != null ? sources : true;
  targets = targets != null ? targets : true;
  const terminals = [];
  const dict = new mxDictionary();
  if (edges != null) {
    for (let i = 0; i < edges.length; i++) {
      const state2 = this.view.getState(edges[i]);
      const source = state2 != null ? state2.getVisibleTerminal(true) : this.view.getVisibleTerminal(edges[i], true);
      const target = state2 != null ? state2.getVisibleTerminal(false) : this.view.getVisibleTerminal(edges[i], false);
      if (source == terminal && target != null && target != terminal && targets) {
        if (!dict.get(target)) {
          dict.put(target, true);
          terminals.push(target);
        }
      } else if (target == terminal && source != null && source != terminal && sources) {
        if (!dict.get(source)) {
          dict.put(source, true);
          terminals.push(source);
        }
      }
    }
  }
  return terminals;
};
mxGraph2.prototype.getEdgesBetween = function(source, target, directed) {
  directed = directed != null ? directed : false;
  const edges = this.getEdges(source);
  const result2 = [];
  for (let i = 0; i < edges.length; i++) {
    const state2 = this.view.getState(edges[i]);
    const src = state2 != null ? state2.getVisibleTerminal(true) : this.view.getVisibleTerminal(edges[i], true);
    const trg = state2 != null ? state2.getVisibleTerminal(false) : this.view.getVisibleTerminal(edges[i], false);
    if (src == source && trg == target || !directed && src == target && trg == source) {
      result2.push(edges[i]);
    }
  }
  return result2;
};
mxGraph2.prototype.getPointForEvent = function(evt, addOffset) {
  const p = convertPoint(this.container, mxEvent2.getClientX(evt), mxEvent2.getClientY(evt));
  const s = this.view.scale;
  const tr = this.view.translate;
  const off = addOffset != false ? this.gridSize / 2 : 0;
  p.x = this.snap(p.x / s - tr.x - off);
  p.y = this.snap(p.y / s - tr.y - off);
  return p;
};
mxGraph2.prototype.getCells = function(x, y, width, height, parent2, result2, intersection2, ignoreFn, includeDescendants) {
  result2 = result2 != null ? result2 : [];
  if (width > 0 || height > 0 || intersection2 != null) {
    const model = this.getModel();
    const right = x + width;
    const bottom = y + height;
    if (parent2 == null) {
      parent2 = this.getCurrentRoot();
      if (parent2 == null) {
        parent2 = model.getRoot();
      }
    }
    if (parent2 != null) {
      const childCount = model.getChildCount(parent2);
      for (let i = 0; i < childCount; i++) {
        const cell2 = model.getChildAt(parent2, i);
        const state2 = this.view.getState(cell2);
        if (state2 != null && this.isCellVisible(cell2) && (ignoreFn == null || !ignoreFn(state2))) {
          const deg = getValue(state2.style, mxConstants2.STYLE_ROTATION) || 0;
          let box = state2;
          if (deg != 0) {
            box = getBoundingBox(box, deg);
          }
          const hit = intersection2 != null && model.isVertex(cell2) && intersects(intersection2, box) || intersection2 == null && (model.isEdge(cell2) || model.isVertex(cell2)) && box.x >= x && box.y + box.height <= bottom && box.y >= y && box.x + box.width <= right;
          if (hit) {
            result2.push(cell2);
          }
          if (!hit || includeDescendants) {
            this.getCells(x, y, width, height, cell2, result2, intersection2, ignoreFn, includeDescendants);
          }
        }
      }
    }
  }
  return result2;
};
mxGraph2.prototype.getCellsBeyond = function(x0, y0, parent2, rightHalfpane, bottomHalfpane) {
  const result2 = [];
  if (rightHalfpane || bottomHalfpane) {
    if (parent2 == null) {
      parent2 = this.getDefaultParent();
    }
    if (parent2 != null) {
      const childCount = this.model.getChildCount(parent2);
      for (let i = 0; i < childCount; i++) {
        const child = this.model.getChildAt(parent2, i);
        const state2 = this.view.getState(child);
        if (this.isCellVisible(child) && state2 != null) {
          if ((!rightHalfpane || state2.x >= x0) && (!bottomHalfpane || state2.y >= y0)) {
            result2.push(child);
          }
        }
      }
    }
  }
  return result2;
};
mxGraph2.prototype.findTreeRoots = function(parent2, isolate, invert) {
  isolate = isolate != null ? isolate : false;
  invert = invert != null ? invert : false;
  const roots = [];
  if (parent2 != null) {
    const model = this.getModel();
    const childCount = model.getChildCount(parent2);
    let best = null;
    let maxDiff = 0;
    for (let i = 0; i < childCount; i++) {
      const cell2 = model.getChildAt(parent2, i);
      if (this.model.isVertex(cell2) && this.isCellVisible(cell2)) {
        const conns = this.getConnections(cell2, isolate ? parent2 : null);
        let fanOut = 0;
        let fanIn = 0;
        for (let j = 0; j < conns.length; j++) {
          const src = this.view.getVisibleTerminal(conns[j], true);
          if (src == cell2) {
            fanOut++;
          } else {
            fanIn++;
          }
        }
        if (invert && fanOut == 0 && fanIn > 0 || !invert && fanIn == 0 && fanOut > 0) {
          roots.push(cell2);
        }
        const diff = invert ? fanIn - fanOut : fanOut - fanIn;
        if (diff > maxDiff) {
          maxDiff = diff;
          best = cell2;
        }
      }
    }
    if (roots.length == 0 && best != null) {
      roots.push(best);
    }
  }
  return roots;
};
mxGraph2.prototype.traverse = function(vertex, directed, func, edge, visited, inverse) {
  if (func != null && vertex != null) {
    directed = directed != null ? directed : true;
    inverse = inverse != null ? inverse : false;
    visited = visited || new mxDictionary();
    if (!visited.get(vertex)) {
      visited.put(vertex, true);
      const result2 = func(vertex, edge);
      if (result2 == null || result2) {
        const edgeCount = this.model.getEdgeCount(vertex);
        if (edgeCount > 0) {
          for (let i = 0; i < edgeCount; i++) {
            const e = this.model.getEdgeAt(vertex, i);
            const isSource = this.model.getTerminal(e, true) == vertex;
            if (!directed || !inverse == isSource) {
              const next = this.model.getTerminal(e, !isSource);
              this.traverse(next, directed, func, e, visited, inverse);
            }
          }
        }
      }
    }
  }
};
mxGraph2.prototype.isCellSelected = function(cell2) {
  return this.getSelectionModel().isSelected(cell2);
};
mxGraph2.prototype.isSelectionEmpty = function() {
  return this.getSelectionModel().isEmpty();
};
mxGraph2.prototype.clearSelection = function() {
  return this.getSelectionModel().clear();
};
mxGraph2.prototype.getSelectionCount = function() {
  return this.getSelectionModel().cells.length;
};
mxGraph2.prototype.getSelectionCell = function() {
  return this.getSelectionModel().cells[0];
};
mxGraph2.prototype.getSelectionCells = function() {
  return this.getSelectionModel().cells.slice();
};
mxGraph2.prototype.setSelectionCell = function(cell2) {
  this.getSelectionModel().setCell(cell2);
};
mxGraph2.prototype.setSelectionCells = function(cells) {
  this.getSelectionModel().setCells(cells);
};
mxGraph2.prototype.addSelectionCell = function(cell2) {
  this.getSelectionModel().addCell(cell2);
};
mxGraph2.prototype.addSelectionCells = function(cells) {
  this.getSelectionModel().addCells(cells);
};
mxGraph2.prototype.removeSelectionCell = function(cell2) {
  this.getSelectionModel().removeCell(cell2);
};
mxGraph2.prototype.removeSelectionCells = function(cells) {
  this.getSelectionModel().removeCells(cells);
};
mxGraph2.prototype.selectRegion = function(rect, evt) {
  const cells = this.getCells(rect.x, rect.y, rect.width, rect.height);
  this.selectCellsForEvent(cells, evt);
  return cells;
};
mxGraph2.prototype.selectNextCell = function() {
  this.selectCell(true);
};
mxGraph2.prototype.selectPreviousCell = function() {
  this.selectCell();
};
mxGraph2.prototype.selectParentCell = function() {
  this.selectCell(false, true);
};
mxGraph2.prototype.selectChildCell = function() {
  this.selectCell(false, false, true);
};
mxGraph2.prototype.selectCell = function(isNext, isParent, isChild) {
  const sel2 = this.selectionModel;
  const cell2 = sel2.cells.length > 0 ? sel2.cells[0] : null;
  if (sel2.cells.length > 1) {
    sel2.clear();
  }
  const parent2 = cell2 != null ? this.model.getParent(cell2) : this.getDefaultParent();
  const childCount = this.model.getChildCount(parent2);
  if (cell2 == null && childCount > 0) {
    const child = this.model.getChildAt(parent2, 0);
    this.setSelectionCell(child);
  } else if ((cell2 == null || isParent) && this.view.getState(parent2) != null && this.model.getGeometry(parent2) != null) {
    if (this.getCurrentRoot() != parent2) {
      this.setSelectionCell(parent2);
    }
  } else if (cell2 != null && isChild) {
    const tmp = this.model.getChildCount(cell2);
    if (tmp > 0) {
      const child = this.model.getChildAt(cell2, 0);
      this.setSelectionCell(child);
    }
  } else if (childCount > 0) {
    const i = parent2.getIndex(cell2);
    if (isNext) {
      const child = this.model.getChildAt(parent2, (i + 1) % childCount);
      this.setSelectionCell(child);
    } else {
      const index = i < 1 ? childCount - 1 : i - 1;
      const child = this.model.getChildAt(parent2, index);
      this.setSelectionCell(child);
    }
  }
};
mxGraph2.prototype.selectAll = function(parent2, descendants) {
  parent2 = parent2 || this.getDefaultParent();
  const cells = descendants ? this.model.filterDescendants(bind(this, function(cell2) {
    return cell2 != parent2 && this.view.getState(cell2) != null;
  }), parent2) : this.model.getChildren(parent2);
  if (cells != null) {
    this.setSelectionCells(cells);
  }
};
mxGraph2.prototype.selectVertices = function(parent2, selectGroups) {
  this.selectCells(true, false, parent2, selectGroups);
};
mxGraph2.prototype.selectEdges = function(parent2) {
  this.selectCells(false, true, parent2);
};
mxGraph2.prototype.selectCells = function(vertices, edges, parent2, selectGroups) {
  parent2 = parent2 || this.getDefaultParent();
  const filter = bind(this, function(cell2) {
    return this.view.getState(cell2) != null && ((selectGroups || this.model.getChildCount(cell2) == 0) && this.model.isVertex(cell2) && vertices && !this.model.isEdge(this.model.getParent(cell2)) || this.model.isEdge(cell2) && edges);
  });
  const cells = this.model.filterDescendants(filter, parent2);
  if (cells != null) {
    this.setSelectionCells(cells);
  }
};
mxGraph2.prototype.selectCellForEvent = function(cell2, evt) {
  const isSelected = this.isCellSelected(cell2);
  if (this.isToggleEvent(evt)) {
    if (isSelected) {
      this.removeSelectionCell(cell2);
    } else {
      this.addSelectionCell(cell2);
    }
  } else if (!isSelected || this.getSelectionCount() != 1) {
    this.setSelectionCell(cell2);
  }
};
mxGraph2.prototype.selectCellsForEvent = function(cells, evt) {
  if (this.isToggleEvent(evt)) {
    this.addSelectionCells(cells);
  } else {
    this.setSelectionCells(cells);
  }
};
mxGraph2.prototype.createHandler = function(state2) {
  let result2 = null;
  if (state2 != null) {
    if (this.model.isEdge(state2.cell)) {
      const source = state2.getVisibleTerminalState(true);
      const target = state2.getVisibleTerminalState(false);
      const geo = this.getCellGeometry(state2.cell);
      const edgeStyle = this.view.getEdgeStyle(state2, geo != null ? geo.points : null, source, target);
      result2 = this.createEdgeHandler(state2, edgeStyle);
    } else {
      result2 = this.createVertexHandler(state2);
    }
  }
  return result2;
};
mxGraph2.prototype.createVertexHandler = function(state2) {
  return new mxVertexHandler2(state2);
};
mxGraph2.prototype.createEdgeHandler = function(state2, edgeStyle) {
  let result2 = null;
  if (edgeStyle == mxEdgeStyle.Loop || edgeStyle == mxEdgeStyle.ElbowConnector || edgeStyle == mxEdgeStyle.SideToSide || edgeStyle == mxEdgeStyle.TopToBottom) {
    result2 = this.createElbowEdgeHandler(state2);
  } else if (edgeStyle == mxEdgeStyle.SegmentConnector || edgeStyle == mxEdgeStyle.OrthConnector) {
    result2 = this.createEdgeSegmentHandler(state2);
  } else {
    result2 = new mxEdgeHandler2(state2);
  }
  return result2;
};
mxGraph2.prototype.createEdgeSegmentHandler = function(state2) {
  return new mxEdgeSegmentHandler(state2);
};
mxGraph2.prototype.createElbowEdgeHandler = function(state2) {
  return new mxElbowEdgeHandler2(state2);
};
mxGraph2.prototype.addMouseListener = function(listener) {
  if (this.mouseListeners == null) {
    this.mouseListeners = [];
  }
  this.mouseListeners.push(listener);
};
mxGraph2.prototype.removeMouseListener = function(listener) {
  if (this.mouseListeners != null) {
    for (let i = 0; i < this.mouseListeners.length; i++) {
      if (this.mouseListeners[i] == listener) {
        this.mouseListeners.splice(i, 1);
        break;
      }
    }
  }
};
mxGraph2.prototype.updateMouseEvent = function(me, evtName) {
  if (me.graphX == null || me.graphY == null) {
    const pt = convertPoint(this.container, me.getX(), me.getY());
    me.graphX = pt.x - this.panDx;
    me.graphY = pt.y - this.panDy;
    if (me.getCell() == null && this.isMouseDown && evtName == mxEvent2.MOUSE_MOVE) {
      me.state = this.view.getState(this.getCellAt(pt.x, pt.y, null, null, null, function(state2) {
        return state2.shape == null || state2.shape.paintBackground != mxRectangleShape.prototype.paintBackground || getValue(state2.style, mxConstants2.STYLE_POINTER_EVENTS, "1") == "1" || state2.shape.fill != null && state2.shape.fill != mxConstants2.NONE;
      }));
    }
  }
  return me;
};
mxGraph2.prototype.getStateForTouchEvent = function(evt) {
  const x = mxEvent2.getClientX(evt);
  const y = mxEvent2.getClientY(evt);
  const pt = convertPoint(this.container, x, y);
  return this.view.getState(this.getCellAt(pt.x, pt.y));
};
mxGraph2.prototype.isEventIgnored = function(evtName, me, sender) {
  const mouseEvent = mxEvent2.isMouseEvent(me.getEvent());
  let result2 = false;
  if (me.getEvent() == this.lastEvent) {
    result2 = true;
  } else {
    this.lastEvent = me.getEvent();
  }
  if (this.eventSource != null && evtName != mxEvent2.MOUSE_MOVE) {
    mxEvent2.removeGestureListeners(this.eventSource, null, this.mouseMoveRedirect, this.mouseUpRedirect);
    this.mouseMoveRedirect = null;
    this.mouseUpRedirect = null;
    this.eventSource = null;
  } else if (!mxClient_default.IS_GC && this.eventSource != null && me.getSource() != this.eventSource) {
    result2 = true;
  } else if (mxClient_default.IS_TOUCH && evtName == mxEvent2.MOUSE_DOWN && !mouseEvent && !mxEvent2.isPenEvent(me.getEvent())) {
    this.eventSource = me.getSource();
    this.mouseMoveRedirect = bind(this, function(evt) {
      this.fireMouseEvent(mxEvent2.MOUSE_MOVE, new mxMouseEvent2(evt, this.getStateForTouchEvent(evt)));
    });
    this.mouseUpRedirect = bind(this, function(evt) {
      this.fireMouseEvent(mxEvent2.MOUSE_UP, new mxMouseEvent2(evt, this.getStateForTouchEvent(evt)));
    });
    mxEvent2.addGestureListeners(this.eventSource, null, this.mouseMoveRedirect, this.mouseUpRedirect);
  }
  if (this.isSyntheticEventIgnored(evtName, me, sender)) {
    result2 = true;
  }
  if (!mxEvent2.isPopupTrigger(this.lastEvent) && evtName != mxEvent2.MOUSE_MOVE && this.lastEvent.detail == 2) {
    return true;
  }
  if (evtName == mxEvent2.MOUSE_UP && this.isMouseDown) {
    this.isMouseDown = false;
  } else if (evtName == mxEvent2.MOUSE_DOWN && !this.isMouseDown) {
    this.isMouseDown = true;
    this.isMouseTrigger = mouseEvent;
  } else if (!result2 && ((!mxClient_default.IS_FF || evtName != mxEvent2.MOUSE_MOVE) && this.isMouseDown && this.isMouseTrigger != mouseEvent || evtName == mxEvent2.MOUSE_DOWN && this.isMouseDown || evtName == mxEvent2.MOUSE_UP && !this.isMouseDown)) {
    result2 = true;
  }
  if (!result2 && evtName == mxEvent2.MOUSE_DOWN) {
    this.lastMouseX = me.getX();
    this.lastMouseY = me.getY();
  }
  return result2;
};
mxGraph2.prototype.isSyntheticEventIgnored = function(evtName, me, sender) {
  let result2 = false;
  const mouseEvent = mxEvent2.isMouseEvent(me.getEvent());
  if (this.ignoreMouseEvents && mouseEvent && evtName != mxEvent2.MOUSE_MOVE) {
    this.ignoreMouseEvents = evtName != mxEvent2.MOUSE_UP;
    result2 = true;
  } else if (mxClient_default.IS_FF && !mouseEvent && evtName == mxEvent2.MOUSE_UP) {
    this.ignoreMouseEvents = true;
  }
  return result2;
};
mxGraph2.prototype.isEventSourceIgnored = function(evtName, me) {
  const source = me.getSource();
  const name = source.nodeName != null ? source.nodeName.toLowerCase() : "";
  const candidate = !mxEvent2.isMouseEvent(me.getEvent()) || mxEvent2.isLeftMouseButton(me.getEvent());
  return evtName == mxEvent2.MOUSE_DOWN && candidate && (name == "select" || name == "option" || name == "input" && source.type != "checkbox" && source.type != "radio" && source.type != "button" && source.type != "submit" && source.type != "file");
};
mxGraph2.prototype.getEventState = function(state2) {
  return state2;
};
mxGraph2.prototype.fireMouseEvent = function(evtName, me, sender) {
  if (this.isEventSourceIgnored(evtName, me)) {
    if (this.tooltipHandler != null) {
      this.tooltipHandler.hide();
    }
    return;
  }
  if (sender == null) {
    sender = this;
  }
  me = this.updateMouseEvent(me, evtName);
  if (!this.nativeDblClickEnabled && !mxEvent2.isPopupTrigger(me.getEvent()) || this.doubleTapEnabled && mxClient_default.IS_TOUCH && (mxEvent2.isTouchEvent(me.getEvent()) || mxEvent2.isPenEvent(me.getEvent()))) {
    const currentTime = new Date().getTime();
    if (!mxClient_default.IS_QUIRKS && evtName == mxEvent2.MOUSE_DOWN || mxClient_default.IS_QUIRKS && evtName == mxEvent2.MOUSE_UP && !this.fireDoubleClick) {
      if (this.lastTouchEvent != null && this.lastTouchEvent != me.getEvent() && currentTime - this.lastTouchTime < this.doubleTapTimeout && Math.abs(this.lastTouchX - me.getX()) < this.doubleTapTolerance && Math.abs(this.lastTouchY - me.getY()) < this.doubleTapTolerance && this.doubleClickCounter < 2) {
        this.doubleClickCounter++;
        let doubleClickFired = false;
        if (evtName == mxEvent2.MOUSE_UP) {
          if (me.getCell() == this.lastTouchCell && this.lastTouchCell != null) {
            this.lastTouchTime = 0;
            const cell2 = this.lastTouchCell;
            this.lastTouchCell = null;
            if (mxClient_default.IS_QUIRKS) {
              me.getSource().fireEvent("ondblclick");
            }
            this.dblClick(me.getEvent(), cell2);
            doubleClickFired = true;
          }
        } else {
          this.fireDoubleClick = true;
          this.lastTouchTime = 0;
        }
        if (!mxClient_default.IS_QUIRKS || doubleClickFired) {
          mxEvent2.consume(me.getEvent());
          return;
        }
      } else if (this.lastTouchEvent == null || this.lastTouchEvent != me.getEvent()) {
        this.lastTouchCell = me.getCell();
        this.lastTouchX = me.getX();
        this.lastTouchY = me.getY();
        this.lastTouchTime = currentTime;
        this.lastTouchEvent = me.getEvent();
        this.doubleClickCounter = 0;
      }
    } else if ((this.isMouseDown || evtName == mxEvent2.MOUSE_UP) && this.fireDoubleClick) {
      this.fireDoubleClick = false;
      const cell2 = this.lastTouchCell;
      this.lastTouchCell = null;
      this.isMouseDown = false;
      const valid = cell2 != null || (mxEvent2.isTouchEvent(me.getEvent()) || mxEvent2.isPenEvent(me.getEvent())) && (mxClient_default.IS_GC || mxClient_default.IS_SF);
      if (valid && Math.abs(this.lastTouchX - me.getX()) < this.doubleTapTolerance && Math.abs(this.lastTouchY - me.getY()) < this.doubleTapTolerance) {
        this.dblClick(me.getEvent(), cell2);
      } else {
        mxEvent2.consume(me.getEvent());
      }
      return;
    }
  }
  if (!this.isEventIgnored(evtName, me, sender)) {
    me.state = this.getEventState(me.getState());
    this.fireEvent(new mxEventObject2(mxEvent2.FIRE_MOUSE_EVENT, "eventName", evtName, "event", me));
    if (mxClient_default.IS_OP || mxClient_default.IS_SF || mxClient_default.IS_GC || mxClient_default.IS_IE11 || mxClient_default.IS_IE && mxClient_default.IS_SVG || me.getEvent().target != this.container) {
      if (evtName == mxEvent2.MOUSE_MOVE && this.isMouseDown && this.autoScroll && !mxEvent2.isMultiTouchEvent(me.getEvent)) {
        this.scrollPointToVisible(me.getGraphX(), me.getGraphY(), this.autoExtend);
      } else if (evtName == mxEvent2.MOUSE_UP && this.ignoreScrollbars && this.translateToScrollPosition && (this.container.scrollLeft != 0 || this.container.scrollTop != 0)) {
        const s = this.view.scale;
        const tr = this.view.translate;
        this.view.setTranslate(tr.x - this.container.scrollLeft / s, tr.y - this.container.scrollTop / s);
        this.container.scrollLeft = 0;
        this.container.scrollTop = 0;
      }
      if (this.mouseListeners != null) {
        const args = [sender, me];
        if (!me.getEvent().preventDefault) {
          me.getEvent().returnValue = true;
        }
        for (let i = 0; i < this.mouseListeners.length; i++) {
          const l = this.mouseListeners[i];
          if (evtName == mxEvent2.MOUSE_DOWN) {
            l.mouseDown.apply(l, args);
          } else if (evtName == mxEvent2.MOUSE_MOVE) {
            l.mouseMove.apply(l, args);
          } else if (evtName == mxEvent2.MOUSE_UP) {
            l.mouseUp.apply(l, args);
          }
        }
      }
      if (evtName == mxEvent2.MOUSE_UP) {
        this.click(me);
      }
    }
    if ((mxEvent2.isTouchEvent(me.getEvent()) || mxEvent2.isPenEvent(me.getEvent())) && evtName == mxEvent2.MOUSE_DOWN && this.tapAndHoldEnabled && !this.tapAndHoldInProgress) {
      this.tapAndHoldInProgress = true;
      this.initialTouchX = me.getGraphX();
      this.initialTouchY = me.getGraphY();
      const handler = function() {
        if (this.tapAndHoldValid) {
          this.tapAndHold(me);
        }
        this.tapAndHoldInProgress = false;
        this.tapAndHoldValid = false;
      };
      if (this.tapAndHoldThread) {
        window.clearTimeout(this.tapAndHoldThread);
      }
      this.tapAndHoldThread = window.setTimeout(bind(this, handler), this.tapAndHoldDelay);
      this.tapAndHoldValid = true;
    } else if (evtName == mxEvent2.MOUSE_UP) {
      this.tapAndHoldInProgress = false;
      this.tapAndHoldValid = false;
    } else if (this.tapAndHoldValid) {
      this.tapAndHoldValid = Math.abs(this.initialTouchX - me.getGraphX()) < this.tolerance && Math.abs(this.initialTouchY - me.getGraphY()) < this.tolerance;
    }
    if (evtName == mxEvent2.MOUSE_DOWN && this.isEditing() && !this.cellEditor.isEventSource(me.getEvent())) {
      this.stopEditing(!this.isInvokesStopCellEditing());
    }
    this.consumeMouseEvent(evtName, me, sender);
  }
};
mxGraph2.prototype.consumeMouseEvent = function(evtName, me, sender) {
  if (evtName == mxEvent2.MOUSE_DOWN && mxEvent2.isTouchEvent(me.getEvent())) {
    me.consume(false);
  }
};
mxGraph2.prototype.fireGestureEvent = function(evt, cell2) {
  this.lastTouchTime = 0;
  this.fireEvent(new mxEventObject2(mxEvent2.GESTURE, "event", evt, "cell", cell2));
};
mxGraph2.prototype.destroy = function() {
  if (!this.destroyed) {
    this.destroyed = true;
    if (this.tooltipHandler != null) {
      this.tooltipHandler.destroy();
    }
    if (this.selectionCellsHandler != null) {
      this.selectionCellsHandler.destroy();
    }
    if (this.panningHandler != null) {
      this.panningHandler.destroy();
    }
    if (this.popupMenuHandler != null) {
      this.popupMenuHandler.destroy();
    }
    if (this.connectionHandler != null) {
      this.connectionHandler.destroy();
    }
    if (this.graphHandler != null) {
      this.graphHandler.destroy();
    }
    if (this.cellEditor != null) {
      this.cellEditor.destroy();
    }
    if (this.view != null) {
      this.view.destroy();
    }
    if (this.model != null && this.graphModelChangeListener != null) {
      this.model.removeListener(this.graphModelChangeListener);
      this.graphModelChangeListener = null;
    }
    this.container = null;
  }
};

// js/graph/mxRubberband.js
var mxRubberband = function(graph) {
  if (graph != null) {
    this.graph = graph;
    this.graph.addMouseListener(this);
    this.forceRubberbandHandler = bind(this, (sender, evt) => {
      const evtName = evt.getProperty("eventName");
      const me = evt.getProperty("event");
      if (evtName === mxEvent2.MOUSE_DOWN && this.isForceRubberbandEvent(me)) {
        const offset = getOffset(this.graph.container);
        const origin = getScrollOrigin(this.graph.container);
        origin.x -= offset.x;
        origin.y -= offset.y;
        this.start(me.getX() + origin.x, me.getY() + origin.y);
        me.consume(false);
      }
    });
    this.graph.addListener(mxEvent2.FIRE_MOUSE_EVENT, this.forceRubberbandHandler);
    this.panHandler = bind(this, () => {
      this.repaint();
    });
    this.graph.addListener(mxEvent2.PAN, this.panHandler);
    this.gestureHandler = bind(this, (sender, eo) => {
      if (this.first != null) {
        this.reset();
      }
    });
    this.graph.addListener(mxEvent2.GESTURE, this.gestureHandler);
    if (mxClient_default.IS_IE) {
      mxEvent2.addListener(window, "unload", bind(this, () => {
        this.destroy();
      }));
    }
  }
};
mxRubberband.prototype.defaultOpacity = 20;
mxRubberband.prototype.enabled = true;
mxRubberband.prototype.div = null;
mxRubberband.prototype.sharedDiv = null;
mxRubberband.prototype.currentX = 0;
mxRubberband.prototype.currentY = 0;
mxRubberband.prototype.fadeOut = false;
mxRubberband.prototype.isEnabled = function() {
  return this.enabled;
};
mxRubberband.prototype.setEnabled = function(enabled) {
  this.enabled = enabled;
};
mxRubberband.prototype.isForceRubberbandEvent = function(me) {
  return mxEvent2.isAltDown(me.getEvent());
};
mxRubberband.prototype.mouseDown = function(sender, me) {
  if (!me.isConsumed() && this.isEnabled() && this.graph.isEnabled() && me.getState() == null && !mxEvent2.isMultiTouchEvent(me.getEvent())) {
    const offset = getOffset(this.graph.container);
    const origin = getScrollOrigin(this.graph.container);
    origin.x -= offset.x;
    origin.y -= offset.y;
    this.start(me.getX() + origin.x, me.getY() + origin.y);
    me.consume(false);
  }
};
mxRubberband.prototype.start = function(x, y) {
  this.first = new mxPoint2(x, y);
  const container = this.graph.container;
  function createMouseEvent(evt) {
    const me = new mxMouseEvent2(evt);
    const pt = convertPoint(container, me.getX(), me.getY());
    me.graphX = pt.x;
    me.graphY = pt.y;
    return me;
  }
  this.dragHandler = bind(this, (evt) => {
    this.mouseMove(this.graph, createMouseEvent(evt));
  });
  this.dropHandler = bind(this, (evt) => {
    this.mouseUp(this.graph, createMouseEvent(evt));
  });
  if (mxClient_default.IS_FF) {
    mxEvent2.addGestureListeners(document, null, this.dragHandler, this.dropHandler);
  }
};
mxRubberband.prototype.mouseMove = function(sender, me) {
  if (!me.isConsumed() && this.first != null) {
    const origin = getScrollOrigin(this.graph.container);
    const offset = getOffset(this.graph.container);
    origin.x -= offset.x;
    origin.y -= offset.y;
    const x = me.getX() + origin.x;
    const y = me.getY() + origin.y;
    const dx = this.first.x - x;
    const dy = this.first.y - y;
    const tol = this.graph.tolerance;
    if (this.div != null || Math.abs(dx) > tol || Math.abs(dy) > tol) {
      if (this.div == null) {
        this.div = this.createShape();
      }
      clearSelection();
      this.update(x, y);
      me.consume();
    }
  }
};
mxRubberband.prototype.createShape = function() {
  if (this.sharedDiv == null) {
    this.sharedDiv = document.createElement("div");
    this.sharedDiv.className = "mxRubberband";
    setOpacity(this.sharedDiv, this.defaultOpacity);
  }
  this.graph.container.appendChild(this.sharedDiv);
  const result2 = this.sharedDiv;
  if (mxClient_default.IS_SVG && (!mxClient_default.IS_IE || document.documentMode >= 10) && this.fadeOut) {
    this.sharedDiv = null;
  }
  return result2;
};
mxRubberband.prototype.isActive = function(sender, me) {
  return this.div != null && this.div.style.display !== "none";
};
mxRubberband.prototype.mouseUp = function(sender, me) {
  const active = this.isActive();
  this.reset();
  if (active) {
    this.execute(me.getEvent());
    me.consume();
  }
};
mxRubberband.prototype.execute = function(evt) {
  const rect = new mxRectangle(this.x, this.y, this.width, this.height);
  this.graph.selectRegion(rect, evt);
};
mxRubberband.prototype.reset = function() {
  if (this.div != null) {
    if (mxClient_default.IS_SVG && (!mxClient_default.IS_IE || document.documentMode >= 10) && this.fadeOut) {
      const temp2 = this.div;
      setPrefixedStyle(temp2.style, "transition", "all 0.2s linear");
      temp2.style.pointerEvents = "none";
      temp2.style.opacity = 0;
      window.setTimeout(() => {
        temp2.parentNode.removeChild(temp2);
      }, 200);
    } else {
      this.div.parentNode.removeChild(this.div);
    }
  }
  mxEvent2.removeGestureListeners(document, null, this.dragHandler, this.dropHandler);
  this.dragHandler = null;
  this.dropHandler = null;
  this.currentX = 0;
  this.currentY = 0;
  this.first = null;
  this.div = null;
};
mxRubberband.prototype.update = function(x, y) {
  this.currentX = x;
  this.currentY = y;
  this.repaint();
};
mxRubberband.prototype.repaint = function() {
  if (this.div != null) {
    const x = this.currentX - this.graph.panDx;
    const y = this.currentY - this.graph.panDy;
    this.x = Math.min(this.first.x, x);
    this.y = Math.min(this.first.y, y);
    this.width = Math.max(this.first.x, x) - this.x;
    this.height = Math.max(this.first.y, y) - this.y;
    const dx = mxClient_default.IS_VML ? this.graph.panDx : 0;
    const dy = mxClient_default.IS_VML ? this.graph.panDy : 0;
    this.div.style.left = `${this.x + dx}px`;
    this.div.style.top = `${this.y + dy}px`;
    this.div.style.width = `${Math.max(1, this.width)}px`;
    this.div.style.height = `${Math.max(1, this.height)}px`;
  }
};
mxRubberband.prototype.destroy = function() {
  if (!this.destroyed) {
    this.destroyed = true;
    this.graph.removeMouseListener(this);
    this.graph.removeListener(this.forceRubberbandHandler);
    this.graph.removeListener(this.panHandler);
    this.reset();
    if (this.sharedDiv != null) {
      this.sharedDiv = null;
    }
  }
};

// js/graph/mxLayoutManager.js
var mxLayoutManager = function(graph) {
  this.undoHandler = bind(this, (sender, evt) => {
    if (this.isEnabled()) {
      this.beforeUndo(evt.getProperty("edit"));
    }
  });
  this.moveHandler = bind(this, (sender, evt) => {
    if (this.isEnabled()) {
      this.cellsMoved(evt.getProperty("cells"), evt.getProperty("event"));
    }
  });
  this.resizeHandler = bind(this, (sender, evt) => {
    if (this.isEnabled()) {
      this.cellsResized(evt.getProperty("cells"), evt.getProperty("bounds"), evt.getProperty("previous"));
    }
  });
  this.setGraph(graph);
};
mxLayoutManager.prototype = new mxEventSource();
mxLayoutManager.prototype.constructor = mxLayoutManager;
mxLayoutManager.prototype.graph = null;
mxLayoutManager.prototype.bubbling = true;
mxLayoutManager.prototype.enabled = true;
mxLayoutManager.prototype.undoHandler = null;
mxLayoutManager.prototype.moveHandler = null;
mxLayoutManager.prototype.resizeHandler = null;
mxLayoutManager.prototype.isEnabled = function() {
  return this.enabled;
};
mxLayoutManager.prototype.setEnabled = function(enabled) {
  this.enabled = enabled;
};
mxLayoutManager.prototype.isBubbling = function() {
  return this.bubbling;
};
mxLayoutManager.prototype.setBubbling = function(value) {
  this.bubbling = value;
};
mxLayoutManager.prototype.getGraph = function() {
  return this.graph;
};
mxLayoutManager.prototype.setGraph = function(graph) {
  if (this.graph != null) {
    const oldModel = this.graph.getModel();
    oldModel.removeListener(this.undoHandler);
    this.graph.removeListener(this.moveHandler);
    this.graph.removeListener(this.resizeHandler);
  }
  this.graph = graph;
  if (this.graph != null) {
    const model = this.graph.getModel();
    model.addListener(mxEvent2.BEFORE_UNDO, this.undoHandler);
    this.graph.addListener(mxEvent2.MOVE_CELLS, this.moveHandler);
    this.graph.addListener(mxEvent2.RESIZE_CELLS, this.resizeHandler);
  }
};
mxLayoutManager.prototype.hasLayout = function(cell2) {
  return this.getLayout(cell2, mxEvent2.LAYOUT_CELLS);
};
mxLayoutManager.prototype.getLayout = function(cell2, eventName) {
  return null;
};
mxLayoutManager.prototype.beforeUndo = function(undoableEdit) {
  this.executeLayoutForCells(this.getCellsForChanges(undoableEdit.changes));
};
mxLayoutManager.prototype.cellsMoved = function(cells, evt) {
  if (cells != null && evt != null) {
    const point = convertPoint(this.getGraph().container, mxEvent2.getClientX(evt), mxEvent2.getClientY(evt));
    const model = this.getGraph().getModel();
    for (let i = 0; i < cells.length; i++) {
      const layout = this.getLayout(model.getParent(cells[i]), mxEvent2.MOVE_CELLS);
      if (layout != null) {
        layout.moveCell(cells[i], point.x, point.y);
      }
    }
  }
};
mxLayoutManager.prototype.cellsResized = function(cells, bounds, prev) {
  if (cells != null && bounds != null) {
    const model = this.getGraph().getModel();
    for (let i = 0; i < cells.length; i++) {
      const layout = this.getLayout(model.getParent(cells[i]), mxEvent2.RESIZE_CELLS);
      if (layout != null) {
        layout.resizeCell(cells[i], bounds[i], prev[i]);
      }
    }
  }
};
mxLayoutManager.prototype.getCellsForChanges = function(changes) {
  let result2 = [];
  for (let i = 0; i < changes.length; i++) {
    const change = changes[i];
    if (change instanceof mxRootChange) {
      return [];
    } else {
      result2 = result2.concat(this.getCellsForChange(change));
    }
  }
  return result2;
};
mxLayoutManager.prototype.getCellsForChange = function(change) {
  if (change instanceof mxChildChange2) {
    return this.addCellsWithLayout(change.child, this.addCellsWithLayout(change.previous));
  } else if (change instanceof mxTerminalChange || change instanceof mxGeometryChange) {
    return this.addCellsWithLayout(change.cell);
  } else if (change instanceof mxVisibleChange || change instanceof mxStyleChange) {
    return this.addCellsWithLayout(change.cell);
  }
  return [];
};
mxLayoutManager.prototype.addCellsWithLayout = function(cell2, result2) {
  return this.addDescendantsWithLayout(cell2, this.addAncestorsWithLayout(cell2, result2));
};
mxLayoutManager.prototype.addAncestorsWithLayout = function(cell2, result2) {
  result2 = result2 != null ? result2 : [];
  if (cell2 != null) {
    const layoutExists = this.hasLayout(cell2);
    if (layoutExists != null) {
      result2.push(cell2);
    }
    if (this.isBubbling()) {
      const model = this.getGraph().getModel();
      this.addAncestorsWithLayout(model.getParent(cell2), result2);
    }
  }
  return result2;
};
mxLayoutManager.prototype.addDescendantsWithLayout = function(cell2, result2) {
  result2 = result2 != null ? result2 : [];
  if (cell2 != null && this.hasLayout(cell2)) {
    const model = this.getGraph().getModel();
    for (let i = 0; i < model.getChildCount(cell2); i++) {
      const child = model.getChildAt(cell2, i);
      if (this.hasLayout(child)) {
        result2.push(child);
        this.addDescendantsWithLayout(child, result2);
      }
    }
  }
  return result2;
};
mxLayoutManager.prototype.executeLayoutForCells = function(cells) {
  const sorted = sortCells(cells, false);
  this.layoutCells(sorted, true);
  this.layoutCells(sorted.reverse(), false);
};
mxLayoutManager.prototype.layoutCells = function(cells, bubble) {
  if (cells.length > 0) {
    const model = this.getGraph().getModel();
    model.beginUpdate();
    try {
      let last = null;
      for (let i = 0; i < cells.length; i++) {
        if (cells[i] != model.getRoot() && cells[i] != last) {
          this.executeLayout(cells[i], bubble);
          last = cells[i];
        }
      }
      this.fireEvent(new mxEventObject2(mxEvent2.LAYOUT_CELLS, "cells", cells));
    } finally {
      model.endUpdate();
    }
  }
};
mxLayoutManager.prototype.executeLayout = function(cell2, bubble) {
  const layout = this.getLayout(cell2, bubble ? mxEvent2.BEGIN_UPDATE : mxEvent2.END_UPDATE);
  if (layout != null) {
    layout.execute(cell2);
  }
};
mxLayoutManager.prototype.destroy = function() {
  this.setGraph(null);
};

// js/graph/mxGraphLayout.js
function mxGraphLayout(graph) {
  this.graph = graph;
}
mxGraphLayout.prototype.graph = null;
mxGraphLayout.prototype.useBoundingBox = true;
mxGraphLayout.prototype.parent = null;
mxGraphLayout.prototype.moveCell = function(cell2, x, y) {
};
mxGraphLayout.prototype.resizeCell = function(cell2, bounds) {
};
mxGraphLayout.prototype.execute = function(parent2) {
};
mxGraphLayout.prototype.getGraph = function() {
  return this.graph;
};
mxGraphLayout.prototype.getConstraint = function(key, cell2, edge, source) {
  return this.graph.getCurrentCellStyle(cell2)[key];
};
mxGraphLayout.traverse = function(vertex, directed, func, edge, visited) {
  if (func != null && vertex != null) {
    directed = directed != null ? directed : true;
    visited = visited || new mxDictionary();
    if (!visited.get(vertex)) {
      visited.put(vertex, true);
      const result2 = func(vertex, edge);
      if (result2 == null || result2) {
        const edgeCount = this.graph.model.getEdgeCount(vertex);
        if (edgeCount > 0) {
          for (let i = 0; i < edgeCount; i++) {
            const e = this.graph.model.getEdgeAt(vertex, i);
            const isSource = this.graph.model.getTerminal(e, true) == vertex;
            if (!directed || isSource) {
              const next = this.graph.view.getVisibleTerminal(e, !isSource);
              this.traverse(next, directed, func, e, visited);
            }
          }
        }
      }
    }
  }
};
mxGraphLayout.prototype.isAncestor = function(parent2, child, traverseAncestors) {
  if (!traverseAncestors) {
    return this.graph.model.getParent(child) == parent2;
  }
  if (child == parent2) {
    return false;
  }
  while (child != null && child != parent2) {
    child = this.graph.model.getParent(child);
  }
  return child == parent2;
};
mxGraphLayout.prototype.isVertexMovable = function(cell2) {
  return this.graph.isCellMovable(cell2);
};
mxGraphLayout.prototype.isVertexIgnored = function(vertex) {
  return !this.graph.getModel().isVertex(vertex) || !this.graph.isCellVisible(vertex);
};
mxGraphLayout.prototype.isEdgeIgnored = function(edge) {
  const model = this.graph.getModel();
  return !model.isEdge(edge) || !this.graph.isCellVisible(edge) || model.getTerminal(edge, true) == null || model.getTerminal(edge, false) == null;
};
mxGraphLayout.prototype.setEdgeStyleEnabled = function(edge, value) {
  this.graph.setCellStyles(mxConstants2.STYLE_NOEDGESTYLE, value ? "0" : "1", [edge]);
};
mxGraphLayout.prototype.setOrthogonalEdge = function(edge, value) {
  this.graph.setCellStyles(mxConstants2.STYLE_ORTHOGONAL, value ? "1" : "0", [edge]);
};
mxGraphLayout.prototype.getParentOffset = function(parent2) {
  const result2 = new mxPoint2();
  if (parent2 != null && parent2 != this.parent) {
    const model = this.graph.getModel();
    if (model.isAncestor(this.parent, parent2)) {
      let parentGeo = model.getGeometry(parent2);
      while (parent2 != this.parent) {
        result2.x = result2.x + parentGeo.x;
        result2.y = result2.y + parentGeo.y;
        parent2 = model.getParent(parent2);
        ;
        parentGeo = model.getGeometry(parent2);
      }
    }
  }
  return result2;
};
mxGraphLayout.prototype.setEdgePoints = function(edge, points) {
  if (edge != null) {
    const model = this.graph.model;
    let geometry = model.getGeometry(edge);
    if (geometry == null) {
      geometry = new mxGeometry();
      geometry.setRelative(true);
    } else {
      geometry = geometry.clone();
    }
    if (this.parent != null && points != null) {
      const parent2 = model.getParent(edge);
      const parentOffset = this.getParentOffset(parent2);
      for (let i = 0; i < points.length; i++) {
        points[i].x = points[i].x - parentOffset.x;
        points[i].y = points[i].y - parentOffset.y;
      }
    }
    geometry.points = points;
    model.setGeometry(edge, geometry);
  }
};
mxGraphLayout.prototype.setVertexLocation = function(cell2, x, y) {
  const model = this.graph.getModel();
  let geometry = model.getGeometry(cell2);
  let result2 = null;
  if (geometry != null) {
    result2 = new mxRectangle(x, y, geometry.width, geometry.height);
    if (this.useBoundingBox) {
      const state2 = this.graph.getView().getState(cell2);
      if (state2 != null && state2.text != null && state2.text.boundingBox != null) {
        const scale = this.graph.getView().scale;
        const box = state2.text.boundingBox;
        if (state2.text.boundingBox.x < state2.x) {
          x += (state2.x - box.x) / scale;
          result2.width = box.width;
        }
        if (state2.text.boundingBox.y < state2.y) {
          y += (state2.y - box.y) / scale;
          result2.height = box.height;
        }
      }
    }
    if (this.parent != null) {
      const parent2 = model.getParent(cell2);
      if (parent2 != null && parent2 != this.parent) {
        const parentOffset = this.getParentOffset(parent2);
        x = x - parentOffset.x;
        y = y - parentOffset.y;
      }
    }
    if (geometry.x != x || geometry.y != y) {
      geometry = geometry.clone();
      geometry.x = x;
      geometry.y = y;
      model.setGeometry(cell2, geometry);
    }
  }
  return result2;
};
mxGraphLayout.prototype.getVertexBounds = function(cell2) {
  let geo = this.graph.getModel().getGeometry(cell2);
  if (this.useBoundingBox) {
    const state2 = this.graph.getView().getState(cell2);
    if (state2 != null && state2.text != null && state2.text.boundingBox != null) {
      const scale = this.graph.getView().scale;
      const tmp = state2.text.boundingBox;
      const dx0 = Math.max(state2.x - tmp.x, 0) / scale;
      const dy0 = Math.max(state2.y - tmp.y, 0) / scale;
      const dx1 = Math.max(tmp.x + tmp.width - (state2.x + state2.width), 0) / scale;
      const dy1 = Math.max(tmp.y + tmp.height - (state2.y + state2.height), 0) / scale;
      geo = new mxRectangle(geo.x - dx0, geo.y - dy0, geo.width + dx0 + dx1, geo.height + dy0 + dy1);
    }
  }
  if (this.parent != null) {
    const parent2 = this.graph.getModel().getParent(cell2);
    geo = geo.clone();
    if (parent2 != null && parent2 != this.parent) {
      const parentOffset = this.getParentOffset(parent2);
      geo.x = geo.x + parentOffset.x;
      geo.y = geo.y + parentOffset.y;
    }
  }
  return new mxRectangle(geo.x, geo.y, geo.width, geo.height);
};
mxGraphLayout.prototype.arrangeGroups = function(cells, border, topBorder, rightBorder, bottomBorder, leftBorder) {
  return this.graph.updateGroupBounds(cells, border, true, topBorder, rightBorder, bottomBorder, leftBorder);
};

// js/graph/mxStackLayout.js
function mxStackLayout(graph, horizontal, spacing, x0, y0, border) {
  mxGraphLayout.call(this, graph);
  this.horizontal = horizontal != null ? horizontal : true;
  this.spacing = spacing != null ? spacing : 0;
  this.x0 = x0 != null ? x0 : 0;
  this.y0 = y0 != null ? y0 : 0;
  this.border = border != null ? border : 0;
}
mxStackLayout.prototype = new mxGraphLayout();
mxStackLayout.prototype.constructor = mxStackLayout;
mxStackLayout.prototype.horizontal = null;
mxStackLayout.prototype.spacing = null;
mxStackLayout.prototype.x0 = null;
mxStackLayout.prototype.y0 = null;
mxStackLayout.prototype.border = 0;
mxStackLayout.prototype.marginTop = 0;
mxStackLayout.prototype.marginLeft = 0;
mxStackLayout.prototype.marginRight = 0;
mxStackLayout.prototype.marginBottom = 0;
mxStackLayout.prototype.keepFirstLocation = false;
mxStackLayout.prototype.fill = false;
mxStackLayout.prototype.resizeParent = false;
mxStackLayout.prototype.resizeParentMax = false;
mxStackLayout.prototype.resizeLast = false;
mxStackLayout.prototype.wrap = null;
mxStackLayout.prototype.borderCollapse = true;
mxStackLayout.prototype.allowGaps = false;
mxStackLayout.prototype.gridSize = 0;
mxStackLayout.prototype.isHorizontal = function() {
  return this.horizontal;
};
mxStackLayout.prototype.moveCell = function(cell2, x, y) {
  const model = this.graph.getModel();
  const parent2 = model.getParent(cell2);
  const horizontal = this.isHorizontal();
  if (cell2 != null && parent2 != null) {
    let i = 0;
    let last = 0;
    const childCount = model.getChildCount(parent2);
    let value = horizontal ? x : y;
    const pstate = this.graph.getView().getState(parent2);
    if (pstate != null) {
      value -= horizontal ? pstate.x : pstate.y;
    }
    value /= this.graph.view.scale;
    for (i = 0; i < childCount; i++) {
      const child = model.getChildAt(parent2, i);
      if (child != cell2) {
        const bounds = model.getGeometry(child);
        if (bounds != null) {
          const tmp = horizontal ? bounds.x + bounds.width / 2 : bounds.y + bounds.height / 2;
          if (last <= value && tmp > value) {
            break;
          }
          last = tmp;
        }
      }
    }
    let idx = parent2.getIndex(cell2);
    idx = Math.max(0, i - (i > idx ? 1 : 0));
    model.add(parent2, cell2, idx);
  }
};
mxStackLayout.prototype.getParentSize = function(parent2) {
  const model = this.graph.getModel();
  let pgeo = model.getGeometry(parent2);
  if (this.graph.container != null && (pgeo == null && model.isLayer(parent2) || parent2 == this.graph.getView().currentRoot)) {
    const width = this.graph.container.offsetWidth - 1;
    const height = this.graph.container.offsetHeight - 1;
    pgeo = new mxRectangle(0, 0, width, height);
  }
  return pgeo;
};
mxStackLayout.prototype.getLayoutCells = function(parent2) {
  const model = this.graph.getModel();
  const childCount = model.getChildCount(parent2);
  const cells = [];
  for (let i = 0; i < childCount; i++) {
    const child = model.getChildAt(parent2, i);
    if (!this.isVertexIgnored(child) && this.isVertexMovable(child)) {
      cells.push(child);
    }
  }
  if (this.allowGaps) {
    cells.sort(bind(this, function(c1, c2) {
      const geo1 = this.graph.getCellGeometry(c1);
      const geo2 = this.graph.getCellGeometry(c2);
      return this.horizontal ? geo1.x == geo2.x ? 0 : geo1.x > geo2.x > 0 ? 1 : -1 : geo1.y == geo2.y ? 0 : geo1.y > geo2.y > 0 ? 1 : -1;
    }));
  }
  return cells;
};
mxStackLayout.prototype.snap = function(value) {
  if (this.gridSize != null && this.gridSize > 0) {
    value = Math.max(value, this.gridSize);
    if (value / this.gridSize > 1) {
      const mod2 = value % this.gridSize;
      value += mod2 > this.gridSize / 2 ? this.gridSize - mod2 : -mod2;
    }
  }
  return value;
};
mxStackLayout.prototype.execute = function(parent2) {
  if (parent2 != null) {
    const pgeo = this.getParentSize(parent2);
    const horizontal = this.isHorizontal();
    const model = this.graph.getModel();
    let fillValue = null;
    if (pgeo != null) {
      fillValue = horizontal ? pgeo.height - this.marginTop - this.marginBottom : pgeo.width - this.marginLeft - this.marginRight;
    }
    fillValue -= 2 * this.border;
    let x0 = this.x0 + this.border + this.marginLeft;
    let y0 = this.y0 + this.border + this.marginTop;
    if (this.graph.isSwimlane(parent2)) {
      const style = this.graph.getCellStyle(parent2);
      let start = getNumber(style, mxConstants2.STYLE_STARTSIZE, mxConstants2.DEFAULT_STARTSIZE);
      const horz = getValue(style, mxConstants2.STYLE_HORIZONTAL, true) == 1;
      if (pgeo != null) {
        if (horz) {
          start = Math.min(start, pgeo.height);
        } else {
          start = Math.min(start, pgeo.width);
        }
      }
      if (horizontal == horz) {
        fillValue -= start;
      }
      if (horz) {
        y0 += start;
      } else {
        x0 += start;
      }
    }
    model.beginUpdate();
    try {
      let tmp = 0;
      let last = null;
      let lastValue = 0;
      let lastChild = null;
      const cells = this.getLayoutCells(parent2);
      for (let i = 0; i < cells.length; i++) {
        const child = cells[i];
        let geo = model.getGeometry(child);
        if (geo != null) {
          geo = geo.clone();
          if (this.wrap != null && last != null) {
            if (horizontal && last.x + last.width + geo.width + 2 * this.spacing > this.wrap || !horizontal && last.y + last.height + geo.height + 2 * this.spacing > this.wrap) {
              last = null;
              if (horizontal) {
                y0 += tmp + this.spacing;
              } else {
                x0 += tmp + this.spacing;
              }
              tmp = 0;
            }
          }
          tmp = Math.max(tmp, horizontal ? geo.height : geo.width);
          let sw = 0;
          if (!this.borderCollapse) {
            const childStyle = this.graph.getCellStyle(child);
            sw = getNumber(childStyle, mxConstants2.STYLE_STROKEWIDTH, 1);
          }
          if (last != null) {
            const temp2 = lastValue + this.spacing + Math.floor(sw / 2);
            if (horizontal) {
              geo.x = this.snap((this.allowGaps ? Math.max(temp2, geo.x) : temp2) - this.marginLeft) + this.marginLeft;
            } else {
              geo.y = this.snap((this.allowGaps ? Math.max(temp2, geo.y) : temp2) - this.marginTop) + this.marginTop;
            }
          } else if (!this.keepFirstLocation) {
            if (horizontal) {
              geo.x = this.allowGaps && geo.x > x0 ? Math.max(this.snap(geo.x - this.marginLeft) + this.marginLeft, x0) : x0;
            } else {
              geo.y = this.allowGaps && geo.y > y0 ? Math.max(this.snap(geo.y - this.marginTop) + this.marginTop, y0) : y0;
            }
          }
          if (horizontal) {
            geo.y = y0;
          } else {
            geo.x = x0;
          }
          if (this.fill && fillValue != null) {
            if (horizontal) {
              geo.height = fillValue;
            } else {
              geo.width = fillValue;
            }
          }
          if (horizontal) {
            geo.width = this.snap(geo.width);
          } else {
            geo.height = this.snap(geo.height);
          }
          this.setChildGeometry(child, geo);
          lastChild = child;
          last = geo;
          if (horizontal) {
            lastValue = last.x + last.width + Math.floor(sw / 2);
          } else {
            lastValue = last.y + last.height + Math.floor(sw / 2);
          }
        }
      }
      if (this.resizeParent && pgeo != null && last != null && !this.graph.isCellCollapsed(parent2)) {
        this.updateParentGeometry(parent2, pgeo, last);
      } else if (this.resizeLast && pgeo != null && last != null && lastChild != null) {
        if (horizontal) {
          last.width = pgeo.width - last.x - this.spacing - this.marginRight - this.marginLeft;
        } else {
          last.height = pgeo.height - last.y - this.spacing - this.marginBottom;
        }
        this.setChildGeometry(lastChild, last);
      }
    } finally {
      model.endUpdate();
    }
  }
};
mxStackLayout.prototype.setChildGeometry = function(child, geo) {
  const geo2 = this.graph.getCellGeometry(child);
  if (geo2 == null || geo.x != geo2.x || geo.y != geo2.y || geo.width != geo2.width || geo.height != geo2.height) {
    this.graph.getModel().setGeometry(child, geo);
  }
};
mxStackLayout.prototype.updateParentGeometry = function(parent2, pgeo, last) {
  const horizontal = this.isHorizontal();
  const model = this.graph.getModel();
  const pgeo2 = pgeo.clone();
  if (horizontal) {
    const tmp = last.x + last.width + this.marginRight + this.border;
    if (this.resizeParentMax) {
      pgeo2.width = Math.max(pgeo2.width, tmp);
    } else {
      pgeo2.width = tmp;
    }
  } else {
    const tmp = last.y + last.height + this.marginBottom + this.border;
    if (this.resizeParentMax) {
      pgeo2.height = Math.max(pgeo2.height, tmp);
    } else {
      pgeo2.height = tmp;
    }
  }
  if (pgeo.x != pgeo2.x || pgeo.y != pgeo2.y || pgeo.width != pgeo2.width || pgeo.height != pgeo2.height) {
    model.setGeometry(parent2, pgeo2);
  }
};

// js/graph/WeightedCellSorter.js
function WeightedCellSorter(cell2, weightedValue) {
  this.cell = cell2;
  this.weightedValue = weightedValue;
}
WeightedCellSorter.prototype.weightedValue = 0;
WeightedCellSorter.prototype.nudge = false;
WeightedCellSorter.prototype.visited = false;
WeightedCellSorter.prototype.rankIndex = null;
WeightedCellSorter.prototype.cell = null;
WeightedCellSorter.prototype.compare = function(a, b) {
  if (a != null && b != null) {
    if (b.weightedValue > a.weightedValue) {
      return -1;
    } else if (b.weightedValue < a.weightedValue) {
      return 1;
    } else {
      return b.nudge ? -1 : 1;
    }
  } else {
    return 0;
  }
};

// js/graph/mxCompactTreeLayout.js
function mxCompactTreeLayout2(graph, horizontal, invert) {
  mxGraphLayout.call(this, graph);
  this.horizontal = horizontal != null ? horizontal : true;
  this.invert = invert != null ? invert : false;
}
mxCompactTreeLayout2.prototype = Object.create(mxGraphLayout.prototype);
mxCompactTreeLayout2.prototype.constructor = mxCompactTreeLayout2;
mxCompactTreeLayout2.prototype.horizontal = null;
mxCompactTreeLayout2.prototype.invert = null;
mxCompactTreeLayout2.prototype.resizeParent = true;
mxCompactTreeLayout2.prototype.maintainParentLocation = false;
mxCompactTreeLayout2.prototype.groupPadding = 10;
mxCompactTreeLayout2.prototype.groupPaddingTop = 0;
mxCompactTreeLayout2.prototype.groupPaddingRight = 0;
mxCompactTreeLayout2.prototype.groupPaddingBottom = 0;
mxCompactTreeLayout2.prototype.groupPaddingLeft = 0;
mxCompactTreeLayout2.prototype.parentsChanged = null;
mxCompactTreeLayout2.prototype.moveTree = false;
mxCompactTreeLayout2.prototype.visited = null;
mxCompactTreeLayout2.prototype.levelDistance = 10;
mxCompactTreeLayout2.prototype.nodeDistance = 20;
mxCompactTreeLayout2.prototype.resetEdges = true;
mxCompactTreeLayout2.prototype.prefHozEdgeSep = 5;
mxCompactTreeLayout2.prototype.prefVertEdgeOff = 4;
mxCompactTreeLayout2.prototype.minEdgeJetty = 8;
mxCompactTreeLayout2.prototype.channelBuffer = 4;
mxCompactTreeLayout2.prototype.edgeRouting = true;
mxCompactTreeLayout2.prototype.sortEdges = false;
mxCompactTreeLayout2.prototype.alignRanks = false;
mxCompactTreeLayout2.prototype.maxRankHeight = null;
mxCompactTreeLayout2.prototype.root = null;
mxCompactTreeLayout2.prototype.node = null;
mxCompactTreeLayout2.prototype.isVertexIgnored = function(vertex) {
  return mxGraphLayout.prototype.isVertexIgnored.apply(this, arguments) || this.graph.getConnections(vertex).length == 0;
};
mxCompactTreeLayout2.prototype.isHorizontal = function() {
  return this.horizontal;
};
mxCompactTreeLayout2.prototype.execute = function(parent2, root) {
  this.parent = parent2;
  const model = this.graph.getModel();
  if (root == null) {
    if (this.graph.getEdges(parent2, model.getParent(parent2), this.invert, !this.invert, false).length > 0) {
      this.root = parent2;
    } else {
      const roots = this.graph.findTreeRoots(parent2, true, this.invert);
      if (roots.length > 0) {
        for (let i = 0; i < roots.length; i++) {
          if (!this.isVertexIgnored(roots[i]) && this.graph.getEdges(roots[i], null, this.invert, !this.invert, false).length > 0) {
            this.root = roots[i];
            break;
          }
        }
      }
    }
  } else {
    this.root = root;
  }
  if (this.root != null) {
    if (this.resizeParent) {
      this.parentsChanged = new Object();
    } else {
      this.parentsChanged = null;
    }
    this.parentX = null;
    this.parentY = null;
    if (parent2 != this.root && model.isVertex(parent2) != null && this.maintainParentLocation) {
      let geo = this.graph.getCellGeometry(parent2);
      if (geo != null) {
        this.parentX = geo.x;
        this.parentY = geo.y;
      }
    }
    model.beginUpdate();
    try {
      this.visited = new Object();
      this.node = this.dfs(this.root, parent2);
      if (this.alignRanks) {
        this.maxRankHeight = [];
        this.findRankHeights(this.node, 0);
        this.setCellHeights(this.node, 0);
      }
      if (this.node != null) {
        this.layout(this.node);
        let x0 = this.graph.gridSize;
        let y0 = x0;
        if (!this.moveTree) {
          const g = this.getVertexBounds(this.root);
          if (g != null) {
            x0 = g.x;
            y0 = g.y;
          }
        }
        let bounds = null;
        if (this.isHorizontal()) {
          bounds = this.horizontalLayout(this.node, x0, y0);
        } else {
          bounds = this.verticalLayout(this.node, null, x0, y0);
        }
        if (bounds != null) {
          let dx = 0;
          let dy = 0;
          if (bounds.x < 0) {
            dx = Math.abs(x0 - bounds.x);
          }
          if (bounds.y < 0) {
            dy = Math.abs(y0 - bounds.y);
          }
          if (dx != 0 || dy != 0) {
            this.moveNode(this.node, dx, dy);
          }
          if (this.resizeParent) {
            this.adjustParents();
          }
          if (this.edgeRouting) {
            this.localEdgeProcessing(this.node);
          }
        }
        if (this.parentX != null && this.parentY != null) {
          let geo = this.graph.getCellGeometry(parent2);
          if (geo != null) {
            geo = geo.clone();
            geo.x = this.parentX;
            geo.y = this.parentY;
            model.setGeometry(parent2, geo);
          }
        }
      }
    } finally {
      model.endUpdate();
    }
  }
};
mxCompactTreeLayout2.prototype.moveNode = function(node, dx, dy) {
  node.x += dx;
  node.y += dy;
  this.apply(node);
  let child = node.child;
  while (child != null) {
    this.moveNode(child, dx, dy);
    child = child.next;
  }
};
mxCompactTreeLayout2.prototype.sortOutgoingEdges = function(source, edges) {
  const lookup = new mxDictionary();
  edges.sort(function(e1, e2) {
    const end1 = e1.getTerminal(e1.getTerminal(false) == source);
    let p1 = lookup.get(end1);
    if (p1 == null) {
      p1 = mxCellPath_default.create(end1).split(mxCellPath_default.PATH_SEPARATOR);
      lookup.put(end1, p1);
    }
    const end2 = e2.getTerminal(e2.getTerminal(false) == source);
    let p2 = lookup.get(end2);
    if (p2 == null) {
      p2 = mxCellPath_default.create(end2).split(mxCellPath_default.PATH_SEPARATOR);
      lookup.put(end2, p2);
    }
    return mxCellPath_default.compare(p1, p2);
  });
};
mxCompactTreeLayout2.prototype.findRankHeights = function(node, rank) {
  if (this.maxRankHeight[rank] == null || this.maxRankHeight[rank] < node.height) {
    this.maxRankHeight[rank] = node.height;
  }
  let child = node.child;
  while (child != null) {
    this.findRankHeights(child, rank + 1);
    child = child.next;
  }
};
mxCompactTreeLayout2.prototype.setCellHeights = function(node, rank) {
  if (this.maxRankHeight[rank] != null && this.maxRankHeight[rank] > node.height) {
    node.height = this.maxRankHeight[rank];
  }
  let child = node.child;
  while (child != null) {
    this.setCellHeights(child, rank + 1);
    child = child.next;
  }
};
mxCompactTreeLayout2.prototype.dfs = function(cell2, parent2) {
  const id = mxCellPath_default.create(cell2);
  let node = null;
  if (cell2 != null && this.visited[id] == null && !this.isVertexIgnored(cell2)) {
    this.visited[id] = cell2;
    node = this.createNode(cell2);
    const model = this.graph.getModel();
    let prev = null;
    const out = this.graph.getEdges(cell2, parent2, this.invert, !this.invert, false, true);
    const view = this.graph.getView();
    if (this.sortEdges) {
      this.sortOutgoingEdges(cell2, out);
    }
    for (let i = 0; i < out.length; i++) {
      const edge = out[i];
      if (!this.isEdgeIgnored(edge)) {
        if (this.resetEdges) {
          this.setEdgePoints(edge, null);
        }
        if (this.edgeRouting) {
          this.setEdgeStyleEnabled(edge, false);
          this.setEdgePoints(edge, null);
        }
        const state2 = view.getState(edge);
        const target = state2 != null ? state2.getVisibleTerminal(this.invert) : view.getVisibleTerminal(edge, this.invert);
        const tmp = this.dfs(target, parent2);
        if (tmp != null && model.getGeometry(target) != null) {
          if (prev == null) {
            node.child = tmp;
          } else {
            prev.next = tmp;
          }
          prev = tmp;
        }
      }
    }
  }
  return node;
};
mxCompactTreeLayout2.prototype.layout = function(node) {
  if (node != null) {
    let child = node.child;
    while (child != null) {
      this.layout(child);
      child = child.next;
    }
    if (node.child != null) {
      this.attachParent(node, this.join(node));
    } else {
      this.layoutLeaf(node);
    }
  }
};
mxCompactTreeLayout2.prototype.horizontalLayout = function(node, x0, y0, bounds) {
  node.x += x0 + node.offsetX;
  node.y += y0 + node.offsetY;
  bounds = this.apply(node, bounds);
  const child = node.child;
  if (child != null) {
    bounds = this.horizontalLayout(child, node.x, node.y, bounds);
    let siblingOffset = node.y + child.offsetY;
    let s = child.next;
    while (s != null) {
      bounds = this.horizontalLayout(s, node.x + child.offsetX, siblingOffset, bounds);
      siblingOffset += s.offsetY;
      s = s.next;
    }
  }
  return bounds;
};
mxCompactTreeLayout2.prototype.verticalLayout = function(node, parent2, x0, y0, bounds) {
  node.x += x0 + node.offsetY;
  node.y += y0 + node.offsetX;
  bounds = this.apply(node, bounds);
  const child = node.child;
  if (child != null) {
    bounds = this.verticalLayout(child, node, node.x, node.y, bounds);
    let siblingOffset = node.x + child.offsetY;
    let s = child.next;
    while (s != null) {
      bounds = this.verticalLayout(s, node, siblingOffset, node.y + child.offsetX, bounds);
      siblingOffset += s.offsetY;
      s = s.next;
    }
  }
  return bounds;
};
mxCompactTreeLayout2.prototype.attachParent = function(node, height) {
  const x = this.nodeDistance + this.levelDistance;
  const y2 = (height - node.width) / 2 - this.nodeDistance;
  const y1 = y2 + node.width + 2 * this.nodeDistance - height;
  node.child.offsetX = x + node.height;
  node.child.offsetY = y1;
  node.contour.upperHead = this.createLine(node.height, 0, this.createLine(x, y1, node.contour.upperHead));
  node.contour.lowerHead = this.createLine(node.height, 0, this.createLine(x, y2, node.contour.lowerHead));
};
mxCompactTreeLayout2.prototype.layoutLeaf = function(node) {
  const dist = 2 * this.nodeDistance;
  node.contour.upperTail = this.createLine(node.height + dist, 0);
  node.contour.upperHead = node.contour.upperTail;
  node.contour.lowerTail = this.createLine(0, -node.width - dist);
  node.contour.lowerHead = this.createLine(node.height + dist, 0, node.contour.lowerTail);
};
mxCompactTreeLayout2.prototype.join = function(node) {
  const dist = 2 * this.nodeDistance;
  let child = node.child;
  node.contour = child.contour;
  let h2 = child.width + dist;
  let sum = h2;
  child = child.next;
  while (child != null) {
    const d = this.merge(node.contour, child.contour);
    child.offsetY = d + h2;
    child.offsetX = 0;
    h2 = child.width + dist;
    sum += d + h2;
    child = child.next;
  }
  return sum;
};
mxCompactTreeLayout2.prototype.merge = function(p1, p2) {
  let x = 0;
  let y = 0;
  let total = 0;
  let upper = p1.lowerHead;
  let lower = p2.upperHead;
  while (lower != null && upper != null) {
    const d = this.offset(x, y, lower.dx, lower.dy, upper.dx, upper.dy);
    y += d;
    total += d;
    if (x + lower.dx <= upper.dx) {
      x += lower.dx;
      y += lower.dy;
      lower = lower.next;
    } else {
      x -= upper.dx;
      y -= upper.dy;
      upper = upper.next;
    }
  }
  if (lower != null) {
    let b = this.bridge(p1.upperTail, 0, 0, lower, x, y);
    p1.upperTail = b.next != null ? p2.upperTail : b;
    p1.lowerTail = p2.lowerTail;
  } else {
    let b = this.bridge(p2.lowerTail, x, y, upper, 0, 0);
    if (b.next == null) {
      p1.lowerTail = b;
    }
  }
  p1.lowerHead = p2.lowerHead;
  return total;
};
mxCompactTreeLayout2.prototype.offset = function(p1, p2, a1, a2, b1, b2) {
  let d = 0;
  if (b1 <= p1 || p1 + a1 <= 0) {
    return 0;
  }
  const t = b1 * a2 - a1 * b2;
  if (t > 0) {
    if (p1 < 0) {
      let s = p1 * a2;
      d = s / a1 - p2;
    } else if (p1 > 0) {
      let s = p1 * b2;
      d = s / b1 - p2;
    } else {
      d = -p2;
    }
  } else if (b1 < p1 + a1) {
    let s = (b1 - p1) * a2;
    d = b2 - (p2 + s / a1);
  } else if (b1 > p1 + a1) {
    let s = (a1 + p1) * b2;
    d = s / b1 - (p2 + a2);
  } else {
    d = b2 - (p2 + a2);
  }
  if (d > 0) {
    return d;
  } else {
    return 0;
  }
};
mxCompactTreeLayout2.prototype.bridge = function(line1, x1, y1, line2, x2, y2) {
  const dx = x2 + line2.dx - x1;
  let dy = 0;
  let s = 0;
  if (line2.dx == 0) {
    dy = line2.dy;
  } else {
    s = dx * line2.dy;
    dy = s / line2.dx;
  }
  const r = this.createLine(dx, dy, line2.next);
  line1.next = this.createLine(0, y2 + line2.dy - dy - y1, r);
  return r;
};
mxCompactTreeLayout2.prototype.createNode = function(cell2) {
  const node = new Object();
  node.cell = cell2;
  node.x = 0;
  node.y = 0;
  node.width = 0;
  node.height = 0;
  const geo = this.getVertexBounds(cell2);
  if (geo != null) {
    if (this.isHorizontal()) {
      node.width = geo.height;
      node.height = geo.width;
    } else {
      node.width = geo.width;
      node.height = geo.height;
    }
  }
  node.offsetX = 0;
  node.offsetY = 0;
  node.contour = new Object();
  return node;
};
mxCompactTreeLayout2.prototype.apply = function(node, bounds) {
  const model = this.graph.getModel();
  const cell2 = node.cell;
  let g = model.getGeometry(cell2);
  if (cell2 != null && g != null) {
    if (this.isVertexMovable(cell2)) {
      g = this.setVertexLocation(cell2, node.x, node.y);
      if (this.resizeParent) {
        const parent2 = model.getParent(cell2);
        const id = mxCellPath_default.create(parent2);
        if (this.parentsChanged[id] == null) {
          this.parentsChanged[id] = parent2;
        }
      }
    }
    if (bounds == null) {
      bounds = new mxRectangle(g.x, g.y, g.width, g.height);
    } else {
      bounds = new mxRectangle(Math.min(bounds.x, g.x), Math.min(bounds.y, g.y), Math.max(bounds.x + bounds.width, g.x + g.width), Math.max(bounds.y + bounds.height, g.y + g.height));
    }
  }
  return bounds;
};
mxCompactTreeLayout2.prototype.createLine = function(dx, dy, next) {
  const line = new Object();
  line.dx = dx;
  line.dy = dy;
  line.next = next;
  return line;
};
mxCompactTreeLayout2.prototype.adjustParents = function() {
  const tmp = [];
  for (const id in this.parentsChanged) {
    tmp.push(this.parentsChanged[id]);
  }
  this.arrangeGroups(sortCells(tmp, true), this.groupPadding, this.groupPaddingTop, this.groupPaddingRight, this.groupPaddingBottom, this.groupPaddingLeft);
};
mxCompactTreeLayout2.prototype.localEdgeProcessing = function(node) {
  this.processNodeOutgoing(node);
  let child = node.child;
  while (child != null) {
    this.localEdgeProcessing(child);
    child = child.next;
  }
};
mxCompactTreeLayout2.prototype.processNodeOutgoing = function(node) {
  let child = node.child;
  const parentCell = node.cell;
  let childCount = 0;
  const sortedCells = [];
  while (child != null) {
    childCount++;
    let sortingCriterion = child.x;
    if (this.horizontal) {
      sortingCriterion = child.y;
    }
    sortedCells.push(new WeightedCellSorter(child, sortingCriterion));
    child = child.next;
  }
  sortedCells.sort(WeightedCellSorter.prototype.compare);
  let availableWidth = node.width;
  const requiredWidth = (childCount + 1) * this.prefHozEdgeSep;
  if (availableWidth > requiredWidth + 2 * this.prefHozEdgeSep) {
    availableWidth -= 2 * this.prefHozEdgeSep;
  }
  let edgeSpacing = availableWidth / childCount;
  let currentXOffset = edgeSpacing / 2;
  if (availableWidth > requiredWidth + 2 * this.prefHozEdgeSep) {
    currentXOffset += this.prefHozEdgeSep;
  }
  let currentYOffset = this.minEdgeJetty - this.prefVertEdgeOff;
  let maxYOffset = 0;
  const parentBounds = this.getVertexBounds(parentCell);
  child = node.child;
  for (let j = 0; j < sortedCells.length; j++) {
    const childCell = sortedCells[j].cell.cell;
    const childBounds = this.getVertexBounds(childCell);
    const edges = this.graph.getEdgesBetween(parentCell, childCell, false);
    let newPoints = [];
    let x = 0;
    let y = 0;
    for (let i = 0; i < edges.length; i++) {
      if (this.horizontal) {
        x = parentBounds.x + parentBounds.width;
        y = parentBounds.y + currentXOffset;
        newPoints.push(new mxPoint2(x, y));
        x = parentBounds.x + parentBounds.width + currentYOffset;
        newPoints.push(new mxPoint2(x, y));
        y = childBounds.y + childBounds.height / 2;
        newPoints.push(new mxPoint2(x, y));
        this.setEdgePoints(edges[i], newPoints);
      } else {
        x = parentBounds.x + currentXOffset;
        y = parentBounds.y + parentBounds.height;
        newPoints.push(new mxPoint2(x, y));
        y = parentBounds.y + parentBounds.height + currentYOffset;
        newPoints.push(new mxPoint2(x, y));
        x = childBounds.x + childBounds.width / 2;
        newPoints.push(new mxPoint2(x, y));
        this.setEdgePoints(edges[i], newPoints);
      }
    }
    if (j < childCount / 2) {
      currentYOffset += this.prefVertEdgeOff;
    } else if (j > childCount / 2) {
      currentYOffset -= this.prefVertEdgeOff;
    }
    currentXOffset += edgeSpacing;
    maxYOffset = Math.max(maxYOffset, currentYOffset);
  }
};

// js/graph/mxHierarchicalLayout.js
var mxHierarchicalLayout2 = function(graph, orientation, deterministic) {
  mxGraphLayout.call(this, graph);
  this.orientation = orientation != null ? orientation : mxConstants2.DIRECTION_NORTH;
  this.deterministic = deterministic != null ? deterministic : true;
};
mxHierarchicalLayout2.prototype = Object.create(mxGraphLayout.prototype);
mxHierarchicalLayout2.prototype.constructor = mxHierarchicalLayout2;

// js/graph/mxCircleLayout.js
var mxCircleLayout2 = function(graph, radius) {
  mxGraphLayout.call(this, graph);
  this.radius = radius != null ? radius : 100;
};
mxCircleLayout2.prototype = new mxGraphLayout();
mxCircleLayout2.prototype.constructor = mxCircleLayout2;
mxCircleLayout2.prototype.radius = null;
mxCircleLayout2.prototype.moveCircle = false;
mxCircleLayout2.prototype.x0 = 0;
mxCircleLayout2.prototype.y0 = 0;
mxCircleLayout2.prototype.resetEdges = true;
mxCircleLayout2.prototype.disableEdgeStyle = true;
mxCircleLayout2.prototype.execute = function(parent2) {
  const model = this.graph.getModel();
  model.beginUpdate();
  try {
    let max = 0;
    let top = null;
    let left = null;
    const vertices = [];
    const childCount = model.getChildCount(parent2);
    for (let i = 0; i < childCount; i++) {
      const cell2 = model.getChildAt(parent2, i);
      if (!this.isVertexIgnored(cell2)) {
        vertices.push(cell2);
        const bounds = this.getVertexBounds(cell2);
        top = top == null ? bounds.y : Math.min(top, bounds.y);
        left = left == null ? bounds.x : Math.min(left, bounds.x);
        max = Math.max(max, Math.max(bounds.width, bounds.height));
      } else if (!this.isEdgeIgnored(cell2)) {
        if (this.resetEdges) {
          this.graph.resetEdge(cell2);
        }
        if (this.disableEdgeStyle) {
          this.setEdgeStyleEnabled(cell2, false);
        }
      }
    }
    const r = this.getRadius(vertices.length, max);
    if (this.moveCircle) {
      left = this.x0;
      top = this.y0;
    }
    this.circle(vertices, r, left, top);
  } finally {
    model.endUpdate();
  }
};
mxCircleLayout2.prototype.getRadius = function(count, max) {
  return Math.max(count * max / Math.PI, this.radius);
};
mxCircleLayout2.prototype.circle = function(vertices, r, left, top) {
  const vertexCount = vertices.length;
  const phi = 2 * Math.PI / vertexCount;
  for (let i = 0; i < vertexCount; i++) {
    if (this.isVertexMovable(vertices[i])) {
      this.setVertexLocation(vertices[i], Math.round(left + r + r * Math.sin(i * phi)), Math.round(top + r + r * Math.cos(i * phi)));
    }
  }
};

// js/graph/mxFastOrganicLayout.js
function mxFastOrganicLayout2(graph) {
  mxGraphLayout.call(this, graph);
}
mxFastOrganicLayout2.prototype = new mxGraphLayout();
mxFastOrganicLayout2.prototype.constructor = mxFastOrganicLayout2;
mxFastOrganicLayout2.prototype.useInputOrigin = true;
mxFastOrganicLayout2.prototype.resetEdges = true;
mxFastOrganicLayout2.prototype.disableEdgeStyle = true;
mxFastOrganicLayout2.prototype.forceConstant = 50;
mxFastOrganicLayout2.prototype.forceConstantSquared = 0;
mxFastOrganicLayout2.prototype.minDistanceLimit = 2;
mxFastOrganicLayout2.prototype.maxDistanceLimit = 500;
mxFastOrganicLayout2.prototype.minDistanceLimitSquared = 4;
mxFastOrganicLayout2.prototype.initialTemp = 200;
mxFastOrganicLayout2.prototype.temperature = 0;
mxFastOrganicLayout2.prototype.maxIterations = 0;
mxFastOrganicLayout2.prototype.iteration = 0;
mxFastOrganicLayout2.prototype.vertexArray;
mxFastOrganicLayout2.prototype.dispX;
mxFastOrganicLayout2.prototype.dispY;
mxFastOrganicLayout2.prototype.cellLocation;
mxFastOrganicLayout2.prototype.radius;
mxFastOrganicLayout2.prototype.radiusSquared;
mxFastOrganicLayout2.prototype.isMoveable;
mxFastOrganicLayout2.prototype.neighbours;
mxFastOrganicLayout2.prototype.indices;
mxFastOrganicLayout2.prototype.allowedToRun = true;
mxFastOrganicLayout2.prototype.isVertexIgnored = function(vertex) {
  return mxGraphLayout.prototype.isVertexIgnored.apply(this, arguments) || this.graph.getConnections(vertex).length == 0;
};
mxFastOrganicLayout2.prototype.execute = function(parent2) {
  const model = this.graph.getModel();
  this.vertexArray = [];
  const cells = this.graph.getChildVertices(parent2);
  for (let i = 0; i < cells.length; i++) {
    if (!this.isVertexIgnored(cells[i])) {
      this.vertexArray.push(cells[i]);
    }
  }
  const initialBounds = this.useInputOrigin ? this.graph.getBoundingBoxFromGeometry(this.vertexArray) : null;
  const n = this.vertexArray.length;
  this.indices = [];
  this.dispX = [];
  this.dispY = [];
  this.cellLocation = [];
  this.isMoveable = [];
  this.neighbours = [];
  this.radius = [];
  this.radiusSquared = [];
  if (this.forceConstant < 1e-3) {
    this.forceConstant = 1e-3;
  }
  this.forceConstantSquared = this.forceConstant * this.forceConstant;
  for (let i = 0; i < this.vertexArray.length; i++) {
    const vertex = this.vertexArray[i];
    this.cellLocation[i] = [];
    const id = mxObjectIdentity.get(vertex);
    this.indices[id] = i;
    const bounds = this.getVertexBounds(vertex);
    const width = bounds.width;
    const height = bounds.height;
    const x = bounds.x;
    const y = bounds.y;
    this.cellLocation[i][0] = x + width / 2;
    this.cellLocation[i][1] = y + height / 2;
    this.radius[i] = Math.min(width, height);
    this.radiusSquared[i] = this.radius[i] * this.radius[i];
  }
  model.beginUpdate();
  try {
    for (let i = 0; i < n; i++) {
      this.dispX[i] = 0;
      this.dispY[i] = 0;
      this.isMoveable[i] = this.isVertexMovable(this.vertexArray[i]);
      const edges = this.graph.getConnections(this.vertexArray[i], parent2);
      const cells2 = this.graph.getOpposites(edges, this.vertexArray[i]);
      this.neighbours[i] = [];
      for (let j = 0; j < cells2.length; j++) {
        if (this.resetEdges) {
          this.graph.resetEdge(edges[j]);
        }
        if (this.disableEdgeStyle) {
          this.setEdgeStyleEnabled(edges[j], false);
        }
        const id = mxObjectIdentity.get(cells2[j]);
        const index = this.indices[id];
        if (index != null) {
          this.neighbours[i][j] = index;
        } else {
          this.neighbours[i][j] = i;
        }
      }
    }
    this.temperature = this.initialTemp;
    if (this.maxIterations == 0) {
      this.maxIterations = 20 * Math.sqrt(n);
    }
    for (this.iteration = 0; this.iteration < this.maxIterations; this.iteration++) {
      if (!this.allowedToRun) {
        return;
      }
      this.calcRepulsion();
      this.calcAttraction();
      this.calcPositions();
      this.reduceTemperature();
    }
    let minx = null;
    let miny = null;
    for (let i = 0; i < this.vertexArray.length; i++) {
      const vertex = this.vertexArray[i];
      if (this.isVertexMovable(vertex)) {
        const bounds = this.getVertexBounds(vertex);
        if (bounds != null) {
          this.cellLocation[i][0] -= bounds.width / 2;
          this.cellLocation[i][1] -= bounds.height / 2;
          const x = this.graph.snap(Math.round(this.cellLocation[i][0]));
          const y = this.graph.snap(Math.round(this.cellLocation[i][1]));
          this.setVertexLocation(vertex, x, y);
          if (minx == null) {
            minx = x;
          } else {
            minx = Math.min(minx, x);
          }
          if (miny == null) {
            miny = y;
          } else {
            miny = Math.min(miny, y);
          }
        }
      }
    }
    let dx = -(minx || 0) + 1;
    let dy = -(miny || 0) + 1;
    if (initialBounds != null) {
      dx += initialBounds.x;
      dy += initialBounds.y;
    }
    this.graph.moveCells(this.vertexArray, dx, dy);
  } finally {
    model.endUpdate();
  }
};
mxFastOrganicLayout2.prototype.calcPositions = function() {
  for (let index = 0; index < this.vertexArray.length; index++) {
    if (this.isMoveable[index]) {
      let deltaLength = Math.sqrt(this.dispX[index] * this.dispX[index] + this.dispY[index] * this.dispY[index]);
      if (deltaLength < 1e-3) {
        deltaLength = 1e-3;
      }
      const newXDisp = this.dispX[index] / deltaLength * Math.min(deltaLength, this.temperature);
      const newYDisp = this.dispY[index] / deltaLength * Math.min(deltaLength, this.temperature);
      this.dispX[index] = 0;
      this.dispY[index] = 0;
      this.cellLocation[index][0] += newXDisp;
      this.cellLocation[index][1] += newYDisp;
    }
  }
};
mxFastOrganicLayout2.prototype.calcAttraction = function() {
  for (let i = 0; i < this.vertexArray.length; i++) {
    for (let k = 0; k < this.neighbours[i].length; k++) {
      const j = this.neighbours[i][k];
      if (i != j && this.isMoveable[i] && this.isMoveable[j]) {
        const xDelta = this.cellLocation[i][0] - this.cellLocation[j][0];
        const yDelta = this.cellLocation[i][1] - this.cellLocation[j][1];
        let deltaLengthSquared = xDelta * xDelta + yDelta * yDelta - this.radiusSquared[i] - this.radiusSquared[j];
        if (deltaLengthSquared < this.minDistanceLimitSquared) {
          deltaLengthSquared = this.minDistanceLimitSquared;
        }
        const deltaLength = Math.sqrt(deltaLengthSquared);
        const force = deltaLengthSquared / this.forceConstant;
        const displacementX = xDelta / deltaLength * force;
        const displacementY = yDelta / deltaLength * force;
        this.dispX[i] -= displacementX;
        this.dispY[i] -= displacementY;
        this.dispX[j] += displacementX;
        this.dispY[j] += displacementY;
      }
    }
  }
};
mxFastOrganicLayout2.prototype.calcRepulsion = function() {
  const vertexCount = this.vertexArray.length;
  for (let i = 0; i < vertexCount; i++) {
    for (let j = i; j < vertexCount; j++) {
      if (!this.allowedToRun) {
        return;
      }
      if (j != i && this.isMoveable[i] && this.isMoveable[j]) {
        let xDelta = this.cellLocation[i][0] - this.cellLocation[j][0];
        let yDelta = this.cellLocation[i][1] - this.cellLocation[j][1];
        if (xDelta == 0) {
          xDelta = 0.01 + Math.random();
        }
        if (yDelta == 0) {
          yDelta = 0.01 + Math.random();
        }
        const deltaLength = Math.sqrt(xDelta * xDelta + yDelta * yDelta);
        let deltaLengthWithRadius = deltaLength - this.radius[i] - this.radius[j];
        if (deltaLengthWithRadius > this.maxDistanceLimit) {
          continue;
        }
        if (deltaLengthWithRadius < this.minDistanceLimit) {
          deltaLengthWithRadius = this.minDistanceLimit;
        }
        const force = this.forceConstantSquared / deltaLengthWithRadius;
        const displacementX = xDelta / deltaLength * force;
        const displacementY = yDelta / deltaLength * force;
        this.dispX[i] += displacementX;
        this.dispY[i] += displacementY;
        this.dispX[j] -= displacementX;
        this.dispY[j] -= displacementY;
      }
    }
  }
};
mxFastOrganicLayout2.prototype.reduceTemperature = function() {
  this.temperature = this.initialTemp * (1 - this.iteration / this.maxIterations);
};

// js/graph/mxStencil.js
function mxStencil2(desc) {
  this.desc = desc;
  this.parseDescription();
  this.parseConstraints();
}
extend(mxStencil2, mxShape);
mxStencil2.defaultLocalized = false;
mxStencil2.allowEval = false;
mxStencil2.prototype.desc = null;
mxStencil2.prototype.constraints = null;
mxStencil2.prototype.aspect = null;
mxStencil2.prototype.w0 = null;
mxStencil2.prototype.h0 = null;
mxStencil2.prototype.bgNode = null;
mxStencil2.prototype.fgNode = null;
mxStencil2.prototype.strokewidth = null;
mxStencil2.prototype.parseDescription = function() {
  this.fgNode = this.desc.getElementsByTagName("foreground")[0];
  this.bgNode = this.desc.getElementsByTagName("background")[0];
  this.w0 = Number(this.desc.getAttribute("w") || 100);
  this.h0 = Number(this.desc.getAttribute("h") || 100);
  const aspect = this.desc.getAttribute("aspect");
  this.aspect = aspect != null ? aspect : "variable";
  const sw = this.desc.getAttribute("strokewidth");
  this.strokewidth = sw != null ? sw : "1";
};
mxStencil2.prototype.parseConstraints = function() {
  const conns = this.desc.getElementsByTagName("connections")[0];
  if (conns != null) {
    const tmp = getChildNodes(conns);
    if (tmp != null && tmp.length > 0) {
      this.constraints = [];
      for (let i = 0; i < tmp.length; i++) {
        this.constraints.push(this.parseConstraint(tmp[i]));
      }
    }
  }
};
mxStencil2.prototype.parseConstraint = function(node) {
  const x = Number(node.getAttribute("x"));
  const y = Number(node.getAttribute("y"));
  const perimeter = node.getAttribute("perimeter") == "1";
  const name = node.getAttribute("name");
  return new mxConnectionConstraint2(new mxPoint2(x, y), perimeter, name);
};
mxStencil2.prototype.evaluateTextAttribute = function(node, attribute, shape) {
  let result2 = this.evaluateAttribute(node, attribute, shape);
  const loc = node.getAttribute("localized");
  if (mxStencil2.defaultLocalized && loc == null || loc == "1") {
    result2 = mxResources2.get(result2);
  }
  return result2;
};
mxStencil2.prototype.evaluateAttribute = function(node, attribute, shape) {
  let result2 = node.getAttribute(attribute);
  if (result2 == null) {
    const text = getTextContent(node);
    if (text != null && mxStencil2.allowEval) {
      const funct = (void 0)(text);
      if (typeof funct == "function") {
        result2 = funct(shape);
      }
    }
  }
  return result2;
};
mxStencil2.prototype.drawShape = function(canvas, shape, x, y, w2, h2) {
  const stack = canvas.states.slice();
  const direction = getValue(shape.style, mxConstants2.STYLE_DIRECTION, null);
  const aspect = this.computeAspect(shape.style, x, y, w2, h2, direction);
  const minScale = Math.min(aspect.width, aspect.height);
  const sw = this.strokewidth == "inherit" ? Number(getNumber(shape.style, mxConstants2.STYLE_STROKEWIDTH, 1)) : Number(this.strokewidth) * minScale;
  canvas.setStrokeWidth(sw);
  if (shape.style != null && getValue(shape.style, mxConstants2.STYLE_POINTER_EVENTS, "0") == "1") {
    canvas.setStrokeColor(mxConstants2.NONE);
    canvas.rect(x, y, w2, h2);
    canvas.stroke();
    canvas.setStrokeColor(shape.stroke);
  }
  this.drawChildren(canvas, shape, x, y, w2, h2, this.bgNode, aspect, false, true);
  this.drawChildren(canvas, shape, x, y, w2, h2, this.fgNode, aspect, true, !shape.outline || shape.style == null || getValue(shape.style, mxConstants2.STYLE_BACKGROUND_OUTLINE, 0) == 0);
  if (canvas.states.length != stack.length) {
    canvas.states = stack;
  }
};
mxStencil2.prototype.drawChildren = function(canvas, shape, x, y, w2, h2, node, aspect, disableShadow, paint) {
  if (node != null && w2 > 0 && h2 > 0) {
    let tmp = node.firstChild;
    while (tmp != null) {
      if (tmp.nodeType == mxConstants2.NODETYPE_ELEMENT) {
        this.drawNode(canvas, shape, tmp, aspect, disableShadow, paint);
      }
      tmp = tmp.nextSibling;
    }
  }
};
mxStencil2.prototype.computeAspect = function(shape, x, y, w2, h2, direction) {
  let x0 = x;
  let y0 = y;
  let sx = w2 / this.w0;
  let sy = h2 / this.h0;
  const inverse = direction == mxConstants2.DIRECTION_NORTH || direction == mxConstants2.DIRECTION_SOUTH;
  if (inverse) {
    sy = w2 / this.h0;
    sx = h2 / this.w0;
    const delta = (w2 - h2) / 2;
    x0 += delta;
    y0 -= delta;
  }
  if (this.aspect == "fixed") {
    sy = Math.min(sx, sy);
    sx = sy;
    if (inverse) {
      x0 += (h2 - this.w0 * sx) / 2;
      y0 += (w2 - this.h0 * sy) / 2;
    } else {
      x0 += (w2 - this.w0 * sx) / 2;
      y0 += (h2 - this.h0 * sy) / 2;
    }
  }
  return new mxRectangle(x0, y0, sx, sy);
};
mxStencil2.prototype.drawNode = function(canvas, shape, node, aspect, disableShadow, paint) {
  const name = node.nodeName;
  const x0 = aspect.x;
  const y0 = aspect.y;
  const sx = aspect.width;
  const sy = aspect.height;
  const minScale = Math.min(sx, sy);
  if (name == "save") {
    canvas.save();
  } else if (name == "restore") {
    canvas.restore();
  } else if (paint) {
    if (name == "path") {
      canvas.begin();
      let parseRegularly = true;
      if (node.getAttribute("rounded") == "1") {
        parseRegularly = false;
        const arcSize = Number(node.getAttribute("arcSize"));
        let pointCount = 0;
        const segs = [];
        let childNode = node.firstChild;
        while (childNode != null) {
          if (childNode.nodeType == mxConstants2.NODETYPE_ELEMENT) {
            const childName = childNode.nodeName;
            if (childName == "move" || childName == "line") {
              if (childName == "move" || segs.length == 0) {
                segs.push([]);
              }
              segs[segs.length - 1].push(new mxPoint2(x0 + Number(childNode.getAttribute("x")) * sx, y0 + Number(childNode.getAttribute("y")) * sy));
              pointCount++;
            } else {
              parseRegularly = true;
              break;
            }
          }
          childNode = childNode.nextSibling;
        }
        if (!parseRegularly && pointCount > 0) {
          for (let i = 0; i < segs.length; i++) {
            let close = false;
            const ps = segs[i][0];
            const pe = segs[i][segs[i].length - 1];
            if (ps.x == pe.x && ps.y == pe.y) {
              segs[i].pop();
              close = true;
            }
            this.addPoints(canvas, segs[i], true, arcSize, close);
          }
        } else {
          parseRegularly = true;
        }
      }
      if (parseRegularly) {
        let childNode = node.firstChild;
        while (childNode != null) {
          if (childNode.nodeType == mxConstants2.NODETYPE_ELEMENT) {
            this.drawNode(canvas, shape, childNode, aspect, disableShadow, paint);
          }
          childNode = childNode.nextSibling;
        }
      }
    } else if (name == "close") {
      canvas.close();
    } else if (name == "move") {
      canvas.moveTo(x0 + Number(node.getAttribute("x")) * sx, y0 + Number(node.getAttribute("y")) * sy);
    } else if (name == "line") {
      canvas.lineTo(x0 + Number(node.getAttribute("x")) * sx, y0 + Number(node.getAttribute("y")) * sy);
    } else if (name == "quad") {
      canvas.quadTo(x0 + Number(node.getAttribute("x1")) * sx, y0 + Number(node.getAttribute("y1")) * sy, x0 + Number(node.getAttribute("x2")) * sx, y0 + Number(node.getAttribute("y2")) * sy);
    } else if (name == "curve") {
      canvas.curveTo(x0 + Number(node.getAttribute("x1")) * sx, y0 + Number(node.getAttribute("y1")) * sy, x0 + Number(node.getAttribute("x2")) * sx, y0 + Number(node.getAttribute("y2")) * sy, x0 + Number(node.getAttribute("x3")) * sx, y0 + Number(node.getAttribute("y3")) * sy);
    } else if (name == "arc") {
      canvas.arcTo(Number(node.getAttribute("rx")) * sx, Number(node.getAttribute("ry")) * sy, Number(node.getAttribute("x-axis-rotation")), Number(node.getAttribute("large-arc-flag")), Number(node.getAttribute("sweep-flag")), x0 + Number(node.getAttribute("x")) * sx, y0 + Number(node.getAttribute("y")) * sy);
    } else if (name == "rect") {
      canvas.rect(x0 + Number(node.getAttribute("x")) * sx, y0 + Number(node.getAttribute("y")) * sy, Number(node.getAttribute("w")) * sx, Number(node.getAttribute("h")) * sy);
    } else if (name == "roundrect") {
      let arcsize = Number(node.getAttribute("arcsize"));
      if (arcsize == 0) {
        arcsize = mxConstants2.RECTANGLE_ROUNDING_FACTOR * 100;
      }
      const w2 = Number(node.getAttribute("w")) * sx;
      const h2 = Number(node.getAttribute("h")) * sy;
      const factor = Number(arcsize) / 100;
      const r = Math.min(w2 * factor, h2 * factor);
      canvas.roundrect(x0 + Number(node.getAttribute("x")) * sx, y0 + Number(node.getAttribute("y")) * sy, w2, h2, r, r);
    } else if (name == "ellipse") {
      canvas.ellipse(x0 + Number(node.getAttribute("x")) * sx, y0 + Number(node.getAttribute("y")) * sy, Number(node.getAttribute("w")) * sx, Number(node.getAttribute("h")) * sy);
    } else if (name == "image") {
      if (!shape.outline) {
        const src = this.evaluateAttribute(node, "src", shape);
        canvas.image(x0 + Number(node.getAttribute("x")) * sx, y0 + Number(node.getAttribute("y")) * sy, Number(node.getAttribute("w")) * sx, Number(node.getAttribute("h")) * sy, src, false, node.getAttribute("flipH") == "1", node.getAttribute("flipV") == "1");
      }
    } else if (name == "text") {
      if (!shape.outline) {
        const str = this.evaluateTextAttribute(node, "str", shape);
        let rotation = node.getAttribute("vertical") == "1" ? -90 : 0;
        if (node.getAttribute("align-shape") == "0") {
          const dr = shape.rotation;
          const flipH = getValue(shape.style, mxConstants2.STYLE_FLIPH, 0) == 1;
          const flipV = getValue(shape.style, mxConstants2.STYLE_FLIPV, 0) == 1;
          if (flipH && flipV) {
            rotation -= dr;
          } else if (flipH || flipV) {
            rotation += dr;
          } else {
            rotation -= dr;
          }
        }
        rotation -= node.getAttribute("rotation");
        canvas.text(x0 + Number(node.getAttribute("x")) * sx, y0 + Number(node.getAttribute("y")) * sy, 0, 0, str, node.getAttribute("align") || "left", node.getAttribute("valign") || "top", false, "", null, false, rotation);
      }
    } else if (name == "include-shape") {
      const stencil = mxStencilRegistry.getStencil(node.getAttribute("name"));
      if (stencil != null) {
        const x = x0 + Number(node.getAttribute("x")) * sx;
        const y = y0 + Number(node.getAttribute("y")) * sy;
        const w2 = Number(node.getAttribute("w")) * sx;
        const h2 = Number(node.getAttribute("h")) * sy;
        stencil.drawShape(canvas, shape, x, y, w2, h2);
      }
    } else if (name == "fillstroke") {
      canvas.fillAndStroke();
    } else if (name == "fill") {
      canvas.fill();
    } else if (name == "stroke") {
      canvas.stroke();
    } else if (name == "strokewidth") {
      const s = node.getAttribute("fixed") == "1" ? 1 : minScale;
      canvas.setStrokeWidth(Number(node.getAttribute("width")) * s);
    } else if (name == "dashed") {
      canvas.setDashed(node.getAttribute("dashed") == "1");
    } else if (name == "dashpattern") {
      let value = node.getAttribute("pattern");
      if (value != null) {
        const tmp = value.split(" ");
        const pat = [];
        for (let i = 0; i < tmp.length; i++) {
          if (tmp[i].length > 0) {
            pat.push(Number(tmp[i]) * minScale);
          }
        }
        value = pat.join(" ");
        canvas.setDashPattern(value);
      }
    } else if (name == "strokecolor") {
      canvas.setStrokeColor(node.getAttribute("color"));
    } else if (name == "linecap") {
      canvas.setLineCap(node.getAttribute("cap"));
    } else if (name == "linejoin") {
      canvas.setLineJoin(node.getAttribute("join"));
    } else if (name == "miterlimit") {
      canvas.setMiterLimit(Number(node.getAttribute("limit")));
    } else if (name == "fillcolor") {
      canvas.setFillColor(node.getAttribute("color"));
    } else if (name == "alpha") {
      canvas.setAlpha(node.getAttribute("alpha"));
    } else if (name == "fillalpha") {
      canvas.setAlpha(node.getAttribute("alpha"));
    } else if (name == "strokealpha") {
      canvas.setAlpha(node.getAttribute("alpha"));
    } else if (name == "fontcolor") {
      canvas.setFontColor(node.getAttribute("color"));
    } else if (name == "fontstyle") {
      canvas.setFontStyle(node.getAttribute("style"));
    } else if (name == "fontfamily") {
      canvas.setFontFamily(node.getAttribute("family"));
    } else if (name == "fontsize") {
      canvas.setFontSize(Number(node.getAttribute("size")) * minScale);
    }
    if (disableShadow && (name == "fillstroke" || name == "fill" || name == "stroke")) {
      disableShadow = false;
      canvas.setShadow(false);
    }
  }
};

// js/graph/mxHandle.js
var mxHandle2 = function(state2, cursor, image, shape) {
  this.graph = state2.view.graph;
  this.state = state2;
  this.cursor = cursor != null ? cursor : this.cursor;
  this.image = image != null ? image : this.image;
  this.shape = shape != null ? shape : null;
  this.init();
};
mxHandle2.prototype.cursor = "default";
mxHandle2.prototype.image = null;
mxHandle2.prototype.ignoreGrid = false;
mxHandle2.prototype.getPosition = function(bounds) {
};
mxHandle2.prototype.setPosition = function(bounds, pt, me) {
};
mxHandle2.prototype.execute = function(me) {
};
mxHandle2.prototype.copyStyle = function(key) {
  this.graph.setCellStyles(key, this.state.style[key], [this.state.cell]);
};
mxHandle2.prototype.processEvent = function(me) {
  const scale = this.graph.view.scale;
  const tr = this.graph.view.translate;
  let pt = new mxPoint2(me.getGraphX() / scale - tr.x, me.getGraphY() / scale - tr.y);
  if (this.shape != null && this.shape.bounds != null) {
    pt.x -= this.shape.bounds.width / scale / 4;
    pt.y -= this.shape.bounds.height / scale / 4;
  }
  const alpha12 = -toRadians(this.getRotation());
  const alpha22 = -toRadians(this.getTotalRotation()) - alpha12;
  pt = this.flipPoint(this.rotatePoint(this.snapPoint(this.rotatePoint(pt, alpha12), this.ignoreGrid || !this.graph.isGridEnabledEvent(me.getEvent())), alpha22));
  this.setPosition(this.state.getPaintBounds(), pt, me);
  this.redraw();
};
mxHandle2.prototype.positionChanged = function() {
  if (this.state.text != null) {
    this.state.text.apply(this.state);
  }
  if (this.state.shape != null) {
    this.state.shape.apply(this.state);
  }
  this.graph.cellRenderer.redraw(this.state, true);
};
mxHandle2.prototype.getRotation = function() {
  if (this.state.shape != null) {
    return this.state.shape.getRotation();
  }
  return 0;
};
mxHandle2.prototype.getTotalRotation = function() {
  if (this.state.shape != null) {
    return this.state.shape.getShapeRotation();
  }
  return 0;
};
mxHandle2.prototype.init = function() {
  const html = this.isHtmlRequired();
  if (this.image != null) {
    this.shape = new mxImageShape(new mxRectangle(0, 0, this.image.width, this.image.height), this.image.src);
    this.shape.preserveImageAspect = false;
  } else if (this.shape == null) {
    this.shape = this.createShape(html);
  }
  this.initShape(html);
};
mxHandle2.prototype.createShape = function(html) {
  const bounds = new mxRectangle(0, 0, mxConstants2.HANDLE_SIZE, mxConstants2.HANDLE_SIZE);
  return new mxRectangleShape(bounds, mxConstants2.HANDLE_FILLCOLOR, mxConstants2.HANDLE_STROKECOLOR);
};
mxHandle2.prototype.initShape = function(html) {
  if (html && this.shape.isHtmlAllowed()) {
    this.shape.dialect = mxConstants2.DIALECT_STRICTHTML;
    this.shape.init(this.graph.container);
  } else {
    this.shape.dialect = this.graph.dialect !== mxConstants2.DIALECT_SVG ? mxConstants2.DIALECT_MIXEDHTML : mxConstants2.DIALECT_SVG;
    if (this.cursor != null) {
      this.shape.init(this.graph.getView().getOverlayPane());
    }
  }
  mxEvent2.redirectMouseEvents(this.shape.node, this.graph, this.state);
  this.shape.node.style.cursor = this.cursor;
};
mxHandle2.prototype.redraw = function() {
  if (this.shape != null && this.state.shape != null) {
    let pt = this.getPosition(this.state.getPaintBounds());
    if (pt != null) {
      const alpha = toRadians(this.getTotalRotation());
      pt = this.rotatePoint(this.flipPoint(pt), alpha);
      const scale = this.graph.view.scale;
      const tr = this.graph.view.translate;
      this.shape.bounds.x = Math.floor((pt.x + tr.x) * scale - this.shape.bounds.width / 2);
      this.shape.bounds.y = Math.floor((pt.y + tr.y) * scale - this.shape.bounds.height / 2);
      this.shape.redraw();
    }
  }
};
mxHandle2.prototype.isHtmlRequired = function() {
  return this.state.text != null && this.state.text.node.parentNode === this.graph.container;
};
mxHandle2.prototype.rotatePoint = function(pt, alpha) {
  const bounds = this.state.getCellBounds();
  const cx = new mxPoint2(bounds.getCenterX(), bounds.getCenterY());
  const cos = Math.cos(alpha);
  const sin = Math.sin(alpha);
  return getRotatedPoint(pt, cos, sin, cx);
};
mxHandle2.prototype.flipPoint = function(pt) {
  if (this.state.shape != null) {
    const bounds = this.state.getCellBounds();
    if (this.state.shape.flipH) {
      pt.x = 2 * bounds.x + bounds.width - pt.x;
    }
    if (this.state.shape.flipV) {
      pt.y = 2 * bounds.y + bounds.height - pt.y;
    }
  }
  return pt;
};
mxHandle2.prototype.snapPoint = function(pt, ignore) {
  if (!ignore) {
    pt.x = this.graph.snap(pt.x);
    pt.y = this.graph.snap(pt.y);
  }
  return pt;
};
mxHandle2.prototype.setVisible = function(visible) {
  if (this.shape != null && this.shape.node != null) {
    this.shape.node.style.display = visible ? "" : "none";
  }
};
mxHandle2.prototype.reset = function() {
  this.setVisible(true);
  this.state.style = this.graph.getCellStyle(this.state.cell);
  this.positionChanged();
};
mxHandle2.prototype.destroy = function() {
  if (this.shape != null) {
    this.shape.destroy();
    this.shape = null;
  }
};

// js/graph/mxOutline.js
function mxOutline(source, container) {
  this.source = source;
  if (container != null) {
    this.init(container);
  }
}
mxOutline.prototype.source = null;
mxOutline.prototype.outline = null;
mxOutline.prototype.graphRenderHint = mxConstants2.RENDERING_HINT_FASTER;
mxOutline.prototype.enabled = true;
mxOutline.prototype.showViewport = true;
mxOutline.prototype.border = 10;
mxOutline.prototype.sizerSize = 8;
mxOutline.prototype.labelsVisible = false;
mxOutline.prototype.updateOnPan = false;
mxOutline.prototype.sizerImage = null;
mxOutline.prototype.minScale = 1e-4;
mxOutline.prototype.suspended = false;
mxOutline.prototype.forceVmlHandles = document.documentMode == 8;
mxOutline.prototype.createGraph = function(container) {
  const graph = new mxGraph2(container, this.source.getModel(), this.graphRenderHint, this.source.getStylesheet());
  graph.foldingEnabled = false;
  graph.autoScroll = false;
  return graph;
};
mxOutline.prototype.init = function(container) {
  this.outline = this.createGraph(container);
  const outlineGraphModelChanged = this.outline.graphModelChanged;
  this.outline.graphModelChanged = bind(this, function(changes) {
    if (!this.suspended && this.outline != null) {
      outlineGraphModelChanged.apply(this.outline, arguments);
    }
  });
  if (mxClient_default.IS_SVG) {
    const node = this.outline.getView().getCanvas().parentNode;
    node.setAttribute("shape-rendering", "optimizeSpeed");
    node.setAttribute("image-rendering", "optimizeSpeed");
  }
  this.outline.labelsVisible = this.labelsVisible;
  this.outline.setEnabled(false);
  this.updateHandler = bind(this, function(sender, evt) {
    if (!this.suspended && !this.active) {
      this.update();
    }
  });
  this.source.getModel().addListener(mxEvent2.CHANGE, this.updateHandler);
  this.outline.addMouseListener(this);
  const view = this.source.getView();
  view.addListener(mxEvent2.SCALE, this.updateHandler);
  view.addListener(mxEvent2.TRANSLATE, this.updateHandler);
  view.addListener(mxEvent2.SCALE_AND_TRANSLATE, this.updateHandler);
  view.addListener(mxEvent2.DOWN, this.updateHandler);
  view.addListener(mxEvent2.UP, this.updateHandler);
  mxEvent2.addListener(this.source.container, "scroll", this.updateHandler);
  this.panHandler = bind(this, function(sender) {
    if (this.updateOnPan) {
      this.updateHandler.apply(this, arguments);
    }
  });
  this.source.addListener(mxEvent2.PAN, this.panHandler);
  this.refreshHandler = bind(this, function(sender) {
    this.outline.setStylesheet(this.source.getStylesheet());
    this.outline.refresh();
  });
  this.source.addListener(mxEvent2.REFRESH, this.refreshHandler);
  this.bounds = new mxRectangle(0, 0, 0, 0);
  this.selectionBorder = new mxRectangleShape(this.bounds, null, mxConstants2.OUTLINE_COLOR, mxConstants2.OUTLINE_STROKEWIDTH);
  this.selectionBorder.dialect = this.outline.dialect;
  if (this.forceVmlHandles) {
    this.selectionBorder.isHtmlAllowed = function() {
      return false;
    };
  }
  this.selectionBorder.init(this.outline.getView().getOverlayPane());
  const handler = bind(this, function(evt) {
    const t = mxEvent2.getSource(evt);
    const redirect = bind(this, function(evt2) {
      this.outline.fireMouseEvent(mxEvent2.MOUSE_MOVE, new mxMouseEvent2(evt2));
    });
    const redirect2 = bind(this, function(evt2) {
      mxEvent2.removeGestureListeners(t, null, redirect, redirect2);
      this.outline.fireMouseEvent(mxEvent2.MOUSE_UP, new mxMouseEvent2(evt2));
    });
    mxEvent2.addGestureListeners(t, null, redirect, redirect2);
    this.outline.fireMouseEvent(mxEvent2.MOUSE_DOWN, new mxMouseEvent2(evt));
  });
  mxEvent2.addGestureListeners(this.selectionBorder.node, handler);
  this.sizer = this.createSizer();
  if (this.forceVmlHandles) {
    this.sizer.isHtmlAllowed = function() {
      return false;
    };
  }
  this.sizer.init(this.outline.getView().getOverlayPane());
  if (this.enabled) {
    this.sizer.node.style.cursor = "nwse-resize";
  }
  mxEvent2.addGestureListeners(this.sizer.node, handler);
  this.selectionBorder.node.style.display = this.showViewport ? "" : "none";
  this.sizer.node.style.display = this.selectionBorder.node.style.display;
  this.selectionBorder.node.style.cursor = "move";
  this.update(false);
};
mxOutline.prototype.isEnabled = function() {
  return this.enabled;
};
mxOutline.prototype.setEnabled = function(value) {
  this.enabled = value;
};
mxOutline.prototype.setZoomEnabled = function(value) {
  this.sizer.node.style.visibility = value ? "visible" : "hidden";
};
mxOutline.prototype.refresh = function() {
  this.update(true);
};
mxOutline.prototype.createSizer = function() {
  if (this.sizerImage != null) {
    const sizer = new mxImageShape(new mxRectangle(0, 0, this.sizerImage.width, this.sizerImage.height), this.sizerImage.src);
    sizer.dialect = this.outline.dialect;
    return sizer;
  } else {
    const sizer = new mxRectangleShape(new mxRectangle(0, 0, this.sizerSize, this.sizerSize), mxConstants2.OUTLINE_HANDLE_FILLCOLOR, mxConstants2.OUTLINE_HANDLE_STROKECOLOR);
    sizer.dialect = this.outline.dialect;
    return sizer;
  }
};
mxOutline.prototype.getSourceContainerSize = function() {
  return new mxRectangle(0, 0, this.source.container.scrollWidth, this.source.container.scrollHeight);
};
mxOutline.prototype.getOutlineOffset = function(scale) {
  return null;
};
mxOutline.prototype.getSourceGraphBounds = function() {
  return this.source.getGraphBounds();
};
mxOutline.prototype.update = function(revalidate) {
  if (this.source != null && this.source.container != null && this.outline != null && this.outline.container != null) {
    const sourceScale = this.source.view.scale;
    const scaledGraphBounds = this.getSourceGraphBounds();
    const unscaledGraphBounds = new mxRectangle(scaledGraphBounds.x / sourceScale + this.source.panDx, scaledGraphBounds.y / sourceScale + this.source.panDy, scaledGraphBounds.width / sourceScale, scaledGraphBounds.height / sourceScale);
    const unscaledFinderBounds = new mxRectangle(0, 0, this.source.container.clientWidth / sourceScale, this.source.container.clientHeight / sourceScale);
    const union = unscaledGraphBounds.clone();
    union.add(unscaledFinderBounds);
    const size = this.getSourceContainerSize();
    const completeWidth = Math.max(size.width / sourceScale, union.width);
    const completeHeight = Math.max(size.height / sourceScale, union.height);
    const availableWidth = Math.max(0, this.outline.container.clientWidth - this.border);
    const availableHeight = Math.max(0, this.outline.container.clientHeight - this.border);
    const outlineScale = Math.min(availableWidth / completeWidth, availableHeight / completeHeight);
    let scale = isNaN(outlineScale) ? this.minScale : Math.max(this.minScale, outlineScale);
    if (scale > 0) {
      if (this.outline.getView().scale != scale) {
        this.outline.getView().scale = scale;
        revalidate = true;
      }
      const navView = this.outline.getView();
      if (navView.currentRoot != this.source.getView().currentRoot) {
        navView.setCurrentRoot(this.source.getView().currentRoot);
      }
      const t = this.source.view.translate;
      let tx = t.x + this.source.panDx;
      let ty = t.y + this.source.panDy;
      const off = this.getOutlineOffset(scale);
      if (off != null) {
        tx += off.x;
        ty += off.y;
      }
      if (unscaledGraphBounds.x < 0) {
        tx = tx - unscaledGraphBounds.x;
      }
      if (unscaledGraphBounds.y < 0) {
        ty = ty - unscaledGraphBounds.y;
      }
      if (navView.translate.x != tx || navView.translate.y != ty) {
        navView.translate.x = tx;
        navView.translate.y = ty;
        revalidate = true;
      }
      const t2 = navView.translate;
      scale = this.source.getView().scale;
      const scale2 = scale / navView.scale;
      const scale3 = 1 / navView.scale;
      const container = this.source.container;
      this.bounds = new mxRectangle((t2.x - t.x - this.source.panDx) / scale3, (t2.y - t.y - this.source.panDy) / scale3, container.clientWidth / scale2, container.clientHeight / scale2);
      this.bounds.x += this.source.container.scrollLeft * navView.scale / scale;
      this.bounds.y += this.source.container.scrollTop * navView.scale / scale;
      const b = this.selectionBorder.bounds;
      if (b.x != this.bounds.x || b.y != this.bounds.y || b.width != this.bounds.width || b.height != this.bounds.height) {
        this.selectionBorder.bounds = this.bounds;
        this.selectionBorder.redraw();
      }
      let bSizer = this.sizer.bounds;
      const b2 = new mxRectangle(this.bounds.x + this.bounds.width - bSizer.width / 2, this.bounds.y + this.bounds.height - bSizer.height / 2, bSizer.width, bSizer.height);
      if (bSizer.x != b2.x || bSizer.y != b2.y || bSizer.width != b2.width || bSizer.height != b2.height) {
        this.sizer.bounds = b2;
        if (this.sizer.node.style.visibility != "hidden") {
          this.sizer.redraw();
        }
      }
      if (revalidate) {
        this.outline.view.revalidate();
      }
    }
  }
};
mxOutline.prototype.mouseDown = function(sender, me) {
  if (this.enabled && this.showViewport) {
    const tol = !mxEvent2.isMouseEvent(me.getEvent()) ? this.source.tolerance : 0;
    const hit = this.source.allowHandleBoundsCheck && (mxClient_default.IS_IE || tol > 0) ? new mxRectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol) : null;
    this.zoom = me.isSource(this.sizer) || hit != null && intersects(me.getCell().shape.bounds, hit);
    this.startX = me.getX();
    this.startY = me.getY();
    this.active = true;
    if (this.source.useScrollbarsForPanning && hasScrollbars(this.source.container)) {
      this.dx0 = this.source.container.scrollLeft;
      this.dy0 = this.source.container.scrollTop;
    } else {
      this.dx0 = 0;
      this.dy0 = 0;
    }
  }
  me.consume();
};
mxOutline.prototype.mouseMove = function(sender, me) {
  if (this.active) {
    this.selectionBorder.node.style.display = this.showViewport ? "" : "none";
    this.sizer.node.style.display = this.selectionBorder.node.style.display;
    const delta = this.getTranslateForEvent(me);
    let dx = delta.x;
    let dy = delta.y;
    let bounds = null;
    if (!this.zoom) {
      const scale = this.outline.getView().scale;
      bounds = new mxRectangle(this.bounds.x + dx, this.bounds.y + dy, this.bounds.width, this.bounds.height);
      this.selectionBorder.bounds = bounds;
      this.selectionBorder.redraw();
      dx /= scale;
      dx *= this.source.getView().scale;
      dy /= scale;
      dy *= this.source.getView().scale;
      this.source.panGraph(-dx - this.dx0, -dy - this.dy0);
    } else {
      const container = this.source.container;
      const viewRatio = container.clientWidth / container.clientHeight;
      dy = dx / viewRatio;
      bounds = new mxRectangle(this.bounds.x, this.bounds.y, Math.max(1, this.bounds.width + dx), Math.max(1, this.bounds.height + dy));
      this.selectionBorder.bounds = bounds;
      this.selectionBorder.redraw();
    }
    const b = this.sizer.bounds;
    this.sizer.bounds = new mxRectangle(bounds.x + bounds.width - b.width / 2, bounds.y + bounds.height - b.height / 2, b.width, b.height);
    if (this.sizer.node.style.visibility != "hidden") {
      this.sizer.redraw();
    }
    me.consume();
  }
};
mxOutline.prototype.getTranslateForEvent = function(me) {
  return new mxPoint2(me.getX() - this.startX, me.getY() - this.startY);
};
mxOutline.prototype.mouseUp = function(sender, me) {
  if (this.active) {
    const delta = this.getTranslateForEvent(me);
    let dx = delta.x;
    let dy = delta.y;
    if (Math.abs(dx) > 0 || Math.abs(dy) > 0) {
      if (!this.zoom) {
        if (!this.source.useScrollbarsForPanning || !hasScrollbars(this.source.container)) {
          this.source.panGraph(0, 0);
          dx /= this.outline.getView().scale;
          dy /= this.outline.getView().scale;
          const t = this.source.getView().translate;
          this.source.getView().setTranslate(t.x - dx, t.y - dy);
        }
      } else {
        const w2 = this.selectionBorder.bounds.width;
        const scale = this.source.getView().scale;
        this.source.zoomTo(Math.max(this.minScale, scale - dx * scale / w2), false);
      }
      this.update();
      me.consume();
    }
    this.index = null;
    this.active = false;
  }
};
mxOutline.prototype.destroy = function() {
  if (this.source != null) {
    this.source.removeListener(this.panHandler);
    this.source.removeListener(this.refreshHandler);
    this.source.getModel().removeListener(this.updateHandler);
    this.source.getView().removeListener(this.updateHandler);
    mxEvent2.removeListener(this.source.container, "scroll", this.updateHandler);
    this.source = null;
  }
  if (this.outline != null) {
    this.outline.removeMouseListener(this);
    this.outline.destroy();
    this.outline = null;
  }
  if (this.selectionBorder != null) {
    this.selectionBorder.destroy();
    this.selectionBorder = null;
  }
  if (this.sizer != null) {
    this.sizer.destroy();
    this.sizer = null;
  }
};

// js/Config.js
function parseUrlParams() {
  const params = new URLSearchParams(window.location.search);
  const urlParams3 = {};
  for (const [key, value] of params) {
    urlParams3[key] = value;
  }
  return urlParams3;
}
var urlParams2 = parseUrlParams();
var STENCIL_PATH2 = "stencils";
var mxLanguage = urlParams2["lang"] || navigator.language;

// js/Graph.js
if (typeof html4 !== "undefined") {
  html4.ATTRIBS["a::target"] = 0;
  html4.ATTRIBS["source::src"] = 0;
  html4.ATTRIBS["video::src"] = 0;
}
if (!Date.prototype.toISOString) {
  (function() {
    function pad(number) {
      var r = String(number);
      if (r.length === 1) {
        r = "0" + r;
      }
      return r;
    }
    Date.prototype.toISOString = function() {
      return this.getUTCFullYear() + "-" + pad(this.getUTCMonth() + 1) + "-" + pad(this.getUTCDate()) + "T" + pad(this.getUTCHours()) + ":" + pad(this.getUTCMinutes()) + ":" + pad(this.getUTCSeconds()) + "." + String((this.getUTCMilliseconds() / 1e3).toFixed(3)).slice(2, 5) + "Z";
    };
  })();
}
if (!Date.now) {
  Date.now = function() {
    return new Date().getTime();
  };
}
mxConstants2.POINTS = 1;
mxConstants2.MILLIMETERS = 2;
mxConstants2.INCHES = 3;
mxConstants2.PIXELS_PER_MM = 3.937;
mxConstants2.PIXELS_PER_INCH = 100;
mxConstants2.SHADOW_OPACITY = 0.25;
mxConstants2.SHADOWCOLOR = "#000000";
mxConstants2.VML_SHADOWCOLOR = "#d0d0d0";
mxGraph2.prototype.pageBreakColor = "#c0c0c0";
mxGraph2.prototype.pageScale = 1;
(function() {
  try {
    if (navigator != null && navigator.language != null) {
      var lang = navigator.language.toLowerCase();
      mxGraph2.prototype.pageFormat = lang === "en-us" || lang === "en-ca" || lang === "es-mx" ? mxConstants2.PAGE_FORMAT_LETTER_PORTRAIT : mxConstants2.PAGE_FORMAT_A4_PORTRAIT;
    }
  } catch (e) {
  }
})();
mxText.prototype.baseSpacingTop = 5;
mxText.prototype.baseSpacingBottom = 1;
mxGraphModel2.prototype.ignoreRelativeEdgeParent = false;
mxGraphView.prototype.gridImage = mxClient_default.IS_SVG ? "data:image/gif;base64,R0lGODlhCgAKAJEAAAAAAP///8zMzP///yH5BAEAAAMALAAAAAAKAAoAAAIJ1I6py+0Po2wFADs=" : IMAGE_PATH + "/grid.gif";
mxGraphView.prototype.gridSteps = 4;
mxGraphView.prototype.minGridSize = 4;
mxGraphView.prototype.defaultGridColor = "#d0d0d0";
mxGraphView.prototype.gridColor = mxGraphView.prototype.defaultGridColor;
mxGraphView.prototype.unit = mxConstants2.POINTS;
mxGraphView.prototype.setUnit = function(unit) {
  if (this.unit != unit) {
    this.unit = unit;
    this.fireEvent(new mxEventObject2("unitChanged", "unit", unit));
  }
};
mxSvgCanvas2D.prototype.foAltText = "[Not supported by viewer]";
mxShape.prototype.getConstraints = function(style, w2, h2) {
  return null;
};
var Graph2 = function(container, model, renderHint, stylesheet, themes, standalone) {
  mxGraph2.call(this, container, model, renderHint, stylesheet);
  this.graphHandler.livePreview = true;
  this.themes = themes || this.defaultThemes;
  this.currentEdgeStyle = clone(this.defaultEdgeStyle);
  this.currentVertexStyle = clone(this.defaultVertexStyle);
  this.standalone = standalone != null ? standalone : false;
  var b = this.baseUrl;
  var p = b.indexOf("//");
  this.domainUrl = "";
  this.domainPathUrl = "";
  if (p > 0) {
    var d = b.indexOf("/", p + 2);
    if (d > 0) {
      this.domainUrl = b.substring(0, d);
    }
    d = b.lastIndexOf("/");
    if (d > 0) {
      this.domainPathUrl = b.substring(0, d + 1);
    }
  }
  this.isHtmlLabel = function(cell2) {
    var style = this.getCurrentCellStyle(cell2);
    return style != null ? style["html"] == "1" || style[mxConstants2.STYLE_WHITE_SPACE] == "wrap" : false;
  };
  if (this.edgeMode) {
    var start = {
      point: null,
      event: null,
      state: null,
      handle: null,
      selected: false
    };
    this.addListener(mxEvent2.FIRE_MOUSE_EVENT, bind(this, function(sender, evt) {
      console.log("FIRE_MOUSE_EVENT fired for:", evt.getProperty("eventName"));
      if (evt.getProperty("eventName") == "mouseDown" && this.isEnabled()) {
        var me = evt.getProperty("event");
        var state2 = me.getState();
        if (!mxEvent2.isAltDown(me.getEvent()) && state2 != null) {
          if (this.model.isEdge(state2.cell)) {
            start.point = new mxPoint2(me.getGraphX(), me.getGraphY());
            start.selected = this.isCellSelected(state2.cell);
            start.state = state2;
            start.event = me;
            if (state2.text != null && state2.text.boundingBox != null && contains(state2.text.boundingBox, me.getGraphX(), me.getGraphY())) {
              start.handle = mxEvent2.LABEL_HANDLE;
            } else {
              var handler = this.selectionCellsHandler.getHandler(state2.cell);
              if (handler != null && handler.bends != null && handler.bends.length > 0) {
                start.handle = handler.getHandleForEvent(me);
              }
            }
          } else if (!this.panningHandler.isActive() && !mxEvent2.isControlDown(me.getEvent())) {
            var handler = this.selectionCellsHandler.getHandler(state2.cell);
            if (handler == null || handler.getHandleForEvent(me) == null) {
              var box = new mxRectangle(me.getGraphX() - 1, me.getGraphY() - 1);
              box.grow(mxEvent2.isTouchEvent(me.getEvent()) ? mxShape.prototype.svgStrokeTolerance - 1 : (mxShape.prototype.svgStrokeTolerance + 1) / 2);
              if (this.isTableCell(state2.cell) && !this.isCellSelected(state2.cell)) {
                var row = this.model.getParent(state2.cell);
                var table = this.model.getParent(row);
                if (!this.isCellSelected(table)) {
                  if (intersects(box, new mxRectangle(state2.x, state2.y - 2, state2.width, 3)) && this.model.getChildAt(table, 0) != row || intersects(box, new mxRectangle(state2.x, state2.y + state2.height - 2, state2.width, 3)) || intersects(box, new mxRectangle(state2.x - 2, state2.y, 2, state2.height)) && this.model.getChildAt(row, 0) != state2.cell || intersects(box, new mxRectangle(state2.x + state2.width - 2, state2.y, 2, state2.height))) {
                    var wasSelected = this.selectionCellsHandler.isHandled(table);
                    this.selectCellForEvent(table, me.getEvent());
                    handler = this.selectionCellsHandler.getHandler(table);
                    if (handler != null) {
                      var handle = handler.getHandleForEvent(me);
                      if (handle != null) {
                        handler.start(me.getGraphX(), me.getGraphY(), handle);
                        handler.blockDelayedSelection = !wasSelected;
                        me.consume();
                      }
                    }
                  }
                }
              }
              var current2 = state2;
              while (!me.isConsumed() && current2 != null && (this.isTableCell(current2.cell) || this.isTableRow(current2.cell) || this.isTable(current2.cell))) {
                if (this.isSwimlane(current2.cell)) {
                  var offset = this.getActualStartSize(current2.cell);
                  var s = this.view.scale;
                  if ((offset.x > 0 || offset.width > 0) && intersects(box, new mxRectangle(current2.x + (offset.x - offset.width - 1) * s + (offset.x == 0 ? current2.width : 0), current2.y, 1, current2.height)) || (offset.y > 0 || offset.height > 0) && intersects(box, new mxRectangle(current2.x, current2.y + (offset.y - offset.height - 1) * s + (offset.y == 0 ? current2.height : 0), current2.width, 1))) {
                    this.selectCellForEvent(current2.cell, me.getEvent());
                    handler = this.selectionCellsHandler.getHandler(current2.cell);
                    if (handler != null) {
                      var handle = mxEvent2.CUSTOM_HANDLE - handler.customHandles.length + 1;
                      handler.start(me.getGraphX(), me.getGraphY(), handle);
                      me.consume();
                    }
                  }
                }
                current2 = this.view.getState(this.model.getParent(current2.cell));
              }
            }
          }
        }
      }
    }));
    var mouseDown2 = null;
    this.addMouseListener({
      mouseDown: function(sender, me) {
      },
      mouseMove: bind(this, function(sender, me) {
        var handlerMap = this.selectionCellsHandler.handlers.map;
        for (var key in handlerMap) {
          if (handlerMap[key].index != null) {
            return;
          }
        }
        if (this.isEnabled() && !this.panningHandler.isActive() && !mxEvent2.isAltDown(me.getEvent())) {
          var tol = this.tolerance;
          if (start.point != null && start.state != null && start.event != null) {
            var state2 = start.state;
            if (Math.abs(start.point.x - me.getGraphX()) > tol || Math.abs(start.point.y - me.getGraphY()) > tol) {
              var handler = this.selectionCellsHandler.getHandler(state2.cell);
              if (handler == null && this.model.isEdge(state2.cell)) {
                handler = this.createHandler(state2);
              }
              if (handler != null && handler.bends != null && handler.bends.length > 0) {
                var handle = handler.getHandleForEvent(start.event);
                var edgeStyle = this.view.getEdgeStyle(state2);
                var entity = edgeStyle == mxEdgeStyle.EntityRelation;
                if (!start.selected && start.handle == mxEvent2.LABEL_HANDLE) {
                  handle = start.handle;
                }
                if (!entity || handle == 0 || handle == handler.bends.length - 1 || handle == mxEvent2.LABEL_HANDLE) {
                  if (handle == mxEvent2.LABEL_HANDLE || handle == 0 || state2.visibleSourceState != null || handle == handler.bends.length - 1 || state2.visibleTargetState != null) {
                    if (!entity && handle != mxEvent2.LABEL_HANDLE) {
                      var pts = state2.absolutePoints;
                      if (pts != null && (edgeStyle == null && handle == null || edgeStyle == mxEdgeStyle.OrthConnector)) {
                        handle = start.handle;
                        if (handle == null) {
                          var box = new mxRectangle(start.point.x, start.point.y);
                          box.grow(mxEdgeHandler2.prototype.handleImage.width / 2);
                          if (contains(box, pts[0].x, pts[0].y)) {
                            handle = 0;
                          } else if (contains(box, pts[pts.length - 1].x, pts[pts.length - 1].y)) {
                            handle = handler.bends.length - 1;
                          } else {
                            var nobends = edgeStyle != null && (pts.length == 2 || pts.length == 3 && (Math.round(pts[0].x - pts[1].x) == 0 && Math.round(pts[1].x - pts[2].x) == 0 || Math.round(pts[0].y - pts[1].y) == 0 && Math.round(pts[1].y - pts[2].y) == 0));
                            if (nobends) {
                              handle = 2;
                            } else {
                              handle = findNearestSegment(state2, start.point.x, start.point.y);
                              if (edgeStyle == null) {
                                handle = mxEvent2.VIRTUAL_HANDLE - handle;
                              } else {
                                handle += 1;
                              }
                            }
                          }
                        }
                      }
                      if (handle == null) {
                        handle = mxEvent2.VIRTUAL_HANDLE;
                      }
                    }
                    handler.start(me.getGraphX(), me.getGraphX(), handle);
                    me.consume();
                    this.graphHandler.reset();
                  }
                } else if (entity && (state2.visibleSourceState != null || state2.visibleTargetState != null)) {
                  this.graphHandler.reset();
                  me.consume();
                }
              }
              if (handler != null) {
                if (this.selectionCellsHandler.isHandlerActive(handler)) {
                  if (!this.isCellSelected(state2.cell)) {
                    this.selectionCellsHandler.handlers.put(state2.cell, handler);
                    this.selectCellForEvent(state2.cell, me.getEvent());
                  }
                } else if (!this.isCellSelected(state2.cell)) {
                  handler.destroy();
                }
              }
              start.selected = false;
              start.handle = null;
              start.state = null;
              start.event = null;
              start.point = null;
            }
          } else {
            var state2 = me.getState();
            if (state2 != null) {
              var cursor = null;
              if (this.model.isEdge(state2.cell)) {
                var box = new mxRectangle(me.getGraphX(), me.getGraphY());
                box.grow(mxEdgeHandler2.prototype.handleImage.width / 2);
                var pts = state2.absolutePoints;
                if (pts != null) {
                  if (state2.text != null && state2.text.boundingBox != null && contains(state2.text.boundingBox, me.getGraphX(), me.getGraphY())) {
                    cursor = "move";
                  } else if (contains(box, pts[0].x, pts[0].y) || contains(box, pts[pts.length - 1].x, pts[pts.length - 1].y)) {
                    cursor = "pointer";
                  } else if (state2.visibleSourceState != null || state2.visibleTargetState != null) {
                    var tmp = this.view.getEdgeStyle(state2);
                    cursor = "crosshair";
                    if (tmp != mxEdgeStyle.EntityRelation && this.isOrthogonal(state2)) {
                      var idx = findNearestSegment(state2, me.getGraphX(), me.getGraphY());
                      if (idx < pts.length - 1 && idx >= 0) {
                        cursor = Math.round(pts[idx].x - pts[idx + 1].x) == 0 ? "col-resize" : "row-resize";
                      }
                    }
                  }
                }
              } else if (!mxEvent2.isControlDown(me.getEvent())) {
                var box = new mxRectangle(me.getGraphX() - 1, me.getGraphY() - 1);
                box.grow(mxShape.prototype.svgStrokeTolerance / 2);
                if (this.isTableCell(state2.cell)) {
                  var row = this.model.getParent(state2.cell);
                  var table = this.model.getParent(row);
                  if (!this.isCellSelected(table)) {
                    if (intersects(box, new mxRectangle(state2.x - 2, state2.y, 2, state2.height)) && this.model.getChildAt(row, 0) != state2.cell || intersects(box, new mxRectangle(state2.x + state2.width - 2, state2.y, 2, state2.height))) {
                      cursor = "col-resize";
                    } else if (intersects(box, new mxRectangle(state2.x, state2.y - 2, state2.width, 3)) && this.model.getChildAt(table, 0) != row || intersects(box, new mxRectangle(state2.x, state2.y + state2.height - 2, state2.width, 3))) {
                      cursor = "row-resize";
                    }
                  }
                }
                var current2 = state2;
                while (cursor == null && current2 != null && (this.isTableCell(current2.cell) || this.isTableRow(current2.cell) || this.isTable(current2.cell))) {
                  if (this.isSwimlane(current2.cell)) {
                    var offset = this.getActualStartSize(current2.cell);
                    var s = this.view.scale;
                    if ((offset.x > 0 || offset.width > 0) && intersects(box, new mxRectangle(current2.x + (offset.x - offset.width - 1) * s + (offset.x == 0 ? current2.width * s : 0), current2.y, 1, current2.height))) {
                      cursor = "col-resize";
                    } else if ((offset.y > 0 || offset.height > 0) && intersects(box, new mxRectangle(current2.x, current2.y + (offset.y - offset.height - 1) * s + (offset.y == 0 ? current2.height : 0), current2.width, 1))) {
                      cursor = "row-resize";
                    }
                  }
                  current2 = this.view.getState(this.model.getParent(current2.cell));
                }
              }
              if (cursor != null) {
                state2.setCursor(cursor);
              }
            }
          }
        }
      }),
      mouseUp: bind(this, function(sender, me) {
        start.state = null;
        start.event = null;
        start.point = null;
        start.handle = null;
      })
    });
  }
  this.cellRenderer.getLabelValue = function(state2) {
    var result2 = mxCellRenderer2.prototype.getLabelValue.apply(this, arguments);
    if (state2.view.graph.isHtmlLabel(state2.cell)) {
      if (state2.style["html"] != 1) {
        result2 = htmlEntities(result2, false);
      } else {
        result2 = state2.view.graph.sanitizeHtml(result2);
      }
    }
    return result2;
  };
  if (typeof mxVertexHandler2 !== "undefined") {
    this.setConnectable(true);
    this.setDropEnabled(true);
    this.setPanning(true);
    this.setTooltips(true);
    this.setAllowLoops(false);
    this.allowAutoPanning = true;
    this.resetEdgesOnConnect = false;
    this.constrainChildren = false;
    this.constrainRelativeChildren = true;
    this.graphHandler.scrollOnMove = false;
    this.graphHandler.scaleGrid = true;
    this.graphHandler.livePreview = true;
    this.connectionHandler.setCreateTarget(false);
    this.connectionHandler.insertBeforeSource = true;
    this.connectionHandler.isValidSource = function(cell2, me) {
      return false;
    };
    this.alternateEdgeStyle = "vertical";
    if (stylesheet == null) {
      this.loadStylesheet();
    }
    mxDragSource.prototype.dragElementZIndex = mxPopupMenu.prototype.zIndex;
    mxGuide.prototype.getGuideColor = function(state2, horizontal) {
      return state2.cell == null ? "#ffa500" : mxConstants2.GUIDE_COLOR;
    };
    var graphHandlerGetCells = this.graphHandler.getCells;
    this.graphHandler.getCells = function(initialCell) {
      var cells = graphHandlerGetCells.apply(this, arguments);
      var lookup = new mxDictionary();
      var newCells = [];
      for (var i = 0; i < cells.length; i++) {
        var cell2 = this.graph.isTableCell(initialCell) && this.graph.isTableCell(cells[i]) && this.graph.isCellSelected(cells[i]) ? this.graph.model.getParent(cells[i]) : this.graph.isTableRow(initialCell) && this.graph.isTableRow(cells[i]) && this.graph.isCellSelected(cells[i]) ? cells[i] : this.graph.getCompositeParent(cells[i]);
        if (cell2 != null && !lookup.get(cell2)) {
          lookup.put(cell2, true);
          newCells.push(cell2);
        }
      }
      return newCells;
    };
    var graphHandlerStart = this.graphHandler.start;
    this.graphHandler.start = function(cell2, x, y, cells) {
      var ignoreParent = false;
      if (this.graph.isTableCell(cell2)) {
        if (!this.graph.isCellSelected(cell2)) {
          cell2 = this.graph.model.getParent(cell2);
        } else {
          ignoreParent = true;
        }
      }
      if (!ignoreParent && (!this.graph.isTableRow(cell2) || !this.graph.isCellSelected(cell2))) {
        cell2 = this.graph.getCompositeParent(cell2);
      }
      graphHandlerStart.apply(this, arguments);
    };
    this.connectionHandler.createTargetVertex = function(evt, source) {
      source = this.graph.getCompositeParent(source);
      return mxConnectionHandler.prototype.createTargetVertex.apply(this, arguments);
    };
    var rubberband = new mxRubberband(this);
    this.getRubberband = function() {
      return rubberband;
    };
    var startTime = new Date().getTime();
    var timeOnTarget = 0;
    const connectionHandlerMouseMove = this.connectionHandler.mouseMove;
    this.connectionHandler.mouseMove = function() {
      var prev = this.currentState;
      connectionHandlerMouseMove.apply(this, arguments);
      if (prev != this.currentState) {
        startTime = new Date().getTime();
        timeOnTarget = 0;
      } else {
        timeOnTarget = new Date().getTime() - startTime;
      }
    };
    const connectionHandleIsOutlineConnectEvent = this.connectionHandler.isOutlineConnectEvent;
    this.connectionHandler.isOutlineConnectEvent = function(me) {
      return this.currentState != null && me.getState() == this.currentState && timeOnTarget > 2e3 || (this.currentState == null || getValue(this.currentState.style, "outlineConnect", "1") != "0") && connectionHandleIsOutlineConnectEvent.apply(this, arguments);
    };
    var isToggleEvent = this.isToggleEvent;
    this.isToggleEvent = function(evt) {
      return isToggleEvent.apply(this, arguments) || !mxClient_default.IS_CHROMEOS && mxEvent2.isShiftDown(evt);
    };
    var isForceRubberBandEvent = rubberband.isForceRubberbandEvent;
    rubberband.isForceRubberbandEvent = function(me) {
      return isForceRubberBandEvent.apply(this, arguments) && !mxEvent2.isShiftDown(me.getEvent()) && !mxEvent2.isControlDown(me.getEvent()) || mxClient_default.IS_CHROMEOS && mxEvent2.isShiftDown(me.getEvent()) || hasScrollbars(this.graph.container) && mxClient_default.IS_FF && mxClient_default.IS_WIN && me.getState() == null && mxEvent2.isTouchEvent(me.getEvent());
    };
    var prevCursor = null;
    this.panningHandler.addListener(mxEvent2.PAN_START, bind(this, function() {
      if (this.isEnabled()) {
        prevCursor = this.container.style.cursor;
        this.container.style.cursor = "move";
      }
    }));
    this.panningHandler.addListener(mxEvent2.PAN_END, bind(this, function() {
      if (this.isEnabled()) {
        this.container.style.cursor = prevCursor;
      }
    }));
    this.popupMenuHandler.autoExpand = true;
    this.popupMenuHandler.isSelectOnPopup = function(me) {
      return mxEvent2.isMouseEvent(me.getEvent());
    };
    var click = this.click;
    this.click = function(me) {
      var locked = me.state == null && me.sourceState != null && this.isCellLocked(me.sourceState.cell);
      if ((!this.isEnabled() || locked) && !me.isConsumed()) {
        var cell2 = locked ? me.sourceState.cell : me.getCell();
        if (cell2 != null) {
          var link2 = this.getClickableLinkForCell(cell2);
          if (link2 != null) {
            if (this.isCustomLink(link2)) {
              this.customLinkClicked(link2);
            } else {
              this.openLink(link2);
            }
          }
        }
        if (this.isEnabled() && locked) {
          this.clearSelection();
        }
      } else {
        return click.apply(this, arguments);
      }
    };
    this.tooltipHandler.getStateForEvent = function(me) {
      return me.sourceState;
    };
    var tooltipHandlerShow = this.tooltipHandler.show;
    this.tooltipHandler.show = function() {
      tooltipHandlerShow.apply(this, arguments);
      if (this.div != null) {
        var links = this.div.getElementsByTagName("a");
        for (var i = 0; i < links.length; i++) {
          if (links[i].getAttribute("href") != null && links[i].getAttribute("target") == null) {
            links[i].setAttribute("target", "_blank");
          }
        }
      }
    };
    this.tooltipHandler.getStateForEvent = function(me) {
      return me.sourceState;
    };
    var getCursorForMouseEvent = this.getCursorForMouseEvent;
    this.getCursorForMouseEvent = function(me) {
      var locked = me.state == null && me.sourceState != null && this.isCellLocked(me.sourceState.cell);
      return this.getCursorForCell(locked ? me.sourceState.cell : me.getCell());
    };
    var getCursorForCell = this.getCursorForCell;
    this.getCursorForCell = function(cell2) {
      if (!this.isEnabled() || this.isCellLocked(cell2)) {
        var link2 = this.getClickableLinkForCell(cell2);
        if (link2 != null) {
          return "pointer";
        } else if (this.isCellLocked(cell2)) {
          return "default";
        }
      }
      return getCursorForCell.apply(this, arguments);
    };
    this.selectRegion = function(rect, evt) {
      var cells = this.getCells(rect.x, rect.y, rect.width, rect.height, null, null, null, function(state2) {
        return getValue(state2.style, "locked", "0") == "1";
      }, true);
      this.selectCellsForEvent(cells, evt);
      return cells;
    };
    var graphHandlerShouldRemoveCellsFromParent = this.graphHandler.shouldRemoveCellsFromParent;
    this.graphHandler.shouldRemoveCellsFromParent = function(parent2, cells, evt) {
      if (this.graph.isCellSelected(parent2)) {
        return false;
      }
      return graphHandlerShouldRemoveCellsFromParent.apply(this, arguments);
    };
    this.isCellLocked = function(cell2) {
      var pState = this.view.getState(cell2);
      while (pState != null) {
        if (getValue(pState.style, "locked", "0") == "1") {
          return true;
        }
        pState = this.view.getState(this.model.getParent(pState.cell));
      }
      return false;
    };
    var tapAndHoldSelection = null;
    this.addListener(mxEvent2.FIRE_MOUSE_EVENT, bind(this, function(sender, evt) {
      if (evt.getProperty("eventName") == "mouseDown") {
        var me = evt.getProperty("event");
        var state2 = me.getState();
        if (state2 != null && !this.isSelectionEmpty() && !this.isCellSelected(state2.cell)) {
          tapAndHoldSelection = this.getSelectionCells();
        } else {
          tapAndHoldSelection = null;
        }
      }
    }));
    this.addListener(mxEvent2.TAP_AND_HOLD, bind(this, function(sender, evt) {
      if (!mxEvent2.isMultiTouchEvent(evt)) {
        var me = evt.getProperty("event");
        var cell2 = evt.getProperty("cell");
        if (cell2 == null) {
          var pt = convertPoint(this.container, mxEvent2.getClientX(me), mxEvent2.getClientY(me));
          rubberband.start(pt.x, pt.y);
        } else if (tapAndHoldSelection != null) {
          this.addSelectionCells(tapAndHoldSelection);
        } else if (this.getSelectionCount() > 1 && this.isCellSelected(cell2)) {
          this.removeSelectionCell(cell2);
        }
        tapAndHoldSelection = null;
        evt.consume();
      }
    }));
    this.connectionHandler.selectCells = function(edge, target) {
      this.graph.setSelectionCell(target || edge);
    };
    this.connectionHandler.constraintHandler.isStateIgnored = function(state2, source) {
      var graph = state2.view.graph;
      return source && (graph.isCellSelected(state2.cell) || graph.isTableRow(state2.cell) && graph.selectionCellsHandler.isHandled(graph.model.getParent(state2.cell)));
    };
    this.selectionModel.addListener(mxEvent2.CHANGE, bind(this, function() {
      var ch = this.connectionHandler.constraintHandler;
      if (ch.currentFocus != null && ch.isStateIgnored(ch.currentFocus, true)) {
        ch.currentFocus = null;
        ch.constraints = null;
        ch.destroyIcons();
      }
      ch.destroyFocusHighlight();
    }));
    if (Graph2.touchStyle) {
      this.initTouch();
    }
    var graphUpdateMouseEvent = this.updateMouseEvent;
    this.updateMouseEvent = function(me) {
      me = graphUpdateMouseEvent.apply(this, arguments);
      if (me.state != null && this.isCellLocked(me.getCell())) {
        me.state = null;
      }
      return me;
    };
  }
  this.currentTranslate = new mxPoint2(0, 0);
};
Graph2.touchStyle = mxClient_default.IS_TOUCH || mxClient_default.IS_FF && mxClient_default.IS_WIN || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 || window.urlParams == null || urlParams2["touch"] == "1";
Graph2.fileSupport = window.File != null && window.FileReader != null && window.FileList != null && (window.urlParams == null || urlParams2["filesupport"] != "0");
Graph2.translateDiagram = urlParams2["translate-diagram"] == "1";
Graph2.diagramLanguage = urlParams2["diagram-language"] != null ? urlParams2["diagram-language"] : mxClient_default.language;
Graph2.lineJumpsEnabled = true;
Graph2.defaultJumpSize = 6;
Graph2.minTableColumnWidth = 20;
Graph2.minTableRowHeight = 20;
Graph2.foreignObjectWarningText = "Viewer does not support full SVG 1.1";
Graph2.foreignObjectWarningLink = "https://desk.draw.io/support/solutions/articles/16000042487";
Graph2.pasteStyles = [
  "rounded",
  "shadow",
  "dashed",
  "dashPattern",
  "fontFamily",
  "fontSource",
  "fontSize",
  "fontColor",
  "fontStyle",
  "align",
  "verticalAlign",
  "strokeColor",
  "strokeWidth",
  "fillColor",
  "gradientColor",
  "swimlaneFillColor",
  "textOpacity",
  "gradientDirection",
  "glass",
  "labelBackgroundColor",
  "labelBorderColor",
  "opacity",
  "spacing",
  "spacingTop",
  "spacingLeft",
  "spacingBottom",
  "spacingRight",
  "endFill",
  "endArrow",
  "endSize",
  "targetPerimeterSpacing",
  "startFill",
  "startArrow",
  "startSize",
  "sourcePerimeterSpacing",
  "arcSize",
  "comic",
  "sketch",
  "fillWeight",
  "hachureGap",
  "hachureAngle",
  "jiggle",
  "disableMultiStroke",
  "disableMultiStrokeFill",
  "fillStyle",
  "curveFitting",
  "simplification",
  "comicStyle"
];
Graph2.createSvgImage = function(w2, h2, data, coordWidth, coordHeight) {
  var tmp = unescape(encodeURIComponent('<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="' + w2 + 'px" height="' + h2 + 'px" ' + (coordWidth != null && coordHeight != null ? 'viewBox="0 0 ' + coordWidth + " " + coordHeight + '" ' : "") + 'version="1.1">' + data + "</svg>"));
  return new mxImage2("data:image/svg+xml;base64," + (window.btoa ? btoa(tmp) : Base64.encode(tmp, true)), w2, h2);
};
Graph2.zapGremlins = function(text) {
  var lastIndex = 0;
  var checked = [];
  for (var i = 0; i < text.length; i++) {
    var code = text.charCodeAt(i);
    if (!((code >= 32 || code == 9 || code == 10 || code == 13) && code != 65535 && code != 65534)) {
      checked.push(text.substring(lastIndex, i));
      lastIndex = i + 1;
    }
  }
  if (lastIndex > 0 && lastIndex < text.length) {
    checked.push(text.substring(lastIndex));
  }
  return checked.length == 0 ? text : checked.join("");
};
Graph2.stringToBytes = function(str) {
  var arr = new Array(str.length);
  for (var i = 0; i < str.length; i++) {
    arr[i] = str.charCodeAt(i);
  }
  return arr;
};
Graph2.bytesToString = function(arr) {
  var result2 = new Array(arr.length);
  for (var i = 0; i < arr.length; i++) {
    result2[i] = String.fromCharCode(arr[i]);
  }
  return result2.join("");
};
Graph2.base64EncodeUnicode = function(str) {
  return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function(match2, p1) {
    return String.fromCharCode(parseInt(p1, 16));
  }));
};
Graph2.base64DecodeUnicode = function(str) {
  return decodeURIComponent(Array.prototype.map.call(atob(str), function(c) {
    return "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2);
  }).join(""));
};
Graph2.compressNode = function(node, checked) {
  var xml2 = getXml(node);
  return Graph2.compress(checked ? xml2 : Graph2.zapGremlins(xml2));
};
Graph2.compress = function(data, deflate) {
  if (data == null || data.length == 0 || typeof pako === "undefined") {
    return data;
  } else {
    var tmp = deflate ? pako.deflate(encodeURIComponent(data), { to: "string" }) : pako.deflateRaw(encodeURIComponent(data), { to: "string" });
    return window.btoa ? btoa(tmp) : Base64.encode(tmp, true);
  }
};
Graph2.decompress = function(data, inflate, checked) {
  if (data == null || data.length == 0 || typeof pako === "undefined") {
    return data;
  } else {
    var tmp = window.atob ? atob(data) : Base64.decode(data, true);
    var inflated = decodeURIComponent(inflate ? pako.inflate(tmp, { to: "string" }) : pako.inflateRaw(tmp, { to: "string" }));
    return checked ? inflated : Graph2.zapGremlins(inflated);
  }
};
Graph2.removePasteFormatting = function(elt) {
  while (elt != null) {
    if (elt.firstChild != null) {
      Graph2.removePasteFormatting(elt.firstChild);
    }
    if (elt.nodeType == mxConstants2.NODETYPE_ELEMENT && elt.style != null) {
      elt.style.whiteSpace = "";
      if (elt.style.color == "#000000") {
        elt.style.color = "";
      }
    }
    elt = elt.nextSibling;
  }
};
Graph2.sanitizeHtml = function(value) {
  if (typeof DOMPurify === "undefined" || typeof DOMPurify.sanitize !== "function") {
    console.error("DOMPurify is not available. Cannot sanitize HTML.");
    return value;
  }
  const cleanHtml = DOMPurify.sanitize(value, {});
  return cleanHtml;
};
Graph2.stripQuotes = function(text) {
  if (text != null) {
    if (text.charAt(0) == "'") {
      text = text.substring(1);
    }
    if (text.charAt(text.length - 1) == "'") {
      text = text.substring(0, text.length - 1);
    }
    if (text.charAt(0) == '"') {
      text = text.substring(1);
    }
    if (text.charAt(text.length - 1) == '"') {
      text = text.substring(0, text.length - 1);
    }
  }
  return text;
};
Graph2.isLink = function(text) {
  return text != null && Graph2.linkPattern.test(text);
};
Graph2.linkPattern = new RegExp("^(https?:\\/\\/)?((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|((\\d{1,3}\\.){3}\\d{1,3}))(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*(\\?[;&a-z\\d%_.~+=-]*)?(\\#[-a-z\\d_]*)?$", "i");
extend(Graph2, mxGraph2);
Graph2.prototype.minFitScale = null;
Graph2.prototype.maxFitScale = null;
Graph2.prototype.linkPolicy = urlParams2["target"] == "frame" ? "blank" : urlParams2["target"] || "auto";
Graph2.prototype.linkTarget = urlParams2["target"] == "frame" ? "_self" : "_blank";
Graph2.prototype.linkRelation = "nofollow noopener noreferrer";
Graph2.prototype.defaultScrollbars = !mxClient_default.IS_IOS;
Graph2.prototype.defaultPageVisible = true;
Graph2.prototype.lightbox = false;
Graph2.prototype.defaultPageBackgroundColor = "#ffffff";
Graph2.prototype.defaultPageBorderColor = "#ffffff";
Graph2.prototype.scrollTileSize = new mxRectangle(0, 0, 400, 400);
Graph2.prototype.transparentBackground = true;
Graph2.prototype.selectParentAfterDelete = false;
Graph2.prototype.defaultEdgeLength = 80;
Graph2.prototype.edgeMode = false;
Graph2.prototype.connectionArrowsEnabled = true;
Graph2.prototype.placeholderPattern = new RegExp("%(date{.*}|[^%^{^}]+)%", "g");
Graph2.prototype.absoluteUrlPattern = new RegExp("^(?:[a-z]+:)?//", "i");
Graph2.prototype.defaultThemeName = "default";
Graph2.prototype.defaultThemes = {};
Graph2.prototype.baseUrl = urlParams2["base"] != null ? decodeURIComponent(urlParams2["base"]) : (window != window.top ? document.referrer : document.location.toString()).split("#")[0];
Graph2.prototype.editAfterInsert = false;
Graph2.prototype.builtInProperties = [
  "label",
  "tooltip",
  "placeholders",
  "placeholder"
];
Graph2.prototype.standalone = false;
Graph2.prototype.init = function(container) {
  mxGraph2.prototype.init.apply(this, arguments);
  this.cellRenderer.initializeLabel = function(state2, shape) {
    mxCellRenderer2.prototype.initializeLabel.apply(this, arguments);
    var tol = state2.view.graph.tolerance;
    var handleClick = true;
    var first = null;
    var down = bind(this, function(evt) {
      handleClick = true;
      first = new mxPoint2(mxEvent2.getClientX(evt), mxEvent2.getClientY(evt));
    });
    var move = bind(this, function(evt) {
      handleClick = handleClick && first != null && Math.abs(first.x - mxEvent2.getClientX(evt)) < tol && Math.abs(first.y - mxEvent2.getClientY(evt)) < tol;
    });
    var up = bind(this, function(evt) {
      if (handleClick) {
        var elt = mxEvent2.getSource(evt);
        while (elt != null && elt != shape.node) {
          if (elt.nodeName.toLowerCase() == "a") {
            state2.view.graph.labelLinkClicked(state2, elt, evt);
            break;
          }
          elt = elt.parentNode;
        }
      }
    });
    mxEvent2.addGestureListeners(shape.node, down, move, up);
    mxEvent2.addListener(shape.node, "click", function(evt) {
      mxEvent2.consume(evt);
    });
  };
  this.initLayoutManager();
};
Graph2.prototype.useCssTransforms = false;
Graph2.prototype.currentScale = 1;
Graph2.prototype.currentTranslate = new mxPoint2(0, 0);
Graph2.prototype.getVerticesAndEdges = function(vertices, edges) {
  vertices = vertices != null ? vertices : true;
  edges = edges != null ? edges : true;
  var model = this.model;
  return model.filterDescendants(function(cell2) {
    return vertices && model.isVertex(cell2) || edges && model.isEdge(cell2);
  }, model.getRoot());
};
Graph2.prototype.getStartEditingCell = function(cell2, trigger) {
  var style = this.getCellStyle(cell2);
  var size = parseInt(getValue(style, mxConstants2.STYLE_STARTSIZE, 0));
  if (this.isTable(cell2) && (!this.isSwimlane(cell2) || size == 0) && this.getLabel(cell2) == "" && this.model.getChildCount(cell2) > 0) {
    cell2 = this.model.getChildAt(cell2, 0);
    style = this.getCellStyle(cell2);
    size = parseInt(getValue(style, mxConstants2.STYLE_STARTSIZE, 0));
  }
  if (this.isTableRow(cell2) && (!this.isSwimlane(cell2) || size == 0) && this.getLabel(cell2) == "" && this.model.getChildCount(cell2) > 0) {
    for (var i = 0; i < this.model.getChildCount(cell2); i++) {
      var temp2 = this.model.getChildAt(cell2, i);
      if (this.isCellEditable(temp2)) {
        cell2 = temp2;
        break;
      }
    }
  }
  return cell2;
};
Graph2.prototype.copyStyle = function(cell2) {
  var style = null;
  if (cell2 != null) {
    style = clone(this.getCurrentCellStyle(cell2));
    var cellStyle = this.model.getStyle(cell2);
    var tokens = cellStyle != null ? cellStyle.split(";") : [];
    for (var j = 0; j < tokens.length; j++) {
      var tmp = tokens[j];
      var pos = tmp.indexOf("=");
      if (pos >= 0) {
        var key = tmp.substring(0, pos);
        var value = tmp.substring(pos + 1);
        if (style[key] == null && value == mxConstants2.NONE) {
          style[key] = mxConstants2.NONE;
        }
      }
    }
  }
  return style;
};
Graph2.prototype.pasteStyle = function(style, cells, keys) {
  keys = keys != null ? keys : Graph2.pasteStyles;
  this.model.beginUpdate();
  try {
    for (var i = 0; i < cells.length; i++) {
      var temp2 = this.getCurrentCellStyle(cells[i]);
      for (var j = 0; j < keys.length; j++) {
        var current2 = temp2[keys[j]];
        var value = style[keys[j]];
        if (current2 != value && (current2 != null || value != mxConstants2.NONE)) {
          this.setCellStyles(keys[j], value, [cells[i]]);
        }
      }
    }
  } finally {
    this.model.endUpdate();
  }
};
Graph2.prototype.isFastZoomEnabled = function() {
  return urlParams2["zoom"] != "nocss" && !mxClient_default.NO_FO && !mxClient_default.IS_EDGE && !this.useCssTransforms && this.isCssTransformsSupported();
};
Graph2.prototype.isCssTransformsSupported = function() {
  return this.dialect == mxConstants2.DIALECT_SVG && !mxClient_default.NO_FO && (!this.lightbox || !mxClient_default.IS_SF);
};
Graph2.prototype.getCellAt = function(x, y, parent2, vertices, edges, ignoreFn) {
  if (this.useCssTransforms) {
    x = x / this.currentScale - this.currentTranslate.x;
    y = y / this.currentScale - this.currentTranslate.y;
  }
  return this.getScaledCellAt.apply(this, arguments);
};
Graph2.prototype.getScaledCellAt = function(x, y, parent2, vertices, edges, ignoreFn) {
  vertices = vertices != null ? vertices : true;
  edges = edges != null ? edges : true;
  if (parent2 == null) {
    parent2 = this.getCurrentRoot();
    if (parent2 == null) {
      parent2 = this.getModel().getRoot();
    }
  }
  if (parent2 != null) {
    var childCount = this.model.getChildCount(parent2);
    for (var i = childCount - 1; i >= 0; i--) {
      var cell2 = this.model.getChildAt(parent2, i);
      var result2 = this.getScaledCellAt(x, y, cell2, vertices, edges, ignoreFn);
      if (result2 != null) {
        return result2;
      } else if (this.isCellVisible(cell2) && (edges && this.model.isEdge(cell2) || vertices && this.model.isVertex(cell2))) {
        var state2 = this.view.getState(cell2);
        if (state2 != null && (ignoreFn == null || !ignoreFn(state2, x, y)) && this.intersects(state2, x, y)) {
          return cell2;
        }
      }
    }
  }
  return null;
};
Graph2.prototype.isRecursiveVertexResize = function(state2) {
  return !this.isSwimlane(state2.cell) && this.model.getChildCount(state2.cell) > 0 && !this.isCellCollapsed(state2.cell) && getValue(state2.style, "recursiveResize", "1") == "1" && getValue(state2.style, "childLayout", null) == null;
};
Graph2.prototype.isPart = function(cell2) {
  return getValue(this.getCurrentCellStyle(cell2), "part", "0") == "1" || this.isTableCell(cell2) || this.isTableRow(cell2);
};
Graph2.prototype.getCompositeParent = function(cell2) {
  while (this.isPart(cell2)) {
    var temp2 = this.model.getParent(cell2);
    if (!this.model.isVertex(temp2)) {
      break;
    }
    cell2 = temp2;
  }
  return cell2;
};
mxCellHighlight2.prototype.getStrokeWidth = function(state2) {
  var s = this.strokeWidth;
  if (this.graph.useCssTransforms) {
    s /= this.graph.currentScale;
  }
  return s;
};
mxGraphView.prototype.getGraphBounds = function() {
  var b = this.graphBounds;
  if (this.graph.useCssTransforms) {
    var t = this.graph.currentTranslate;
    var s = this.graph.currentScale;
    b = new mxRectangle((b.x + t.x) * s, (b.y + t.y) * s, b.width * s, b.height * s);
  }
  return b;
};
mxGraphView.prototype.viewStateChanged = function() {
  if (this.graph.useCssTransforms) {
    this.validate();
    this.graph.sizeDidChange();
  } else {
    this.revalidate();
    this.graph.sizeDidChange();
  }
};
var graphViewValidate = mxGraphView.prototype.validate;
mxGraphView.prototype.validate = function(cell2) {
  if (this.graph.useCssTransforms) {
    this.graph.currentScale = this.scale;
    this.graph.currentTranslate.x = this.translate.x;
    this.graph.currentTranslate.y = this.translate.y;
    this.scale = 1;
    this.translate.x = 0;
    this.translate.y = 0;
  }
  graphViewValidate.apply(this, arguments);
  if (this.graph.useCssTransforms) {
    this.graph.updateCssTransform();
    this.scale = this.graph.currentScale;
    this.translate.x = this.graph.currentTranslate.x;
    this.translate.y = this.graph.currentTranslate.y;
  }
};
var graphGetCellsForGroup = mxGraph2.prototype.getCellsForGroup;
Graph2.prototype.getCellsForGroup = function(cells) {
  cells = graphGetCellsForGroup.apply(this, arguments);
  var result2 = [];
  for (var i = 0; i < cells.length; i++) {
    if (!this.isTableRow(cells[i]) && !this.isTableCell(cells[i])) {
      result2.push(cells[i]);
    }
  }
  return result2;
};
var graphGetCellsForUngroup = mxGraph2.prototype.getCellsForUngroup;
Graph2.prototype.getCellsForUngroup = function(cells) {
  cells = graphGetCellsForUngroup.apply(this, arguments);
  var result2 = [];
  for (var i = 0; i < cells.length; i++) {
    if (!this.isTable(cells[i]) && !this.isTableRow(cells[i]) && !this.isTableCell(cells[i])) {
      result2.push(cells[i]);
    }
  }
  return result2;
};
Graph2.prototype.updateCssTransform = function() {
  var temp2 = this.view.getDrawPane();
  if (temp2 != null) {
    var g = temp2.parentNode;
    if (!this.useCssTransforms) {
      g.removeAttribute("transformOrigin");
      g.removeAttribute("transform");
    } else {
      var prev = g.getAttribute("transform");
      g.setAttribute("transformOrigin", "0 0");
      var s = Math.round(this.currentScale * 100) / 100;
      var dx = Math.round(this.currentTranslate.x * 100) / 100;
      var dy = Math.round(this.currentTranslate.y * 100) / 100;
      g.setAttribute("transform", "scale(" + s + "," + s + ")translate(" + dx + "," + dy + ")");
      if (prev != g.getAttribute("transform")) {
        try {
          if (mxClient_default.IS_EDGE) {
            var val = g.style.display;
            g.style.display = "none";
            g.getBBox();
            g.style.display = val;
          }
        } catch (e) {
        }
      }
    }
  }
};
var graphViewValidateBackgroundPage = mxGraphView.prototype.validateBackgroundPage;
mxGraphView.prototype.validateBackgroundPage = function() {
  var useCssTranforms = this.graph.useCssTransforms, scale = this.scale, translate = this.translate;
  if (useCssTranforms) {
    this.scale = this.graph.currentScale;
    this.translate = this.graph.currentTranslate;
  }
  graphViewValidateBackgroundPage.apply(this, arguments);
  if (useCssTranforms) {
    this.scale = scale;
    this.translate = translate;
  }
};
var graphUpdatePageBreaks = mxGraph2.prototype.updatePageBreaks;
mxGraph2.prototype.updatePageBreaks = function(visible, width, height) {
  var useCssTranforms = this.useCssTransforms, scale = this.view.scale, translate = this.view.translate;
  if (useCssTranforms) {
    this.view.scale = 1;
    this.view.translate = new mxPoint2(0, 0);
    this.useCssTransforms = false;
  }
  graphUpdatePageBreaks.apply(this, arguments);
  if (useCssTranforms) {
    this.view.scale = scale;
    this.view.translate = translate;
    this.useCssTransforms = true;
  }
};
Graph2.prototype.isLightboxView = function() {
  return this.lightbox;
};
Graph2.prototype.isViewer = function() {
  return false;
};
Graph2.prototype.labelLinkClicked = function(state2, elt, evt) {
  var href = elt.getAttribute("href");
  if (href != null && !this.isCustomLink(href) && (mxEvent2.isLeftMouseButton(evt) && !mxEvent2.isPopupTrigger(evt) || mxEvent2.isTouchEvent(evt))) {
    if (!this.isEnabled() || this.isCellLocked(state2.cell)) {
      var target = this.isBlankLink(href) ? this.linkTarget : "_top";
      this.openLink(this.getAbsoluteUrl(href), target);
    }
    mxEvent2.consume(evt);
  }
};
Graph2.prototype.openLink = function(href, target, allowOpener) {
  var result2 = window;
  try {
    if (target == "_self" && window != window.top) {
      window.location.href = href;
    } else {
      if (href.substring(0, this.baseUrl.length) == this.baseUrl && href.charAt(this.baseUrl.length) == "#" && target == "_top" && window == window.top) {
        var hash = href.split("#")[1];
        if (window.location.hash == "#" + hash) {
          window.location.hash = "";
        }
        window.location.hash = hash;
      } else {
        result2 = window.open(href, target != null ? target : "_blank");
        if (result2 != null && !allowOpener) {
          result2.opener = null;
        }
      }
    }
  } catch (e) {
  }
  return result2;
};
Graph2.prototype.getLinkTitle = function(href) {
  return href.substring(href.lastIndexOf("/") + 1);
};
Graph2.prototype.isCustomLink = function(href) {
  return href.substring(0, 5) == "data:";
};
Graph2.prototype.customLinkClicked = function(link2) {
  return false;
};
Graph2.prototype.isExternalProtocol = function(href) {
  return href.substring(0, 7) === "mailto:";
};
Graph2.prototype.isBlankLink = function(href) {
  return !this.isExternalProtocol(href) && (this.linkPolicy === "blank" || this.linkPolicy !== "self" && !this.isRelativeUrl(href) && href.substring(0, this.domainUrl.length) !== this.domainUrl);
};
Graph2.prototype.isRelativeUrl = function(url) {
  return url != null && !this.absoluteUrlPattern.test(url) && url.substring(0, 5) !== "data:" && !this.isExternalProtocol(url);
};
Graph2.prototype.getAbsoluteUrl = function(url) {
  if (url != null && this.isRelativeUrl(url)) {
    if (url.charAt(0) == "#") {
      url = this.baseUrl + url;
    } else if (url.charAt(0) == "/") {
      url = this.domainUrl + url;
    } else {
      url = this.domainPathUrl + url;
    }
  }
  return url;
};
Graph2.prototype.initLayoutManager = function() {
  this.layoutManager = new mxLayoutManager(this);
  this.layoutManager.hasLayout = function(cell2, eventName) {
    return this.graph.getCellStyle(cell2)["childLayout"] != null;
  };
  this.layoutManager.getLayout = function(cell2, eventName) {
    var parent2 = this.graph.model.getParent(cell2);
    if (eventName != mxEvent2.BEGIN_UPDATE || this.hasLayout(parent2, eventName)) {
      var style = this.graph.getCellStyle(cell2);
      if (style["childLayout"] == "stackLayout") {
        var stackLayout = new mxStackLayout(this.graph, true);
        stackLayout.resizeParentMax = getValue(style, "resizeParentMax", "1") == "1";
        stackLayout.horizontal = getValue(style, "horizontalStack", "1") == "1";
        stackLayout.resizeParent = getValue(style, "resizeParent", "1") == "1";
        stackLayout.resizeLast = getValue(style, "resizeLast", "0") == "1";
        stackLayout.spacing = style["stackSpacing"] || stackLayout.spacing;
        stackLayout.border = style["stackBorder"] || stackLayout.border;
        stackLayout.marginLeft = style["marginLeft"] || 0;
        stackLayout.marginRight = style["marginRight"] || 0;
        stackLayout.marginTop = style["marginTop"] || 0;
        stackLayout.marginBottom = style["marginBottom"] || 0;
        stackLayout.allowGaps = style["allowGaps"] || 0;
        stackLayout.fill = true;
        if (stackLayout.allowGaps) {
          stackLayout.gridSize = parseFloat(getValue(style, "stackUnitSize", 20));
        }
        return stackLayout;
      } else if (style["childLayout"] == "treeLayout") {
        var treeLayout = new mxCompactTreeLayout2(this.graph);
        treeLayout.horizontal = getValue(style, "horizontalTree", "1") == "1";
        treeLayout.resizeParent = getValue(style, "resizeParent", "1") == "1";
        treeLayout.groupPadding = getValue(style, "parentPadding", 20);
        treeLayout.levelDistance = getValue(style, "treeLevelDistance", 30);
        treeLayout.maintainParentLocation = true;
        treeLayout.edgeRouting = false;
        treeLayout.resetEdges = false;
        return treeLayout;
      } else if (style["childLayout"] == "flowLayout") {
        var flowLayout = new mxHierarchicalLayout2(this.graph, getValue(style, "flowOrientation", mxConstants2.DIRECTION_EAST));
        flowLayout.resizeParent = getValue(style, "resizeParent", "1") == "1";
        flowLayout.parentBorder = getValue(style, "parentPadding", 20);
        flowLayout.maintainParentLocation = true;
        flowLayout.intraCellSpacing = getValue(style, "intraCellSpacing", mxHierarchicalLayout2.prototype.intraCellSpacing);
        flowLayout.interRankCellSpacing = getValue(style, "interRankCellSpacing", mxHierarchicalLayout2.prototype.interRankCellSpacing);
        flowLayout.interHierarchySpacing = getValue(style, "interHierarchySpacing", mxHierarchicalLayout2.prototype.interHierarchySpacing);
        flowLayout.parallelEdgeSpacing = getValue(style, "parallelEdgeSpacing", mxHierarchicalLayout2.prototype.parallelEdgeSpacing);
        return flowLayout;
      } else if (style["childLayout"] == "circleLayout") {
        return new mxCircleLayout2(this.graph);
      } else if (style["childLayout"] == "organicLayout") {
        return new mxFastOrganicLayout2(this.graph);
      } else if (style["childLayout"] == "tableLayout") {
        return new TableLayout(this.graph);
      }
    }
    return null;
  };
};
Graph2.prototype.getPageSize = function() {
  return this.pageVisible ? new mxRectangle(0, 0, this.pageFormat.width * this.pageScale, this.pageFormat.height * this.pageScale) : this.scrollTileSize;
};
Graph2.prototype.getPageLayout = function() {
  var size = this.getPageSize();
  var bounds = this.getGraphBounds();
  if (bounds.width == 0 || bounds.height == 0) {
    return new mxRectangle(0, 0, 1, 1);
  } else {
    var x0 = Math.floor(Math.ceil(bounds.x / this.view.scale - this.view.translate.x) / size.width);
    var y0 = Math.floor(Math.ceil(bounds.y / this.view.scale - this.view.translate.y) / size.height);
    var w0 = Math.ceil((Math.floor((bounds.x + bounds.width) / this.view.scale) - this.view.translate.x) / size.width) - x0;
    var h0 = Math.ceil((Math.floor((bounds.y + bounds.height) / this.view.scale) - this.view.translate.y) / size.height) - y0;
    return new mxRectangle(x0, y0, w0, h0);
  }
};
Graph2.prototype.sanitizeHtml = function(value, editing) {
  return Graph2.sanitizeHtml(value, editing);
};
Graph2.prototype.updatePlaceholders = function() {
  var model = this.model;
  var validate = false;
  for (var key in this.model.cells) {
    var cell2 = this.model.cells[key];
    if (this.isReplacePlaceholders(cell2)) {
      this.view.invalidate(cell2, false, false);
      validate = true;
    }
  }
  if (validate) {
    this.view.validate();
  }
};
Graph2.prototype.isReplacePlaceholders = function(cell2) {
  return cell2.value != null && typeof cell2.value == "object" && cell2.value.getAttribute("placeholders") == "1";
};
Graph2.prototype.isZoomWheelEvent = function(evt) {
  return mxEvent2.isAltDown(evt) || mxEvent2.isMetaDown(evt) && mxClient_default.IS_MAC || mxEvent2.isControlDown(evt);
};
Graph2.prototype.isScrollWheelEvent = function(evt) {
  return !this.isZoomWheelEvent(evt);
};
Graph2.prototype.isTransparentClickEvent = function(evt) {
  return mxEvent2.isAltDown(evt) || mxClient_default.IS_CHROMEOS && mxEvent2.isShiftDown(evt);
};
Graph2.prototype.isIgnoreTerminalEvent = function(evt) {
  return mxEvent2.isShiftDown(evt) && mxEvent2.isControlDown(evt);
};
Graph2.prototype.isSplitTarget = function(target, cells, evt) {
  return !this.model.isEdge(cells[0]) && !mxEvent2.isAltDown(evt) && !mxEvent2.isShiftDown(evt) && mxGraph2.prototype.isSplitTarget.apply(this, arguments);
};
Graph2.prototype.getLabel = function(cell2) {
  var result2 = mxGraph2.prototype.getLabel.apply(this, arguments);
  if (result2 != null && this.isReplacePlaceholders(cell2) && cell2.getAttribute("placeholder") == null) {
    result2 = this.replacePlaceholders(cell2, result2);
  }
  return result2;
};
Graph2.prototype.isLabelMovable = function(cell2) {
  var style = this.getCurrentCellStyle(cell2);
  return !this.isCellLocked(cell2) && (this.model.isEdge(cell2) && this.edgeLabelsMovable || this.model.isVertex(cell2) && (this.vertexLabelsMovable || getValue(style, "labelMovable", "0") == "1"));
};
Graph2.prototype.setGridSize = function(value) {
  this.gridSize = value;
  this.fireEvent(new mxEventObject2("gridSizeChanged"));
};
Graph2.prototype.setDefaultParent = function(cell2) {
  this.defaultParent = cell2;
  this.fireEvent(new mxEventObject2("defaultParentChanged"));
};
Graph2.prototype.getClickableLinkForCell = function(cell2) {
  do {
    var link2 = this.getLinkForCell(cell2);
    if (link2 != null) {
      return link2;
    }
    cell2 = this.model.getParent(cell2);
  } while (cell2 != null);
  return null;
};
Graph2.prototype.getGlobalVariable = function(name) {
  var val = null;
  if (name == "date") {
    val = new Date().toLocaleDateString();
  } else if (name == "time") {
    val = new Date().toLocaleTimeString();
  } else if (name == "timestamp") {
    val = new Date().toLocaleString();
  } else if (name.substring(0, 5) == "date{") {
    var fmt = name.substring(5, name.length - 1);
    val = this.formatDate(new Date(), fmt);
  }
  return val;
};
Graph2.prototype.formatDate = function(date, mask, utc) {
  if (this.dateFormatCache == null) {
    this.dateFormatCache = {
      i18n: {
        dayNames: [
          "Sun",
          "Mon",
          "Tue",
          "Wed",
          "Thu",
          "Fri",
          "Sat",
          "Sunday",
          "Monday",
          "Tuesday",
          "Wednesday",
          "Thursday",
          "Friday",
          "Saturday"
        ],
        monthNames: [
          "Jan",
          "Feb",
          "Mar",
          "Apr",
          "May",
          "Jun",
          "Jul",
          "Aug",
          "Sep",
          "Oct",
          "Nov",
          "Dec",
          "January",
          "February",
          "March",
          "April",
          "May",
          "June",
          "July",
          "August",
          "September",
          "October",
          "November",
          "December"
        ]
      },
      masks: {
        default: "ddd mmm dd yyyy HH:MM:ss",
        shortDate: "m/d/yy",
        mediumDate: "mmm d, yyyy",
        longDate: "mmmm d, yyyy",
        fullDate: "dddd, mmmm d, yyyy",
        shortTime: "h:MM TT",
        mediumTime: "h:MM:ss TT",
        longTime: "h:MM:ss TT Z",
        isoDate: "yyyy-mm-dd",
        isoTime: "HH:MM:ss",
        isoDateTime: "yyyy-mm-dd'T'HH:MM:ss",
        isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
      }
    };
  }
  var dF = this.dateFormatCache;
  var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g, timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g, timezoneClip = /[^-+\dA-Z]/g, pad = function(val, len) {
    val = String(val);
    len = len || 2;
    while (val.length < len)
      val = "0" + val;
    return val;
  };
  if (arguments.length == 1 && Object.prototype.toString.call(date) == "[object String]" && !/\d/.test(date)) {
    mask = date;
    date = void 0;
  }
  date = date ? new Date(date) : new Date();
  if (isNaN(date))
    throw SyntaxError("invalid date");
  mask = String(dF.masks[mask] || mask || dF.masks["default"]);
  if (mask.slice(0, 4) == "UTC:") {
    mask = mask.slice(4);
    utc = true;
  }
  var _ = utc ? "getUTC" : "get", d = date[_ + "Date"](), D = date[_ + "Day"](), m = date[_ + "Month"](), y = date[_ + "FullYear"](), H = date[_ + "Hours"](), M = date[_ + "Minutes"](), s = date[_ + "Seconds"](), L = date[_ + "Milliseconds"](), o = utc ? 0 : date.getTimezoneOffset(), flags = {
    d,
    dd: pad(d),
    ddd: dF.i18n.dayNames[D],
    dddd: dF.i18n.dayNames[D + 7],
    m: m + 1,
    mm: pad(m + 1),
    mmm: dF.i18n.monthNames[m],
    mmmm: dF.i18n.monthNames[m + 12],
    yy: String(y).slice(2),
    yyyy: y,
    h: H % 12 || 12,
    hh: pad(H % 12 || 12),
    H,
    HH: pad(H),
    M,
    MM: pad(M),
    s,
    ss: pad(s),
    l: pad(L, 3),
    L: pad(L > 99 ? Math.round(L / 10) : L),
    t: H < 12 ? "a" : "p",
    tt: H < 12 ? "am" : "pm",
    T: H < 12 ? "A" : "P",
    TT: H < 12 ? "AM" : "PM",
    Z: utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""),
    o: (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
    S: ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]
  };
  return mask.replace(token, function($0) {
    return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);
  });
};
Graph2.prototype.createLayersDialog = function() {
  var div = document.createElement("div");
  div.style.position = "absolute";
  var model = this.getModel();
  var childCount = model.getChildCount(model.root);
  for (var i = 0; i < childCount; i++) {
    bind(this, function(layer) {
      var span = document.createElement("div");
      span.style.overflow = "hidden";
      span.style.textOverflow = "ellipsis";
      span.style.padding = "2px";
      span.style.whiteSpace = "nowrap";
      var cb = document.createElement("input");
      cb.style.display = "inline-block";
      cb.setAttribute("type", "checkbox");
      if (model.isVisible(layer)) {
        cb.setAttribute("checked", "checked");
        cb.defaultChecked = true;
      }
      span.appendChild(cb);
      var title = this.convertValueToString(layer) || mxResources2.get("background") || "Background";
      span.setAttribute("title", title);
      write(span, title);
      div.appendChild(span);
      mxEvent2.addListener(cb, "click", function() {
        if (cb.getAttribute("checked") != null) {
          cb.removeAttribute("checked");
        } else {
          cb.setAttribute("checked", "checked");
        }
        model.setVisible(layer, cb.checked);
      });
    })(model.getChildAt(model.root, i));
  }
  return div;
};
Graph2.prototype.replacePlaceholders = function(cell2, str, vars, translate) {
  var result2 = [];
  if (str != null) {
    var last = 0;
    while (match = this.placeholderPattern.exec(str)) {
      var val = match[0];
      if (val.length > 2 && val != "%label%" && val != "%tooltip%") {
        var tmp = null;
        if (match.index > last && str.charAt(match.index - 1) == "%") {
          tmp = val.substring(1);
        } else {
          var name = val.substring(1, val.length - 1);
          if (name == "id") {
            tmp = cell2.id;
          } else if (name.indexOf("{") < 0) {
            var current2 = cell2;
            while (tmp == null && current2 != null) {
              if (current2.value != null && typeof current2.value == "object") {
                if (Graph2.translateDiagram && Graph2.diagramLanguage != null) {
                  tmp = current2.getAttribute(name + "_" + Graph2.diagramLanguage);
                }
                if (tmp == null) {
                  tmp = current2.hasAttribute(name) ? current2.getAttribute(name) != null ? current2.getAttribute(name) : "" : null;
                }
              }
              current2 = this.model.getParent(current2);
            }
          }
          if (tmp == null) {
            tmp = this.getGlobalVariable(name);
          }
          if (tmp == null && vars != null) {
            tmp = vars[name];
          }
        }
        result2.push(str.substring(last, match.index) + (tmp != null ? tmp : val));
        last = match.index + val.length;
      }
    }
    result2.push(str.substring(last));
  }
  return result2.join("");
};
Graph2.prototype.restoreSelection = function(cells) {
  if (cells != null && cells.length > 0) {
    var temp2 = [];
    for (var i = 0; i < cells.length; i++) {
      var newCell = this.model.getCell(cells[i].id);
      if (newCell != null) {
        temp2.push(newCell);
      }
    }
    this.setSelectionCells(temp2);
  } else {
    this.clearSelection();
  }
};
Graph2.prototype.selectCellsForConnectVertex = function(cells, evt, hoverIcons) {
  if (cells.length == 2 && this.model.isVertex(cells[1])) {
    this.setSelectionCell(cells[1]);
    this.scrollCellToVisible(cells[1]);
    if (hoverIcons != null) {
      if (mxEvent2.isTouchEvent(evt)) {
        hoverIcons.update(hoverIcons.getState(this.view.getState(cells[1])));
      } else {
        hoverIcons.reset();
      }
    }
  } else {
    this.setSelectionCells(cells);
  }
};
Graph2.prototype.isCloneConnectSource = function(source) {
  var layout = null;
  if (this.layoutManager != null) {
    layout = this.layoutManager.getLayout(this.model.getParent(source));
  }
  return this.isTableRow(source) || this.isTableCell(source) || layout != null && layout.constructor == mxStackLayout;
};
Graph2.prototype.connectVertex = function(source, direction, length, evt, forceClone, ignoreCellAt, createTarget, done) {
  ignoreCellAt = ignoreCellAt ? ignoreCellAt : false;
  if (source.geometry.relative && this.model.isEdge(source.parent)) {
    return [];
  }
  while (source.geometry.relative && this.model.isVertex(source.parent)) {
    source = source.parent;
  }
  var cloneSource = this.isCloneConnectSource(source);
  var composite = cloneSource ? source : this.getCompositeParent(source);
  var pt = source.geometry.relative && source.parent.geometry != null ? new mxPoint2(source.parent.geometry.width * source.geometry.x, source.parent.geometry.height * source.geometry.y) : new mxPoint2(composite.geometry.x, composite.geometry.y);
  if (direction == mxConstants2.DIRECTION_NORTH) {
    pt.x += composite.geometry.width / 2;
    pt.y -= length;
  } else if (direction == mxConstants2.DIRECTION_SOUTH) {
    pt.x += composite.geometry.width / 2;
    pt.y += composite.geometry.height + length;
  } else if (direction == mxConstants2.DIRECTION_WEST) {
    pt.x -= length;
    pt.y += composite.geometry.height / 2;
  } else {
    pt.x += composite.geometry.width + length;
    pt.y += composite.geometry.height / 2;
  }
  var parentState = this.view.getState(this.model.getParent(source));
  var s = this.view.scale;
  var t = this.view.translate;
  var dx = t.x * s;
  var dy = t.y * s;
  if (parentState != null && this.model.isVertex(parentState.cell)) {
    dx = parentState.x;
    dy = parentState.y;
  }
  if (this.model.isVertex(source.parent) && source.geometry.relative) {
    pt.x += source.parent.geometry.x;
    pt.y += source.parent.geometry.y;
  }
  var rect = !ignoreCellAt ? new mxRectangle(dx + pt.x * s, dy + pt.y * s).grow(40) : null;
  var tempCells = rect != null ? this.getCells(0, 0, 0, 0, null, null, rect) : null;
  var target = tempCells != null && tempCells.length > 0 ? tempCells.reverse()[0] : null;
  var keepParent = false;
  if (target != null && this.model.isAncestor(target, source)) {
    keepParent = true;
    target = null;
  }
  if (target == null) {
    var temp2 = this.getSwimlaneAt(dx + pt.x * s, dy + pt.y * s);
    if (temp2 != null) {
      keepParent = false;
      target = temp2;
    }
  }
  var temp2 = target;
  while (temp2 != null) {
    if (this.isCellLocked(temp2)) {
      target = null;
      break;
    }
    temp2 = this.model.getParent(temp2);
  }
  if (target != null) {
    var sourceState = this.view.getState(source);
    var targetState = this.view.getState(target);
    if (sourceState != null && targetState != null && intersects(sourceState, targetState)) {
      target = null;
    }
  }
  var duplicate = !mxEvent2.isShiftDown(evt) || mxEvent2.isControlDown(evt) || forceClone;
  if (duplicate) {
    if (direction == mxConstants2.DIRECTION_NORTH) {
      pt.y -= source.geometry.height / 2;
    } else if (direction == mxConstants2.DIRECTION_SOUTH) {
      pt.y += source.geometry.height / 2;
    } else if (direction == mxConstants2.DIRECTION_WEST) {
      pt.x -= source.geometry.width / 2;
    } else {
      pt.x += source.geometry.width / 2;
    }
  }
  if (target != null && !this.isCellConnectable(target) && !this.isSwimlane(target)) {
    var parent2 = this.getModel().getParent(target);
    if (this.getModel().isVertex(parent2) && this.isCellConnectable(parent2)) {
      target = parent2;
    }
  }
  if (target == source || this.model.isEdge(target) || !this.isCellConnectable(target) && !this.isSwimlane(target)) {
    target = null;
  }
  var result2 = [];
  var swimlane = target != null && this.isSwimlane(target);
  var realTarget = !swimlane ? target : null;
  var execute = bind(this, function(targetCell) {
    if (createTarget == null || targetCell != null || target == null && cloneSource) {
      this.model.beginUpdate();
      try {
        if (realTarget == null && duplicate) {
          var cellToClone = targetCell != null ? targetCell : source;
          var geo = this.getCellGeometry(cellToClone);
          while (geo != null && geo.relative) {
            cellToClone = this.getModel().getParent(cellToClone);
            geo = this.getCellGeometry(cellToClone);
          }
          cellToClone = cloneSource ? source : this.getCompositeParent(cellToClone);
          realTarget = targetCell != null ? targetCell : this.duplicateCells([cellToClone], false)[0];
          if (targetCell != null) {
            this.addCells([realTarget], this.model.getParent(source), null, null, null, true);
          }
          var geo = this.getCellGeometry(realTarget);
          if (geo != null) {
            geo.x = pt.x - geo.width / 2;
            geo.y = pt.y - geo.height / 2;
          }
          if (swimlane) {
            this.addCells([realTarget], target, null, null, null, true);
            target = null;
          } else if (duplicate && target == null && !keepParent && !cloneSource) {
            this.addCells([realTarget], this.getDefaultParent(), null, null, null, true);
          }
        }
        var edge = mxEvent2.isControlDown(evt) && mxEvent2.isShiftDown(evt) && duplicate || target == null && cloneSource ? null : this.insertEdge(this.model.getParent(source), null, "", source, realTarget, this.createCurrentEdgeStyle());
        if (edge != null && this.connectionHandler.insertBeforeSource) {
          var index = null;
          var tmp = source;
          while (tmp.parent != null && tmp.geometry != null && tmp.geometry.relative && tmp.parent != edge.parent) {
            tmp = this.model.getParent(tmp);
          }
          if (tmp != null && tmp.parent != null && tmp.parent == edge.parent) {
            var index = tmp.parent.getIndex(tmp);
            this.model.add(tmp.parent, edge, index);
          }
        }
        if (target == null && realTarget != null && source.parent != null && cloneSource && direction == mxConstants2.DIRECTION_WEST) {
          var index = source.parent.getIndex(source);
          this.model.add(source.parent, realTarget, index);
        }
        if (edge != null) {
          result2.push(edge);
        }
        if (target == null && realTarget != null) {
          result2.push(realTarget);
        }
        if (realTarget == null && edge != null) {
          edge.geometry.setTerminalPoint(pt, false);
        }
        if (edge != null) {
          this.fireEvent(new mxEventObject2("cellsInserted", "cells", [edge]));
        }
      } finally {
        this.model.endUpdate();
      }
    }
    if (done != null) {
      done(result2);
    } else {
      return result2;
    }
  });
  if (createTarget != null && realTarget == null && duplicate && (target != null || !cloneSource)) {
    createTarget(dx + pt.x * s, dy + pt.y * s, execute);
  } else {
    return execute(realTarget);
  }
};
Graph2.prototype.getIndexableText = function() {
  var tmp = document.createElement("div");
  var labels = [];
  var label = "";
  for (var key in this.model.cells) {
    var cell2 = this.model.cells[key];
    if (this.model.isVertex(cell2) || this.model.isEdge(cell2)) {
      if (this.isHtmlLabel(cell2)) {
        tmp.innerHTML = this.sanitizeHtml(this.getLabel(cell2));
        label = extractTextWithWhitespace([tmp]);
      } else {
        label = this.getLabel(cell2);
      }
      label = trim(label.replace(/[\x00-\x1F\x7F-\x9F]|\s+/g, " "));
      if (label.length > 0) {
        labels.push(label);
      }
    }
  }
  return labels.join(" ");
};
Graph2.prototype.convertValueToString = function(cell2) {
  var value = this.model.getValue(cell2);
  if (value != null && typeof value == "object") {
    var result2 = null;
    if (this.isReplacePlaceholders(cell2) && cell2.getAttribute("placeholder") != null) {
      var name = cell2.getAttribute("placeholder");
      var current2 = cell2;
      while (result2 == null && current2 != null) {
        if (current2.value != null && typeof current2.value == "object") {
          result2 = current2.hasAttribute(name) ? current2.getAttribute(name) != null ? current2.getAttribute(name) : "" : null;
        }
        current2 = this.model.getParent(current2);
      }
    } else {
      var result2 = null;
      if (Graph2.translateDiagram && Graph2.diagramLanguage != null) {
        result2 = value.getAttribute("label_" + Graph2.diagramLanguage);
      }
      if (result2 == null) {
        result2 = value.getAttribute("label") || "";
      }
    }
    return result2 || "";
  }
  return mxGraph2.prototype.convertValueToString.apply(this, arguments);
};
Graph2.prototype.getLinksForState = function(state2) {
  if (state2 != null && state2.text != null && state2.text.node != null) {
    return state2.text.node.getElementsByTagName("a");
  }
  return null;
};
Graph2.prototype.getLinkForCell = function(cell2) {
  if (cell2.value != null && typeof cell2.value == "object") {
    var link2 = cell2.value.getAttribute("link");
    if (link2 != null && link2.toLowerCase().substring(0, 11) === "javascript:") {
      link2 = link2.substring(11);
    }
    return link2;
  }
  return null;
};
Graph2.prototype.getCellStyle = function(cell2) {
  var style = mxGraph2.prototype.getCellStyle.apply(this, arguments);
  if (cell2 != null && this.layoutManager != null) {
    var parent2 = this.model.getParent(cell2);
    if (this.model.isVertex(parent2) && this.isCellCollapsed(cell2)) {
      var layout = this.layoutManager.getLayout(parent2);
      if (layout != null && layout.constructor == mxStackLayout) {
        style[mxConstants2.STYLE_HORIZONTAL] = !layout.horizontal;
      }
    }
  }
  return style;
};
Graph2.prototype.updateAlternateBounds = function(cell2, geo, willCollapse) {
  if (cell2 != null && geo != null && this.layoutManager != null && geo.alternateBounds != null) {
    var layout = this.layoutManager.getLayout(this.model.getParent(cell2));
    if (layout != null && layout.constructor == mxStackLayout) {
      if (layout.horizontal) {
        geo.alternateBounds.height = 0;
      } else {
        geo.alternateBounds.width = 0;
      }
    }
  }
  mxGraph2.prototype.updateAlternateBounds.apply(this, arguments);
};
Graph2.prototype.isMoveCellsEvent = function(evt, state2) {
  return mxEvent2.isShiftDown(evt) || getValue(state2.style, "moveCells", "0") == "1";
};
Graph2.prototype.foldCells = function(collapse, recurse, cells, checkFoldable, evt) {
  recurse = recurse != null ? recurse : false;
  if (cells == null) {
    cells = this.getFoldableCells(this.getSelectionCells(), collapse);
  }
  if (cells != null) {
    this.model.beginUpdate();
    try {
      mxGraph2.prototype.foldCells.apply(this, arguments);
      if (this.layoutManager != null) {
        for (var i = 0; i < cells.length; i++) {
          var state2 = this.view.getState(cells[i]);
          var geo = this.getCellGeometry(cells[i]);
          if (state2 != null && geo != null) {
            var dx = Math.round(geo.width - state2.width / this.view.scale);
            var dy = Math.round(geo.height - state2.height / this.view.scale);
            if (dy != 0 || dx != 0) {
              var parent2 = this.model.getParent(cells[i]);
              var layout = this.layoutManager.getLayout(parent2);
              if (layout == null) {
                if (evt != null && this.isMoveCellsEvent(evt, state2)) {
                  this.moveSiblings(state2, parent2, dx, dy);
                }
              } else if ((evt == null || !mxEvent2.isAltDown(evt)) && layout.constructor == mxStackLayout && !layout.resizeLast) {
                this.resizeParentStacks(parent2, layout, dx, dy);
              }
            }
          }
        }
      }
    } finally {
      this.model.endUpdate();
    }
    if (this.isEnabled()) {
      this.setSelectionCells(cells);
    }
  }
};
Graph2.prototype.moveSiblings = function(state2, parent2, dx, dy) {
  this.model.beginUpdate();
  try {
    var cells = this.getCellsBeyond(state2.x, state2.y, parent2, true, true);
    for (var i = 0; i < cells.length; i++) {
      if (cells[i] != state2.cell) {
        var tmp = this.view.getState(cells[i]);
        var geo = this.getCellGeometry(cells[i]);
        if (tmp != null && geo != null) {
          geo = geo.clone();
          geo.translate(Math.round(dx * Math.max(0, Math.min(1, (tmp.x - state2.x) / state2.width))), Math.round(dy * Math.max(0, Math.min(1, (tmp.y - state2.y) / state2.height))));
          this.model.setGeometry(cells[i], geo);
        }
      }
    }
  } finally {
    this.model.endUpdate();
  }
};
Graph2.prototype.resizeParentStacks = function(parent2, layout, dx, dy) {
  if (this.layoutManager != null && layout != null && layout.constructor == mxStackLayout && !layout.resizeLast) {
    this.model.beginUpdate();
    try {
      var dir = layout.horizontal;
      while (parent2 != null && layout != null && layout.constructor == mxStackLayout && layout.horizontal == dir && !layout.resizeLast) {
        var pgeo = this.getCellGeometry(parent2);
        var pstate = this.view.getState(parent2);
        if (pstate != null && pgeo != null) {
          pgeo = pgeo.clone();
          if (layout.horizontal) {
            pgeo.width += dx + Math.min(0, pstate.width / this.view.scale - pgeo.width);
          } else {
            pgeo.height += dy + Math.min(0, pstate.height / this.view.scale - pgeo.height);
          }
          this.model.setGeometry(parent2, pgeo);
        }
        parent2 = this.model.getParent(parent2);
        layout = this.layoutManager.getLayout(parent2);
      }
    } finally {
      this.model.endUpdate();
    }
  }
};
Graph2.prototype.isContainer = function(cell2) {
  var style = this.getCurrentCellStyle(cell2);
  if (this.isSwimlane(cell2)) {
    return style["container"] != "0";
  } else {
    return style["container"] == "1";
  }
};
Graph2.prototype.isCellConnectable = function(cell2) {
  var style = this.getCurrentCellStyle(cell2);
  return style["connectable"] != null ? style["connectable"] != "0" : mxGraph2.prototype.isCellConnectable.apply(this, arguments);
};
Graph2.prototype.isLabelMovable = function(cell2) {
  var style = this.getCurrentCellStyle(cell2);
  return style["movableLabel"] != null ? style["movableLabel"] != "0" : mxGraph2.prototype.isLabelMovable.apply(this, arguments);
};
Graph2.prototype.selectAll = function(parent2) {
  parent2 = parent2 || this.getDefaultParent();
  if (!this.isCellLocked(parent2)) {
    mxGraph2.prototype.selectAll.apply(this, arguments);
  }
};
Graph2.prototype.selectCells = function(vertices, edges, parent2) {
  parent2 = parent2 || this.getDefaultParent();
  if (!this.isCellLocked(parent2)) {
    mxGraph2.prototype.selectCells.apply(this, arguments);
  }
};
Graph2.prototype.getSwimlaneAt = function(x, y, parent2) {
  var result2 = mxGraph2.prototype.getSwimlaneAt.apply(this, arguments);
  if (this.isCellLocked(result2)) {
    result2 = null;
  }
  return result2;
};
Graph2.prototype.isCellFoldable = function(cell2) {
  var style = this.getCurrentCellStyle(cell2);
  return this.foldingEnabled && (style["treeFolding"] == "1" || !this.isCellLocked(cell2) && (this.isContainer(cell2) && style["collapsible"] != "0" || !this.isContainer(cell2) && style["collapsible"] == "1"));
};
Graph2.prototype.reset = function() {
  if (this.isEditing()) {
    this.stopEditing(true);
  }
  this.escape();
  if (!this.isSelectionEmpty()) {
    this.clearSelection();
  }
};
Graph2.prototype.zoom = function(factor, center) {
  factor = Math.max(0.01, Math.min(this.view.scale * factor, 160)) / this.view.scale;
  mxGraph2.prototype.zoom.apply(this, arguments);
};
Graph2.prototype.zoomIn = function() {
  if (this.view.scale < 0.15) {
    this.zoom((this.view.scale + 0.01) / this.view.scale);
  } else {
    this.zoom(Math.round(this.view.scale * this.zoomFactor * 20) / 20 / this.view.scale);
  }
};
Graph2.prototype.zoomOut = function() {
  if (this.view.scale <= 0.15) {
    this.zoom((this.view.scale - 0.01) / this.view.scale);
  } else {
    this.zoom(Math.round(this.view.scale * (1 / this.zoomFactor) * 20) / 20 / this.view.scale);
  }
};
Graph2.prototype.fitWindow = function(bounds, border) {
  border = border != null ? border : 10;
  var cw = this.container.clientWidth - border;
  var ch = this.container.clientHeight - border;
  var scale = Math.floor(20 * Math.min(cw / bounds.width, ch / bounds.height)) / 20;
  this.zoomTo(scale);
  if (hasScrollbars(this.container)) {
    var t = this.view.translate;
    this.container.scrollTop = (bounds.y + t.y) * scale - Math.max((ch - bounds.height * scale) / 2 + border / 2, 0);
    this.container.scrollLeft = (bounds.x + t.x) * scale - Math.max((cw - bounds.width * scale) / 2 + border / 2, 0);
  }
};
Graph2.prototype.getTooltipForCell = function(cell2) {
  var tip = "";
  if (isNode(cell2.value)) {
    var tmp = null;
    if (Graph2.translateDiagram && Graph2.diagramLanguage != null) {
      tmp = cell2.value.getAttribute("tooltip_" + Graph2.diagramLanguage);
    }
    if (tmp == null) {
      tmp = cell2.value.getAttribute("tooltip");
    }
    if (tmp != null) {
      if (tmp != null && this.isReplacePlaceholders(cell2)) {
        tmp = this.replacePlaceholders(cell2, tmp);
      }
      tip = this.sanitizeHtml(tmp);
    } else {
      var ignored = this.builtInProperties;
      var attrs = cell2.value.attributes;
      var temp2 = [];
      if (this.isEnabled()) {
        ignored.push("link");
      }
      for (var i = 0; i < attrs.length; i++) {
        if (indexOf(ignored, attrs[i].nodeName) < 0 && attrs[i].nodeValue.length > 0) {
          temp2.push({ name: attrs[i].nodeName, value: attrs[i].nodeValue });
        }
      }
      temp2.sort(function(a, b) {
        if (a.name < b.name) {
          return -1;
        } else if (a.name > b.name) {
          return 1;
        } else {
          return 0;
        }
      });
      for (var i = 0; i < temp2.length; i++) {
        if (temp2[i].name != "link" || !this.isCustomLink(temp2[i].value)) {
          tip += (temp2[i].name != "link" ? "<b>" + temp2[i].name + ":</b> " : "") + htmlEntities(temp2[i].value) + "\n";
        }
      }
      if (tip.length > 0) {
        tip = tip.substring(0, tip.length - 1);
        if (mxClient_default.IS_SVG) {
          tip = '<div style="max-width:360px;">' + tip + "</div>";
        }
      }
    }
  }
  return tip;
};
Graph2.prototype.stringToBytes = function(str) {
  return Graph2.stringToBytes(str);
};
Graph2.prototype.bytesToString = function(arr) {
  return Graph2.bytesToString(arr);
};
Graph2.prototype.compressNode = function(node) {
  return Graph2.compressNode(node);
};
Graph2.prototype.compress = function(data, deflate) {
  return Graph2.compress(data, deflate);
};
Graph2.prototype.decompress = function(data, inflate) {
  return Graph2.decompress(data, inflate);
};
Graph2.prototype.zapGremlins = function(text) {
  return Graph2.zapGremlins(text);
};
Graph2.prototype.createParent = function(parent2, child, childCount, dx, dy) {
  parent2 = this.cloneCell(parent2);
  for (var i = 0; i < childCount; i++) {
    var clone3 = this.cloneCell(child);
    var geo = this.getCellGeometry(clone3);
    if (geo != null) {
      geo.x += i * dx;
      geo.y += i * dy;
    }
    parent2.insert(clone3);
  }
  return parent2;
};
Graph2.prototype.createTable = function(rowCount, colCount, w2, h2, title, startSize, tableStyle, rowStyle, cellStyle) {
  w2 = w2 != null ? w2 : 60;
  h2 = h2 != null ? h2 : 40;
  startSize = startSize != null ? startSize : 30;
  tableStyle = tableStyle != null ? tableStyle : "shape=table;html=1;whiteSpace=wrap;startSize=" + (title != null ? startSize : "0") + ";container=1;collapsible=0;childLayout=tableLayout;";
  rowStyle = rowStyle != null ? rowStyle : "shape=partialRectangle;html=1;whiteSpace=wrap;collapsible=0;dropTarget=0;pointerEvents=0;fillColor=none;top=0;left=0;bottom=0;right=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;";
  cellStyle = cellStyle != null ? cellStyle : "shape=partialRectangle;html=1;whiteSpace=wrap;connectable=0;overflow=hidden;fillColor=none;top=0;left=0;bottom=0;right=0;";
  return this.createParent(this.createVertex(null, null, title != null ? title : "", 0, 0, colCount * w2, rowCount * h2 + (title != null ? startSize : 0), tableStyle), this.createParent(this.createVertex(null, null, "", 0, 0, colCount * w2, h2, rowStyle), this.createVertex(null, null, "", 0, 0, w2, h2, cellStyle), colCount, w2, 0), rowCount, 0, h2);
};
Graph2.prototype.setTableValues = function(table, values, rowValues) {
  var rows = this.model.getChildCells(table, true);
  for (var i = 0; i < rows.length; i++) {
    if (rowValues != null) {
      rows[i].value = rowValues[i];
    }
    if (values != null) {
      var cells = this.model.getChildCells(rows[i], true);
      for (var j = 0; j < cells.length; j++) {
        if (values[i][j] != null) {
          cells[j].value = values[i][j];
        }
      }
    }
  }
  return table;
};
Graph2.prototype.createCrossFunctionalSwimlane = function(rowCount, colCount, w2, h2, startSize, tableStyle, rowStyle, firstCellStyle, cellStyle) {
  w2 = w2 != null ? w2 : 120;
  h2 = h2 != null ? h2 : 120;
  startSize = startSize != null ? startSize : 40;
  var s = "html=1;whiteSpace=wrap;collapsible=0;recursiveResize=0;expand=0;pointerEvents=0;";
  tableStyle = tableStyle != null ? tableStyle : "shape=table;childLayout=tableLayout;rowLines=0;columnLines=0;startSize=" + startSize + ";" + s;
  rowStyle = rowStyle != null ? rowStyle : "swimlane;horizontal=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;startSize=" + startSize + ";" + s;
  firstCellStyle = firstCellStyle != null ? firstCellStyle : "swimlane;connectable=0;startSize=40;" + s;
  cellStyle = cellStyle != null ? cellStyle : "swimlane;connectable=0;startSize=0;" + s;
  var table = this.createVertex(null, null, "", 0, 0, colCount * w2, rowCount * h2, tableStyle);
  var t = getValue(this.getCellStyle(table), mxConstants2.STYLE_STARTSIZE, mxConstants2.DEFAULT_STARTSIZE);
  table.geometry.width += t;
  table.geometry.height += t;
  var row = this.createVertex(null, null, "", 0, t, colCount * w2 + t, h2, rowStyle);
  table.insert(this.createParent(row, this.createVertex(null, null, "", t, 0, w2, h2, firstCellStyle), colCount, w2, 0));
  if (rowCount > 1) {
    row.geometry.y = h2 + t;
    return this.createParent(table, this.createParent(row, this.createVertex(null, null, "", t, 0, w2, h2, cellStyle), colCount, w2, 0), rowCount - 1, 0, h2);
  } else {
    return table;
  }
};
Graph2.prototype.isTableCell = function(cell2) {
  return this.model.isVertex(cell2) && this.isTableRow(this.model.getParent(cell2));
};
Graph2.prototype.isTableRow = function(cell2) {
  return this.model.isVertex(cell2) && this.isTable(this.model.getParent(cell2));
};
Graph2.prototype.isTable = function(cell2) {
  var style = this.getCellStyle(cell2);
  return style != null && style["childLayout"] == "tableLayout";
};
Graph2.prototype.setTableRowHeight = function(row, dy, extend2) {
  extend2 = extend2 != null ? extend2 : true;
  var model = this.getModel();
  model.beginUpdate();
  try {
    var rgeo = this.getCellGeometry(row);
    if (rgeo != null) {
      rgeo = rgeo.clone();
      rgeo.height += dy;
      model.setGeometry(row, rgeo);
      var table = model.getParent(row);
      var rows = model.getChildCells(table, true);
      if (!extend2) {
        var index = indexOf(rows, row);
        if (index < rows.length - 1) {
          var nextRow = rows[index + 1];
          var geo = this.getCellGeometry(nextRow);
          if (geo != null) {
            geo = geo.clone();
            geo.y += dy;
            geo.height -= dy;
            model.setGeometry(nextRow, geo);
          }
        }
      }
      var tgeo = this.getCellGeometry(table);
      if (tgeo != null) {
        if (!extend2) {
          extend2 = row == rows[rows.length - 1];
        }
        if (extend2) {
          tgeo = tgeo.clone();
          tgeo.height += dy;
          model.setGeometry(table, tgeo);
        }
      }
      if (this.layoutManager != null) {
        this.layoutManager.executeLayout(table, true);
      }
    }
  } finally {
    model.endUpdate();
  }
};
Graph2.prototype.setTableColumnWidth = function(col, dx, extend2) {
  extend2 = extend2 != null ? extend2 : false;
  var model = this.getModel();
  var row = model.getParent(col);
  var table = model.getParent(row);
  var cells = model.getChildCells(row, true);
  var index = indexOf(cells, col);
  var lastColumn = index == cells.length - 1;
  model.beginUpdate();
  try {
    var rows = model.getChildCells(table, true);
    for (var i = 0; i < rows.length; i++) {
      row = rows[i];
      cells = model.getChildCells(row, true);
      var cell2 = cells[index];
      var geo = this.getCellGeometry(cell2);
      if (geo != null) {
        geo = geo.clone();
        geo.width += dx;
        model.setGeometry(cell2, geo);
      }
      if (index < cells.length - 1) {
        cell2 = cells[index + 1];
        var geo = this.getCellGeometry(cell2);
        if (geo != null) {
          geo = geo.clone();
          geo.x += dx;
          if (!extend2) {
            geo.width -= dx;
          }
          model.setGeometry(cell2, geo);
        }
      }
    }
    if (lastColumn || extend2) {
      var tgeo = this.getCellGeometry(table);
      if (tgeo != null) {
        tgeo = tgeo.clone();
        tgeo.width += dx;
        model.setGeometry(table, tgeo);
      }
    }
    if (this.layoutManager != null) {
      this.layoutManager.executeLayout(table, true);
    }
  } finally {
    model.endUpdate();
  }
};
function TableLayout(graph) {
  mxGraphLayout.call(this, graph);
}
TableLayout.prototype = new mxStackLayout();
TableLayout.prototype.constructor = TableLayout;
TableLayout.prototype.isHorizontal = function() {
  return false;
};
TableLayout.prototype.isVertexIgnored = function(vertex) {
  return !this.graph.getModel().isVertex(vertex) || !this.graph.isCellVisible(vertex);
};
TableLayout.prototype.getSize = function(cells, horizontal) {
  var total = 0;
  for (var i = 0; i < cells.length; i++) {
    if (!this.isVertexIgnored(cells[i])) {
      var geo = this.graph.getCellGeometry(cells[i]);
      if (geo != null) {
        total += horizontal ? geo.width : geo.height;
      }
    }
  }
  return total;
};
TableLayout.prototype.getRowLayout = function(row, width) {
  var cells = this.graph.model.getChildCells(row, true);
  var off = this.graph.getActualStartSize(row, true);
  var sw = this.getSize(cells, true);
  var rw = width - off.x - off.width;
  var result2 = [];
  var x = off.x;
  for (var i = 0; i < cells.length; i++) {
    var cell2 = this.graph.getCellGeometry(cells[i]);
    if (cell2 != null) {
      x += cell2.width * rw / sw;
      result2.push(Math.round(x));
    }
  }
  return result2;
};
TableLayout.prototype.layoutRow = function(row, positions, height, tw) {
  var model = this.graph.getModel();
  var cells = model.getChildCells(row, true);
  var off = this.graph.getActualStartSize(row, true);
  var x = off.x;
  var sw = 0;
  if (positions != null) {
    positions = positions.slice();
    positions.splice(0, 0, off.x);
  }
  for (var i = 0; i < cells.length; i++) {
    var cell2 = this.graph.getCellGeometry(cells[i]);
    if (cell2 != null) {
      cell2 = cell2.clone();
      cell2.y = off.y;
      cell2.height = height - off.y - off.height;
      if (positions != null) {
        cell2.x = positions[i];
        cell2.width = positions[i + 1] - cell2.x;
        if (i == cells.length - 1 && i < positions.length - 2) {
          cell2.width = tw - cell2.x - off.x - off.width;
        }
      } else {
        cell2.x = x;
        x += cell2.width;
        if (i == cells.length - 1) {
          cell2.width = tw - off.x - off.width - sw;
        } else {
          sw += cell2.width;
        }
      }
      model.setGeometry(cells[i], cell2);
    }
  }
  return sw;
};
TableLayout.prototype.execute = function(parent2) {
  if (parent2 != null) {
    var offset = this.graph.getActualStartSize(parent2, true);
    var table = this.graph.getCellGeometry(parent2);
    var style = this.graph.getCellStyle(parent2);
    var resizeLastRow = getValue(style, "resizeLastRow", "0") == "1";
    var resizeLast = getValue(style, "resizeLast", "0") == "1";
    var fixedRows = getValue(style, "fixedRows", "0") == "1";
    var model = this.graph.getModel();
    var sw = 0;
    model.beginUpdate();
    try {
      var th = table.height - offset.y - offset.height;
      var tw = table.width - offset.x - offset.width;
      var rows = model.getChildCells(parent2, true);
      var sh = this.getSize(rows, false);
      if (th > 0 && tw > 0 && rows.length > 0 && sh > 0) {
        if (resizeLastRow) {
          var row = this.graph.getCellGeometry(rows[rows.length - 1]);
          if (row != null) {
            row = row.clone();
            row.height = th - sh + row.height;
            model.setGeometry(rows[rows.length - 1], row);
          }
        }
        var pos = resizeLast ? null : this.getRowLayout(rows[0], tw);
        var y = offset.y;
        for (var i = 0; i < rows.length; i++) {
          var row = this.graph.getCellGeometry(rows[i]);
          if (row != null) {
            row = row.clone();
            row.x = offset.x;
            row.width = tw;
            row.y = Math.round(y);
            if (resizeLastRow || fixedRows) {
              y += row.height;
            } else {
              y += row.height / sh * th;
            }
            row.height = Math.round(y) - row.y;
            model.setGeometry(rows[i], row);
          }
          sw = Math.max(sw, this.layoutRow(rows[i], pos, row.height, tw));
        }
        if (fixedRows && th < sh) {
          table = table.clone();
          table.height = y + offset.height;
          model.setGeometry(parent2, table);
        }
        if (resizeLast && tw < sw + Graph2.minTableColumnWidth) {
          table = table.clone();
          table.width = sw + offset.width + offset.x + Graph2.minTableColumnWidth;
          model.setGeometry(parent2, table);
        }
      }
    } finally {
      model.endUpdate();
    }
  }
};
var mxGraphViewResetValidationState = mxGraphView.prototype.resetValidationState;
mxGraphView.prototype.resetValidationState = function() {
  mxGraphViewResetValidationState.apply(this, arguments);
  this.validEdges = [];
};
var mxGraphViewValidateCellState = mxGraphView.prototype.validateCellState;
mxGraphView.prototype.validateCellState = function(cell2, recurse) {
  recurse = recurse != null ? recurse : true;
  var state2 = this.getState(cell2);
  if (state2 != null && recurse && this.graph.model.isEdge(state2.cell) && state2.style != null && state2.style[mxConstants2.STYLE_CURVED] != 1 && !state2.invalid && this.updateLineJumps(state2)) {
    this.graph.cellRenderer.redraw(state2, false, this.isRendering());
  }
  state2 = mxGraphViewValidateCellState.apply(this, arguments);
  if (state2 != null && recurse && this.graph.model.isEdge(state2.cell) && state2.style != null && state2.style[mxConstants2.STYLE_CURVED] != 1) {
    this.validEdges.push(state2);
  }
  return state2;
};
var mxCellRendererIsShapeInvalid = mxCellRenderer2.prototype.isShapeInvalid;
mxCellRenderer2.prototype.isShapeInvalid = function(state2, shape) {
  return mxCellRendererIsShapeInvalid.apply(this, arguments) || state2.routedPoints != null && shape.routedPoints != null && !equalPoints(shape.routedPoints, state2.routedPoints);
};
var mxGraphViewUpdateCellState = mxGraphView.prototype.updateCellState;
mxGraphView.prototype.updateCellState = function(state2) {
  mxGraphViewUpdateCellState.apply(this, arguments);
  if (this.graph.model.isEdge(state2.cell) && state2.style[mxConstants2.STYLE_CURVED] != 1) {
    this.updateLineJumps(state2);
  }
};
mxGraphView.prototype.updateLineJumps = function(state2) {
  var pts = state2.absolutePoints;
  if (Graph2.lineJumpsEnabled) {
    var changed = state2.routedPoints != null;
    var actual = null;
    if (pts != null && this.validEdges != null && getValue(state2.style, "jumpStyle", "none") !== "none") {
      let addPoint = function(type, x, y) {
        var rpt = new mxPoint2(x, y);
        rpt.type = type;
        actual.push(rpt);
        var curr = state2.routedPoints != null ? state2.routedPoints[actual.length - 1] : null;
        return curr == null || curr.type != type || curr.x != x || curr.y != y;
      };
      var thresh = 0.5 * this.scale;
      changed = false;
      actual = [];
      for (var i = 0; i < pts.length - 1; i++) {
        var p1 = pts[i + 1];
        var p0 = pts[i];
        var list = [];
        var pn = pts[i + 2];
        while (i < pts.length - 2 && ptSegDistSq(p0.x, p0.y, pn.x, pn.y, p1.x, p1.y) < 1 * this.scale * this.scale) {
          p1 = pn;
          i++;
          pn = pts[i + 2];
        }
        changed = addPoint(0, p0.x, p0.y) || changed;
        for (var e = 0; e < this.validEdges.length; e++) {
          var state22 = this.validEdges[e];
          var pts2 = state22.absolutePoints;
          if (pts2 != null && intersects(state2, state22) && state22.style["noJump"] != "1") {
            for (var j = 0; j < pts2.length - 1; j++) {
              var p3 = pts2[j + 1];
              var p2 = pts2[j];
              pn = pts2[j + 2];
              while (j < pts2.length - 2 && ptSegDistSq(p2.x, p2.y, pn.x, pn.y, p3.x, p3.y) < 1 * this.scale * this.scale) {
                p3 = pn;
                j++;
                pn = pts2[j + 2];
              }
              var pt = intersection(p0.x, p0.y, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
              if (pt != null && (Math.abs(pt.x - p0.x) > thresh || Math.abs(pt.y - p0.y) > thresh) && (Math.abs(pt.x - p1.x) > thresh || Math.abs(pt.y - p1.y) > thresh) && (Math.abs(pt.x - p2.x) > thresh || Math.abs(pt.y - p2.y) > thresh) && (Math.abs(pt.x - p3.x) > thresh || Math.abs(pt.y - p3.y) > thresh)) {
                var dx = pt.x - p0.x;
                var dy = pt.y - p0.y;
                var temp2 = { distSq: dx * dx + dy * dy, x: pt.x, y: pt.y };
                for (var t = 0; t < list.length; t++) {
                  if (list[t].distSq > temp2.distSq) {
                    list.splice(t, 0, temp2);
                    temp2 = null;
                    break;
                  }
                }
                if (temp2 != null && (list.length == 0 || list[list.length - 1].x !== temp2.x || list[list.length - 1].y !== temp2.y)) {
                  list.push(temp2);
                }
              }
            }
          }
        }
        for (var j = 0; j < list.length; j++) {
          changed = addPoint(1, list[j].x, list[j].y) || changed;
        }
      }
      var pt = pts[pts.length - 1];
      changed = addPoint(0, pt.x, pt.y) || changed;
    }
    state2.routedPoints = actual;
    return changed;
  } else {
    return false;
  }
};
var mxConnectorPaintLine = mxConnector.prototype.paintLine;
mxConnector.prototype.paintLine = function(c, absPts, rounded) {
  this.routedPoints = this.state != null ? this.state.routedPoints : null;
  if (this.outline || this.state == null || this.style == null || this.state.routedPoints == null || this.state.routedPoints.length == 0) {
    mxConnectorPaintLine.apply(this, arguments);
  } else {
    var arcSize = getValue(this.style, mxConstants2.STYLE_ARCSIZE, mxConstants2.LINE_ARCSIZE) / 2;
    var size = (parseInt(getValue(this.style, "jumpSize", Graph2.defaultJumpSize)) - 2) / 2 + this.strokewidth;
    var style = getValue(this.style, "jumpStyle", "none");
    var moveTo = true;
    var last = null;
    var len = null;
    var pts = [];
    var n = null;
    c.begin();
    for (var i = 0; i < this.state.routedPoints.length; i++) {
      var rpt = this.state.routedPoints[i];
      var pt = new mxPoint2(rpt.x / this.scale, rpt.y / this.scale);
      if (i == 0) {
        pt = absPts[0];
      } else if (i == this.state.routedPoints.length - 1) {
        pt = absPts[absPts.length - 1];
      }
      var done = false;
      if (last != null && rpt.type == 1) {
        var next = this.state.routedPoints[i + 1];
        var dx = next.x / this.scale - pt.x;
        var dy = next.y / this.scale - pt.y;
        var dist = dx * dx + dy * dy;
        if (n == null) {
          n = new mxPoint2(pt.x - last.x, pt.y - last.y);
          len = Math.sqrt(n.x * n.x + n.y * n.y);
          if (len > 0) {
            n.x = n.x * size / len;
            n.y = n.y * size / len;
          } else {
            n = null;
          }
        }
        if (dist > size * size && len > 0) {
          var dx = last.x - pt.x;
          var dy = last.y - pt.y;
          var dist = dx * dx + dy * dy;
          if (dist > size * size) {
            var p0 = new mxPoint2(pt.x - n.x, pt.y - n.y);
            var p1 = new mxPoint2(pt.x + n.x, pt.y + n.y);
            pts.push(p0);
            this.addPoints(c, pts, rounded, arcSize, false, null, moveTo);
            var f = Math.round(n.x) < 0 || Math.round(n.x) == 0 && Math.round(n.y) <= 0 ? 1 : -1;
            moveTo = false;
            if (style == "sharp") {
              c.lineTo(p0.x - n.y * f, p0.y + n.x * f);
              c.lineTo(p1.x - n.y * f, p1.y + n.x * f);
              c.lineTo(p1.x, p1.y);
            } else if (style == "arc") {
              f *= 1.3;
              c.curveTo(p0.x - n.y * f, p0.y + n.x * f, p1.x - n.y * f, p1.y + n.x * f, p1.x, p1.y);
            } else {
              c.moveTo(p1.x, p1.y);
              moveTo = true;
            }
            pts = [p1];
            done = true;
          }
        }
      } else {
        n = null;
      }
      if (!done) {
        pts.push(pt);
        last = pt;
      }
    }
    this.addPoints(c, pts, rounded, arcSize, false, null, moveTo);
    c.stroke();
  }
};
var mxGraphViewUpdateFloatingTerminalPoint = mxGraphView.prototype.updateFloatingTerminalPoint;
mxGraphView.prototype.updateFloatingTerminalPoint = function(edge, start, end, source) {
  if (start != null && edge != null && (start.style["snapToPoint"] == "1" || edge.style["snapToPoint"] == "1")) {
    start = this.getTerminalPort(edge, start, source);
    var next = this.getNextPoint(edge, end, source);
    var orth = this.graph.isOrthogonal(edge);
    var alpha = toRadians(Number(start.style[mxConstants2.STYLE_ROTATION] || "0"));
    var center = new mxPoint2(start.getCenterX(), start.getCenterY());
    if (alpha != 0) {
      var cos = Math.cos(-alpha);
      var sin = Math.sin(-alpha);
      next = getRotatedPoint(next, cos, sin, center);
    }
    var border = parseFloat(edge.style[mxConstants2.STYLE_PERIMETER_SPACING] || 0);
    border += parseFloat(edge.style[source ? mxConstants2.STYLE_SOURCE_PERIMETER_SPACING : mxConstants2.STYLE_TARGET_PERIMETER_SPACING] || 0);
    var pt = this.getPerimeterPoint(start, next, alpha == 0 && orth, border);
    if (alpha != 0) {
      var cos = Math.cos(alpha);
      var sin = Math.sin(alpha);
      pt = getRotatedPoint(pt, cos, sin, center);
    }
    edge.setAbsoluteTerminalPoint(this.snapToAnchorPoint(edge, start, end, source, pt), source);
  } else {
    mxGraphViewUpdateFloatingTerminalPoint.apply(this, arguments);
  }
};
mxGraphView.prototype.snapToAnchorPoint = function(edge, start, end, source, pt) {
  if (start != null && edge != null) {
    var constraints = this.graph.getAllConnectionConstraints(start);
    var nearest = null;
    var dist = null;
    if (constraints != null) {
      for (var i = 0; i < constraints.length; i++) {
        var cp = this.graph.getConnectionPoint(start, constraints[i]);
        if (cp != null) {
          var tmp = (cp.x - pt.x) * (cp.x - pt.x) + (cp.y - pt.y) * (cp.y - pt.y);
          if (dist == null || tmp < dist) {
            nearest = cp;
            dist = tmp;
          }
        }
      }
    }
    if (nearest != null) {
      pt = nearest;
    }
  }
  return pt;
};
var mxStencilEvaluateTextAttribute = mxStencil2.prototype.evaluateTextAttribute;
mxStencil2.prototype.evaluateTextAttribute = function(node, attribute, shape) {
  var result2 = mxStencilEvaluateTextAttribute.apply(this, arguments);
  var placeholders = node.getAttribute("placeholders");
  if (placeholders == "1" && shape.state != null) {
    result2 = shape.state.view.graph.replacePlaceholders(shape.state.cell, result2);
  }
  return result2;
};
var mxCellRendererCreateShape = mxCellRenderer2.prototype.createShape;
mxCellRenderer2.prototype.createShape = function(state2) {
  if (state2.style != null && typeof pako !== "undefined") {
    var shape = getValue(state2.style, mxConstants2.STYLE_SHAPE, null);
    if (shape != null && typeof shape === "string" && shape.substring(0, 8) == "stencil(") {
      try {
        var stencil = shape.substring(8, shape.length - 1);
        var doc = parseXml(Graph2.decompress(stencil));
        return new mxShape(new mxStencil2(doc.documentElement));
      } catch (e) {
        if (window.console != null) {
          console.log("Error in shape: " + e);
        }
      }
    }
  }
  return mxCellRendererCreateShape.apply(this, arguments);
};
mxStencilRegistry.libraries = {};
mxStencilRegistry.dynamicLoading = true;
mxStencilRegistry.allowEval = true;
mxStencilRegistry.packages = [];
mxStencilRegistry.getStencil = function(name) {
  var result2 = mxStencilRegistry.stencils[name];
  if (result2 == null && mxCellRenderer2.defaultShapes[name] == null && mxStencilRegistry.dynamicLoading) {
    var basename = mxStencilRegistry.getBasenameForStencil(name);
    if (basename != null) {
      var libs = mxStencilRegistry.libraries[basename];
      if (libs != null) {
        if (mxStencilRegistry.packages[basename] == null) {
          for (var i = 0; i < libs.length; i++) {
            var fname = libs[i];
            if (fname.toLowerCase().substring(fname.length - 4, fname.length) == ".xml") {
              mxStencilRegistry.loadStencilSet(fname, null);
            } else if (fname.toLowerCase().substring(fname.length - 3, fname.length) == ".js") {
              try {
                if (mxStencilRegistry.allowEval) {
                  var req = load(fname);
                  if (req != null && req.getStatus() >= 200 && req.getStatus() <= 299) {
                    eval.call(window, req.getText());
                  }
                }
              } catch (e) {
                if (window.console != null) {
                  console.log("error in getStencil:", fname, e);
                }
              }
            } else {
            }
          }
          mxStencilRegistry.packages[basename] = 1;
        }
      } else {
        basename = basename.replace("_-_", "_");
        mxStencilRegistry.loadStencilSet(STENCIL_PATH2 + "/" + basename + ".xml", null);
      }
      result2 = mxStencilRegistry.stencils[name];
    }
  }
  return result2;
};
mxStencilRegistry.getBasenameForStencil = function(name) {
  var tmp = null;
  if (name != null && typeof name === "string") {
    var parts = name.split(".");
    if (parts.length > 0 && parts[0] == "mxgraph") {
      tmp = parts[1];
      for (var i = 2; i < parts.length - 1; i++) {
        tmp += "/" + parts[i];
      }
    }
  }
  return tmp;
};
mxStencilRegistry.loadStencilSet = function(stencilFile, postStencilLoad, force, async) {
  force = force != null ? force : false;
  var xmlDoc = mxStencilRegistry.packages[stencilFile];
  if (force || xmlDoc == null) {
    var install = false;
    if (xmlDoc == null) {
      try {
        if (async) {
          mxStencilRegistry.loadStencil(stencilFile, bind(this, function(xmlDoc2) {
            if (xmlDoc2 != null && xmlDoc2.documentElement != null) {
              mxStencilRegistry.packages[stencilFile] = xmlDoc2;
              install = true;
              mxStencilRegistry.parseStencilSet(xmlDoc2.documentElement, postStencilLoad, install);
            }
          }));
          return;
        } else {
          xmlDoc = mxStencilRegistry.loadStencil(stencilFile);
          mxStencilRegistry.packages[stencilFile] = xmlDoc;
          install = true;
        }
      } catch (e) {
        if (window.console != null) {
          console.log("error in loadStencilSet:", stencilFile, e);
        }
      }
    }
    if (xmlDoc != null && xmlDoc.documentElement != null) {
      mxStencilRegistry.parseStencilSet(xmlDoc.documentElement, postStencilLoad, install);
    }
  }
};
mxStencilRegistry.loadStencil = function(filename, fn) {
  if (fn != null) {
    var req = get(filename, bind(this, function(req2) {
      fn(req2.getStatus() >= 200 && req2.getStatus() <= 299 ? req2.getXml() : null);
    }));
  } else {
    return load(filename).getXml();
  }
};
mxStencilRegistry.parseStencilSets = function(stencils) {
  for (var i = 0; i < stencils.length; i++) {
    mxStencilRegistry.parseStencilSet(parseXml(stencils[i]).documentElement);
  }
};
mxStencilRegistry.parseStencilSet = function(root, postStencilLoad, install) {
  if (root.nodeName == "stencils") {
    var shapes = root.firstChild;
    while (shapes != null) {
      if (shapes.nodeName == "shapes") {
        mxStencilRegistry.parseStencilSet(shapes, postStencilLoad, install);
      }
      shapes = shapes.nextSibling;
    }
  } else {
    install = install != null ? install : true;
    var shape = root.firstChild;
    var packageName = "";
    var name = root.getAttribute("name");
    if (name != null) {
      packageName = name + ".";
    }
    while (shape != null) {
      if (shape.nodeType == mxConstants2.NODETYPE_ELEMENT) {
        name = shape.getAttribute("name");
        if (name != null) {
          packageName = packageName.toLowerCase();
          var stencilName = name.replace(/ /g, "_");
          if (install) {
            mxStencilRegistry.addStencil(packageName + stencilName.toLowerCase(), new mxStencil2(shape));
          }
          if (postStencilLoad != null) {
            var w2 = shape.getAttribute("w");
            var h2 = shape.getAttribute("h");
            w2 = w2 == null ? 80 : parseInt(w2, 10);
            h2 = h2 == null ? 80 : parseInt(h2, 10);
            postStencilLoad(packageName, stencilName, name, w2, h2);
          }
        }
      }
      shape = shape.nextSibling;
    }
  }
};
if (typeof mxVertexHandler2 != "undefined") {
  let createHint = function() {
    var hint = document.createElement("div");
    hint.className = "geHint";
    hint.style.whiteSpace = "nowrap";
    hint.style.position = "absolute";
    return hint;
  }, formatHintText = function(pixels, unit) {
    switch (unit) {
      case mxConstants2.POINTS:
        return pixels;
      case mxConstants2.MILLIMETERS:
        return (pixels / mxConstants2.PIXELS_PER_MM).toFixed(1);
      case mxConstants2.INCHES:
        return (pixels / mxConstants2.PIXELS_PER_INCH).toFixed(2);
    }
  };
  mxConstants2.HANDLE_FILLCOLOR = "#29b6f2";
  mxConstants2.HANDLE_STROKECOLOR = "#0088cf";
  mxConstants2.VERTEX_SELECTION_COLOR = "#00a8ff";
  mxConstants2.OUTLINE_COLOR = "#00a8ff";
  mxConstants2.OUTLINE_HANDLE_FILLCOLOR = "#99ccff";
  mxConstants2.OUTLINE_HANDLE_STROKECOLOR = "#00a8ff";
  mxConstants2.CONNECT_HANDLE_FILLCOLOR = "#cee7ff";
  mxConstants2.EDGE_SELECTION_COLOR = "#00a8ff";
  mxConstants2.DEFAULT_VALID_COLOR = "#00a8ff";
  mxConstants2.LABEL_HANDLE_FILLCOLOR = "#cee7ff";
  mxConstants2.GUIDE_COLOR = "#0088cf";
  mxConstants2.HIGHLIGHT_OPACITY = 30;
  mxConstants2.HIGHLIGHT_SIZE = 5;
  mxEdgeHandler2.prototype.snapToTerminals = true;
  mxGraphHandler.prototype.guidesEnabled = true;
  mxGraphHandler.prototype.removeEmptyParents = true;
  mxRubberband.prototype.fadeOut = true;
  mxGuide.prototype.isEnabledForEvent = function(evt) {
    return !mxEvent2.isAltDown(evt);
  };
  graphLayoutIsVertexIgnored = mxGraphLayout.prototype.isVertexIgnored;
  mxGraphLayout.prototype.isVertexIgnored = function(vertex) {
    return graphLayoutIsVertexIgnored.apply(this, arguments) || this.graph.isTableRow(vertex) || this.graph.isTableCell(vertex);
  };
  mxConnectionHandlerCreateTarget = mxConnectionHandler.prototype.isCreateTarget;
  mxConnectionHandler.prototype.isCreateTarget = function(evt) {
    return this.graph.isCloneEvent(evt) || mxConnectionHandlerCreateTarget.apply(this, arguments);
  };
  mxConstraintHandler.prototype.createHighlightShape = function() {
    var hl = new mxEllipse(null, this.highlightColor, this.highlightColor, 0);
    hl.opacity = mxConstants2.HIGHLIGHT_OPACITY;
    return hl;
  };
  mxConnectionHandler.prototype.livePreview = true;
  mxConnectionHandler.prototype.cursor = "crosshair";
  mxConnectionHandler.prototype.createEdgeState = function(me) {
    var style = this.graph.createCurrentEdgeStyle();
    var edge = this.graph.createEdge(null, null, null, null, null, style);
    console.log("edgestate");
    var state2 = new mxCellState(this.graph.view, edge, this.graph.getCellStyle(edge));
    for (var key in this.graph.currentEdgeStyle) {
      state2.style[key] = this.graph.currentEdgeStyle[key];
    }
    return state2;
  };
  connectionHandlerCreateShape = mxConnectionHandler.prototype.createShape;
  mxConnectionHandler.prototype.createShape = function() {
    var shape = connectionHandlerCreateShape.apply(this, arguments);
    shape.isDashed = this.graph.currentEdgeStyle[mxConstants2.STYLE_DASHED] == "1";
    return shape;
  };
  mxConnectionHandler.prototype.updatePreview = function(valid) {
  };
  mxConnectionHandlerCreateMarker = mxConnectionHandler.prototype.createMarker;
  mxConnectionHandler.prototype.createMarker = function() {
    var marker = mxConnectionHandlerCreateMarker.apply(this, arguments);
    var markerGetCell = marker.getCell;
    marker.getCell = bind(this, function(me) {
      var result2 = markerGetCell.apply(this, arguments);
      this.error = null;
      return result2;
    });
    return marker;
  };
  Graph2.prototype.defaultVertexStyle = {};
  Graph2.prototype.defaultEdgeStyle = {
    edgeStyle: "orthogonalEdgeStyle",
    rounded: "0",
    jettySize: "auto",
    orthogonalLoop: "1"
  };
  Graph2.prototype.createCurrentEdgeStyle = function() {
    var style = "edgeStyle=" + (this.currentEdgeStyle["edgeStyle"] || "none") + ";";
    var keys = [
      "shape",
      "curved",
      "rounded",
      "comic",
      "sketch",
      "fillWeight",
      "hachureGap",
      "hachureAngle",
      "jiggle",
      "disableMultiStroke",
      "disableMultiStrokeFill",
      "fillStyle",
      "curveFitting",
      "simplification",
      "comicStyle",
      "jumpStyle",
      "jumpSize"
    ];
    for (var i = 0; i < keys.length; i++) {
      if (this.currentEdgeStyle[keys[i]] != null) {
        style += keys[i] + "=" + this.currentEdgeStyle[keys[i]] + ";";
      }
    }
    if (this.currentEdgeStyle["orthogonalLoop"] != null) {
      style += "orthogonalLoop=" + this.currentEdgeStyle["orthogonalLoop"] + ";";
    } else if (Graph2.prototype.defaultEdgeStyle["orthogonalLoop"] != null) {
      style += "orthogonalLoop=" + Graph2.prototype.defaultEdgeStyle["orthogonalLoop"] + ";";
    }
    if (this.currentEdgeStyle["jettySize"] != null) {
      style += "jettySize=" + this.currentEdgeStyle["jettySize"] + ";";
    } else if (Graph2.prototype.defaultEdgeStyle["jettySize"] != null) {
      style += "jettySize=" + Graph2.prototype.defaultEdgeStyle["jettySize"] + ";";
    }
    if (this.currentEdgeStyle["edgeStyle"] == "elbowEdgeStyle" && this.currentEdgeStyle["elbow"] != null) {
      style += "elbow=" + this.currentEdgeStyle["elbow"] + ";";
    }
    if (this.currentEdgeStyle["html"] != null) {
      style += "html=" + this.currentEdgeStyle["html"] + ";";
    } else {
      style += "html=1;";
    }
    return style;
  };
  Graph2.prototype.updateCellStyles = function(key, value, cells) {
    this.model.beginUpdate();
    try {
      for (var i = 0; i < cells.length; i++) {
        if (this.model.isVertex(cells[i]) || this.model.isEdge(cells[i])) {
          this.setCellStyles(key, null, [cells[i]]);
          var style = this.getCellStyle(cells[i]);
          var temp2 = style[key];
          if (value != (temp2 == null ? mxConstants2.NONE : temp2)) {
            this.setCellStyles(key, value, [cells[i]]);
          }
        }
      }
    } finally {
      this.model.endUpdate();
    }
  };
  Graph2.prototype.getPagePadding = function() {
    return new mxPoint2(0, 0);
  };
  Graph2.prototype.loadStylesheet = function() {
    var node = this.themes != null ? this.themes[this.defaultThemeName] : !mxStyleRegistry.dynamicLoading ? null : load(STYLE_PATH + "/default.xml").getDocumentElement();
    if (node != null) {
      var dec = new mxCodec(node.ownerDocument);
      dec.decode(node, this.getStylesheet());
    }
  };
  Graph2.prototype.createCellLookup = function(cells, lookup) {
    lookup = lookup != null ? lookup : new Object();
    for (var i = 0; i < cells.length; i++) {
      var cell2 = cells[i];
      lookup[mxObjectIdentity.get(cell2)] = cell2.getId();
      var childCount = this.model.getChildCount(cell2);
      for (var j = 0; j < childCount; j++) {
        this.createCellLookup([this.model.getChildAt(cell2, j)], lookup);
      }
    }
    return lookup;
  };
  Graph2.prototype.createCellMapping = function(mapping, lookup, cellMapping) {
    cellMapping = cellMapping != null ? cellMapping : new Object();
    for (var objectId in mapping) {
      var cellId = lookup[objectId];
      if (cellMapping[cellId] == null) {
        cellMapping[cellId] = mapping[objectId].getId() || "";
      }
    }
    return cellMapping;
  };
  Graph2.prototype.importGraphModel = function(node, dx, dy, crop) {
    dx = dx != null ? dx : 0;
    dy = dy != null ? dy : 0;
    var codec = new mxCodec(node.ownerDocument);
    var tempModel = new mxGraphModel2();
    codec.decode(node, tempModel);
    var cells = [];
    var cloneMap = new Object();
    var cellMapping = new Object();
    var layers = tempModel.getChildren(this.cloneCell(tempModel.root, this.isCloneInvalidEdges(), cloneMap));
    if (layers != null) {
      var lookup = this.createCellLookup([tempModel.root]);
      layers = layers.slice();
      this.model.beginUpdate();
      try {
        if (layers.length == 1 && !this.isCellLocked(this.getDefaultParent())) {
          var children = tempModel.getChildren(layers[0]);
          if (children != null) {
            cells = this.moveCells(children, dx, dy, false, this.getDefaultParent());
            cellMapping[tempModel.getChildAt(tempModel.root, 0).getId()] = this.getDefaultParent().getId();
          }
        } else {
          for (var i = 0; i < layers.length; i++) {
            var children = this.model.getChildren(this.moveCells([layers[i]], dx, dy, false, this.model.getRoot())[0]);
            if (children != null) {
              cells = cells.concat(children);
            }
          }
        }
        if (cells != null) {
          this.createCellMapping(cloneMap, lookup, cellMapping);
          this.updateCustomLinks(cellMapping, cells);
          if (crop) {
            if (this.isGridEnabled()) {
              dx = this.snap(dx);
              dy = this.snap(dy);
            }
            var bounds = this.getBoundingBoxFromGeometry(cells, true);
            if (bounds != null) {
              this.moveCells(cells, dx - bounds.x, dy - bounds.y);
            }
          }
        }
      } finally {
        this.model.endUpdate();
      }
    }
    return cells;
  };
  Graph2.prototype.encodeCells = function(cells) {
    var cloneMap = new Object();
    var clones = this.cloneCells(cells, null, cloneMap);
    var dict = new mxDictionary();
    for (var i = 0; i < cells.length; i++) {
      dict.put(cells[i], true);
    }
    var codec = new mxCodec();
    var model = new mxGraphModel2();
    var parent2 = model.getChildAt(model.getRoot(), 0);
    for (var i = 0; i < clones.length; i++) {
      model.add(parent2, clones[i]);
      var state2 = this.view.getState(cells[i]);
      if (state2 != null) {
        var geo = this.getCellGeometry(clones[i]);
        if (geo != null && geo.relative && !this.model.isEdge(cells[i]) && dict.get(this.model.getParent(cells[i])) == null) {
          geo.offset = null;
          geo.relative = false;
          geo.x = state2.x / state2.view.scale - state2.view.translate.x;
          geo.y = state2.y / state2.view.scale - state2.view.translate.y;
        }
      }
    }
    this.updateCustomLinks(this.createCellMapping(cloneMap, this.createCellLookup(cells)), clones);
    return codec.encode(model);
  };
  Graph2.prototype.isSwimlane = function(cell2, ignoreState) {
    if (cell2 != null && this.model.getParent(cell2) != this.model.getRoot() && !this.model.isEdge(cell2)) {
      var shape = this.getCurrentCellStyle(cell2, ignoreState)[mxConstants2.STYLE_SHAPE];
      return shape == mxConstants2.SHAPE_SWIMLANE || shape == "table";
    }
    return false;
  };
  graphIsExtendParent = Graph2.prototype.isExtendParent;
  Graph2.prototype.isExtendParent = function(cell2) {
    var parent2 = this.model.getParent(cell2);
    if (parent2 != null) {
      var style = this.getCurrentCellStyle(parent2);
      if (style["expand"] != null) {
        return style["expand"] != "0";
      }
    }
    return graphIsExtendParent.apply(this, arguments) && (parent2 == null || !this.isTable(parent2));
  };
  graphSplitEdge = Graph2.prototype.splitEdge;
  Graph2.prototype.splitEdge = function(edge, cells, newEdge, dx, dy, x, y, parent2) {
    if (parent2 == null) {
      parent2 = this.model.getParent(edge);
      if (this.isTable(parent2) || this.isTableRow(parent2)) {
        parent2 = this.getCellAt(x, y, null, true, false);
      }
    }
    graphSplitEdge.apply(this, [edge, cells, newEdge, dx, dy, x, y, parent2]);
  };
  graphSelectCell = Graph2.prototype.selectCell;
  Graph2.prototype.selectCell = function(isNext, isParent, isChild) {
    if (isParent || isChild) {
      graphSelectCell.apply(this, arguments);
    } else {
      var cell2 = this.getSelectionCell();
      var index = null;
      var cells = [];
      var flatten = bind(this, function(temp2) {
        if (this.view.getState(temp2) != null && (this.model.isVertex(temp2) || this.model.isEdge(temp2))) {
          cells.push(temp2);
          if (temp2 == cell2) {
            index = cells.length - 1;
          } else if (isNext && cell2 == null && cells.length > 0 || index != null && isNext && cells.length > index || !isNext && index > 0) {
            return;
          }
        }
        for (var i = 0; i < this.model.getChildCount(temp2); i++) {
          flatten(this.model.getChildAt(temp2, i));
        }
      });
      flatten(this.model.root);
      if (cells.length > 0) {
        if (index != null) {
          index = mod(index + (isNext ? 1 : -1), cells.length);
        } else {
          index = 0;
        }
        this.setSelectionCell(cells[index]);
      }
    }
  };
  graphMoveCells = Graph2.prototype.moveCells;
  Graph2.prototype.moveCells = function(cells, dx, dy, clone3, target, evt, mapping) {
    mapping = mapping != null ? mapping : new Object();
    if (this.isTable(target)) {
      var newCells = [];
      for (var i = 0; i < cells.length; i++) {
        if (this.isTable(cells[i])) {
          newCells = newCells.concat(this.model.getChildCells(cells[i], true).reverse());
        } else {
          newCells.push(cells[i]);
        }
      }
      cells = newCells;
    }
    this.model.beginUpdate();
    try {
      var sourceTables = [];
      for (var i = 0; i < cells.length; i++) {
        if (target != null && this.isTableRow(cells[i])) {
          var parent2 = this.model.getParent(cells[i]);
          var row = this.getCellGeometry(cells[i]);
          if (this.isTable(parent2)) {
            sourceTables.push(parent2);
          }
          if (parent2 != null && row != null && this.isTable(parent2) && this.isTable(target) && (clone3 || parent2 != target)) {
            if (!clone3) {
              var table = this.getCellGeometry(parent2);
              if (table != null) {
                table = table.clone();
                table.height -= row.height;
                this.model.setGeometry(parent2, table);
              }
            }
            var table = this.getCellGeometry(target);
            if (table != null) {
              table = table.clone();
              table.height += row.height;
              this.model.setGeometry(target, table);
            }
            var rows = this.model.getChildCells(target, true);
            if (rows.length > 0) {
              var cell2 = clone3 ? this.cloneCell(cells[i]) : cells[i];
              var sourceCols = this.model.getChildCells(cell2, true);
              var cols = this.model.getChildCells(rows[0], true);
              var count = cols.length - sourceCols.length;
              if (count > 0) {
                for (var j = 0; j < count; j++) {
                  var col = this.cloneCell(sourceCols[sourceCols.length - 1]);
                  if (col != null) {
                    col.value = "";
                    this.model.add(cell2, col);
                  }
                }
              } else if (count < 0) {
                for (var j = 0; j > count; j--) {
                  this.model.remove(sourceCols[sourceCols.length + j - 1]);
                }
              }
              sourceCols = this.model.getChildCells(cell2, true);
              for (var j = 0; j < cols.length; j++) {
                var geo = this.getCellGeometry(cols[j]);
                var geo2 = this.getCellGeometry(sourceCols[j]);
                if (geo != null && geo2 != null) {
                  geo2 = geo2.clone();
                  geo2.width = geo.width;
                  this.model.setGeometry(sourceCols[j], geo2);
                }
              }
            }
          }
        }
      }
      var result2 = graphMoveCells.apply(this, arguments);
      for (var i = 0; i < sourceTables.length; i++) {
        if (!clone3 && this.model.contains(sourceTables[i]) && this.model.getChildCount(sourceTables[i]) == 0) {
          this.model.remove(sourceTables[i]);
        }
      }
      if (clone3) {
        this.updateCustomLinks(this.createCellMapping(mapping, this.createCellLookup(cells)), result2);
      }
    } finally {
      this.model.endUpdate();
    }
    return result2;
  };
  graphRemoveCells = Graph2.prototype.removeCells;
  Graph2.prototype.removeCells = function(cells, includeEdges) {
    var result2 = [];
    this.model.beginUpdate();
    try {
      for (var i = 0; i < cells.length; i++) {
        if (this.isTableCell(cells[i])) {
          var row = this.model.getParent(cells[i]);
          var table = this.model.getParent(row);
          if (this.model.getChildCount(row) == 1 && this.model.getChildCount(table) == 1) {
            if (indexOf(cells, table) < 0 && indexOf(result2, table) < 0) {
              result2.push(table);
            }
          } else {
            this.labelChanged(cells[i], "");
          }
        } else {
          if (this.isTableRow(cells[i])) {
            var table = this.model.getParent(cells[i]);
            if (indexOf(cells, table) < 0 && indexOf(result2, table) < 0) {
              var rows = this.model.getChildCells(table, true);
              var deleteCount = 0;
              for (var j = 0; j < rows.length; j++) {
                if (indexOf(cells, rows[j]) >= 0) {
                  deleteCount++;
                }
              }
              if (deleteCount == rows.length) {
                result2.push(table);
              }
            }
          }
          result2.push(cells[i]);
        }
      }
      result2 = graphRemoveCells.apply(this, [result2, includeEdges]);
    } finally {
      this.model.endUpdate();
    }
    return result2;
  };
  Graph2.prototype.updateCustomLinks = function(mapping, cells) {
    for (var i = 0; i < cells.length; i++) {
      if (cells[i] != null) {
        this.updateCustomLinksForCell(mapping, cells[i]);
      }
    }
  };
  Graph2.prototype.updateCustomLinksForCell = function(mapping, cell2) {
  };
  Graph2.prototype.getAllConnectionConstraints = function(terminal, source) {
    if (terminal != null) {
      var constraints = getValue(terminal.style, "points", null);
      if (constraints != null) {
        var result2 = [];
        try {
          var c = JSON.parse(constraints);
          for (var i = 0; i < c.length; i++) {
            var tmp = c[i];
            result2.push(new mxConnectionConstraint(new mxPoint2(tmp[0], tmp[1]), tmp.length > 2 ? tmp[2] != "0" : true, null, tmp.length > 3 ? tmp[3] : 0, tmp.length > 4 ? tmp[4] : 0));
          }
        } catch (e) {
        }
        return result2;
      } else if (terminal.shape != null && terminal.shape.bounds != null) {
        var dir = terminal.shape.direction;
        var bounds = terminal.shape.bounds;
        var scale = terminal.shape.scale;
        var w2 = bounds.width / scale;
        var h2 = bounds.height / scale;
        if (dir == mxConstants2.DIRECTION_NORTH || dir == mxConstants2.DIRECTION_SOUTH) {
          var tmp = w2;
          w2 = h2;
          h2 = tmp;
        }
        constraints = terminal.shape.getConstraints(terminal.style, w2, h2);
        if (constraints != null) {
          return constraints;
        } else if (terminal.shape.stencil != null && terminal.shape.stencil.constraints != null) {
          return terminal.shape.stencil.constraints;
        } else if (terminal.shape.constraints != null) {
          return terminal.shape.constraints;
        }
      }
    }
    return null;
  };
  Graph2.prototype.flipEdge = function(edge) {
    if (edge != null) {
      var style = this.getCurrentCellStyle(edge);
      var elbow = getValue(style, mxConstants2.STYLE_ELBOW, mxConstants2.ELBOW_HORIZONTAL);
      var value = elbow == mxConstants2.ELBOW_HORIZONTAL ? mxConstants2.ELBOW_VERTICAL : mxConstants2.ELBOW_HORIZONTAL;
      this.setCellStyles(mxConstants2.STYLE_ELBOW, value, [edge]);
    }
  };
  Graph2.prototype.isValidRoot = function(cell2) {
    var childCount = this.model.getChildCount(cell2);
    var realChildCount = 0;
    for (var i = 0; i < childCount; i++) {
      var child = this.model.getChildAt(cell2, i);
      if (this.model.isVertex(child)) {
        var geometry = this.getCellGeometry(child);
        if (geometry != null && !geometry.relative) {
          realChildCount++;
        }
      }
    }
    return realChildCount > 0 || this.isContainer(cell2);
  };
  Graph2.prototype.isValidDropTarget = function(cell2, cells, evt) {
    var style = this.getCurrentCellStyle(cell2);
    var tables = true;
    var rows = true;
    for (var i = 0; i < cells.length && rows; i++) {
      tables = tables && this.isTable(cells[i]);
      rows = rows && this.isTableRow(cells[i]);
    }
    return (getValue(style, "part", "0") != "1" || this.isContainer(cell2)) && getValue(style, "dropTarget", "1") != "0" && (mxGraph2.prototype.isValidDropTarget.apply(this, arguments) || this.isContainer(cell2)) && !this.isTableRow(cell2) && (!this.isTable(cell2) || rows || tables);
  };
  Graph2.prototype.createGroupCell = function() {
    var group = mxGraph2.prototype.createGroupCell.apply(this, arguments);
    group.setStyle("group");
    return group;
  };
  Graph2.prototype.isExtendParentsOnAdd = function(cell2) {
    var result2 = mxGraph2.prototype.isExtendParentsOnAdd.apply(this, arguments);
    if (result2 && cell2 != null && this.layoutManager != null) {
      var parent2 = this.model.getParent(cell2);
      if (parent2 != null) {
        var layout = this.layoutManager.getLayout(parent2);
        if (layout != null && layout.constructor == mxStackLayout) {
          result2 = false;
        }
      }
    }
    return result2;
  };
  Graph2.prototype.getPreferredSizeForCell = function(cell2) {
    var result2 = mxGraph2.prototype.getPreferredSizeForCell.apply(this, arguments);
    if (result2 != null) {
      result2.width += 10;
      result2.height += 4;
      if (this.gridEnabled) {
        result2.width = this.snap(result2.width);
        result2.height = this.snap(result2.height);
      }
    }
    return result2;
  };
  Graph2.prototype.turnShapes = function(cells, backwards) {
    var model = this.getModel();
    var select = [];
    model.beginUpdate();
    try {
      for (var i = 0; i < cells.length; i++) {
        var cell2 = cells[i];
        if (model.isEdge(cell2)) {
          var src = model.getTerminal(cell2, true);
          var trg = model.getTerminal(cell2, false);
          model.setTerminal(cell2, trg, true);
          model.setTerminal(cell2, src, false);
          var geo = model.getGeometry(cell2);
          if (geo != null) {
            geo = geo.clone();
            if (geo.points != null) {
              geo.points.reverse();
            }
            var sp = geo.getTerminalPoint(true);
            var tp = geo.getTerminalPoint(false);
            geo.setTerminalPoint(sp, false);
            geo.setTerminalPoint(tp, true);
            model.setGeometry(cell2, geo);
            var edgeState = this.view.getState(cell2);
            var sourceState = this.view.getState(src);
            var targetState = this.view.getState(trg);
            if (edgeState != null) {
              var sc = sourceState != null ? this.getConnectionConstraint(edgeState, sourceState, true) : null;
              var tc = targetState != null ? this.getConnectionConstraint(edgeState, targetState, false) : null;
              this.setConnectionConstraint(cell2, src, true, tc);
              this.setConnectionConstraint(cell2, trg, false, sc);
            }
            select.push(cell2);
          }
        } else if (model.isVertex(cell2)) {
          var geo = this.getCellGeometry(cell2);
          if (geo != null) {
            if (!this.isTable(cell2) && !this.isTableRow(cell2) && !this.isTableCell(cell2) && !this.isSwimlane(cell2)) {
              geo = geo.clone();
              geo.x += geo.width / 2 - geo.height / 2;
              geo.y += geo.height / 2 - geo.width / 2;
              var tmp = geo.width;
              geo.width = geo.height;
              geo.height = tmp;
              model.setGeometry(cell2, geo);
            }
            var state2 = this.view.getState(cell2);
            if (state2 != null) {
              var dirs = [
                mxConstants2.DIRECTION_EAST,
                mxConstants2.DIRECTION_SOUTH,
                mxConstants2.DIRECTION_WEST,
                mxConstants2.DIRECTION_NORTH
              ];
              var dir = getValue(state2.style, mxConstants2.STYLE_DIRECTION, mxConstants2.DIRECTION_EAST);
              this.setCellStyles(mxConstants2.STYLE_DIRECTION, dirs[mod(indexOf(dirs, dir) + (backwards ? -1 : 1), dirs.length)], [cell2]);
            }
            select.push(cell2);
          }
        }
      }
    } finally {
      model.endUpdate();
    }
    return select;
  };
  Graph2.prototype.stencilHasPlaceholders = function(stencil) {
    if (stencil != null && stencil.fgNode != null) {
      var node = stencil.fgNode.firstChild;
      while (node != null) {
        if (node.nodeName == "text" && node.getAttribute("placeholders") == "1") {
          return true;
        }
        node = node.nextSibling;
      }
    }
    return false;
  };
  graphProcessChange = Graph2.prototype.processChange;
  Graph2.prototype.processChange = function(change) {
    if (change instanceof mxGeometryChange && (this.isTableCell(change.cell) || this.isTableRow(change.cell)) && (change.previous == null && change.geometry != null || change.previous != null && !change.previous.equals(change.geometry))) {
      var cell2 = change.cell;
      if (this.isTableCell(cell2)) {
        cell2 = this.model.getParent(cell2);
      }
      if (this.isTableRow(cell2)) {
        cell2 = this.model.getParent(cell2);
      }
      var state2 = this.view.getState(cell2);
      if (state2 != null && state2.shape != null) {
        this.view.invalidate(cell2);
        state2.shape.bounds = null;
      }
    }
    graphProcessChange.apply(this, arguments);
    if (change instanceof mxValueChange && change.cell != null && change.cell.value != null && typeof change.cell.value == "object") {
      this.invalidateDescendantsWithPlaceholders(change.cell);
    }
  };
  Graph2.prototype.invalidateDescendantsWithPlaceholders = function(cell2) {
    var desc = this.model.getDescendants(cell2);
    if (desc.length > 0) {
      for (var i = 0; i < desc.length; i++) {
        var state2 = this.view.getState(desc[i]);
        if (state2 != null && state2.shape != null && state2.shape.stencil != null && this.stencilHasPlaceholders(state2.shape.stencil)) {
          this.removeStateForCell(desc[i]);
        } else if (this.isReplacePlaceholders(desc[i])) {
          this.view.invalidate(desc[i], false, false);
        }
      }
    }
  };
  Graph2.prototype.replaceElement = function(elt, tagName) {
    var span = elt.ownerDocument.createElement(tagName != null ? tagName : "span");
    var attributes = Array.prototype.slice.call(elt.attributes);
    while (attr = attributes.pop()) {
      span.setAttribute(attr.nodeName, attr.nodeValue);
    }
    span.innerHTML = elt.innerHTML;
    elt.parentNode.replaceChild(span, elt);
  };
  Graph2.prototype.processElements = function(elt, fn) {
    if (elt != null) {
      var elts = elt.getElementsByTagName("*");
      for (var i = 0; i < elts.length; i++) {
        fn(elts[i]);
      }
    }
  };
  Graph2.prototype.updateLabelElements = function(cells, fn, tagName) {
    cells = cells != null ? cells : this.getSelectionCells();
    var div = document.createElement("div");
    for (var i = 0; i < cells.length; i++) {
      if (this.isHtmlLabel(cells[i])) {
        var label = this.convertValueToString(cells[i]);
        if (label != null && label.length > 0) {
          div.innerHTML = label;
          var elts = div.getElementsByTagName(tagName != null ? tagName : "*");
          for (var j = 0; j < elts.length; j++) {
            fn(elts[j]);
          }
          if (div.innerHTML != label) {
            this.cellLabelChanged(cells[i], div.innerHTML);
          }
        }
      }
    }
  };
  Graph2.prototype.cellLabelChanged = function(cell2, value, autoSize) {
    value = Graph2.zapGremlins(value);
    this.model.beginUpdate();
    try {
      if (cell2.value != null && typeof cell2.value == "object") {
        if (this.isReplacePlaceholders(cell2) && cell2.getAttribute("placeholder") != null) {
          var name = cell2.getAttribute("placeholder");
          var current2 = cell2;
          while (current2 != null) {
            if (current2 == this.model.getRoot() || current2.value != null && typeof current2.value == "object" && current2.hasAttribute(name)) {
              this.setAttributeForCell(current2, name, value);
              break;
            }
            current2 = this.model.getParent(current2);
          }
        }
        var tmp = cell2.value.cloneNode(true);
        if (Graph2.translateDiagram && Graph2.diagramLanguage != null && tmp.hasAttribute("label_" + Graph2.diagramLanguage)) {
          tmp.setAttribute("label_" + Graph2.diagramLanguage, value);
        } else {
          tmp.setAttribute("label", value);
        }
        value = tmp;
      }
      mxGraph2.prototype.cellLabelChanged.apply(this, arguments);
    } finally {
      this.model.endUpdate();
    }
  };
  Graph2.prototype.cellsRemoved = function(cells) {
    if (cells != null) {
      var dict = new mxDictionary();
      for (var i = 0; i < cells.length; i++) {
        dict.put(cells[i], true);
      }
      var parents = [];
      for (var i = 0; i < cells.length; i++) {
        var parent2 = this.model.getParent(cells[i]);
        if (parent2 != null && !dict.get(parent2)) {
          dict.put(parent2, true);
          parents.push(parent2);
        }
      }
      for (var i = 0; i < parents.length; i++) {
        var state2 = this.view.getState(parents[i]);
        if (state2 != null && (this.model.isEdge(state2.cell) || this.model.isVertex(state2.cell)) && this.isCellDeletable(state2.cell) && this.isTransparentState(state2)) {
          var allChildren = true;
          for (var j = 0; j < this.model.getChildCount(state2.cell) && allChildren; j++) {
            if (!dict.get(this.model.getChildAt(state2.cell, j))) {
              allChildren = false;
            }
          }
          if (allChildren) {
            cells.push(state2.cell);
          }
        }
      }
    }
    mxGraph2.prototype.cellsRemoved.apply(this, arguments);
  };
  Graph2.prototype.removeCellsAfterUngroup = function(cells) {
    var cellsToRemove = [];
    for (var i = 0; i < cells.length; i++) {
      if (this.isCellDeletable(cells[i]) && this.isTransparentState(this.view.getState(cells[i]))) {
        cellsToRemove.push(cells[i]);
      }
    }
    cells = cellsToRemove;
    mxGraph2.prototype.removeCellsAfterUngroup.apply(this, arguments);
  };
  Graph2.prototype.setLinkForCell = function(cell2, link2) {
    this.setAttributeForCell(cell2, "link", link2);
  };
  Graph2.prototype.setTooltipForCell = function(cell2, link2) {
    var key = "tooltip";
    if (Graph2.translateDiagram && Graph2.diagramLanguage != null && isNode(cell2.value) && cell2.value.hasAttribute("tooltip_" + Graph2.diagramLanguage)) {
      key = "tooltip_" + Graph2.diagramLanguage;
    }
    this.setAttributeForCell(cell2, key, link2);
  };
  Graph2.prototype.getAttributeForCell = function(cell2, attributeName, defaultValue) {
    var value = cell2.value != null && typeof cell2.value === "object" ? cell2.value.getAttribute(attributeName) : null;
    return value != null ? value : defaultValue;
  };
  Graph2.prototype.setAttributeForCell = function(cell2, attributeName, attributeValue) {
    var value = null;
    if (cell2.value != null && typeof cell2.value == "object") {
      value = cell2.value.cloneNode(true);
    } else {
      var doc = createXmlDocument();
      value = doc.createElement("UserObject");
      value.setAttribute("label", cell2.value || "");
    }
    if (attributeValue != null) {
      value.setAttribute(attributeName, attributeValue);
    } else {
      value.removeAttribute(attributeName);
    }
    this.model.setValue(cell2, value);
  };
  graphGetDropTarget = Graph2.prototype.getDropTarget;
  Graph2.prototype.getDropTarget = function(cells, evt, cell2, clone3) {
    var model = this.getModel();
    if (mxEvent2.isAltDown(evt)) {
      return null;
    }
    for (var i = 0; i < cells.length; i++) {
      if (this.model.isEdge(this.model.getParent(cells[i]))) {
        return null;
      }
    }
    var target = graphGetDropTarget.apply(this, arguments);
    var rows = true;
    for (var i = 0; i < cells.length && rows; i++) {
      rows = rows && this.isTableRow(cells[i]);
    }
    if (rows) {
      if (this.isTableCell(target)) {
        target = this.model.getParent(target);
      }
      if (this.isTableRow(target)) {
        target = this.model.getParent(target);
      }
      if (!this.isTable(target)) {
        target = null;
      }
    }
    return target;
  };
  Graph2.prototype.click = function(me) {
    mxGraph2.prototype.click.call(this, me);
    this.firstClickState = me.getState();
    this.firstClickSource = me.getSource();
  };
  Graph2.prototype.dblClick = function(evt, cell2) {
    if (this.isEnabled()) {
      cell2 = this.insertTextForEvent(evt, cell2);
      mxGraph2.prototype.dblClick.call(this, evt, cell2);
    }
  };
  Graph2.prototype.insertTextForEvent = function(evt, cell2) {
    var pt = convertPoint(this.container, mxEvent2.getClientX(evt), mxEvent2.getClientY(evt));
    if (evt != null && !this.model.isVertex(cell2)) {
      var state2 = this.model.isEdge(cell2) ? this.view.getState(cell2) : null;
      var src = mxEvent2.getSource(evt);
      if (this.firstClickState == state2 && this.firstClickSource == src && (state2 == null || state2.text == null || state2.text.node == null || state2.text.boundingBox == null || !contains(state2.text.boundingBox, pt.x, pt.y) && !isAncestorNode(state2.text.node, mxEvent2.getSource(evt))) && (state2 == null && !this.isCellLocked(this.getDefaultParent()) || state2 != null && !this.isCellLocked(state2.cell)) && (state2 != null || mxClient_default.IS_VML && src == this.view.getCanvas() || mxClient_default.IS_SVG && src == this.view.getCanvas().ownerSVGElement)) {
        if (state2 == null) {
          state2 = this.view.getState(this.getCellAt(pt.x, pt.y));
        }
        cell2 = this.addText(pt.x, pt.y, state2);
      }
    }
    return cell2;
  };
  Graph2.prototype.getInsertPoint = function() {
    var gs = this.getGridSize();
    var dx = this.container.scrollLeft / this.view.scale - this.view.translate.x;
    var dy = this.container.scrollTop / this.view.scale - this.view.translate.y;
    if (this.pageVisible) {
      var layout = this.getPageLayout();
      var page = this.getPageSize();
      dx = Math.max(dx, layout.x * page.width);
      dy = Math.max(dy, layout.y * page.height);
    }
    return new mxPoint2(this.snap(dx + gs), this.snap(dy + gs));
  };
  Graph2.prototype.getFreeInsertPoint = function() {
    var view = this.view;
    var bds = this.getGraphBounds();
    var pt = this.getInsertPoint();
    var x = this.snap(Math.round(Math.max(pt.x, bds.x / view.scale - view.translate.x + (bds.width == 0 ? 2 * this.gridSize : 0))));
    var y = this.snap(Math.round(Math.max(pt.y, (bds.y + bds.height) / view.scale - view.translate.y + 2 * this.gridSize)));
    return new mxPoint2(x, y);
  };
  Graph2.prototype.getCenterInsertPoint = function(bbox) {
    bbox = bbox != null ? bbox : new mxRectangle();
    if (hasScrollbars(this.container)) {
      return new mxPoint2(this.snap(Math.round((this.container.scrollLeft + this.container.clientWidth / 2) / this.view.scale - this.view.translate.x - bbox.width / 2)), this.snap(Math.round((this.container.scrollTop + this.container.clientHeight / 2) / this.view.scale - this.view.translate.y - bbox.height / 2)));
    } else {
      return new mxPoint2(this.snap(Math.round(this.container.clientWidth / 2 / this.view.scale - this.view.translate.x - bbox.width / 2)), this.snap(Math.round(this.container.clientHeight / 2 / this.view.scale - this.view.translate.y - bbox.height / 2)));
    }
  };
  Graph2.prototype.isMouseInsertPoint = function() {
    return false;
  };
  Graph2.prototype.addText = function(x, y, state2) {
    var label = new mxCell();
    label.value = "Text";
    label.geometry = new mxGeometry(0, 0, 0, 0);
    label.vertex = true;
    var style = "html=1;align=center;verticalAlign=middle;resizable=0;points=[];";
    if (state2 != null && this.model.isEdge(state2.cell)) {
      label.style = "edgeLabel;" + style;
      label.geometry.relative = true;
      label.connectable = false;
      var pt2 = this.view.getRelativePoint(state2, x, y);
      label.geometry.x = Math.round(pt2.x * 1e4) / 1e4;
      label.geometry.y = Math.round(pt2.y);
      label.geometry.offset = new mxPoint2(0, 0);
      const originalGraphHandlerGetGuideStates = mxGraphHandler.prototype.getGuideStates;
      const originalGraphHandlerCreatePreviewShape = mxGraphHandler.prototype.createPreviewShape;
      const originalGraphHandlerGetCells = mxGraphHandler.prototype.getCells;
      const originalGraphHandlerStart = mxGraphHandler.prototype.start;
      const originalGraphHandlerShouldRemoveCellsFromParent = mxGraphHandler.prototype.shouldRemoveCellsFromParent;
      mxGraphHandler.prototype.getGuideStates = function() {
        var result2 = originalGraphHandlerGetGuideStates.apply(this, arguments);
        if (this.graph.pageVisible) {
          var guides = [];
          var pf = this.graph.pageFormat;
          var ps = this.graph.pageScale;
          var pw = pf.width * ps;
          var ph = pf.height * ps;
          var t = this.graph.view.translate;
          var s = this.graph.view.scale;
          var layout = this.graph.getPageLayout();
          for (var i = 0; i < layout.width; i++) {
            guides.push(new mxRectangle(((layout.x + i) * pw + t.x) * s, (layout.y * ph + t.y) * s, pw * s, ph * s));
          }
          for (var j = 1; j < layout.height; j++) {
            guides.push(new mxRectangle((layout.x * pw + t.x) * s, ((layout.y + j) * ph + t.y) * s, pw * s, ph * s));
          }
          result2 = guides.concat(result2);
        }
        return result2;
      };
      mxGraphHandler.prototype.createPreviewShape = function(bounds) {
        console.log("Live preview createPreviewShape is being called.");
        if (this.cells != null && this.cells.length > 0) {
          var cell2 = this.graph.getCompositeParent(this.cells[0]);
          var state3 = this.graph.view.getState(cell2);
          if (state3 != null && state3.shape != null) {
            var preview = state3.shape.clone();
            preview.bounds = bounds;
            preview.isShadow = false;
            preview.opacity = 50;
            preview.scale = this.graph.view.scale;
            preview.isDashed = false;
            return preview;
          }
        }
        this.previewColor = this.graph.background === "#000000" ? "#ffffff" : mxConstants2.GUIDE_COLOR;
        var shape = new mxRectangleShape(bounds, null, this.previewColor);
        shape.isDashed = true;
        return shape;
      };
      mxGraphHandler.prototype.getCells = function(initialCell) {
        var cells = originalGraphHandlerGetCells.apply(this, arguments);
        var lookup = new mxDictionary();
        var newCells = [];
        for (var i = 0; i < cells.length; i++) {
          var cell2 = this.graph.isTableCell(initialCell) && this.graph.isTableCell(cells[i]) && this.graph.isCellSelected(cells[i]) ? this.graph.model.getParent(cells[i]) : this.graph.isTableRow(initialCell) && this.graph.isTableRow(cells[i]) && this.graph.isCellSelected(cells[i]) ? cells[i] : this.graph.getCompositeParent(cells[i]);
          if (cell2 != null && !lookup.get(cell2)) {
            lookup.put(cell2, true);
            newCells.push(cell2);
          }
        }
        return newCells;
      };
      mxGraphHandler.prototype.start = function(cell2, x2, y2, cells) {
        var ignoreParent = false;
        if (this.graph.isTableCell(cell2)) {
          if (!this.graph.isCellSelected(cell2)) {
            cell2 = this.graph.model.getParent(cell2);
          } else {
            ignoreParent = true;
          }
        }
        if (!ignoreParent && (!this.graph.isTableRow(cell2) || !this.graph.isCellSelected(cell2))) {
          cell2 = this.graph.getCompositeParent(cell2);
        }
        originalGraphHandlerStart.call(this, cell2, x2, y2, cells);
      };
      mxGraphHandler.prototype.shouldRemoveCellsFromParent = function(parent2, cells, evt) {
        if (this.graph.isCellSelected(parent2)) {
          return false;
        }
        return originalGraphHandlerShouldRemoveCellsFromParent.apply(this, arguments);
      };
      pt2 = this.view.getPoint(state2, label.geometry);
      var scale = this.view.scale;
      label.geometry.offset = new mxPoint2(Math.round((x - pt2.x) / scale), Math.round((y - pt2.y) / scale));
    } else {
      var tr = this.view.translate;
      label.style = "text;" + style;
      label.geometry.width = 40;
      label.geometry.height = 20;
      label.geometry.x = Math.round(x / this.view.scale) - tr.x - (state2 != null ? state2.origin.x : 0);
      label.geometry.y = Math.round(y / this.view.scale) - tr.y - (state2 != null ? state2.origin.y : 0);
      label.style += "autosize=1;";
    }
    this.getModel().beginUpdate();
    try {
      this.addCells([label], state2 != null ? state2.cell : null);
      this.fireEvent(new mxEventObject2("textInserted", "cells", [label]));
      this.autoSizeCell(label);
    } finally {
      this.getModel().endUpdate();
    }
    return label;
  };
  Graph2.prototype.addClickHandler = function(highlight2, beforeClick, onClick) {
    var checkLinks = bind(this, function() {
      var links = this.container.getElementsByTagName("a");
      if (links != null) {
        for (var i = 0; i < links.length; i++) {
          var href = this.getAbsoluteUrl(links[i].getAttribute("href"));
          if (href != null) {
            links[i].setAttribute("rel", this.linkRelation);
            links[i].setAttribute("href", href);
            if (beforeClick != null) {
              mxEvent2.addGestureListeners(links[i], null, null, beforeClick);
            }
          }
        }
      }
    });
    this.model.addListener(mxEvent2.CHANGE, checkLinks);
    checkLinks();
    var cursor = this.container.style.cursor;
    var tol = this.getTolerance();
    var graph = this;
    var mouseListener = {
      currentState: null,
      currentLink: null,
      highlight: highlight2 != null && highlight2 != "" && highlight2 != mxConstants2.NONE ? new mxCellHighlight2(graph, highlight2, 4) : null,
      startX: 0,
      startY: 0,
      scrollLeft: 0,
      scrollTop: 0,
      updateCurrentState: function(me) {
        var tmp = me.sourceState;
        if (tmp == null || graph.getLinkForCell(tmp.cell) == null) {
          var cell2 = graph.getCellAt(me.getGraphX(), me.getGraphY(), null, null, null, function(state2, x, y) {
            return graph.getLinkForCell(state2.cell) == null;
          });
          tmp = graph.view.getState(cell2);
        }
        if (tmp != this.currentState) {
          if (this.currentState != null) {
            this.clear();
          }
          this.currentState = tmp;
          if (this.currentState != null) {
            this.activate(this.currentState);
          }
        }
      },
      mouseDown: function(sender, me) {
        this.startX = me.getGraphX();
        this.startY = me.getGraphY();
        this.scrollLeft = graph.container.scrollLeft;
        this.scrollTop = graph.container.scrollTop;
        if (this.currentLink == null && graph.container.style.overflow == "auto") {
          graph.container.style.cursor = "move";
        }
        this.updateCurrentState(me);
      },
      mouseMove: function(sender, me) {
        if (graph.isMouseDown) {
          if (this.currentLink != null) {
            var dx = Math.abs(this.startX - me.getGraphX());
            var dy = Math.abs(this.startY - me.getGraphY());
            if (dx > tol || dy > tol) {
              this.clear();
            }
          }
        } else {
          var linkNode = me.getSource();
          while (linkNode != null && linkNode.nodeName.toLowerCase() != "a") {
            linkNode = linkNode.parentNode;
          }
          if (linkNode != null) {
            this.clear();
          } else {
            if (graph.tooltipHandler != null && this.currentLink != null && this.currentState != null) {
              graph.tooltipHandler.reset(me, true, this.currentState);
            }
            if (this.currentState != null && (me.getState() == this.currentState || me.sourceState == null) && graph.intersects(this.currentState, me.getGraphX(), me.getGraphY())) {
              return;
            }
            this.updateCurrentState(me);
          }
        }
      },
      mouseUp: function(sender, me) {
        var source = me.getSource();
        var evt = me.getEvent();
        var linkNode = source;
        while (linkNode != null && linkNode.nodeName.toLowerCase() != "a") {
          linkNode = linkNode.parentNode;
        }
        if (linkNode == null && Math.abs(this.scrollLeft - graph.container.scrollLeft) < tol && Math.abs(this.scrollTop - graph.container.scrollTop) < tol && (me.sourceState == null || !me.isSource(me.sourceState.control)) && ((mxEvent2.isLeftMouseButton(evt) || mxEvent2.isMiddleMouseButton(evt)) && !mxEvent2.isPopupTrigger(evt) || mxEvent2.isTouchEvent(evt))) {
          if (this.currentLink != null) {
            var blank = graph.isBlankLink(this.currentLink);
            if ((this.currentLink.substring(0, 5) === "data:" || !blank) && beforeClick != null) {
              beforeClick(evt, this.currentLink);
            }
            if (!mxEvent2.isConsumed(evt)) {
              var target = mxEvent2.isMiddleMouseButton(evt) ? "_blank" : blank ? graph.linkTarget : "_top";
              graph.openLink(this.currentLink, target);
              me.consume();
            }
          } else if (onClick != null && !me.isConsumed() && Math.abs(this.scrollLeft - graph.container.scrollLeft) < tol && Math.abs(this.scrollTop - graph.container.scrollTop) < tol && Math.abs(this.startX - me.getGraphX()) < tol && Math.abs(this.startY - me.getGraphY()) < tol) {
            onClick(me.getEvent());
          }
        }
        this.clear();
      },
      activate: function(state2) {
        this.currentLink = graph.getAbsoluteUrl(graph.getLinkForCell(state2.cell));
        if (this.currentLink != null) {
          graph.container.style.cursor = "pointer";
          if (this.highlight != null) {
            this.highlight.highlight(state2);
          }
        }
      },
      clear: function() {
        if (graph.container != null) {
          graph.container.style.cursor = cursor;
        }
        this.currentState = null;
        this.currentLink = null;
        if (this.highlight != null) {
          this.highlight.hide();
        }
        if (graph.tooltipHandler != null) {
          graph.tooltipHandler.hide();
        }
      }
    };
    graph.click = function(me) {
    };
    graph.addMouseListener(mouseListener);
    mxEvent2.addListener(document, "mouseleave", function(evt) {
      mouseListener.clear();
    });
  };
  Graph2.prototype.duplicateCells = function(cells, append) {
    cells = cells != null ? cells : this.getSelectionCells();
    append = append != null ? append : true;
    for (var i = 0; i < cells.length; i++) {
      if (this.isTableCell(cells[i])) {
        cells[i] = this.model.getParent(cells[i]);
      }
    }
    cells = this.model.getTopmostCells(cells);
    var model = this.getModel();
    var s = this.gridSize;
    var select = [];
    model.beginUpdate();
    try {
      var clones = this.cloneCells(cells, false, null, true);
      for (var i = 0; i < cells.length; i++) {
        var parent2 = model.getParent(cells[i]);
        var child = this.moveCells([clones[i]], s, s, false)[0];
        select.push(child);
        if (append) {
          model.add(parent2, clones[i]);
        } else {
          var index = parent2.getIndex(cells[i]);
          model.add(parent2, clones[i], index + 1);
        }
        if (this.isTable(parent2)) {
          var row = this.getCellGeometry(clones[i]);
          var table = this.getCellGeometry(parent2);
          if (row != null && table != null) {
            table = table.clone();
            table.height += row.height;
            model.setGeometry(parent2, table);
          }
        }
      }
    } finally {
      model.endUpdate();
    }
    return select;
  };
  Graph2.prototype.insertImage = function(newValue, w2, h2) {
    if (newValue != null && this.cellEditor.textarea != null) {
      var tmp = this.cellEditor.textarea.getElementsByTagName("img");
      var oldImages = [];
      for (var i = 0; i < tmp.length; i++) {
        oldImages.push(tmp[i]);
      }
      document.execCommand("insertimage", false, newValue);
      var newImages = this.cellEditor.textarea.getElementsByTagName("img");
      if (newImages.length == oldImages.length + 1) {
        for (var i = newImages.length - 1; i >= 0; i--) {
          if (i == 0 || newImages[i] != oldImages[i - 1]) {
            newImages[i].setAttribute("width", w2);
            newImages[i].setAttribute("height", h2);
            break;
          }
        }
      }
    }
  };
  Graph2.prototype.insertLink = function(value) {
    if (this.cellEditor.textarea != null) {
      if (value.length == 0) {
        document.execCommand("unlink", false);
      } else if (mxClient_default.IS_FF) {
        var tmp = this.cellEditor.textarea.getElementsByTagName("a");
        var oldLinks = [];
        for (var i = 0; i < tmp.length; i++) {
          oldLinks.push(tmp[i]);
        }
        document.execCommand("createlink", false, trim(value));
        var newLinks = this.cellEditor.textarea.getElementsByTagName("a");
        if (newLinks.length == oldLinks.length + 1) {
          for (var i = newLinks.length - 1; i >= 0; i--) {
            if (newLinks[i] != oldLinks[i - 1]) {
              var tmp = newLinks[i].getElementsByTagName("a");
              while (tmp.length > 0) {
                var parent2 = tmp[0].parentNode;
                while (tmp[0].firstChild != null) {
                  parent2.insertBefore(tmp[0].firstChild, tmp[0]);
                }
                parent2.removeChild(tmp[0]);
              }
              break;
            }
          }
        }
      } else {
        document.execCommand("createlink", false, trim(value));
      }
    }
  };
  Graph2.prototype.isCellResizable = function(cell2) {
    var result2 = mxGraph2.prototype.isCellResizable.apply(this, arguments);
    var style = this.getCurrentCellStyle(cell2);
    return !this.isTableCell(cell2) && !this.isTableRow(cell2) && (result2 || getValue(style, mxConstants2.STYLE_RESIZABLE, "1") != "0" && style[mxConstants2.STYLE_WHITE_SPACE] == "wrap");
  };
  Graph2.prototype.distributeCells = function(horizontal, cells) {
    if (cells == null) {
      cells = this.getSelectionCells();
    }
    if (cells != null && cells.length > 1) {
      var vertices = [];
      var max = null;
      var min = null;
      for (var i = 0; i < cells.length; i++) {
        if (this.getModel().isVertex(cells[i])) {
          var state2 = this.view.getState(cells[i]);
          if (state2 != null) {
            var tmp = horizontal ? state2.getCenterX() : state2.getCenterY();
            max = max != null ? Math.max(max, tmp) : tmp;
            min = min != null ? Math.min(min, tmp) : tmp;
            vertices.push(state2);
          }
        }
      }
      if (vertices.length > 2) {
        vertices.sort(function(a, b) {
          return horizontal ? a.x - b.x : a.y - b.y;
        });
        var t = this.view.translate;
        var s = this.view.scale;
        min = min / s - (horizontal ? t.x : t.y);
        max = max / s - (horizontal ? t.x : t.y);
        this.getModel().beginUpdate();
        try {
          var dt = (max - min) / (vertices.length - 1);
          var t0 = min;
          for (var i = 1; i < vertices.length - 1; i++) {
            var pstate = this.view.getState(this.model.getParent(vertices[i].cell));
            var geo = this.getCellGeometry(vertices[i].cell);
            t0 += dt;
            if (geo != null && pstate != null) {
              geo = geo.clone();
              if (horizontal) {
                geo.x = Math.round(t0 - geo.width / 2) - pstate.origin.x;
              } else {
                geo.y = Math.round(t0 - geo.height / 2) - pstate.origin.y;
              }
              this.getModel().setGeometry(vertices[i].cell, geo);
            }
          }
        } finally {
          this.getModel().endUpdate();
        }
      }
    }
    return cells;
  };
  Graph2.prototype.isCloneEvent = function(evt) {
    return mxClient_default.IS_MAC && mxEvent2.isMetaDown(evt) || mxEvent2.isControlDown(evt);
  };
  Graph2.prototype.createSvgImageExport = function() {
    var exp = new mxImageExport();
    exp.getLinkForCellState = bind(this, function(state2, canvas) {
      return this.getLinkForCell(state2.cell);
    });
    return exp;
  };
  Graph2.prototype.getSvg = function(background, scale, border, nocrop, crisp, ignoreSelection, showText, imgExport, linkTarget, hasShadow) {
    var origUseCssTrans = this.useCssTransforms;
    if (origUseCssTrans) {
      this.useCssTransforms = false;
      this.view.revalidate();
      this.sizeDidChange();
    }
    try {
      scale = scale != null ? scale : 1;
      border = border != null ? border : 0;
      crisp = crisp != null ? crisp : true;
      ignoreSelection = ignoreSelection != null ? ignoreSelection : true;
      showText = showText != null ? showText : true;
      var bounds = ignoreSelection || nocrop ? this.getGraphBounds() : this.getBoundingBox(this.getSelectionCells());
      if (bounds == null) {
        throw Error(mxResources2.get("drawingEmpty"));
      }
      var vs = this.view.scale;
      var svgDoc = createXmlDocument();
      var root = svgDoc.createElementNS != null ? svgDoc.createElementNS(mxConstants2.NS_SVG, "svg") : svgDoc.createElement("svg");
      if (background != null) {
        if (root.style != null) {
          root.style.backgroundColor = background;
        } else {
          root.setAttribute("style", "background-color:" + background);
        }
      }
      if (svgDoc.createElementNS == null) {
        root.setAttribute("xmlns", mxConstants2.NS_SVG);
        root.setAttribute("xmlns:xlink", mxConstants2.NS_XLINK);
      } else {
        root.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", mxConstants2.NS_XLINK);
      }
      var s = scale / vs;
      var w2 = Math.max(1, Math.ceil(bounds.width * s) + 2 * border) + (hasShadow ? 5 : 0);
      var h2 = Math.max(1, Math.ceil(bounds.height * s) + 2 * border) + (hasShadow ? 5 : 0);
      root.setAttribute("version", "1.1");
      root.setAttribute("width", w2 + "px");
      root.setAttribute("height", h2 + "px");
      root.setAttribute("viewBox", (crisp ? "-0.5 -0.5" : "0 0") + " " + w2 + " " + h2);
      svgDoc.appendChild(root);
      var group = svgDoc.createElementNS != null ? svgDoc.createElementNS(mxConstants2.NS_SVG, "g") : svgDoc.createElement("g");
      root.appendChild(group);
      var svgCanvas = this.createSvgCanvas(group);
      svgCanvas.foOffset = crisp ? -0.5 : 0;
      svgCanvas.textOffset = crisp ? -0.5 : 0;
      svgCanvas.imageOffset = crisp ? -0.5 : 0;
      svgCanvas.translate(Math.floor((border / scale - bounds.x) / vs), Math.floor((border / scale - bounds.y) / vs));
      var htmlConverter = document.createElement("div");
      var getAlternateText = svgCanvas.getAlternateText;
      svgCanvas.getAlternateText = function(fo, x, y, w3, h3, str, align, valign, wrap, format, overflow, clip, rotation) {
        if (str != null && this.state.fontSize > 0) {
          try {
            if (isNode(str)) {
              str = str.innerText;
            } else {
              htmlConverter.innerHTML = str;
              str = extractTextWithWhitespace(htmlConverter.childNodes);
            }
            var exp = Math.ceil(2 * w3 / this.state.fontSize);
            var result2 = [];
            var length = 0;
            var index = 0;
            while ((exp == 0 || length < exp) && index < str.length) {
              var char = str.charCodeAt(index);
              if (char == 10 || char == 13) {
                if (length > 0) {
                  break;
                }
              } else {
                result2.push(str.charAt(index));
                if (char < 255) {
                  length++;
                }
              }
              index++;
            }
            if (result2.length < str.length && str.length - result2.length > 1) {
              str = trim(result2.join("")) + "...";
            }
            return str;
          } catch (e) {
            return getAlternateText.apply(this, arguments);
          }
        } else {
          return getAlternateText.apply(this, arguments);
        }
      };
      var bgImg = this.backgroundImage;
      if (bgImg != null) {
        var s2 = vs / scale;
        var tr = this.view.translate;
        var tmp = new mxRectangle(tr.x * s2, tr.y * s2, bgImg.width * s2, bgImg.height * s2);
        if (intersects(bounds, tmp)) {
          svgCanvas.image(tr.x, tr.y, bgImg.width, bgImg.height, bgImg.src, true);
        }
      }
      svgCanvas.scale(s);
      svgCanvas.textEnabled = showText;
      imgExport = imgExport != null ? imgExport : this.createSvgImageExport();
      var imgExportDrawCellState = imgExport.drawCellState;
      var imgExportGetLinkForCellState = imgExport.getLinkForCellState;
      imgExport.getLinkForCellState = function(state2, canvas) {
        var result2 = imgExportGetLinkForCellState.apply(this, arguments);
        return result2 != null && !state2.view.graph.isCustomLink(result2) ? result2 : null;
      };
      imgExport.drawCellState = function(state2, canvas) {
        var graph = state2.view.graph;
        var selected = graph.isCellSelected(state2.cell);
        var parent2 = graph.model.getParent(state2.cell);
        while (!ignoreSelection && !selected && parent2 != null) {
          selected = graph.isCellSelected(parent2);
          parent2 = graph.model.getParent(parent2);
        }
        if (ignoreSelection || selected) {
          imgExportDrawCellState.apply(this, arguments);
        }
      };
      imgExport.drawState(this.getView().getState(this.model.root), svgCanvas);
      this.updateSvgLinks(root, linkTarget, true);
      this.addForeignObjectWarning(svgCanvas, root);
      return root;
    } finally {
      if (origUseCssTrans) {
        this.useCssTransforms = true;
        this.view.revalidate();
        this.sizeDidChange();
      }
    }
  };
  Graph2.prototype.addForeignObjectWarning = function(canvas, root) {
    if (root.getElementsByTagName("foreignObject").length > 0) {
      var sw = canvas.createElement("switch");
      var g1 = canvas.createElement("g");
      g1.setAttribute("requiredFeatures", "http://www.w3.org/TR/SVG11/feature#Extensibility");
      var a = canvas.createElement("a");
      a.setAttribute("transform", "translate(0,-5)");
      if (a.setAttributeNS == null || root.ownerDocument != document && document.documentMode == null) {
        a.setAttribute("xlink:href", Graph2.foreignObjectWarningLink);
        a.setAttribute("target", "_blank");
      } else {
        a.setAttributeNS(mxConstants2.NS_XLINK, "xlink:href", Graph2.foreignObjectWarningLink);
        a.setAttributeNS(mxConstants2.NS_XLINK, "target", "_blank");
      }
      var text = canvas.createElement("text");
      text.setAttribute("text-anchor", "middle");
      text.setAttribute("font-size", "10px");
      text.setAttribute("x", "50%");
      text.setAttribute("y", "100%");
      write(text, Graph2.foreignObjectWarningText);
      sw.appendChild(g1);
      a.appendChild(text);
      sw.appendChild(a);
      root.appendChild(sw);
    }
  };
  Graph2.prototype.updateSvgLinks = function(node, target, removeCustom) {
    var links = node.getElementsByTagName("a");
    for (var i = 0; i < links.length; i++) {
      var href = links[i].getAttribute("href");
      if (href == null) {
        href = links[i].getAttribute("xlink:href");
      }
      if (href != null) {
        if (target != null && /^https?:\/\//.test(href)) {
          links[i].setAttribute("target", target);
        } else if (removeCustom && this.isCustomLink(href)) {
          links[i].setAttribute("href", "javascript:void(0);");
        }
      }
    }
  };
  Graph2.prototype.createSvgCanvas = function(node) {
    var canvas = new mxSvgCanvas2D(node);
    canvas.pointerEvents = true;
    return canvas;
  };
  Graph2.prototype.getSelectedElement = function() {
    var node = null;
    if (window.getSelection) {
      var sel2 = window.getSelection();
      if (sel2.getRangeAt && sel2.rangeCount) {
        var range = sel2.getRangeAt(0);
        node = range.commonAncestorContainer;
      }
    } else if (document.selection) {
      node = document.selection.createRange().parentElement();
    }
    return node;
  };
  Graph2.prototype.getSelectedEditingElement = function() {
    var node = this.getSelectedElement();
    while (node != null && node.nodeType != mxConstants2.NODETYPE_ELEMENT) {
      node = node.parentNode;
    }
    if (node != null) {
      if (node == this.cellEditor.textarea && this.cellEditor.textarea.children.length == 1 && this.cellEditor.textarea.firstChild.nodeType == mxConstants2.NODETYPE_ELEMENT) {
        node = this.cellEditor.textarea.firstChild;
      }
    }
    return node;
  };
  Graph2.prototype.getParentByName = function(node, name, stopAt) {
    while (node != null) {
      if (node.nodeName == name) {
        return node;
      }
      if (node == stopAt) {
        return null;
      }
      node = node.parentNode;
    }
    return node;
  };
  Graph2.prototype.getParentByNames = function(node, names, stopAt) {
    while (node != null) {
      if (indexOf(names, node.nodeName) >= 0) {
        return node;
      }
      if (node == stopAt) {
        return null;
      }
      node = node.parentNode;
    }
    return node;
  };
  Graph2.prototype.selectNode = function(node) {
    var sel2 = null;
    if (window.getSelection) {
      sel2 = window.getSelection();
      if (sel2.getRangeAt && sel2.rangeCount) {
        var range = document.createRange();
        range.selectNode(node);
        sel2.removeAllRanges();
        sel2.addRange(range);
      }
    } else if ((sel2 = document.selection) && sel2.type != "Control") {
      var originalRange = sel2.createRange();
      originalRange.collapse(true);
      var range = sel2.createRange();
      range.setEndPoint("StartToStart", originalRange);
      range.select();
    }
  };
  Graph2.prototype.deleteCells = function(cells, includeEdges) {
    var select = null;
    includeEdges = true;
    if (cells != null && cells.length > 0) {
      this.model.beginUpdate();
      try {
        for (var i = 0; i < cells.length; i++) {
          var parent2 = this.model.getParent(cells[i]);
          if (this.isTable(parent2)) {
            var row = this.getCellGeometry(cells[i]);
            var table = this.getCellGeometry(parent2);
            if (row != null && table != null) {
              table = table.clone();
              table.height -= row.height;
              this.model.setGeometry(parent2, table);
            }
          }
        }
        var parents = this.selectParentAfterDelete ? this.model.getParents(cells) : null;
        this.removeCells(cells, includeEdges);
      } finally {
        this.model.endUpdate();
      }
      if (parents != null) {
        select = [];
        for (var i = 0; i < parents.length; i++) {
          if (this.model.contains(parents[i]) && (this.model.isVertex(parents[i]) || this.model.isEdge(parents[i]))) {
            select.push(parents[i]);
          }
        }
      }
    }
    return select;
  };
  Graph2.prototype.insertTableColumn = function(cell2, before) {
    var model = this.getModel();
    model.beginUpdate();
    try {
      var table = cell2;
      var index = 0;
      if (this.isTableCell(cell2)) {
        var row = model.getParent(cell2);
        table = model.getParent(row);
        index = indexOf(model.getChildCells(row, true), cell2);
      } else {
        if (this.isTableRow(cell2)) {
          table = model.getParent(cell2);
        } else {
          cell2 = model.getChildCells(table, true)[0];
        }
        if (!before) {
          index = model.getChildCells(cell2, true).length - 1;
        }
      }
      var rows = model.getChildCells(table, true);
      var dw = Graph2.minTableColumnWidth;
      for (var i = 0; i < rows.length; i++) {
        var child = model.getChildCells(rows[i], true)[index];
        var clone3 = model.cloneCell(child, false);
        var geo = this.getCellGeometry(clone3);
        clone3.value = null;
        if (geo != null) {
          dw = geo.width;
          var rowGeo = this.getCellGeometry(rows[i]);
          if (rowGeo != null) {
            geo.height = rowGeo.height;
          }
        }
        model.add(rows[i], clone3, index + (before ? 0 : 1));
      }
      var tableGeo = this.getCellGeometry(table);
      if (tableGeo != null) {
        tableGeo = tableGeo.clone();
        tableGeo.width += dw;
        model.setGeometry(table, tableGeo);
      }
    } finally {
      model.endUpdate();
    }
  };
  Graph2.prototype.insertTableRow = function(cell2, before) {
    var model = this.getModel();
    model.beginUpdate();
    try {
      var table = cell2;
      var row = cell2;
      if (this.isTableCell(cell2)) {
        row = model.getParent(cell2);
        table = model.getParent(row);
      } else if (this.isTableRow(cell2)) {
        table = model.getParent(cell2);
      } else {
        var rows = model.getChildCells(table, true);
        row = rows[before ? 0 : rows.length - 1];
      }
      var cells = model.getChildCells(row, true);
      var index = table.getIndex(row);
      row = model.cloneCell(row, false);
      row.value = null;
      var rowGeo = this.getCellGeometry(row);
      if (rowGeo != null) {
        for (var i = 0; i < cells.length; i++) {
          var cell2 = model.cloneCell(cells[i], false);
          row.insert(cell2);
          cell2.value = null;
          var geo = this.getCellGeometry(cell2);
          if (geo != null) {
            geo.height = rowGeo.height;
          }
        }
        model.add(table, row, index + (before ? 0 : 1));
        var tableGeo = this.getCellGeometry(table);
        if (tableGeo != null) {
          tableGeo = tableGeo.clone();
          tableGeo.height += rowGeo.height;
          model.setGeometry(table, tableGeo);
        }
      }
    } finally {
      model.endUpdate();
    }
  };
  Graph2.prototype.deleteTableColumn = function(cell2) {
    var model = this.getModel();
    model.beginUpdate();
    try {
      var table = cell2;
      var row = cell2;
      if (this.isTableCell(cell2)) {
        row = model.getParent(cell2);
      }
      if (this.isTableRow(row)) {
        table = model.getParent(row);
      }
      var rows = model.getChildCells(table, true);
      if (rows.length == 0) {
        model.remove(table);
      } else {
        if (!this.isTableRow(row)) {
          row = rows[0];
        }
        var cells = model.getChildCells(row, true);
        if (cells.length <= 1) {
          model.remove(table);
        } else {
          var index = cells.length - 1;
          if (this.isTableCell(cell2)) {
            index = indexOf(cells, cell2);
          }
          var width = 0;
          for (var i = 0; i < rows.length; i++) {
            var child = model.getChildCells(rows[i], true)[index];
            model.remove(child);
            var geo = this.getCellGeometry(child);
            if (geo != null) {
              width = Math.max(width, geo.width);
            }
          }
          var tableGeo = this.getCellGeometry(table);
          if (tableGeo != null) {
            tableGeo = tableGeo.clone();
            tableGeo.width -= width;
            model.setGeometry(table, tableGeo);
          }
        }
      }
    } finally {
      model.endUpdate();
    }
  };
  Graph2.prototype.deleteTableRow = function(cell2) {
    var model = this.getModel();
    model.beginUpdate();
    try {
      var table = cell2;
      var row = cell2;
      if (this.isTableCell(cell2)) {
        row = model.getParent(cell2);
        cell2 = row;
      }
      if (this.isTableRow(cell2)) {
        table = model.getParent(row);
      }
      var rows = model.getChildCells(table, true);
      if (rows.length <= 1) {
        model.remove(table);
      } else {
        if (!this.isTableRow(row)) {
          row = rows[rows.length - 1];
        }
        model.remove(row);
        var height = 0;
        var geo = this.getCellGeometry(row);
        if (geo != null) {
          height = geo.height;
        }
        var tableGeo = this.getCellGeometry(table);
        if (tableGeo != null) {
          tableGeo = tableGeo.clone();
          tableGeo.height -= height;
          model.setGeometry(table, tableGeo);
        }
      }
    } finally {
      model.endUpdate();
    }
  };
  Graph2.prototype.insertRow = function(table, index) {
    var bd = table.tBodies[0];
    var cells = bd.rows[0].cells;
    var cols = 0;
    for (var i = 0; i < cells.length; i++) {
      var colspan = cells[i].getAttribute("colspan");
      cols += colspan != null ? parseInt(colspan) : 1;
    }
    var row = bd.insertRow(index);
    for (var i = 0; i < cols; i++) {
      br(row.insertCell(-1));
    }
    return row.cells[0];
  };
  Graph2.prototype.deleteRow = function(table, index) {
    table.tBodies[0].deleteRow(index);
  };
  Graph2.prototype.insertColumn = function(table, index) {
    var hd = table.tHead;
    if (hd != null) {
      for (var h2 = 0; h2 < hd.rows.length; h2++) {
        var th = document.createElement("th");
        hd.rows[h2].appendChild(th);
        br(th);
      }
    }
    var bd = table.tBodies[0];
    for (var i = 0; i < bd.rows.length; i++) {
      var cell2 = bd.rows[i].insertCell(index);
      br(cell2);
    }
    return bd.rows[0].cells[index >= 0 ? index : bd.rows[0].cells.length - 1];
  };
  Graph2.prototype.deleteColumn = function(table, index) {
    if (index >= 0) {
      var bd = table.tBodies[0];
      var rows = bd.rows;
      for (var i = 0; i < rows.length; i++) {
        if (rows[i].cells.length > index) {
          rows[i].deleteCell(index);
        }
      }
    }
  };
  Graph2.prototype.pasteHtmlAtCaret = function(html) {
    var sel2, range;
    if (window.getSelection) {
      sel2 = window.getSelection();
      if (sel2.getRangeAt && sel2.rangeCount) {
        range = sel2.getRangeAt(0);
        range.deleteContents();
        var el = document.createElement("div");
        el.innerHTML = html;
        var frag = document.createDocumentFragment(), node;
        while (node = el.firstChild) {
          lastNode = frag.appendChild(node);
        }
        range.insertNode(frag);
      }
    } else if ((sel2 = document.selection) && sel2.type != "Control") {
      sel2.createRange().pasteHTML(html);
    }
  };
  Graph2.prototype.createLinkForHint = function(link2, label) {
    link2 = link2 != null ? link2 : "javascript:void(0);";
    if (label == null || label.length == 0) {
      if (this.isCustomLink(link2)) {
        label = this.getLinkTitle(link2);
      } else {
        label = link2;
      }
    }
    function short(str, max) {
      if (str.length > max) {
        str = str.substring(0, Math.round(max / 2)) + "..." + str.substring(str.length - Math.round(max / 4));
      }
      return str;
    }
    var a = document.createElement("a");
    a.setAttribute("rel", this.linkRelation);
    a.setAttribute("href", this.getAbsoluteUrl(link2));
    a.setAttribute("title", short(this.isCustomLink(link2) ? this.getLinkTitle(link2) : link2, 80));
    if (this.linkTarget != null) {
      a.setAttribute("target", this.linkTarget);
    }
    write(a, short(label, 40));
    if (this.isCustomLink(link2)) {
      mxEvent2.addListener(a, "click", bind(this, function(evt) {
        this.customLinkClicked(link2);
        mxEvent2.consume(evt);
      }));
    }
    return a;
  };
  Graph2.prototype.initTouch = function() {
    this.connectionHandler.marker.isEnabled = function() {
      return this.graph.connectionHandler.first != null;
    };
    this.addListener(mxEvent2.START_EDITING, function(sender, evt) {
      this.popupMenuHandler.hideMenu();
    });
    var graphUpdateMouseEvent = this.updateMouseEvent;
    this.updateMouseEvent = function(me) {
      me = graphUpdateMouseEvent.apply(this, arguments);
      if (mxEvent2.isTouchEvent(me.getEvent()) && me.getState() == null) {
        var cell2 = this.getCellAt(me.graphX, me.graphY);
        if (cell2 != null && this.isSwimlane(cell2) && this.hitsSwimlaneContent(cell2, me.graphX, me.graphY)) {
          cell2 = null;
        } else {
          me.state = this.view.getState(cell2);
          if (me.state != null && me.state.shape != null) {
            this.container.style.cursor = me.state.shape.node.style.cursor;
          }
        }
      }
      if (me.getState() == null && this.isEnabled()) {
        this.container.style.cursor = "default";
      }
      return me;
    };
    var cellSelected = false;
    var selectionEmpty = false;
    var menuShowing = false;
    var oldFireMouseEvent = this.fireMouseEvent;
    this.fireMouseEvent = function(evtName, me, sender) {
      if (evtName == mxEvent2.MOUSE_DOWN) {
        me = this.updateMouseEvent(me);
        cellSelected = this.isCellSelected(me.getCell());
        selectionEmpty = this.isSelectionEmpty();
        menuShowing = this.popupMenuHandler.isMenuShowing();
      }
      oldFireMouseEvent.apply(this, arguments);
    };
    this.popupMenuHandler.mouseUp = bind(this, function(sender, me) {
      this.popupMenuHandler.popupTrigger = !this.isEditing() && this.isEnabled() && (me.getState() == null || !me.isSource(me.getState().control)) && (this.popupMenuHandler.popupTrigger || !menuShowing && !mxEvent2.isMouseEvent(me.getEvent()) && (selectionEmpty && me.getCell() == null && this.isSelectionEmpty() || cellSelected && this.isCellSelected(me.getCell())));
      mxPopupMenuHandler.prototype.mouseUp.apply(this.popupMenuHandler, arguments);
    });
  };
  mxCellEditor.prototype.isContentEditing = function() {
    var state2 = this.graph.view.getState(this.editingCell);
    return state2 != null && state2.style["html"] == 1;
  };
  mxCellEditor.prototype.isTableSelected = function() {
    return this.graph.getParentByName(this.graph.getSelectedElement(), "TABLE", this.textarea) != null;
  };
  mxCellEditor.prototype.alignText = function(align, evt) {
    var shiftPressed = evt != null && mxEvent2.isShiftDown(evt);
    if (shiftPressed || window.getSelection != null && window.getSelection().containsNode != null) {
      var allSelected = true;
      this.graph.processElements(this.textarea, function(node) {
        if (shiftPressed || window.getSelection().containsNode(node, true)) {
          node.removeAttribute("align");
          node.style.textAlign = null;
        } else {
          allSelected = false;
        }
      });
      if (allSelected) {
        this.graph.cellEditor.setAlign(align);
      }
    }
    document.execCommand("justify" + align.toLowerCase(), false, null);
  };
  mxCellEditor.prototype.saveSelection = function() {
    if (window.getSelection) {
      var sel2 = window.getSelection();
      if (sel2.getRangeAt && sel2.rangeCount) {
        var ranges = [];
        for (var i = 0, len = sel2.rangeCount; i < len; ++i) {
          ranges.push(sel2.getRangeAt(i));
        }
        return ranges;
      }
    } else if (document.selection && document.selection.createRange) {
      return document.selection.createRange();
    }
    return null;
  };
  mxCellEditor.prototype.restoreSelection = function(savedSel) {
    try {
      if (savedSel) {
        if (window.getSelection) {
          sel = window.getSelection();
          sel.removeAllRanges();
          for (var i = 0, len = savedSel.length; i < len; ++i) {
            sel.addRange(savedSel[i]);
          }
        } else if (document.selection && savedSel.select) {
          savedSel.select();
        }
      }
    } catch (e) {
    }
  };
  mxCellRendererInitializeLabel = mxCellRenderer2.prototype.initializeLabel;
  mxCellRenderer2.prototype.initializeLabel = function(state2) {
    if (state2.text != null) {
      state2.text.replaceLinefeeds = getValue(state2.style, "nl2Br", "1") != "0";
    }
    mxCellRendererInitializeLabel.apply(this, arguments);
  };
  mxConstraintHandlerUpdate = mxConstraintHandler.prototype.update;
  mxConstraintHandler.prototype.update = function(me, source) {
    if (this.isKeepFocusEvent(me) || !mxEvent2.isAltDown(me.getEvent())) {
      mxConstraintHandlerUpdate.apply(this, arguments);
    } else {
      this.reset();
    }
  };
  mxGuide.prototype.createGuideShape = function(horizontal) {
    var guide = new mxPolyline([], mxConstants2.GUIDE_COLOR, mxConstants2.GUIDE_STROKEWIDTH);
    return guide;
  };
  mxCellEditor.prototype.escapeCancelsEditing = false;
  mxCellEditorStartEditing = mxCellEditor.prototype.startEditing;
  mxCellEditor.prototype.startEditing = function(cell2, trigger) {
    cell2 = this.graph.getStartEditingCell(cell2, trigger);
    mxCellEditorStartEditing.apply(this, arguments);
    var state2 = this.graph.view.getState(cell2);
    if (state2 != null && state2.style["html"] == 1) {
      this.textarea.className = "mxCellEditor geContentEditable";
    } else {
      this.textarea.className = "mxCellEditor mxPlainTextEditor";
    }
    this.codeViewMode = false;
    this.switchSelectionState = null;
    this.graph.setSelectionCell(cell2);
    var parent2 = this.graph.getModel().getParent(cell2);
    var geo = this.graph.getCellGeometry(cell2);
    if (this.graph.getModel().isEdge(parent2) && geo != null && geo.relative || this.graph.getModel().isEdge(cell2)) {
      if (mxClient_default.IS_QUIRKS) {
        this.textarea.style.border = "gray dotted 1px";
      } else if (mxClient_default.IS_IE || mxClient_default.IS_IE11 || mxClient_default.IS_FF && mxClient_default.IS_WIN) {
        this.textarea.style.outline = "gray dotted 1px";
      } else {
        this.textarea.style.outline = "";
      }
    } else if (mxClient_default.IS_QUIRKS) {
      this.textarea.style.outline = "none";
      this.textarea.style.border = "";
    }
  };
  cellEditorInstallListeners = mxCellEditor.prototype.installListeners;
  mxCellEditor.prototype.installListeners = function(elt) {
    cellEditorInstallListeners.apply(this, arguments);
    function reference(node, clone3) {
      clone3.originalNode = node;
      node = node.firstChild;
      var child = clone3.firstChild;
      while (node != null && child != null) {
        reference(node, child);
        node = node.nextSibling;
        child = child.nextSibling;
      }
      return clone3;
    }
    function checkNode(node, clone3) {
      if (node != null) {
        if (clone3.originalNode != node) {
          cleanNode(node);
        } else {
          node = node.firstChild;
          clone3 = clone3.firstChild;
          while (node != null) {
            var nextNode = node.nextSibling;
            if (clone3 == null) {
              cleanNode(node);
            } else {
              checkNode(node, clone3);
              clone3 = clone3.nextSibling;
            }
            node = nextNode;
          }
        }
      }
    }
    function cleanNode(node) {
      var child = node.firstChild;
      while (child != null) {
        var next = child.nextSibling;
        cleanNode(child);
        child = next;
      }
      if ((node.nodeType != 1 || node.nodeName !== "BR" && node.firstChild == null) && (node.nodeType != 3 || trim(getTextContent(node)).length == 0)) {
        node.parentNode.removeChild(node);
      } else {
        if (node.nodeType == 3) {
          setTextContent(node, getTextContent(node).replace(/\n|\r/g, ""));
        }
        if (node.nodeType == 1) {
          node.removeAttribute("style");
          node.removeAttribute("class");
          node.removeAttribute("width");
          node.removeAttribute("cellpadding");
          node.removeAttribute("cellspacing");
          node.removeAttribute("border");
        }
      }
    }
    if (!mxClient_default.IS_QUIRKS && document.documentMode !== 7 && document.documentMode !== 8) {
      mxEvent2.addListener(this.textarea, "paste", bind(this, function(evt) {
        var clone3 = reference(this.textarea, this.textarea.cloneNode(true));
        window.setTimeout(bind(this, function() {
          if (this.textarea != null) {
            if (this.textarea.innerHTML.indexOf("<o:OfficeDocumentSettings>") >= 0 || this.textarea.innerHTML.indexOf("<!--[if !mso]>") >= 0) {
              checkNode(this.textarea, clone3);
            } else {
              Graph2.removePasteFormatting(this.textarea);
            }
          }
        }), 0);
      }));
    }
  };
  mxCellEditor.prototype.toggleViewMode = function() {
    var state2 = this.graph.view.getState(this.editingCell);
    if (state2 != null) {
      var nl2Br = state2 != null && getValue(state2.style, "nl2Br", "1") != "0";
      var tmp = this.saveSelection();
      if (!this.codeViewMode) {
        if (this.clearOnChange && this.textarea.innerHTML == this.getEmptyLabelText()) {
          this.clearOnChange = false;
          this.textarea.innerHTML = "";
        }
        var content = htmlEntities(this.textarea.innerHTML);
        if (!mxClient_default.IS_QUIRKS && document.documentMode != 8) {
          content = replaceTrailingNewlines(content, "<div><br></div>");
        }
        content = this.graph.sanitizeHtml(nl2Br ? content.replace(/\n/g, "").replace(/&lt;br\s*.?&gt;/g, "<br>") : content, true);
        this.textarea.className = "mxCellEditor mxPlainTextEditor";
        var size = mxConstants2.DEFAULT_FONTSIZE;
        this.textarea.style.lineHeight = mxConstants2.ABSOLUTE_LINE_HEIGHT ? Math.round(size * mxConstants2.LINE_HEIGHT) + "px" : mxConstants2.LINE_HEIGHT;
        this.textarea.style.fontSize = Math.round(size) + "px";
        this.textarea.style.textDecoration = "";
        this.textarea.style.fontWeight = "normal";
        this.textarea.style.fontStyle = "";
        this.textarea.style.fontFamily = mxConstants2.DEFAULT_FONTFAMILY;
        this.textarea.style.textAlign = "left";
        this.textarea.style.padding = "2px";
        if (this.textarea.innerHTML != content) {
          this.textarea.innerHTML = content;
        }
        this.codeViewMode = true;
      } else {
        var content = extractTextWithWhitespace(this.textarea.childNodes);
        if (content.length > 0 && content.charAt(content.length - 1) == "\n") {
          content = content.substring(0, content.length - 1);
        }
        content = this.graph.sanitizeHtml(nl2Br ? content.replace(/\n/g, "<br/>") : content, true);
        this.textarea.className = "mxCellEditor geContentEditable";
        var size = getValue(state2.style, mxConstants2.STYLE_FONTSIZE, mxConstants2.DEFAULT_FONTSIZE);
        var family = getValue(state2.style, mxConstants2.STYLE_FONTFAMILY, mxConstants2.DEFAULT_FONTFAMILY);
        var align = getValue(state2.style, mxConstants2.STYLE_ALIGN, mxConstants2.ALIGN_LEFT);
        var bold = (getValue(state2.style, mxConstants2.STYLE_FONTSTYLE, 0) & mxConstants2.FONT_BOLD) == mxConstants2.FONT_BOLD;
        var italic = (getValue(state2.style, mxConstants2.STYLE_FONTSTYLE, 0) & mxConstants2.FONT_ITALIC) == mxConstants2.FONT_ITALIC;
        var txtDecor = [];
        if ((getValue(state2.style, mxConstants2.STYLE_FONTSTYLE, 0) & mxConstants2.FONT_UNDERLINE) == mxConstants2.FONT_UNDERLINE) {
          txtDecor.push("underline");
        }
        if ((getValue(state2.style, mxConstants2.STYLE_FONTSTYLE, 0) & mxConstants2.FONT_STRIKETHROUGH) == mxConstants2.FONT_STRIKETHROUGH) {
          txtDecor.push("line-through");
        }
        this.textarea.style.lineHeight = mxConstants2.ABSOLUTE_LINE_HEIGHT ? Math.round(size * mxConstants2.LINE_HEIGHT) + "px" : mxConstants2.LINE_HEIGHT;
        this.textarea.style.fontSize = Math.round(size) + "px";
        this.textarea.style.textDecoration = txtDecor.join(" ");
        this.textarea.style.fontWeight = bold ? "bold" : "normal";
        this.textarea.style.fontStyle = italic ? "italic" : "";
        this.textarea.style.fontFamily = family;
        this.textarea.style.textAlign = align;
        this.textarea.style.padding = "0px";
        if (this.textarea.innerHTML != content) {
          this.textarea.innerHTML = content;
          if (this.textarea.innerHTML.length == 0) {
            this.textarea.innerHTML = this.getEmptyLabelText();
            this.clearOnChange = this.textarea.innerHTML.length > 0;
          }
        }
        this.codeViewMode = false;
      }
      this.textarea.focus();
      if (this.switchSelectionState != null) {
        this.restoreSelection(this.switchSelectionState);
      }
      this.switchSelectionState = tmp;
      this.resize();
    }
  };
  mxCellEditorResize = mxCellEditor.prototype.resize;
  mxCellEditor.prototype.resize = function(state2, trigger) {
    if (this.textarea != null) {
      var state2 = this.graph.getView().getState(this.editingCell);
      if (this.codeViewMode && state2 != null) {
        var scale = state2.view.scale;
        this.bounds = mxRectangle.fromRectangle(state2);
        if (this.bounds.width == 0 && this.bounds.height == 0) {
          this.bounds.width = 160 * scale;
          this.bounds.height = 60 * scale;
          var m = state2.text != null ? state2.text.margin : null;
          if (m == null) {
            m = getAlignmentAsPoint(getValue(state2.style, mxConstants2.STYLE_ALIGN, mxConstants2.ALIGN_CENTER), getValue(state2.style, mxConstants2.STYLE_VERTICAL_ALIGN, mxConstants2.ALIGN_MIDDLE));
          }
          this.bounds.x += m.x * this.bounds.width;
          this.bounds.y += m.y * this.bounds.height;
        }
        this.textarea.style.width = Math.round((this.bounds.width - 4) / scale) + "px";
        this.textarea.style.height = Math.round((this.bounds.height - 4) / scale) + "px";
        this.textarea.style.overflow = "auto";
        if (this.textarea.clientHeight < this.textarea.offsetHeight) {
          this.textarea.style.height = Math.round(this.bounds.height / scale) + (this.textarea.offsetHeight - this.textarea.clientHeight) + "px";
          this.bounds.height = parseInt(this.textarea.style.height) * scale;
        }
        if (this.textarea.clientWidth < this.textarea.offsetWidth) {
          this.textarea.style.width = Math.round(this.bounds.width / scale) + (this.textarea.offsetWidth - this.textarea.clientWidth) + "px";
          this.bounds.width = parseInt(this.textarea.style.width) * scale;
        }
        this.textarea.style.left = Math.round(this.bounds.x) + "px";
        this.textarea.style.top = Math.round(this.bounds.y) + "px";
        if (mxClient_default.IS_VML) {
          this.textarea.style.zoom = scale;
        } else {
          setPrefixedStyle(this.textarea.style, "transform", "scale(" + scale + "," + scale + ")");
        }
      } else {
        this.textarea.style.height = "";
        this.textarea.style.overflow = "";
        mxCellEditorResize.apply(this, arguments);
      }
    }
  };
  mxCellEditorGetInitialValue = mxCellEditor.prototype.getInitialValue;
  mxCellEditor.prototype.getInitialValue = function(state2, trigger) {
    if (getValue(state2.style, "html", "0") == "0") {
      return mxCellEditorGetInitialValue.apply(this, arguments);
    } else {
      var result2 = this.graph.getEditingValue(state2.cell, trigger);
      if (getValue(state2.style, "nl2Br", "1") == "1") {
        result2 = result2.replace(/\n/g, "<br/>");
      }
      result2 = this.graph.sanitizeHtml(result2, true);
      return result2;
    }
  };
  mxCellEditorGetCurrentValue = mxCellEditor.prototype.getCurrentValue;
  mxCellEditor.prototype.getCurrentValue = function(state2) {
    if (getValue(state2.style, "html", "0") == "0") {
      return mxCellEditorGetCurrentValue.apply(this, arguments);
    } else {
      var result2 = this.graph.sanitizeHtml(this.textarea.innerHTML, true);
      if (getValue(state2.style, "nl2Br", "1") == "1") {
        result2 = result2.replace(/\r\n/g, "<br/>").replace(/\n/g, "<br/>");
      } else {
        result2 = result2.replace(/\r\n/g, "").replace(/\n/g, "");
      }
      return result2;
    }
  };
  mxCellEditorStopEditing = mxCellEditor.prototype.stopEditing;
  mxCellEditor.prototype.stopEditing = function(cancel) {
    if (this.codeViewMode) {
      this.toggleViewMode();
    }
    mxCellEditorStopEditing.apply(this, arguments);
    this.focusContainer();
  };
  mxCellEditor.prototype.focusContainer = function() {
    try {
      this.graph.container.focus();
    } catch (e) {
    }
  };
  mxCellEditorApplyValue = mxCellEditor.prototype.applyValue;
  mxCellEditor.prototype.applyValue = function(state2, value) {
    this.graph.getModel().beginUpdate();
    try {
      mxCellEditorApplyValue.apply(this, arguments);
      if (value == "" && this.graph.isCellDeletable(state2.cell) && this.graph.model.getChildCount(state2.cell) == 0 && this.graph.isTransparentState(state2)) {
        this.graph.removeCells([state2.cell], false);
      }
    } finally {
      this.graph.getModel().endUpdate();
    }
  };
  mxCellEditor.prototype.getBackgroundColor = function(state2) {
    var color = getValue(state2.style, mxConstants2.STYLE_LABEL_BACKGROUNDCOLOR, null);
    if ((color == null || color == mxConstants2.NONE) && state2.cell.geometry != null && state2.cell.geometry.width > 0 && (getValue(state2.style, mxConstants2.STYLE_ROTATION, 0) != 0 || getValue(state2.style, mxConstants2.STYLE_HORIZONTAL, 1) == 0)) {
      color = getValue(state2.style, mxConstants2.STYLE_FILLCOLOR, null);
    }
    if (color == mxConstants2.NONE) {
      color = null;
    }
    return color;
  };
  mxCellEditor.prototype.getMinimumSize = function(state2) {
    var scale = this.graph.getView().scale;
    return new mxRectangle(0, 0, state2.text == null ? 30 : state2.text.size * scale + 20, 30);
  };
  mxGraphHandlerIsValidDropTarget = mxGraphHandler.prototype.isValidDropTarget;
  mxGraphHandler.prototype.isValidDropTarget = function(target, me) {
    return mxGraphHandlerIsValidDropTarget.apply(this, arguments) && !mxEvent2.isAltDown(me.getEvent);
  };
  mxGraphView.prototype.formatUnitText = function(pixels) {
    return pixels ? formatHintText(pixels, this.unit) : pixels;
  };
  mxGraphHandler.prototype.updateHint = function(me) {
    if (this.pBounds != null && (this.shape != null || this.livePreviewActive)) {
      if (this.hint == null) {
        this.hint = createHint();
        this.graph.container.appendChild(this.hint);
      }
      var t = this.graph.view.translate;
      var s = this.graph.view.scale;
      var x = this.roundLength((this.bounds.x + this.currentDx) / s - t.x);
      var y = this.roundLength((this.bounds.y + this.currentDy) / s - t.y);
      var unit = this.graph.view.unit;
      this.hint.innerHTML = formatHintText(x, unit) + ", " + formatHintText(y, unit);
      this.hint.style.left = this.pBounds.x + this.currentDx + Math.round((this.pBounds.width - this.hint.clientWidth) / 2) + "px";
      this.hint.style.top = this.pBounds.y + this.currentDy + this.pBounds.height + 20 + "px";
    }
  };
  mxGraphHandler.prototype.removeHint = function() {
    if (this.hint != null) {
      this.hint.parentNode.removeChild(this.hint);
      this.hint = null;
    }
  };
  stackLayoutResizeCell = mxStackLayout.prototype.resizeCell;
  mxStackLayout.prototype.resizeCell = function(cell2, bounds) {
    stackLayoutResizeCell.apply(this, arguments);
    var style = this.graph.getCellStyle(cell2);
    if (style["childLayout"] == null) {
      var parent2 = this.graph.model.getParent(cell2);
      var geo = parent2 != null ? this.graph.getCellGeometry(parent2) : null;
      if (geo != null) {
        style = this.graph.getCellStyle(parent2);
        if (style["childLayout"] == "stackLayout") {
          var border = parseFloat(getValue(style, "stackBorder", mxStackLayout.prototype.border));
          var horizontal = getValue(style, "horizontalStack", "1") == "1";
          var start = this.graph.getActualStartSize(parent2);
          geo = geo.clone();
          if (horizontal) {
            geo.height = bounds.height + start.y + start.height + 2 * border;
          } else {
            geo.width = bounds.width + start.x + start.width + 2 * border;
          }
          this.graph.model.setGeometry(parent2, geo);
        }
      }
    }
  };
  selectionCellsHandlerGetHandledSelectionCells = mxSelectionCellsHandler.prototype.getHandledSelectionCells;
  mxSelectionCellsHandler.prototype.getHandledSelectionCells = function() {
    var cells = selectionCellsHandlerGetHandledSelectionCells.apply(this, arguments);
    var dict = new mxDictionary();
    var model = this.graph.model;
    var result2 = [];
    function addCell(cell3) {
      if (!dict.get(cell3)) {
        dict.put(cell3, true);
        result2.push(cell3);
      }
    }
    for (var i = 0; i < cells.length; i++) {
      var cell2 = cells[i];
      if (this.graph.isTableCell(cell2)) {
        addCell(model.getParent(model.getParent(cell2)));
      } else if (this.graph.isTableRow(cell2)) {
        addCell(model.getParent(cell2));
      }
      addCell(cell2);
    }
    return result2;
  };
  vertexHandlerCreateParentHighlightShape = mxVertexHandler2.prototype.createParentHighlightShape;
  mxVertexHandler2.prototype.createParentHighlightShape = function(bounds) {
    var shape = vertexHandlerCreateParentHighlightShape.apply(this, arguments);
    shape.stroke = "#C0C0C0";
    shape.strokewidth = 1;
    return shape;
  };
  edgeHandlerCreateParentHighlightShape = mxEdgeHandler2.prototype.createParentHighlightShape;
  mxEdgeHandler2.prototype.createParentHighlightShape = function(bounds) {
    var shape = edgeHandlerCreateParentHighlightShape.apply(this, arguments);
    shape.stroke = "#C0C0C0";
    shape.strokewidth = 1;
    return shape;
  };
  mxVertexHandler2.prototype.rotationHandleVSpacing = -12;
  mxVertexHandler2.prototype.getRotationHandlePosition = function() {
    var padding = this.getHandlePadding();
    return new mxPoint2(this.bounds.x + this.bounds.width - this.rotationHandleVSpacing + padding.x / 2, this.bounds.y + this.rotationHandleVSpacing - padding.y / 2);
  };
  mxVertexHandler2.prototype.isRecursiveResize = function(state2, me) {
    return this.graph.isRecursiveVertexResize(state2) && !mxEvent2.isControlDown(me.getEvent());
  };
  mxVertexHandler2.prototype.isCenteredEvent = function(state2, me) {
    return !(!this.graph.isSwimlane(state2.cell) && this.graph.model.getChildCount(state2.cell) > 0 && !this.graph.isCellCollapsed(state2.cell) && getValue(state2.style, "recursiveResize", "1") == "1" && getValue(state2.style, "childLayout", null) == null) && mxEvent2.isControlDown(me.getEvent()) || mxEvent2.isMetaDown(me.getEvent());
  };
  vertexHandlerIsRotationHandleVisible = mxVertexHandler2.prototype.isRotationHandleVisible;
  mxVertexHandler2.prototype.isRotationHandleVisible = function() {
    return vertexHandlerIsRotationHandleVisible.apply(this, arguments) && !this.graph.isTableCell(this.state.cell) && !this.graph.isTableRow(this.state.cell) && !this.graph.isTable(this.state.cell);
  };
  mxVertexHandler2.prototype.getSizerBounds = function() {
    if (this.graph.isTableCell(this.state.cell)) {
      return this.graph.view.getState(this.graph.model.getParent(this.graph.model.getParent(this.state.cell)));
    } else {
      return this.bounds;
    }
  };
  vertexHandlerIsParentHighlightVisible = mxVertexHandler2.prototype.isParentHighlightVisible;
  mxVertexHandler2.prototype.isParentHighlightVisible = function() {
    return vertexHandlerIsParentHighlightVisible.apply(this, arguments) && !this.graph.isTableCell(this.state.cell) && !this.graph.isTableRow(this.state.cell);
  };
  vertexHandlerIsCustomHandleVisible = mxVertexHandler2.prototype.isCustomHandleVisible;
  mxVertexHandler2.prototype.isCustomHandleVisible = function(handle) {
    return handle.tableHandle || vertexHandlerIsCustomHandleVisible.apply(this, arguments) && (!this.graph.isTable(this.state.cell) || this.graph.isCellSelected(this.state.cell));
  };
  mxVertexHandler2.prototype.getSelectionBorderInset = function() {
    var result2 = 0;
    if (this.graph.isTableRow(this.state.cell)) {
      result2 = 1;
    } else if (this.graph.isTableCell(this.state.cell)) {
      result2 = 2;
    }
    return result2;
  };
  vertexHandlerGetSelectionBorderBounds = mxVertexHandler2.prototype.getSelectionBorderBounds;
  mxVertexHandler2.prototype.getSelectionBorderBounds = function() {
    return vertexHandlerGetSelectionBorderBounds.apply(this, arguments).grow(-this.getSelectionBorderInset());
  };
  vertexHandlerCreateCustomHandles = mxVertexHandler2.prototype.createCustomHandles;
  mxVertexHandler2.prototype.createCustomHandles = function() {
    var handles = vertexHandlerCreateCustomHandles.apply(this, arguments);
    if (this.graph.isTable(this.state.cell)) {
      var graph = this.graph;
      var model = graph.model;
      var tableState = this.state;
      var sel2 = this.selectionBorder;
      var self = this;
      if (handles == null) {
        handles = [];
      }
      var rows = graph.view.getCellStates(model.getChildCells(this.state.cell, true));
      if (rows.length > 0) {
        var cols = graph.view.getCellStates(model.getChildCells(rows[0].cell, true));
        for (var i = 0; i < cols.length; i++) {
          bind(this, function(index) {
            var colState = cols[index];
            var nextCol = index < cols.length - 1 ? cols[index + 1] : null;
            var shape = new mxLine(new mxRectangle(), mxConstants2.NONE, 1, true);
            shape.isDashed = sel2.isDashed;
            shape.svgStrokeTolerance++;
            var handle = new mxHandle2(colState, "col-resize", null, shape);
            handle.tableHandle = true;
            var dx = 0;
            handle.shape.node.parentNode.insertBefore(handle.shape.node, handle.shape.node.parentNode.firstChild);
            handle.redraw = function() {
              if (this.shape != null && this.state.shape != null) {
                var start = graph.getActualStartSize(tableState.cell);
                this.shape.stroke = dx == 0 ? mxConstants2.NONE : sel2.stroke;
                this.shape.bounds.x = this.state.x + this.state.width + dx * this.graph.view.scale;
                this.shape.bounds.width = 1;
                this.shape.bounds.y = tableState.y + (index == cols.length - 1 ? 0 : start.y * this.graph.view.scale);
                this.shape.bounds.height = tableState.height - (index == cols.length - 1 ? 0 : (start.height + start.y) * this.graph.view.scale);
                this.shape.redraw();
              }
            };
            var shiftPressed = false;
            handle.setPosition = function(bounds, pt, me) {
              dx = Math.max(Graph2.minTableColumnWidth - bounds.width, pt.x - bounds.x - bounds.width);
              shiftPressed = mxEvent2.isShiftDown(me.getEvent());
              if (nextCol != null && !shiftPressed) {
                dx = Math.min((nextCol.x + nextCol.width - colState.x - colState.width) / graph.view.scale - Graph2.minTableColumnWidth, dx);
              }
            };
            handle.execute = function(me) {
              if (dx != 0) {
                graph.setTableColumnWidth(this.state.cell, dx, shiftPressed);
              } else if (!self.blockDelayedSelection) {
                var temp2 = graph.getCellAt(me.getGraphX(), me.getGraphY()) || tableState.cell;
                graph.graphHandler.selectCellForEvent(temp2, me);
              }
              dx = 0;
            };
            handle.reset = function() {
              dx = 0;
            };
            handles.push(handle);
          })(i);
        }
        for (var i = 0; i < rows.length; i++) {
          bind(this, function(index) {
            var rowState = rows[index];
            var shape = new mxLine(new mxRectangle(), mxConstants2.NONE, 1);
            shape.isDashed = sel2.isDashed;
            shape.svgStrokeTolerance++;
            var handle = new mxHandle2(rowState, "row-resize", null, shape);
            handle.tableHandle = true;
            var dy = 0;
            handle.shape.node.parentNode.insertBefore(handle.shape.node, handle.shape.node.parentNode.firstChild);
            handle.redraw = function() {
              if (this.shape != null && this.state.shape != null) {
                this.shape.stroke = dy == 0 ? mxConstants2.NONE : sel2.stroke;
                this.shape.bounds.x = this.state.x;
                this.shape.bounds.width = this.state.width;
                this.shape.bounds.y = this.state.y + this.state.height + dy * this.graph.view.scale;
                this.shape.bounds.height = 1;
                this.shape.redraw();
              }
            };
            handle.setPosition = function(bounds, pt, me) {
              dy = Math.max(Graph2.minTableRowHeight - bounds.height, pt.y - bounds.y - bounds.height);
            };
            handle.execute = function(me) {
              if (dy != 0) {
                graph.setTableRowHeight(this.state.cell, dy, !mxEvent2.isShiftDown(me.getEvent()));
              } else if (!self.blockDelayedSelection) {
                var temp2 = graph.getCellAt(me.getGraphX(), me.getGraphY()) || tableState.cell;
                graph.graphHandler.selectCellForEvent(temp2, me);
              }
              dy = 0;
            };
            handle.reset = function() {
              dy = 0;
            };
            handles.push(handle);
          })(i);
        }
      }
    }
    return handles != null ? handles.reverse() : null;
  };
  vertexHandlerSetHandlesVisible = mxVertexHandler2.prototype.setHandlesVisible;
  mxVertexHandler2.prototype.setHandlesVisible = function(visible) {
    vertexHandlerSetHandlesVisible.apply(this, arguments);
    if (this.moveHandles != null) {
      for (var i = 0; i < this.moveHandles.length; i++) {
        this.moveHandles[i].style.visibility = visible ? "" : "hidden";
      }
    }
    if (this.cornerHandles != null) {
      for (var i = 0; i < this.cornerHandles.length; i++) {
        this.cornerHandles[i].node.style.visibility = visible ? "" : "hidden";
      }
    }
  };
  mxVertexHandler2.prototype.refreshMoveHandles = function() {
    var graph = this.graph;
    var model = graph.model;
    if (this.moveHandles != null) {
      for (var i = 0; i < this.moveHandles.length; i++) {
        this.moveHandles[i].parentNode.removeChild(this.moveHandles[i]);
      }
      this.moveHandles = null;
    }
    this.moveHandles = [];
    for (var i = 0; i < model.getChildCount(this.state.cell); i++) {
      bind(this, function(rowState) {
        if (rowState != null && model.isVertex(rowState.cell)) {
          var moveHandle = createImage(Editor.rowMoveImage);
          moveHandle.style.position = "absolute";
          moveHandle.style.cursor = "pointer";
          moveHandle.style.width = "7px";
          moveHandle.style.height = "4px";
          moveHandle.style.padding = "4px 2px 4px 2px";
          moveHandle.rowState = rowState;
          mxEvent2.addGestureListeners(moveHandle, bind(this, function(evt) {
            this.graph.popupMenuHandler.hideMenu();
            this.graph.stopEditing(false);
            if (this.graph.isToggleEvent(evt) || !this.graph.isCellSelected(rowState.cell)) {
              this.graph.selectCellForEvent(rowState.cell, evt);
            }
            if (!mxEvent2.isPopupTrigger(evt)) {
              this.graph.graphHandler.start(this.state.cell, mxEvent2.getClientX(evt), mxEvent2.getClientY(evt), this.graph.getSelectionCells());
              this.graph.graphHandler.cellWasClicked = true;
              this.graph.isMouseTrigger = mxEvent2.isMouseEvent(evt);
              this.graph.isMouseDown = true;
            }
            mxEvent2.consume(evt);
          }), null, bind(this, function(evt) {
            if (mxEvent2.isPopupTrigger(evt)) {
              this.graph.popupMenuHandler.popup(mxEvent2.getClientX(evt), mxEvent2.getClientY(evt), rowState.cell, evt);
              mxEvent2.consume(evt);
            }
          }));
          this.moveHandles.push(moveHandle);
          this.graph.container.appendChild(moveHandle);
        }
      })(this.graph.view.getState(model.getChildAt(this.state.cell, i)));
    }
  };
  mxVertexHandler2.prototype.refresh = function() {
    if (this.customHandles != null) {
      for (var i = 0; i < this.customHandles.length; i++) {
        this.customHandles[i].destroy();
      }
      this.customHandles = this.createCustomHandles();
    }
    if (this.graph.isTable(this.state.cell)) {
      this.refreshMoveHandles();
    }
  };
  vertexHandlerGetHandlePadding = mxVertexHandler2.prototype.getHandlePadding;
  mxVertexHandler2.prototype.getHandlePadding = function() {
    var result2 = new mxPoint2(0, 0);
    var tol = this.tolerance;
    var name = this.state.style["shape"];
    if (mxCellRenderer2.defaultShapes[name] == null && mxStencilRegistry.getStencil(name) == null) {
      name = mxConstants2.SHAPE_RECTANGLE;
    }
    var handlePadding = this.graph.isTable(this.state.cell) || this.graph.cellEditor.getEditingCell() == this.state.cell;
    if (!handlePadding) {
      if (this.customHandles != null) {
        for (var i = 0; i < this.customHandles.length; i++) {
          if (this.customHandles[i].shape != null && this.customHandles[i].shape.bounds != null) {
            var b = this.customHandles[i].shape.bounds;
            var px = b.getCenterX();
            var py = b.getCenterY();
            if (Math.abs(this.state.x - px) < b.width / 2 || Math.abs(this.state.y - py) < b.height / 2 || Math.abs(this.state.x + this.state.width - px) < b.width / 2 || Math.abs(this.state.y + this.state.height - py) < b.height / 2) {
              handlePadding = true;
              break;
            }
          }
        }
      }
    }
    if (handlePadding && this.sizers != null && this.sizers.length > 0 && this.sizers[0] != null) {
      tol /= 2;
      if (this.graph.isTable(this.state.cell)) {
        tol += 7;
      }
      result2.x = this.sizers[0].bounds.width + tol;
      result2.y = this.sizers[0].bounds.height + tol;
    } else {
      result2 = vertexHandlerGetHandlePadding.apply(this, arguments);
    }
    return result2;
  };
  mxVertexHandler2.prototype.updateHint = function(me) {
    if (this.index != mxEvent2.LABEL_HANDLE) {
      if (this.hint == null) {
        this.hint = createHint();
        this.state.view.graph.container.appendChild(this.hint);
      }
      if (this.index == mxEvent2.ROTATION_HANDLE) {
        this.hint.innerHTML = this.currentAlpha + "&deg;";
      } else {
        var s = this.state.view.scale;
        var unit = this.state.view.unit;
        this.hint.innerHTML = formatHintText(this.roundLength(this.bounds.width / s), unit) + " x " + formatHintText(this.roundLength(this.bounds.height / s), unit);
      }
      var rot = this.currentAlpha != null ? this.currentAlpha : this.state.style[mxConstants2.STYLE_ROTATION] || "0";
      var bb = getBoundingBox(this.bounds, rot);
      if (bb == null) {
        bb = this.bounds;
      }
      this.hint.style.left = bb.x + Math.round((bb.width - this.hint.clientWidth) / 2) + "px";
      this.hint.style.top = bb.y + bb.height + 20 + "px";
      if (this.linkHint != null) {
        this.linkHint.style.display = "none";
      }
    }
  };
  mxVertexHandler2.prototype.removeHint = function() {
    mxGraphHandler.prototype.removeHint.apply(this, arguments);
    if (this.linkHint != null) {
      this.linkHint.style.display = "";
    }
  };
  edgeHandlerMouseMove = mxEdgeHandler2.prototype.mouseMove;
  mxEdgeHandler2.prototype.mouseMove = function(sender, me) {
    edgeHandlerMouseMove.apply(this, arguments);
    if (this.linkHint != null && this.linkHint.style.display != "none" && this.graph.graphHandler != null && this.graph.graphHandler.first != null) {
      this.linkHint.style.display = "none";
    }
  };
  edgeHandlerMouseUp = mxEdgeHandler2.prototype.mouseUp;
  mxEdgeHandler2.prototype.mouseUp = function(sender, me) {
    edgeHandlerMouseUp.apply(this, arguments);
    if (this.linkHint != null && this.linkHint.style.display == "none") {
      this.linkHint.style.display = "";
    }
  };
  mxEdgeHandler2.prototype.updateHint = function(me, point) {
    if (this.hint == null) {
      this.hint = createHint();
      this.state.view.graph.container.appendChild(this.hint);
    }
    var t = this.graph.view.translate;
    var s = this.graph.view.scale;
    var x = this.roundLength(point.x / s - t.x);
    var y = this.roundLength(point.y / s - t.y);
    var unit = this.graph.view.unit;
    this.hint.innerHTML = formatHintText(x, unit) + ", " + formatHintText(y, unit);
    this.hint.style.visibility = "visible";
    if (this.isSource || this.isTarget) {
      if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null) {
        var pt = this.constraintHandler.currentConstraint.point;
        this.hint.innerHTML = "[" + Math.round(pt.x * 100) + "%, " + Math.round(pt.y * 100) + "%]";
      } else if (this.marker.hasValidState()) {
        this.hint.style.visibility = "hidden";
      }
    }
    this.hint.style.left = Math.round(me.getGraphX() - this.hint.clientWidth / 2) + "px";
    this.hint.style.top = Math.max(me.getGraphY(), point.y) + 20 + "px";
    if (this.linkHint != null) {
      this.linkHint.style.display = "none";
    }
  };
  mxEdgeHandler2.prototype.removeHint = mxVertexHandler2.prototype.removeHint;
  HoverIcons.prototype.mainHandle = !mxClient_default.IS_SVG ? new mxImage2(IMAGE_PATH + "/handle-main.png", 17, 17) : Graph2.createSvgImage(18, 18, '<circle cx="9" cy="9" r="5" stroke="#fff" fill="' + HoverIcons.prototype.arrowFill + '" stroke-width="1"/>');
  HoverIcons.prototype.secondaryHandle = !mxClient_default.IS_SVG ? new mxImage2(IMAGE_PATH + "/handle-secondary.png", 17, 17) : Graph2.createSvgImage(16, 16, '<path d="m 8 3 L 13 8 L 8 13 L 3 8 z" stroke="#fff" fill="#fca000"/>');
  HoverIcons.prototype.fixedHandle = !mxClient_default.IS_SVG ? new mxImage2(IMAGE_PATH + "/handle-fixed.png", 17, 17) : Graph2.createSvgImage(18, 18, '<circle cx="9" cy="9" r="5" stroke="#fff" fill="' + HoverIcons.prototype.arrowFill + '" stroke-width="1"/><path d="m 7 7 L 11 11 M 7 11 L 11 7" stroke="#fff"/>');
  HoverIcons.prototype.terminalHandle = !mxClient_default.IS_SVG ? new mxImage2(IMAGE_PATH + "/handle-terminal.png", 17, 17) : Graph2.createSvgImage(18, 18, '<circle cx="9" cy="9" r="5" stroke="#fff" fill="' + HoverIcons.prototype.arrowFill + '" stroke-width="1"/><circle cx="9" cy="9" r="2" stroke="#fff" fill="transparent"/>');
  HoverIcons.prototype.rotationHandle = !mxClient_default.IS_SVG ? new mxImage2(IMAGE_PATH + "/handle-rotate.png", 16, 16) : Graph2.createSvgImage(16, 16, '<path stroke="' + HoverIcons.prototype.arrowFill + '" fill="' + HoverIcons.prototype.arrowFill + '" d="M15.55 5.55L11 1v3.07C7.06 4.56 4 7.92 4 12s3.05 7.44 7 7.93v-2.02c-2.84-.48-5-2.94-5-5.91s2.16-5.43 5-5.91V10l4.55-4.45zM19.93 11c-.17-1.39-.72-2.73-1.62-3.89l-1.42 1.42c.54.75.88 1.6 1.02 2.47h2.02zM13 17.9v2.02c1.39-.17 2.74-.71 3.9-1.61l-1.44-1.44c-.75.54-1.59.89-2.46 1.03zm3.89-2.42l1.42 1.41c.9-1.16 1.45-2.5 1.62-3.89h-2.02c-.14.87-.48 1.72-1.02 2.48z"/>', 24, 24);
  if (mxClient_default.IS_SVG) {
    mxConstraintHandler.prototype.pointImage = Graph2.createSvgImage(5, 5, '<path d="m 0 0 L 5 5 M 0 5 L 5 0" stroke="' + HoverIcons.prototype.arrowFill + '"/>');
  }
  mxVertexHandler2.TABLE_HANDLE_COLOR = "#fca000";
  mxVertexHandler2.prototype.handleImage = HoverIcons.prototype.mainHandle;
  mxVertexHandler2.prototype.secondaryHandleImage = HoverIcons.prototype.secondaryHandle;
  mxEdgeHandler2.prototype.handleImage = HoverIcons.prototype.mainHandle;
  mxEdgeHandler2.prototype.terminalHandleImage = HoverIcons.prototype.terminalHandle;
  mxEdgeHandler2.prototype.fixedHandleImage = HoverIcons.prototype.fixedHandle;
  mxEdgeHandler2.prototype.labelHandleImage = HoverIcons.prototype.secondaryHandle;
  mxOutline.prototype.sizerImage = HoverIcons.prototype.mainHandle;
  if (window.Sidebar != null) {
    Sidebar.prototype.triangleUp = HoverIcons.prototype.triangleUp;
    Sidebar.prototype.triangleRight = HoverIcons.prototype.triangleRight;
    Sidebar.prototype.triangleDown = HoverIcons.prototype.triangleDown;
    Sidebar.prototype.triangleLeft = HoverIcons.prototype.triangleLeft;
    Sidebar.prototype.refreshTarget = HoverIcons.prototype.refreshTarget;
    Sidebar.prototype.roundDrop = HoverIcons.prototype.roundDrop;
  }
  if (!mxClient_default.IS_SVG) {
    new Image().src = HoverIcons.prototype.mainHandle.src;
    new Image().src = HoverIcons.prototype.fixedHandle.src;
    new Image().src = HoverIcons.prototype.terminalHandle.src;
    new Image().src = HoverIcons.prototype.secondaryHandle.src;
    new Image().src = HoverIcons.prototype.rotationHandle.src;
    new Image().src = HoverIcons.prototype.triangleUp.src;
    new Image().src = HoverIcons.prototype.triangleRight.src;
    new Image().src = HoverIcons.prototype.triangleDown.src;
    new Image().src = HoverIcons.prototype.triangleLeft.src;
    new Image().src = HoverIcons.prototype.refreshTarget.src;
    new Image().src = HoverIcons.prototype.roundDrop.src;
  }
  mxVertexHandler2.prototype.rotationEnabled = true;
  mxVertexHandler2.prototype.manageSizers = true;
  mxVertexHandler2.prototype.livePreview = true;
  mxGraphHandler.prototype.maxLivePreview = 16;
  mxRubberband.prototype.defaultOpacity = 30;
  mxConnectionHandler.prototype.outlineConnect = true;
  mxCellHighlight2.prototype.keepOnTop = true;
  mxVertexHandler2.prototype.parentHighlightEnabled = true;
  mxEdgeHandler2.prototype.parentHighlightEnabled = true;
  mxEdgeHandler2.prototype.dblClickRemoveEnabled = true;
  mxEdgeHandler2.prototype.straightRemoveEnabled = true;
  mxEdgeHandler2.prototype.virtualBendsEnabled = true;
  mxEdgeHandler2.prototype.mergeRemoveEnabled = true;
  mxEdgeHandler2.prototype.manageLabelHandle = true;
  mxEdgeHandler2.prototype.outlineConnect = true;
  mxEdgeHandler2.prototype.isAddVirtualBendEvent = function(me) {
    return !mxEvent2.isShiftDown(me.getEvent());
  };
  mxEdgeHandler2.prototype.isCustomHandleEvent = function(me) {
    return !mxEvent2.isShiftDown(me.getEvent());
  };
  if (Graph2.touchStyle) {
    if (mxClient_default.IS_TOUCH || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0) {
      mxShape.prototype.svgStrokeTolerance = 18;
      mxVertexHandler2.prototype.tolerance = 12;
      mxEdgeHandler2.prototype.tolerance = 12;
      Graph2.prototype.tolerance = 12;
      mxVertexHandler2.prototype.rotationHandleVSpacing = -16;
      mxConstraintHandler.prototype.getTolerance = function(me) {
        return mxEvent2.isMouseEvent(me.getEvent()) ? 4 : this.graph.getTolerance();
      };
    }
    mxPanningHandler.prototype.isPanningTrigger = function(me) {
      var evt = me.getEvent();
      return me.getState() == null && !mxEvent2.isMouseEvent(evt) || mxEvent2.isPopupTrigger(evt) && (me.getState() == null || mxEvent2.isControlDown(evt) || mxEvent2.isShiftDown(evt));
    };
    graphHandlerMouseDown = mxGraphHandler.prototype.mouseDown;
    mxGraphHandler.prototype.mouseDown = function(sender, me) {
      graphHandlerMouseDown.apply(this, arguments);
      if (mxEvent2.isTouchEvent(me.getEvent()) && this.graph.isCellSelected(me.getCell()) && this.graph.getSelectionCount() > 1) {
        this.delayedSelection = false;
      }
    };
  } else {
    mxPanningHandler.prototype.isPanningTrigger = function(me) {
      var evt = me.getEvent();
      return mxEvent2.isLeftMouseButton(evt) && (this.useLeftButtonForPanning && me.getState() == null || mxEvent2.isControlDown(evt) && !mxEvent2.isShiftDown(evt)) || this.usePopupTrigger && mxEvent2.isPopupTrigger(evt);
    };
  }
  mxRubberband.prototype.isSpaceEvent = function(me) {
    return this.graph.isEnabled() && !this.graph.isCellLocked(this.graph.getDefaultParent()) && mxEvent2.isControlDown(me.getEvent()) && mxEvent2.isShiftDown(me.getEvent());
  };
  mxRubberband.prototype.cancelled = false;
  mxRubberband.prototype.cancel = function() {
    if (this.isActive()) {
      this.cancelled = true;
      this.reset();
    }
  };
  mxRubberband.prototype.mouseUp = function(sender, me) {
    if (this.cancelled) {
      this.cancelled = false;
      me.consume();
    } else {
      var execute = this.div != null && this.div.style.display != "none";
      var x0 = null;
      var y0 = null;
      var dx = null;
      var dy = null;
      if (this.first != null && this.currentX != null && this.currentY != null) {
        x0 = this.first.x;
        y0 = this.first.y;
        dx = (this.currentX - x0) / this.graph.view.scale;
        dy = (this.currentY - y0) / this.graph.view.scale;
        if (!mxEvent2.isAltDown(me.getEvent())) {
          dx = this.graph.snap(dx);
          dy = this.graph.snap(dy);
          if (!this.graph.isGridEnabled()) {
            if (Math.abs(dx) < this.graph.tolerance) {
              dx = 0;
            }
            if (Math.abs(dy) < this.graph.tolerance) {
              dy = 0;
            }
          }
        }
      }
      this.reset();
      if (execute) {
        if (mxEvent2.isAltDown(me.getEvent()) && this.graph.isToggleEvent(me.getEvent())) {
          var rect = new mxRectangle(this.x, this.y, this.width, this.height);
          var cells = this.graph.getCells(rect.x, rect.y, rect.width, rect.height);
          this.graph.removeSelectionCells(cells);
        } else if (this.isSpaceEvent(me)) {
          this.graph.model.beginUpdate();
          try {
            var cells = this.graph.getCellsBeyond(x0, y0, this.graph.getDefaultParent(), true, true);
            for (var i = 0; i < cells.length; i++) {
              if (this.graph.isCellMovable(cells[i])) {
                var tmp = this.graph.view.getState(cells[i]);
                var geo = this.graph.getCellGeometry(cells[i]);
                if (tmp != null && geo != null) {
                  geo = geo.clone();
                  geo.translate(dx, dy);
                  this.graph.model.setGeometry(cells[i], geo);
                }
              }
            }
          } finally {
            this.graph.model.endUpdate();
          }
        } else {
          var rect = new mxRectangle(this.x, this.y, this.width, this.height);
          this.graph.selectRegion(rect, me.getEvent());
        }
        me.consume();
      }
    }
  };
  mxRubberband.prototype.mouseMove = function(sender, me) {
    if (!me.isConsumed() && this.first != null) {
      var origin = getScrollOrigin(this.graph.container);
      var offset = getOffset(this.graph.container);
      origin.x -= offset.x;
      origin.y -= offset.y;
      var x = me.getX() + origin.x;
      var y = me.getY() + origin.y;
      var dx = this.first.x - x;
      var dy = this.first.y - y;
      var tol = this.graph.tolerance;
      if (this.div != null || Math.abs(dx) > tol || Math.abs(dy) > tol) {
        if (this.div == null) {
          this.div = this.createShape();
        }
        clearSelection();
        this.update(x, y);
        if (this.isSpaceEvent(me)) {
          var right = this.x + this.width;
          var bottom = this.y + this.height;
          var scale = this.graph.view.scale;
          if (!mxEvent2.isAltDown(me.getEvent())) {
            this.width = this.graph.snap(this.width / scale) * scale;
            this.height = this.graph.snap(this.height / scale) * scale;
            if (!this.graph.isGridEnabled()) {
              if (this.width < this.graph.tolerance) {
                this.width = 0;
              }
              if (this.height < this.graph.tolerance) {
                this.height = 0;
              }
            }
            if (this.x < this.first.x) {
              this.x = right - this.width;
            }
            if (this.y < this.first.y) {
              this.y = bottom - this.height;
            }
          }
          this.div.style.borderStyle = "dashed";
          this.div.style.backgroundColor = "white";
          this.div.style.left = this.x + "px";
          this.div.style.top = this.y + "px";
          this.div.style.width = Math.max(0, this.width) + "px";
          this.div.style.height = this.graph.container.clientHeight + "px";
          this.div.style.borderWidth = this.width <= 0 ? "0px 1px 0px 0px" : "0px 1px 0px 1px";
          if (this.secondDiv == null) {
            this.secondDiv = this.div.cloneNode(true);
            this.div.parentNode.appendChild(this.secondDiv);
          }
          this.secondDiv.style.left = this.x + "px";
          this.secondDiv.style.top = this.y + "px";
          this.secondDiv.style.width = this.graph.container.clientWidth + "px";
          this.secondDiv.style.height = Math.max(0, this.height) + "px";
          this.secondDiv.style.borderWidth = this.height <= 0 ? "1px 0px 0px 0px" : "1px 0px 1px 0px";
        } else {
          this.div.style.backgroundColor = "";
          this.div.style.borderWidth = "";
          this.div.style.borderStyle = "";
          if (this.secondDiv != null) {
            this.secondDiv.parentNode.removeChild(this.secondDiv);
            this.secondDiv = null;
          }
        }
        me.consume();
      }
    }
  };
  mxRubberbandReset = mxRubberband.prototype.reset;
  mxRubberband.prototype.reset = function() {
    if (this.secondDiv != null) {
      this.secondDiv.parentNode.removeChild(this.secondDiv);
      this.secondDiv = null;
    }
    mxRubberbandReset.apply(this, arguments);
  };
  startTime = new Date().getTime();
  timeOnTarget = 0;
  mxEdgeHandlerUpdatePreviewState = mxEdgeHandler2.prototype.updatePreviewState;
  mxEdgeHandler2.prototype.updatePreviewState = function(edge, point, terminalState, me) {
    mxEdgeHandlerUpdatePreviewState.apply(this, arguments);
    if (terminalState != this.currentTerminalState) {
      startTime = new Date().getTime();
      timeOnTarget = 0;
    } else {
      timeOnTarget = new Date().getTime() - startTime;
    }
    this.currentTerminalState = terminalState;
  };
  mxEdgeHandlerIsOutlineConnectEvent = mxEdgeHandler2.prototype.isOutlineConnectEvent;
  mxEdgeHandler2.prototype.isOutlineConnectEvent = function(me) {
    return this.currentTerminalState != null && me.getState() == this.currentTerminalState && timeOnTarget > 2e3 || (this.currentTerminalState == null || getValue(this.currentTerminalState.style, "outlineConnect", "1") != "0") && mxEdgeHandlerIsOutlineConnectEvent.apply(this, arguments);
  };
  mxEdgeHandler2.prototype.createHandleShape = function(index, virtual) {
    var source = index != null && index == 0;
    var terminalState = this.state.getVisibleTerminalState(source);
    var c = index != null && (index == 0 || index >= this.state.absolutePoints.length - 1 || this.constructor == mxElbowEdgeHandler2 && index == 2) ? this.graph.getConnectionConstraint(this.state, terminalState, source) : null;
    var pt = c != null ? this.graph.getConnectionPoint(this.state.getVisibleTerminalState(source), c) : null;
    var img = pt != null ? this.fixedHandleImage : c != null && terminalState != null ? this.terminalHandleImage : this.handleImage;
    if (img != null) {
      var shape = new mxImageShape(new mxRectangle(0, 0, img.width, img.height), img.src);
      shape.preserveImageAspect = false;
      return shape;
    } else {
      var s = mxConstants2.HANDLE_SIZE;
      if (this.preferHtml) {
        s -= 1;
      }
      return new mxRectangleShape(new mxRectangle(0, 0, s, s), mxConstants2.HANDLE_FILLCOLOR, mxConstants2.HANDLE_STROKECOLOR);
    }
  };
  vertexHandlerCreateSizerShape = mxVertexHandler2.prototype.createSizerShape;
  mxVertexHandler2.prototype.createSizerShape = function(bounds, index, fillColor) {
    this.handleImage = index == mxEvent2.ROTATION_HANDLE ? HoverIcons.prototype.rotationHandle : index == mxEvent2.LABEL_HANDLE ? this.secondaryHandleImage : this.handleImage;
    return vertexHandlerCreateSizerShape.apply(this, arguments);
  };
  mxGraphHandlerGetBoundingBox = mxGraphHandler.prototype.getBoundingBox;
  mxGraphHandler.prototype.getBoundingBox = function(cells) {
    if (cells != null && cells.length == 1) {
      var model = this.graph.getModel();
      var parent2 = model.getParent(cells[0]);
      var geo = this.graph.getCellGeometry(cells[0]);
      if (model.isEdge(parent2) && geo != null && geo.relative) {
        var state2 = this.graph.view.getState(cells[0]);
        if (state2 != null && state2.width < 2 && state2.height < 2 && state2.text != null && state2.text.boundingBox != null) {
          return mxRectangle.fromRectangle(state2.text.boundingBox);
        }
      }
    }
    return mxGraphHandlerGetBoundingBox.apply(this, arguments);
  };
  mxGraphHandlerGetGuideStates = mxGraphHandler.prototype.getGuideStates;
  mxGraphHandler.prototype.getGuideStates = function() {
    var states = mxGraphHandlerGetGuideStates.apply(this, arguments);
    var result2 = [];
    for (var i = 0; i < states.length; i++) {
      if (getValue(states[i].style, "part", "0") != "1") {
        result2.push(states[i]);
      }
    }
    return result2;
  };
  mxVertexHandlerGetSelectionBounds = mxVertexHandler2.prototype.getSelectionBounds;
  mxVertexHandler2.prototype.getSelectionBounds = function(state2) {
    var model = this.graph.getModel();
    var parent2 = model.getParent(state2.cell);
    var geo = this.graph.getCellGeometry(state2.cell);
    if (model.isEdge(parent2) && geo != null && geo.relative && state2.width < 2 && state2.height < 2 && state2.text != null && state2.text.boundingBox != null) {
      var bbox = state2.text.unrotatedBoundingBox || state2.text.boundingBox;
      return new mxRectangle(Math.round(bbox.x), Math.round(bbox.y), Math.round(bbox.width), Math.round(bbox.height));
    } else {
      return mxVertexHandlerGetSelectionBounds.apply(this, arguments);
    }
  };
  mxVertexHandlerMouseDown = mxVertexHandler2.prototype.mouseDown;
  mxVertexHandler2.prototype.mouseDown = function(sender, me) {
    var model = this.graph.getModel();
    var parent2 = model.getParent(this.state.cell);
    var geo = this.graph.getCellGeometry(this.state.cell);
    var handle = this.getHandleForEvent(me);
    if (handle == mxEvent2.ROTATION_HANDLE || !model.isEdge(parent2) || geo == null || !geo.relative || this.state == null || this.state.width >= 2 || this.state.height >= 2) {
      mxVertexHandlerMouseDown.apply(this, arguments);
    }
  };
  mxVertexHandler2.prototype.rotateClick = function() {
    var stroke = getValue(this.state.style, mxConstants2.STYLE_STROKECOLOR, mxConstants2.NONE);
    var fill = getValue(this.state.style, mxConstants2.STYLE_FILLCOLOR, mxConstants2.NONE);
    if (this.state.view.graph.model.isVertex(this.state.cell) && stroke == mxConstants2.NONE && fill == mxConstants2.NONE) {
      var angle = mod(getValue(this.state.style, mxConstants2.STYLE_ROTATION, 0) + 90, 360);
      this.state.view.graph.setCellStyles(mxConstants2.STYLE_ROTATION, angle, [
        this.state.cell
      ]);
    } else {
      this.state.view.graph.turnShapes([this.state.cell]);
    }
  };
  vertexHandlerMouseMove = mxVertexHandler2.prototype.mouseMove;
  mxVertexHandler2.prototype.mouseMove = function(sender, me) {
    vertexHandlerMouseMove.apply(this, arguments);
    if (this.graph.graphHandler.first != null) {
      if (this.rotationShape != null && this.rotationShape.node != null) {
        this.rotationShape.node.style.display = "none";
      }
      if (this.linkHint != null && this.linkHint.style.display != "none") {
        this.linkHint.style.display = "none";
      }
    }
  };
  vertexHandlerMouseUp = mxVertexHandler2.prototype.mouseUp;
  mxVertexHandler2.prototype.mouseUp = function(sender, me) {
    vertexHandlerMouseUp.apply(this, arguments);
    if (this.rotationShape != null && this.rotationShape.node != null) {
      this.rotationShape.node.style.display = this.graph.getSelectionCount() == 1 ? "" : "none";
    }
    if (this.linkHint != null && this.linkHint.style.display == "none") {
      this.linkHint.style.display = "";
    }
    this.blockDelayedSelection = null;
  };
  vertexHandlerInit = mxVertexHandler2.prototype.init;
  mxVertexHandler2.prototype.init = function() {
    vertexHandlerInit.apply(this, arguments);
    var redraw = false;
    if (this.rotationShape != null) {
      this.rotationShape.node.setAttribute("title", mxResources2.get("rotateTooltip"));
    }
    if (this.graph.isTable(this.state.cell)) {
      this.refreshMoveHandles();
    } else if (this.graph.getSelectionCount() == 1 && (this.graph.isTableCell(this.state.cell) || this.graph.isTableRow(this.state.cell))) {
      this.cornerHandles = [];
      for (var i = 0; i < 4; i++) {
        var shape = new mxRectangleShape(new mxRectangle(0, 0, 6, 6), "#ffffff", mxConstants2.HANDLE_STROKECOLOR);
        shape.dialect = this.graph.dialect != mxConstants2.DIALECT_SVG ? mxConstants2.DIALECT_VML : mxConstants2.DIALECT_SVG;
        shape.init(this.graph.view.getOverlayPane());
        this.cornerHandles.push(shape);
      }
    }
    var update = bind(this, function() {
      if (this.specialHandle != null) {
        this.specialHandle.node.style.display = this.graph.isEnabled() && this.graph.getSelectionCount() < this.graph.graphHandler.maxCells ? "" : "none";
      }
      this.redrawHandles();
    });
    this.changeHandler = bind(this, function(sender, evt) {
      this.updateLinkHint(this.graph.getLinkForCell(this.state.cell), this.graph.getLinksForState(this.state));
      update();
    });
    this.graph.getSelectionModel().addListener(mxEvent2.CHANGE, this.changeHandler);
    this.graph.getModel().addListener(mxEvent2.CHANGE, this.changeHandler);
    this.editingHandler = bind(this, function(sender, evt) {
      this.redrawHandles();
    });
    this.graph.addListener(mxEvent2.EDITING_STOPPED, this.editingHandler);
    var link2 = this.graph.getLinkForCell(this.state.cell);
    var links = this.graph.getLinksForState(this.state);
    this.updateLinkHint(link2, links);
    if (link2 != null || links != null && links.length > 0) {
      redraw = true;
    }
    if (redraw) {
      this.redrawHandles();
    }
  };
  mxVertexHandler2.prototype.updateLinkHint = function(link2, links) {
    try {
      if (link2 == null && (links == null || links.length == 0) || this.graph.getSelectionCount() > 1) {
        if (this.linkHint != null) {
          this.linkHint.parentNode.removeChild(this.linkHint);
          this.linkHint = null;
        }
      } else if (link2 != null || links != null && links.length > 0) {
        if (this.linkHint == null) {
          this.linkHint = createHint();
          this.linkHint.style.padding = "6px 8px 6px 8px";
          this.linkHint.style.opacity = "1";
          this.linkHint.style.filter = "";
          this.graph.container.appendChild(this.linkHint);
        }
        this.linkHint.innerHTML = "";
        if (link2 != null) {
          this.linkHint.appendChild(this.graph.createLinkForHint(link2));
          if (this.graph.isEnabled() && typeof this.graph.editLink === "function") {
            var changeLink = document.createElement("img");
            changeLink.setAttribute("src", Editor.editImage);
            changeLink.setAttribute("title", mxResources2.get("editLink"));
            changeLink.setAttribute("width", "11");
            changeLink.setAttribute("height", "11");
            changeLink.style.marginLeft = "10px";
            changeLink.style.marginBottom = "-1px";
            changeLink.style.cursor = "pointer";
            this.linkHint.appendChild(changeLink);
            mxEvent2.addListener(changeLink, "click", bind(this, function(evt) {
              this.graph.setSelectionCell(this.state.cell);
              this.graph.editLink();
              mxEvent2.consume(evt);
            }));
            var removeLink = document.createElement("img");
            removeLink.setAttribute("src", Dialog.prototype.clearImage);
            removeLink.setAttribute("title", mxResources2.get("removeIt", [mxResources2.get("link")]));
            removeLink.setAttribute("width", "13");
            removeLink.setAttribute("height", "10");
            removeLink.style.marginLeft = "4px";
            removeLink.style.marginBottom = "-1px";
            removeLink.style.cursor = "pointer";
            this.linkHint.appendChild(removeLink);
            mxEvent2.addListener(removeLink, "click", bind(this, function(evt) {
              this.graph.setLinkForCell(this.state.cell, null);
              mxEvent2.consume(evt);
            }));
          }
        }
        if (links != null) {
          for (var i = 0; i < links.length; i++) {
            var div = document.createElement("div");
            div.style.marginTop = link2 != null || i > 0 ? "6px" : "0px";
            div.appendChild(this.graph.createLinkForHint(links[i].getAttribute("href"), getTextContent(links[i])));
            this.linkHint.appendChild(div);
          }
        }
      }
    } catch (e) {
    }
  };
  mxEdgeHandler2.prototype.updateLinkHint = mxVertexHandler2.prototype.updateLinkHint;
  edgeHandlerInit = mxEdgeHandler2.prototype.init;
  mxEdgeHandler2.prototype.init = function() {
    edgeHandlerInit.apply(this, arguments);
    this.constraintHandler.isEnabled = bind(this, function() {
      return this.state.view.graph.connectionHandler.isEnabled();
    });
    var update = bind(this, function() {
      if (this.linkHint != null) {
        this.linkHint.style.display = this.graph.getSelectionCount() == 1 ? "" : "none";
      }
      if (this.labelShape != null) {
        this.labelShape.node.style.display = this.graph.isEnabled() && this.graph.getSelectionCount() < this.graph.graphHandler.maxCells ? "" : "none";
      }
    });
    this.changeHandler = bind(this, function(sender, evt) {
      this.updateLinkHint(this.graph.getLinkForCell(this.state.cell), this.graph.getLinksForState(this.state));
      update();
      this.redrawHandles();
    });
    this.graph.getSelectionModel().addListener(mxEvent2.CHANGE, this.changeHandler);
    this.graph.getModel().addListener(mxEvent2.CHANGE, this.changeHandler);
    var link2 = this.graph.getLinkForCell(this.state.cell);
    var links = this.graph.getLinksForState(this.state);
    if (link2 != null || links != null && links.length > 0) {
      this.updateLinkHint(link2, links);
      this.redrawHandles();
    }
  };
  connectionHandlerInit = mxConnectionHandler.prototype.init;
  mxConnectionHandler.prototype.init = function() {
    connectionHandlerInit.apply(this, arguments);
    this.constraintHandler.isEnabled = bind(this, function() {
      return this.graph.connectionHandler.isEnabled();
    });
  };
  vertexHandlerRedrawHandles = mxVertexHandler2.prototype.redrawHandles;
  mxVertexHandler2.prototype.redrawHandles = function() {
    if (this.moveHandles != null) {
      for (var i = 0; i < this.moveHandles.length; i++) {
        this.moveHandles[i].style.left = this.moveHandles[i].rowState.x + this.moveHandles[i].rowState.width - 5 + "px";
        this.moveHandles[i].style.top = this.moveHandles[i].rowState.y + this.moveHandles[i].rowState.height / 2 - 6 + "px";
      }
    }
    if (this.cornerHandles != null) {
      var inset = this.getSelectionBorderInset();
      var ch = this.cornerHandles;
      var w2 = ch[0].bounds.width / 2;
      var h2 = ch[0].bounds.height / 2;
      ch[0].bounds.x = this.state.x - w2 + inset;
      ch[0].bounds.y = this.state.y - h2 + inset;
      ch[0].redraw();
      ch[1].bounds.x = ch[0].bounds.x + this.state.width - 2 * inset;
      ch[1].bounds.y = ch[0].bounds.y;
      ch[1].redraw();
      ch[2].bounds.x = ch[0].bounds.x;
      ch[2].bounds.y = this.state.y + this.state.height - 2 * inset;
      ch[2].redraw();
      ch[3].bounds.x = ch[1].bounds.x;
      ch[3].bounds.y = ch[2].bounds.y;
      ch[3].redraw();
      for (var i = 0; i < this.cornerHandles.length; i++) {
        this.cornerHandles[i].node.style.display = this.graph.getSelectionCount() == 1 ? "" : "none";
      }
    }
    if (this.rotationShape != null && this.rotationShape.node != null) {
      this.rotationShape.node.style.display = this.moveHandles == null && this.graph.getSelectionCount() == 1 && (this.index == null || this.index == mxEvent2.ROTATION_HANDLE) ? "" : "none";
    }
    vertexHandlerRedrawHandles.apply(this);
    if (this.state != null && this.linkHint != null) {
      var c = new mxPoint2(this.state.getCenterX(), this.state.getCenterY());
      var tmp = new mxRectangle(this.state.x, this.state.y - 22, this.state.width + 24, this.state.height + 22);
      var bb = getBoundingBox(tmp, this.state.style[mxConstants2.STYLE_ROTATION] || "0", c);
      var rs = bb != null ? getBoundingBox(this.state, this.state.style[mxConstants2.STYLE_ROTATION] || "0") : this.state;
      var tb = this.state.text != null ? this.state.text.boundingBox : null;
      if (bb == null) {
        bb = this.state;
      }
      var b = bb.y + bb.height;
      if (tb != null) {
        b = Math.max(b, tb.y + tb.height);
      }
      this.linkHint.style.left = Math.max(0, Math.round(rs.x + (rs.width - this.linkHint.clientWidth) / 2)) + "px";
      this.linkHint.style.top = Math.round(b + this.verticalOffset / 2 + 20) + "px";
    }
  };
  vertexHandlerDestroy = mxVertexHandler2.prototype.destroy;
  mxVertexHandler2.prototype.destroy = function() {
    vertexHandlerDestroy.apply(this, arguments);
    if (this.moveHandles != null) {
      for (var i = 0; i < this.moveHandles.length; i++) {
        if (this.moveHandles[i] != null && this.moveHandles[i].parentNode != null) {
          this.moveHandles[i].parentNode.removeChild(this.moveHandles[i]);
        }
      }
      this.moveHandles = null;
    }
    if (this.cornerHandles != null) {
      for (var i = 0; i < this.cornerHandles.length; i++) {
        if (this.cornerHandles[i] != null && this.cornerHandles[i].node != null && this.cornerHandles[i].node.parentNode != null) {
          this.cornerHandles[i].node.parentNode.removeChild(this.cornerHandles[i].node);
        }
      }
      this.cornerHandles = null;
    }
    if (this.linkHint != null) {
      if (this.linkHint.parentNode != null) {
        this.linkHint.parentNode.removeChild(this.linkHint);
      }
      this.linkHint = null;
    }
    if (this.changeHandler != null) {
      this.graph.getSelectionModel().removeListener(this.changeHandler);
      this.graph.getModel().removeListener(this.changeHandler);
      this.changeHandler = null;
    }
    if (this.editingHandler != null) {
      this.graph.removeListener(this.editingHandler);
      this.editingHandler = null;
    }
  };
  edgeHandlerRedrawHandles = mxEdgeHandler2.prototype.redrawHandles;
  mxEdgeHandler2.prototype.redrawHandles = function() {
    if (this.marker != null) {
      edgeHandlerRedrawHandles.apply(this);
      if (this.state != null && this.linkHint != null) {
        var b = this.state;
        if (this.state.text != null && this.state.text.bounds != null) {
          b = new mxRectangle(b.x, b.y, b.width, b.height);
          b.add(this.state.text.bounds);
        }
        this.linkHint.style.left = Math.max(0, Math.round(b.x + (b.width - this.linkHint.clientWidth) / 2)) + "px";
        this.linkHint.style.top = Math.round(b.y + b.height + 20) + "px";
      }
    }
  };
  edgeHandlerReset = mxEdgeHandler2.prototype.reset;
  mxEdgeHandler2.prototype.reset = function() {
    edgeHandlerReset.apply(this, arguments);
    if (this.linkHint != null) {
      this.linkHint.style.visibility = "";
    }
  };
  edgeHandlerDestroy = mxEdgeHandler2.prototype.destroy;
  mxEdgeHandler2.prototype.destroy = function() {
    edgeHandlerDestroy.apply(this, arguments);
    if (this.linkHint != null) {
      this.linkHint.parentNode.removeChild(this.linkHint);
      this.linkHint = null;
    }
    if (this.changeHandler != null) {
      this.graph.getModel().removeListener(this.changeHandler);
      this.graph.getSelectionModel().removeListener(this.changeHandler);
      this.changeHandler = null;
    }
  };
}
var graphLayoutIsVertexIgnored;
var mxConnectionHandlerCreateTarget;
var connectionHandlerCreateShape;
var mxConnectionHandlerCreateMarker;
var graphIsExtendParent;
var graphSplitEdge;
var graphSelectCell;
var graphMoveCells;
var graphRemoveCells;
var graphProcessChange;
var graphGetDropTarget;
var mxCellRendererInitializeLabel;
var mxConstraintHandlerUpdate;
var mxCellEditorStartEditing;
var cellEditorInstallListeners;
var mxCellEditorResize;
var mxCellEditorGetInitialValue;
var mxCellEditorGetCurrentValue;
var mxCellEditorStopEditing;
var mxCellEditorApplyValue;
var mxGraphHandlerIsValidDropTarget;
var stackLayoutResizeCell;
var selectionCellsHandlerGetHandledSelectionCells;
var vertexHandlerCreateParentHighlightShape;
var edgeHandlerCreateParentHighlightShape;
var vertexHandlerIsRotationHandleVisible;
var vertexHandlerIsParentHighlightVisible;
var vertexHandlerIsCustomHandleVisible;
var vertexHandlerGetSelectionBorderBounds;
var vertexHandlerCreateCustomHandles;
var vertexHandlerSetHandlesVisible;
var vertexHandlerGetHandlePadding;
var edgeHandlerMouseMove;
var edgeHandlerMouseUp;
var graphHandlerMouseDown;
var mxRubberbandReset;
var startTime;
var timeOnTarget;
var mxEdgeHandlerUpdatePreviewState;
var mxEdgeHandlerIsOutlineConnectEvent;
var vertexHandlerCreateSizerShape;
var mxGraphHandlerGetBoundingBox;
var mxGraphHandlerGetGuideStates;
var mxVertexHandlerGetSelectionBounds;
var mxVertexHandlerMouseDown;
var vertexHandlerMouseMove;
var vertexHandlerMouseUp;
var vertexHandlerInit;
var edgeHandlerInit;
var connectionHandlerInit;
var vertexHandlerRedrawHandles;
var vertexHandlerDestroy;
var edgeHandlerRedrawHandles;
var edgeHandlerReset;
var edgeHandlerDestroy;

// js/graph/mxUndoManager.js
var mxUndoManager = function(size) {
  this.size = size != null ? size : 100;
  this.clear();
};
mxUndoManager.prototype = new mxEventSource();
mxUndoManager.prototype.constructor = mxUndoManager;
mxUndoManager.prototype.size = null;
mxUndoManager.prototype.history = null;
mxUndoManager.prototype.indexOfNextAdd = 0;
mxUndoManager.prototype.isEmpty = function() {
  return this.history.length === 0;
};
mxUndoManager.prototype.clear = function() {
  this.history = [];
  this.indexOfNextAdd = 0;
  this.fireEvent(new mxEventObject2(mxEvent2.CLEAR));
};
mxUndoManager.prototype.canUndo = function() {
  return this.indexOfNextAdd > 0;
};
mxUndoManager.prototype.undo = function() {
  while (this.indexOfNextAdd > 0) {
    const edit = this.history[--this.indexOfNextAdd];
    edit.undo();
    if (edit.isSignificant()) {
      this.fireEvent(new mxEventObject2(mxEvent2.UNDO, "edit", edit));
      break;
    }
  }
};
mxUndoManager.prototype.canRedo = function() {
  return this.indexOfNextAdd < this.history.length;
};
mxUndoManager.prototype.redo = function() {
  const n = this.history.length;
  while (this.indexOfNextAdd < n) {
    const edit = this.history[this.indexOfNextAdd++];
    edit.redo();
    if (edit.isSignificant()) {
      this.fireEvent(new mxEventObject2(mxEvent2.REDO, "edit", edit));
      break;
    }
  }
};
mxUndoManager.prototype.undoableEditHappened = function(undoableEdit) {
  this.trim();
  if (this.size > 0 && this.size === this.history.length) {
    this.history.shift();
  }
  this.history.push(undoableEdit);
  this.indexOfNextAdd = this.history.length;
  this.fireEvent(new mxEventObject2(mxEvent2.ADD, "edit", undoableEdit));
};
mxUndoManager.prototype.trim = function() {
  if (this.history.length > this.indexOfNextAdd) {
    const edits = this.history.splice(this.indexOfNextAdd, this.history.length - this.indexOfNextAdd);
    for (let i = 0; i < edits.length; i++) {
      edits[i].die();
    }
  }
};

// js/graph/mxPrintPreview.js
var mxPrintPreview = function(graph, scale, pageFormat, border, x0, y0, borderColor, title, pageSelector) {
  this.graph = graph;
  this.scale = scale != null ? scale : 1 / graph.pageScale;
  this.border = border != null ? border : 0;
  this.pageFormat = mxRectangle.fromRectangle(pageFormat != null ? pageFormat : graph.pageFormat);
  this.title = title != null ? title : "Printer-friendly version";
  this.x0 = x0 != null ? x0 : 0;
  this.y0 = y0 != null ? y0 : 0;
  this.borderColor = borderColor;
  this.pageSelector = pageSelector != null ? pageSelector : true;
};
mxPrintPreview.prototype.graph = null;
mxPrintPreview.prototype.pageFormat = null;
mxPrintPreview.prototype.scale = null;
mxPrintPreview.prototype.border = 0;
mxPrintPreview.prototype.marginTop = 0;
mxPrintPreview.prototype.marginBottom = 0;
mxPrintPreview.prototype.x0 = 0;
mxPrintPreview.prototype.y0 = 0;
mxPrintPreview.prototype.autoOrigin = true;
mxPrintPreview.prototype.printOverlays = false;
mxPrintPreview.prototype.printControls = false;
mxPrintPreview.prototype.printBackgroundImage = false;
mxPrintPreview.prototype.backgroundColor = "#ffffff";
mxPrintPreview.prototype.borderColor = null;
mxPrintPreview.prototype.title = null;
mxPrintPreview.prototype.pageSelector = null;
mxPrintPreview.prototype.wnd = null;
mxPrintPreview.prototype.targetWindow = null;
mxPrintPreview.prototype.pageCount = 0;
mxPrintPreview.prototype.clipping = true;
mxPrintPreview.prototype.getWindow = function() {
  return this.wnd;
};
mxPrintPreview.prototype.getDoctype = function() {
  let dt = "";
  if (document.documentMode == 5) {
    dt = '<meta http-equiv="X-UA-Compatible" content="IE=5">';
  } else if (document.documentMode == 8) {
    dt = '<meta http-equiv="X-UA-Compatible" content="IE=8">';
  } else if (document.documentMode > 8) {
    dt = '<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->';
  }
  return dt;
};
mxPrintPreview.prototype.appendGraph = function(graph, scale, x0, y0, forcePageBreaks, keepOpen) {
  this.graph = graph;
  this.scale = scale != null ? scale : 1 / graph.pageScale;
  this.x0 = x0;
  this.y0 = y0;
  this.open(null, null, forcePageBreaks, keepOpen);
};
mxPrintPreview.prototype.open = function(css, targetWindow, forcePageBreaks, keepOpen) {
  const previousInitializeOverlay = this.graph.cellRenderer.initializeOverlay;
  let div = null;
  try {
    if (this.printOverlays) {
      this.graph.cellRenderer.initializeOverlay = function(state2, overlay) {
        overlay.init(state2.view.getDrawPane());
      };
    }
    if (this.printControls) {
      this.graph.cellRenderer.initControl = function(state2, control, handleEvents, clickHandler) {
        control.dialect = state2.view.graph.dialect;
        control.init(state2.view.getDrawPane());
      };
    }
    this.wnd = targetWindow != null ? targetWindow : this.wnd;
    let isNewWindow = false;
    if (this.wnd == null) {
      isNewWindow = true;
      this.wnd = window.open();
    }
    const doc = this.wnd.document;
    if (isNewWindow) {
      const dt = this.getDoctype();
      if (dt != null && dt.length > 0) {
        doc.writeln(dt);
      }
      if (mxClient_default.IS_VML) {
        doc.writeln('<html xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office">');
      } else {
        if (document.compatMode === "CSS1Compat") {
          doc.writeln("<!DOCTYPE html>");
        }
        doc.writeln("<html>");
      }
      doc.writeln("<head>");
      this.writeHead(doc, css);
      doc.writeln("</head>");
      doc.writeln('<body class="mxPage">');
    }
    const bounds = this.graph.getGraphBounds().clone();
    const currentScale = this.graph.getView().getScale();
    const sc = currentScale / this.scale;
    const tr = this.graph.getView().getTranslate();
    if (!this.autoOrigin) {
      this.x0 -= tr.x * this.scale;
      this.y0 -= tr.y * this.scale;
      bounds.width += bounds.x;
      bounds.height += bounds.y;
      bounds.x = 0;
      bounds.y = 0;
      this.border = 0;
    }
    const availableWidth = this.pageFormat.width - this.border * 2;
    const availableHeight = this.pageFormat.height - this.border * 2;
    this.pageFormat.height += this.marginTop + this.marginBottom;
    bounds.width /= sc;
    bounds.height /= sc;
    const hpages = Math.max(1, Math.ceil((bounds.width + this.x0) / availableWidth));
    const vpages = Math.max(1, Math.ceil((bounds.height + this.y0) / availableHeight));
    this.pageCount = hpages * vpages;
    const writePageSelector = bind(this, function() {
      if (this.pageSelector && (vpages > 1 || hpages > 1)) {
        const table = this.createPageSelector(vpages, hpages);
        doc.body.appendChild(table);
        if (mxClient_default.IS_IE && doc.documentMode == null || doc.documentMode == 5 || doc.documentMode == 8 || doc.documentMode == 7) {
          table.style.position = "absolute";
          const update = function() {
            table.style.top = (doc.body.scrollTop || doc.documentElement.scrollTop) + 10 + "px";
          };
          mxEvent2.addListener(this.wnd, "scroll", function(evt) {
            update();
          });
          mxEvent2.addListener(this.wnd, "resize", function(evt) {
            update();
          });
        }
      }
    });
    const addPage = bind(this, function(div2, addBreak) {
      if (this.borderColor != null) {
        div2.style.borderColor = this.borderColor;
        div2.style.borderStyle = "solid";
        div2.style.borderWidth = "1px";
      }
      div2.style.background = this.backgroundColor;
      if (forcePageBreaks || addBreak) {
        div2.style.pageBreakAfter = "always";
      }
      if (isNewWindow && (mxClient_default.IS_IE || document.documentMode >= 11 || mxClient_default.IS_EDGE)) {
        doc.writeln(div2.outerHTML);
        div2.parentNode.removeChild(div2);
      } else if (mxClient_default.IS_IE || document.documentMode >= 11 || mxClient_default.IS_EDGE) {
        let clone3 = doc.createElement("div");
        clone3.innerHTML = div2.outerHTML;
        clone3 = clone3.getElementsByTagName("div")[0];
        doc.body.appendChild(clone3);
        div2.parentNode.removeChild(div2);
      } else {
        div2.parentNode.removeChild(div2);
        doc.body.appendChild(div2);
      }
      if (forcePageBreaks || addBreak) {
        this.addPageBreak(doc);
      }
    });
    const cov = this.getCoverPages(this.pageFormat.width, this.pageFormat.height);
    if (cov != null) {
      for (let i = 0; i < cov.length; i++) {
        addPage(cov[i], true);
      }
    }
    const apx = this.getAppendices(this.pageFormat.width, this.pageFormat.height);
    for (let i = 0; i < vpages; i++) {
      const dy = i * availableHeight / this.scale - this.y0 / this.scale + (bounds.y - tr.y * currentScale) / currentScale;
      for (let j = 0; j < hpages; j++) {
        if (this.wnd == null) {
          return null;
        }
        const dx = j * availableWidth / this.scale - this.x0 / this.scale + (bounds.x - tr.x * currentScale) / currentScale;
        const pageNum = i * hpages + j + 1;
        const clip = new mxRectangle(dx, dy, availableWidth, availableHeight);
        div = this.renderPage(this.pageFormat.width, this.pageFormat.height, 0, 0, bind(this, function(div2) {
          this.addGraphFragment(-dx, -dy, this.scale, pageNum, div2, clip);
          if (this.printBackgroundImage) {
            this.insertBackgroundImage(div2, -dx, -dy);
          }
        }), pageNum);
        div.setAttribute("id", "mxPage-" + pageNum);
        addPage(div, apx != null || i < vpages - 1 || j < hpages - 1);
      }
    }
    if (apx != null) {
      for (let i = 0; i < apx.length; i++) {
        addPage(apx[i], i < apx.length - 1);
      }
    }
    if (isNewWindow && !keepOpen) {
      this.closeDocument();
      writePageSelector();
    }
    this.wnd.focus();
  } catch (e) {
    if (div != null && div.parentNode != null) {
      div.parentNode.removeChild(div);
    }
  } finally {
    this.graph.cellRenderer.initializeOverlay = previousInitializeOverlay;
  }
  return this.wnd;
};
mxPrintPreview.prototype.addPageBreak = function(doc) {
  const hr = doc.createElement("hr");
  hr.className = "mxPageBreak";
  doc.body.appendChild(hr);
};
mxPrintPreview.prototype.closeDocument = function() {
  try {
    if (this.wnd != null && this.wnd.document != null) {
      const doc = this.wnd.document;
      this.writePostfix(doc);
      doc.writeln("</body>");
      doc.writeln("</html>");
      doc.close();
      mxEvent2.release(doc.body);
    }
  } catch (e) {
  }
};
mxPrintPreview.prototype.writeHead = function(doc, css) {
  if (this.title != null) {
    doc.writeln("<title>" + this.title + "</title>");
  }
  if (mxClient_default.IS_VML) {
    doc.writeln('<style type="text/css">v\\:*{behavior:url(#default#VML)}o\\:*{behavior:url(#default#VML)}</style>');
  }
  let basePath2 = mxClient_default.basePath;
  if (window.location.pathname.includes("/ThreagilePlus/")) {
    basePath2 = basePath2.replace("/src", "/ThreagilePlus/src");
  }
  mxClient_default.link("stylesheet", mxClient_default.basePath + "/css/common.css", doc);
  doc.writeln('<style type="text/css">');
  doc.writeln("@media print {");
  doc.writeln("  * { -webkit-print-color-adjust: exact; }");
  doc.writeln("  table.mxPageSelector { display: none; }");
  doc.writeln("  hr.mxPageBreak { display: none; }");
  doc.writeln("}");
  doc.writeln("@media screen {");
  doc.writeln("  table.mxPageSelector { position: fixed; right: 10px; top: 10px;font-family: Arial; font-size:10pt; border: solid 1px darkgray;background: white; border-collapse:collapse; }");
  doc.writeln("  table.mxPageSelector td { border: solid 1px gray; padding:4px; }");
  doc.writeln("  body.mxPage { background: gray; }");
  doc.writeln("}");
  if (css != null) {
    doc.writeln(css);
  }
  doc.writeln("</style>");
};
mxPrintPreview.prototype.writePostfix = function(doc) {
};
mxPrintPreview.prototype.createPageSelector = function(vpages, hpages) {
  const doc = this.wnd.document;
  const table = doc.createElement("table");
  table.className = "mxPageSelector";
  table.setAttribute("border", "0");
  const tbody = doc.createElement("tbody");
  for (let i = 0; i < vpages; i++) {
    const row = doc.createElement("tr");
    for (let j = 0; j < hpages; j++) {
      const pageNum = i * hpages + j + 1;
      const cell2 = doc.createElement("td");
      const a = doc.createElement("a");
      a.setAttribute("href", "#mxPage-" + pageNum);
      if (mxClient_default.IS_NS && !mxClient_default.IS_SF && !mxClient_default.IS_GC) {
        const js = "var page = document.getElementById('mxPage-" + pageNum + "');page.scrollIntoView(true);event.preventDefault();";
        a.setAttribute("onclick", js);
      }
      write(a, pageNum, doc);
      cell2.appendChild(a);
      row.appendChild(cell2);
    }
    tbody.appendChild(row);
  }
  table.appendChild(tbody);
  return table;
};
mxPrintPreview.prototype.renderPage = function(w2, h2, dx, dy, content, pageNumber) {
  const doc = this.wnd.document;
  let div = document.createElement("div");
  let arg = null;
  try {
    if (dx != 0 || dy != 0) {
      div.style.position = "relative";
      div.style.width = w2 + "px";
      div.style.height = h2 + "px";
      div.style.pageBreakInside = "avoid";
      const innerDiv = document.createElement("div");
      innerDiv.style.position = "relative";
      innerDiv.style.top = this.border + "px";
      innerDiv.style.left = this.border + "px";
      innerDiv.style.width = w2 - 2 * this.border + "px";
      innerDiv.style.height = h2 - 2 * this.border + "px";
      innerDiv.style.overflow = "hidden";
      const viewport = document.createElement("div");
      viewport.style.position = "relative";
      viewport.style.marginLeft = dx + "px";
      viewport.style.marginTop = dy + "px";
      if (doc.documentMode == 8) {
        innerDiv.style.position = "absolute";
        viewport.style.position = "absolute";
      }
      if (doc.documentMode == 10) {
        viewport.style.width = "100%";
        viewport.style.height = "100%";
      }
      innerDiv.appendChild(viewport);
      div.appendChild(innerDiv);
      document.body.appendChild(div);
      arg = viewport;
    } else {
      div.style.width = w2 + "px";
      div.style.height = h2 + "px";
      div.style.overflow = "hidden";
      div.style.pageBreakInside = "avoid";
      if (doc.documentMode == 8) {
        div.style.position = "relative";
      }
      const innerDiv = document.createElement("div");
      innerDiv.style.width = w2 - 2 * this.border + "px";
      innerDiv.style.height = h2 - 2 * this.border + "px";
      innerDiv.style.overflow = "hidden";
      if (mxClient_default.IS_IE && (doc.documentMode == null || doc.documentMode == 5 || doc.documentMode == 8 || doc.documentMode == 7)) {
        innerDiv.style.marginTop = this.border + "px";
        innerDiv.style.marginLeft = this.border + "px";
      } else {
        innerDiv.style.top = this.border + "px";
        innerDiv.style.left = this.border + "px";
      }
      if (this.graph.dialect == mxConstants2.DIALECT_VML) {
        innerDiv.style.position = "absolute";
      }
      div.appendChild(innerDiv);
      document.body.appendChild(div);
      arg = innerDiv;
    }
  } catch (e) {
    div.parentNode.removeChild(div);
    div = null;
    throw e;
  }
  content(arg);
  return div;
};
mxPrintPreview.prototype.getRoot = function() {
  let root = this.graph.view.currentRoot;
  if (root == null) {
    root = this.graph.getModel().getRoot();
  }
  return root;
};
mxPrintPreview.prototype.useCssTransforms = function() {
  return !mxClient_default.NO_FO && !mxClient_default.IS_SF;
};
mxPrintPreview.prototype.addGraphFragment = function(dx, dy, scale, pageNumber, div, clip) {
  const view = this.graph.getView();
  const previousContainer = this.graph.container;
  this.graph.container = div;
  let canvas = view.getCanvas();
  let backgroundPane = view.getBackgroundPane();
  let drawPane = view.getDrawPane();
  let overlayPane = view.getOverlayPane();
  const realScale = scale;
  if (this.graph.dialect == mxConstants2.DIALECT_SVG) {
    view.createSvg();
    if (this.useCssTransforms()) {
      const g = view.getDrawPane().parentNode;
      const prev = g.getAttribute("transform");
      g.setAttribute("transformOrigin", "0 0");
      g.setAttribute("transform", "scale(" + scale + "," + scale + ")translate(" + dx + "," + dy + ")");
      scale = 1;
      dx = 0;
      dy = 0;
    }
  } else if (this.graph.dialect == mxConstants2.DIALECT_VML) {
    view.createVml();
  } else {
    view.createHtml();
  }
  const eventsEnabled = view.isEventsEnabled();
  view.setEventsEnabled(false);
  const graphEnabled = this.graph.isEnabled();
  this.graph.setEnabled(false);
  const translate = view.getTranslate();
  view.translate = new mxPoint2(dx, dy);
  const redraw = this.graph.cellRenderer.redraw;
  const states = view.states;
  const s = view.scale;
  if (this.clipping) {
    const tempClip = new mxRectangle((clip.x + translate.x) * s, (clip.y + translate.y) * s, clip.width * s / realScale, clip.height * s / realScale);
    this.graph.cellRenderer.redraw = function(state2, force, rendering) {
      if (state2 != null) {
        const orig = states.get(state2.cell);
        if (orig != null) {
          const bbox = view.getBoundingBox(orig, false);
          if (bbox != null && bbox.width > 0 && bbox.height > 0 && !intersects(tempClip, bbox)) {
            return;
          }
        }
      }
      redraw.apply(this, arguments);
    };
  }
  let temp2 = null;
  try {
    const cells = [this.getRoot()];
    temp2 = new mxTemporaryCellStates(view, scale, cells, null, bind(this, function(state2) {
      return this.getLinkForCellState(state2);
    }));
  } finally {
    if (mxClient_default.IS_IE) {
      view.overlayPane.innerHTML = "";
      view.canvas.style.overflow = "hidden";
      view.canvas.style.position = "relative";
      view.canvas.style.top = this.marginTop + "px";
      view.canvas.style.width = clip.width + "px";
      view.canvas.style.height = clip.height + "px";
    } else {
      let tmp = div.firstChild;
      while (tmp != null) {
        let next = tmp.nextSibling;
        const name = tmp.nodeName.toLowerCase();
        if (name == "svg") {
          tmp.style.overflow = "hidden";
          tmp.style.position = "relative";
          tmp.style.top = this.marginTop + "px";
          tmp.setAttribute("width", clip.width);
          tmp.setAttribute("height", clip.height);
          tmp.style.width = "";
          tmp.style.height = "";
        } else if (tmp.style.cursor != "default" && name != "div") {
          tmp.parentNode.removeChild(tmp);
        }
        tmp = next;
      }
    }
    if (this.printBackgroundImage) {
      const svgs = div.getElementsByTagName("svg");
      if (svgs.length > 0) {
        svgs[0].style.position = "absolute";
      }
    }
    view.overlayPane.parentNode.removeChild(view.overlayPane);
    this.graph.setEnabled(graphEnabled);
    this.graph.container = previousContainer;
    this.graph.cellRenderer.redraw = redraw;
    view.canvas = canvas;
    view.backgroundPane = backgroundPane;
    view.drawPane = drawPane;
    view.overlayPane = overlayPane;
    view.translate = translate;
    temp2.destroy();
    view.setEventsEnabled(eventsEnabled);
  }
};
mxPrintPreview.prototype.getLinkForCellState = function(state2) {
  return this.graph.getLinkForCell(state2.cell);
};
mxPrintPreview.prototype.insertBackgroundImage = function(div, dx, dy) {
  const bg = this.graph.backgroundImage;
  if (bg != null) {
    const img = document.createElement("img");
    img.style.position = "absolute";
    img.style.marginLeft = Math.round(dx * this.scale) + "px";
    img.style.marginTop = Math.round(dy * this.scale) + "px";
    img.setAttribute("width", Math.round(this.scale * bg.width));
    img.setAttribute("height", Math.round(this.scale * bg.height));
    img.src = bg.src;
    div.insertBefore(img, div.firstChild);
  }
};
mxPrintPreview.prototype.getCoverPages = function() {
  return null;
};
mxPrintPreview.prototype.getAppendices = function() {
  return null;
};
mxPrintPreview.prototype.print = function(css) {
  const wnd = this.open(css);
  if (wnd != null) {
    wnd.print();
  }
};
mxPrintPreview.prototype.close = function() {
  if (this.wnd != null) {
    this.wnd.close();
    this.wnd = null;
  }
};

// js/graph/mxDivResizer.js
var mxDivResizer2 = function(div, container) {
  if (div.nodeName.toLowerCase() === "div") {
    if (container == null) {
      container = window;
    }
    this.div = div;
    const style = getCurrentStyle(div);
    if (style != null) {
      this.resizeWidth = style.width === "auto";
      this.resizeHeight = style.height === "auto";
    }
    mxEvent2.addListener(container, "resize", bind(this, function(evt) {
      if (!this.handlingResize) {
        this.handlingResize = true;
        this.resize();
        this.handlingResize = false;
      }
    }));
    this.resize();
  }
};
mxDivResizer2.prototype.resizeWidth = true;
mxDivResizer2.prototype.resizeHeight = true;
mxDivResizer2.prototype.handlingResize = false;
mxDivResizer2.prototype.resize = function() {
  const w2 = this.getDocumentWidth();
  const h2 = this.getDocumentHeight();
  const l = parseInt(this.div.style.left, 10);
  const r = parseInt(this.div.style.right, 10);
  const t = parseInt(this.div.style.top, 10);
  const b = parseInt(this.div.style.bottom, 10);
  if (this.resizeWidth && !isNaN(l) && !isNaN(r) && l >= 0 && r >= 0 && w2 - r - l > 0) {
    this.div.style.width = w2 - r - l + "px";
  }
  if (this.resizeHeight && !isNaN(t) && !isNaN(b) && t >= 0 && b >= 0 && h2 - t - b > 0) {
    this.div.style.height = h2 - t - b + "px";
  }
};
mxDivResizer2.prototype.getDocumentWidth = function() {
  return document.body.clientWidth;
};
mxDivResizer2.prototype.getDocumentHeight = function() {
  return document.body.clientHeight;
};

// js/Editor.js
var DeleteElementCommand = class {
  constructor(mxObjectId, cellid, threagile, asset, path, assetType, assetInformation, graph, batchId = null) {
    this.mxObjectId = mxObjectId;
    this.cellid = cellid;
    this.threagile = threagile;
    this.graph = graph;
    this.asset = asset ? JSON.parse(JSON.stringify(asset)) : null;
    this.path = path;
    this.assetType = assetType;
    this.references = [];
    this.assetId = null;
    this.batchId = batchId;
    this.assetInformation = assetInformation;
    if (this.assetType === "TechnicalAsset" && this.asset && this.asset.id) {
      this.assetId = this.asset.id;
    } else if (this.assetType === "TechnicalAsset") {
      console.warn("Cannot determine ID for Technical Asset being deleted. Reference restoration during undo might fail.", this.path, this.asset);
    }
    console.log(`Command created: Delete ${this.assetType} at path:`, this.path);
  }
  execute() {
    console.log(`Executing delete for ${this.assetType} at path:`, this.path);
    if (!this.threagile || typeof this.threagile.deleteIn !== "function") {
      console.error("Threagile object or deleteIn method is missing!");
      return;
    }
    if (!this.path || this.path.length === 0) {
      console.error("Invalid path provided for deletion.");
      return;
    }
    try {
      if (this.assetType === "TechnicalAsset" && this.assetId) {
        console.log(`Finding references for Technical Asset ID: ${this.assetId}`);
        this.references = findIdInTrustBoundaryAssets(this.threagile, this.assetId);
        console.log(`Found ${this.references.length} references to restore on undo:`, this.references);
      } else if (this.assetType === "TechnicalAsset" && !this.assetId) {
        console.warn("Skipping reference finding because asset ID was not available.");
      }
      if (this.asset) {
        this.threagile.deleteIn(this.path);
      }
      console.log(`Successfully deleted element at path:`, this.path);
    } catch (error2) {
      console.error(`Error during command execution (deleteIn) for path [${this.path.join(", ")}]:`, error2);
    }
  }
  undo() {
    console.log(`Undoing delete for ${this.assetType} at path:`, this.path);
    if (!this.threagile || typeof this.threagile.setIn !== "function") {
      console.error("Threagile object or setIn method is missing! Cannot undo.");
      return;
    }
    if (!this.path || this.path.length === 0) {
      console.error("Invalid path provided for undo.");
      return;
    }
    if (this.asset) {
      try {
        console.log("Restoring main asset object:", JSON.stringify(this.asset));
        const assetNode = this.threagile.createNode(this.asset);
        this.threagile.setIn(this.path, assetNode);
        console.log(`Restored main ${this.assetType} object at path:`, this.path);
        if (this.assetType === "TechnicalAsset") {
          if (!this.assetId) {
            console.warn("Cannot restore references: Original Technical Asset ID was not stored.");
          } else if (this.references && this.references.length > 0) {
            console.log(`Restoring ${this.references.length} references for ID: ${this.assetId}`);
            const assetIdToAdd = assetNode.toJSON().id;
            this.references.forEach((refPathString) => {
              let parsedRefPath;
              try {
                parsedRefPath = parsePathString(refPathString);
                if (parsedRefPath && parsedRefPath.length > 1) {
                  const pathToArray = parsedRefPath.slice(0, -1);
                  console.log(`  Attempting to add/ensure ID ${assetIdToAdd} in collection at path: ${JSON.stringify(pathToArray)} (derived from: ${refPathString})`);
                  try {
                    const arrayNode = this.threagile.getIn(pathToArray, true);
                    if (YAML.isSeq(arrayNode)) {
                      console.log(`    Collection exists. Checking if ID ${assetIdToAdd} is present.`);
                      const alreadyExists = arrayNode.items.some((item) => {
                        const itemValue = item && item.constructor?.name === "Scalar" ? item.value : item;
                        return itemValue === assetIdToAdd;
                      });
                      if (!alreadyExists) {
                        console.log(`    Adding ID ${assetIdToAdd}.`);
                        arrayNode.add(assetIdToAdd);
                        console.log(`    -> Successfully added ID.`);
                      } else {
                        console.log(`    ID ${assetIdToAdd} is already present. No action needed.`);
                        console.log(`    -> Reference effectively restored (already present).`);
                      }
                    } else {
                      console.warn(`    Path ${JSON.stringify(pathToArray)} exists but is not a sequence. Overwriting with new array containing ID ${assetIdToAdd}.`);
                      this.threagile.setIn(pathToArray, [assetIdToAdd]);
                      console.log(`    -> Successfully restored reference by creating/overwriting array.`);
                    }
                  } catch (getError) {
                    const pathNotFound = getError.message.includes("Cannot");
                    if (pathNotFound) {
                      console.log(`    Collection or parent path does not exist. Creating array at ${JSON.stringify(pathToArray)} with ID ${assetIdToAdd}.`);
                      this.threagile.setIn(pathToArray, [assetIdToAdd]);
                      console.log(`    -> Successfully restored reference by creating array.`);
                    } else {
                      console.error(`    Unexpected error getting node at ${JSON.stringify(pathToArray)}:`, getError);
                      throw getError;
                    }
                  }
                } else {
                  console.warn(`  Could not parse reference path string effectively: "${refPathString}"`);
                }
              } catch (outerError) {
                console.error(`  Error processing reference restoration for path "${refPathString}":`, outerError);
              }
            });
            console.log("Finished restoring references.");
          } else {
            console.log("No references needed restoration for this Technical Asset.");
          }
        }
        console.log(`Successfully undone deletion for ${this.assetType} at path:`, this.path);
      } catch (error2) {
        console.error(`Error during command undo (setIn) for path [${this.path.join(", ")}]:`, error2);
      }
    }
    let cell2 = this.graph.model.getCell(this.cellid);
    if (this.assetType === "TechnicalAsset") {
      cell2.technicalAsset = this.assetInformation;
    } else if (this.assetType === "CommunicationAsset") {
      cell2.communicationAssetKey = this.assetInformation;
      cell2.commnunicationAsset = this.threagile.getIn(this.path);
    } else if (this.assetType === "trust_boundaries") {
      cell2.trust_boundarieskey = this.assetInformation;
    }
  }
};
var UndoRedoManager = class {
  constructor() {
    this.undoStack = [];
    this.redoStack = [];
  }
  executeCommand(command) {
    command.execute();
    this.undoStack.push(command);
    this.redoStack = [];
    this.updateUIState();
  }
  undo() {
    if (this.undoStack.length === 0) {
      Logger.log("Undo stack empty.");
      return;
    }
    const topCommand = this.undoStack[this.undoStack.length - 1];
    const targetBatchId = topCommand.batchId;
    const commandsToUndo = [];
    if (targetBatchId && this.undoStack.length > 0) {
      while (this.undoStack.length > 0 && this.undoStack[this.undoStack.length - 1].batchId === targetBatchId) {
        commandsToUndo.push(this.undoStack.pop());
      }
    } else {
      Logger.log("Performing single undo (no batch ID or last in batch).");
      commandsToUndo.push(this.undoStack.pop());
    }
    commandsToUndo.forEach((cmd) => {
      try {
        cmd.undo();
      } catch (e) {
        Logger.error(`Error during undo execution (Batch: ${cmd.batchId}):`, e);
      }
    });
    this.redoStack.push(...commandsToUndo.reverse());
    Logger.log(`Undo complete. Redo stack size: ${this.redoStack.length}`);
  }
  redo() {
    if (this.redoStack.length === 0) {
      return;
    }
    const topCommand = this.redoStack[this.redoStack.length - 1];
    const targetBatchId = topCommand.batchId;
    const commandsToRedo = [];
    if (targetBatchId && this.redoStack.length > 0) {
      while (this.redoStack.length > 0 && this.redoStack[this.redoStack.length - 1].batchId === targetBatchId) {
        commandsToRedo.push(this.redoStack.pop());
      }
    } else {
      commandsToRedo.push(this.redoStack.pop());
    }
    commandsToRedo.reverse().forEach((cmd) => {
      try {
        cmd.redo();
      } catch (e) {
        Logger.error(`Error during redo execution (Batch: ${cmd.batchId}):`, e);
      }
    });
    this.undoStack.push(...commandsToRedo);
    Logger.log(`Redo complete. Undo stack size: ${this.undoStack.length}`);
  }
  canUndo() {
    return this.undoStack.length > 0;
  }
  canRedo() {
    return this.redoStack.length > 0;
  }
  updateUIState() {
    console.log(`Undo possible: ${this.canUndo()}, Redo possible: ${this.canRedo()}`);
  }
  clearHistory() {
    this.undoStack = [];
    this.redoStack = [];
    this.updateUIState();
  }
};
var Editor2 = function(chromeless, themes, model, graph, editable) {
  let undoManagerThreat = new UndoRedoManager();
  mxEventSource.call(this);
  this.chromeless = chromeless != null ? chromeless : this.chromeless;
  this.initStencilRegistry();
  this.graph = graph || this.createGraph(themes, model);
  this.editable = editable != null ? editable : !chromeless;
  this.undoManager = this.createUndoManager(undoManagerThreat);
  this.status = "";
  this.getOrCreateFilename = function() {
    return this.filename || mxResources2.get("drawing", [Editor2.pageCounter]) + ".xml";
  };
  this.graph.floweffect = false;
  this.graph.view.addListener(mxEvent2.SCALE_AND_TRANSLATE, (sender, evt) => {
    let scale = this.graph.view.scale;
    let translate = this.graph.view.translate;
    overlayLayer.setAttribute("transform", "scale(" + scale + ") translate(" + translate.x + " " + translate.y + ")");
  });
  this.graph.addListener(mxEvent2.CELLS_MOVED, (sender, evt) => {
    if (this.graph.floweffect) {
      var cells = this.graph.getVerticesAndEdges(false, true);
      cells.forEach((cell2) => {
        if (cell2.isEdge() && cell2.source != null && cell2.target != null) {
          setTimeout(() => {
            let state2 = this.graph.view.getState(cell2);
            if (state2) {
              let pathNodes = state2.shape.node.getElementsByTagName("path");
              if (pathNodes.length >= 2) {
                pathNodes[0].removeAttribute("visibility");
                pathNodes[0].setAttribute("stroke-width", "6");
                pathNodes[0].setAttribute("stroke", "lightGray");
                pathNodes[1].setAttribute("class", "pipeFlowAnimation");
              }
            }
          }, 0);
        }
      });
    }
  });
  this.graph.addListener(mxEvent2.GEOMETRY_CHANGE, (sender, evt) => {
    if (this.graph.floweffect) {
      var cells = this.graph.getVerticesAndEdges(false, true);
      console.log("H");
      cells.forEach((cell2) => {
        if (cell2.isEdge() && cell2.source != null && cell2.target != null) {
          setTimeout(() => {
            let state2 = this.graph.view.getState(cell2);
            if (state2) {
              let pathNodes = state2.shape.node.getElementsByTagName("path");
              if (pathNodes.length >= 2) {
                pathNodes[0].removeAttribute("visibility");
                pathNodes[0].setAttribute("stroke-width", "6");
                pathNodes[0].setAttribute("stroke", "lightGray");
                pathNodes[1].setAttribute("class", "pipeFlowAnimation");
              }
            }
          }, 0);
        }
      });
    }
  });
  this.graph.view.addListener(mxEvent2.SCALE, (sender, evt) => {
    if (this.graph.floweffect) {
      var cells = this.graph.getVerticesAndEdges(false, true);
      console.log("H");
      cells.forEach((cell2) => {
        if (cell2.isEdge() && cell2.source != null && cell2.target != null) {
          setTimeout(() => {
            let state2 = this.graph.view.getState(cell2);
            if (state2) {
              let pathNodes = state2.shape.node.getElementsByTagName("path");
              if (pathNodes.length >= 2) {
                pathNodes[0].removeAttribute("visibility");
                pathNodes[0].setAttribute("stroke-width", "6");
                pathNodes[0].setAttribute("stroke", "lightGray");
                pathNodes[1].setAttribute("class", "pipeFlowAnimation");
              }
            }
          }, 0);
        }
      });
    }
  });
  this.graph.addListener(mxEvent2.ADD_CELLS, (sender, evt) => {
    if (this.graph.floweffect) {
      let cells = evt.getProperty("cells");
      cells.forEach((cell2) => {
        if (cell2.isEdge() && cell2.source != null && cell2.target != null) {
          setTimeout(() => {
            let state2 = this.graph.view.getState(cell2);
            if (state2) {
              let pathNodes = state2.shape.node.getElementsByTagName("path");
              if (pathNodes.length >= 2) {
                pathNodes[0].removeAttribute("visibility");
                pathNodes[0].setAttribute("stroke-width", "6");
                pathNodes[0].setAttribute("stroke", "lightGray");
                pathNodes[1].setAttribute("class", "pipeFlowAnimation");
              }
            }
          }, 0);
        }
      });
    }
  });
  this.getFilename = function() {
    return this.filename;
  };
  this.setStatus = function(value) {
    this.status = value;
    this.fireEvent(new mxEventObject2("statusChanged"));
  };
  this.getStatus = function() {
    return this.status;
  };
  this.graphChangeListener = function(sender, eventObject) {
    var edit = eventObject != null ? eventObject.getProperty("edit") : null;
    if (edit == null || !edit.ignoreEdit) {
      this.setModified(true);
    }
  };
  this.graph.getModel().addListener(mxEvent2.CHANGE, bind(this, function() {
    this.graphChangeListener.apply(this, arguments);
  }));
  this.graph.resetViewOnRootChange = false;
  this.init();
  let self = this;
  this.graph.addListener(mxEvent2.REMOVE_CELLS, function(sender, evt) {
    let graph2 = self.graph;
    const currentBatchId = `batch-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    evt.properties.cells.forEach((cell2) => {
      let cellType;
      let asset;
      let path;
      let assetInformation;
      if (cell2.trust_boundarieskey) {
        cellType = "TrustBoundary";
        path = ["trust_boundaries"];
        assetInformation = cell2.trust_boundarieskey;
        path.push(cell2.trust_boundarieskey);
        asset = self.graph.getModel().threagile.getIn(path, true);
      } else if (cell2.technicalAsset && cell2.technicalAsset.key) {
        cellType = "TechnicalAsset";
        path = ["technical_assets"];
        path.push(cell2.technicalAsset.key);
        assetInformation = JSON.parse(JSON.stringify(cell2.technicalAsset));
        asset = self.graph.getModel().threagile.getIn(path, true);
      } else if (cell2.communicationAsset) {
        cellType = "CommunicationAsset";
        path = ["technical_assets", cell2.source.technicalAsset.key, "communication_links", cell2.communicationAssetKey];
        asset = self.graph.getModel().threagile.getIn(path, true);
        assetInformation = cell2.communicationAssetKey;
      } else {
        console.log("Not a regular threat asset");
      }
      if (cellType) {
        const command = new DeleteElementCommand(cell2.mxObjectId, cell2.id, self.graph.getModel().threagile, asset, path, cellType, assetInformation, self.graph, currentBatchId);
        undoManagerThreat.executeCommand(command);
      } else {
        console.warn(`No Threagile data found for deleted cell ${cell2.id}`);
      }
    });
  });
};
Editor2.pageCounter = 0;
(function() {
  try {
    var op = window;
    while (op.opener != null && typeof op.opener.Editor !== "undefined" && !isNaN(op.opener.Editor.pageCounter) && op.opener != op) {
      op = op.opener;
    }
    if (op != null) {
      op.Editor.pageCounter++;
      Editor2.pageCounter = op.Editor.pageCounter;
    }
  } catch (e) {
  }
})();
Editor2.useLocalStorage = typeof Storage != "undefined" && mxClient_default.IS_IOS;
Editor2.moveImage = mxClient_default.IS_SVG ? "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI4cHgiIGhlaWdodD0iMjhweCI+PGc+PC9nPjxnPjxnPjxnPjxwYXRoIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIuNCwyLjQpc2NhbGUoMC44KXJvdGF0ZSg0NSwxMiwxMikiIHN0cm9rZT0iIzI5YjZmMiIgZmlsbD0iIzI5YjZmMiIgZD0iTTE1LDNsMi4zLDIuM2wtMi44OSwyLjg3bDEuNDIsMS40MkwxOC43LDYuN0wyMSw5VjNIMTV6IE0zLDlsMi4zLTIuM2wyLjg3LDIuODlsMS40Mi0xLjQyTDYuNyw1LjNMOSwzSDNWOXogTTksMjEgbC0yLjMtMi4zbDIuODktMi44N2wtMS40Mi0xLjQyTDUuMywxNy4zTDMsMTV2Nkg5eiBNMjEsMTVsLTIuMywyLjNsLTIuODctMi44OWwtMS40MiwxLjQybDIuODksMi44N0wxNSwyMWg2VjE1eiIvPjwvZz48L2c+PC9nPjwvc3ZnPgo=" : IMAGE_PATH + "/move.png";
Editor2.rowMoveImage = mxClient_default.IS_SVG ? "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAEBAMAAACw6DhOAAAAGFBMVEUzMzP///9tbW1QUFCKiopBQUF8fHxfX1/IXlmXAAAAFElEQVQImWNgNVdzYBAUFBRggLMAEzYBy29kEPgAAAAASUVORK5CYII=" : IMAGE_PATH + "/thumb_horz.png";
Editor2.helpImage = mxClient_default.IS_SVG ? "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBmaWxsPSJub25lIiBkPSJNMCAwaDI0djI0SDB6Ii8+PHBhdGggZD0iTTExIDE4aDJ2LTJoLTJ2MnptMS0xNkM2LjQ4IDIgMiA2LjQ4IDIgMTJzNC40OCAxMCAxMCAxMCAxMC00LjQ4IDEwLTEwUzE3LjUyIDIgMTIgMnptMCAxOGMtNC40MSAwLTgtMy41OS04LThzMy41OS04IDgtOCA4IDMuNTkgOCA4LTMuNTkgOC04IDh6bTAtMTRjLTIuMjEgMC00IDEuNzktNCA0aDJjMC0xLjEuOS0yIDItMnMyIC45IDIgMmMwIDItMyAxLjc1LTMgNWgyYzAtMi4yNSAzLTIuNSAzLTUgMC0yLjIxLTEuNzktNC00LTR6Ii8+PC9zdmc+" : IMAGE_PATH + "/help.png";
Editor2.checkmarkImage = mxClient_default.IS_SVG ? "data:image/gif;base64,R0lGODlhFQAVAMQfAGxsbHx8fIqKioaGhvb29nJycvr6+sDAwJqamltbW5OTk+np6YGBgeTk5Ly8vJiYmP39/fLy8qWlpa6ursjIyOLi4vj4+N/f3+3t7fT09LCwsHZ2dubm5r6+vmZmZv///yH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS4wLWMwNjAgNjEuMTM0Nzc3LCAyMDEwLzAyLzEyLTE3OjMyOjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IFdpbmRvd3MiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OEY4NTZERTQ5QUFBMTFFMUE5MTVDOTM5MUZGMTE3M0QiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OEY4NTZERTU5QUFBMTFFMUE5MTVDOTM5MUZGMTE3M0QiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Rjg1NkRFMjlBQUExMUUxQTkxNUM5MzkxRkYxMTczRCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Rjg1NkRFMzlBQUExMUUxQTkxNUM5MzkxRkYxMTczRCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PgH//v38+/r5+Pf29fTz8vHw7+7t7Ovq6ejn5uXk4+Lh4N/e3dzb2tnY19bV1NPS0dDPzs3My8rJyMfGxcTDwsHAv769vLu6ubi3trW0s7KxsK+urayrqqmop6alpKOioaCfnp2cm5qZmJeWlZSTkpGQj46NjIuKiYiHhoWEg4KBgH9+fXx7enl4d3Z1dHNycXBvbm1sa2ppaGdmZWRjYmFgX15dXFtaWVhXVlVUU1JRUE9OTUxLSklIR0ZFRENCQUA/Pj08Ozo5ODc2NTQzMjEwLy4tLCsqKSgnJiUkIyIhIB8eHRwbGhkYFxYVFBMSERAPDg0MCwoJCAcGBQQDAgEAACH5BAEAAB8ALAAAAAAVABUAAAVI4CeOZGmeaKqubKtylktSgCOLRyLd3+QJEJnh4VHcMoOfYQXQLBcBD4PA6ngGlIInEHEhPOANRkaIFhq8SuHCE1Hb8Lh8LgsBADs=" : IMAGE_PATH + "/checkmark.gif";
Editor2.maximizeImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVBAMAAABbObilAAAAElBMVEUAAAAAAAAAAAAAAAAAAAAAAADgKxmiAAAABXRSTlMA758vX1Pw3BoAAABJSURBVAjXY8AJQkODGBhUQ0MhbAUGBiYY24CBgRnGFmZgMISwgwwDGRhEhVVBbAVmEQYGRwMmBjIAQi/CTIRd6G5AuA3dzYQBAHj0EFdHkvV4AAAAAElFTkSuQmCC";
Editor2.zoomOutImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVBAMAAABbObilAAAAElBMVEUAAAAAAAAsLCxxcXEhISFgYGChjTUxAAAAAXRSTlMAQObYZgAAAEdJREFUCNdjIAMwCQrB2YKCggJQJqMwA7MglK1owMBgqABVApITgLJZXFxgbIQ4Qj3CHIT5ggoIe5kgNkM1KSDYKBKqxPkDAPo5BAZBE54hAAAAAElFTkSuQmCC";
Editor2.zoomInImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVBAMAAABbObilAAAAElBMVEUAAAAAAAAsLCwhISFxcXFgYGBavKaoAAAAAXRSTlMAQObYZgAAAElJREFUCNdjIAMwCQrB2YKCggJQJqMIA4sglK3owMzgqABVwsDMwCgAZTMbG8PYCHGEeoQ5CPMFFRD2MkFshmpSQLBRJFSJ8wcAEqcEM2uhl2MAAAAASUVORK5CYII=";
Editor2.zoomFitImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVBAMAAABbObilAAAAD1BMVEUAAAAAAAAwMDBwcHBgYGC1xl09AAAAAXRSTlMAQObYZgAAAEFJREFUCNdjIAMwCQrB2YKCggJQJqMwA7MglK1owMBgqABVApITwMdGqEeYgzBfUAFhLxPEZqgmBQQbRUKFOH8AAK5OA3lA+FFOAAAAAElFTkSuQmCC";
Editor2.layersImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVCAMAAACeyVWkAAAAaVBMVEUAAAAgICAICAgdHR0PDw8WFhYICAgLCwsXFxcvLy8ODg4uLi4iIiIqKiokJCQYGBgKCgonJycFBQUCAgIqKiocHBwcHBwODg4eHh4cHBwnJycJCQkUFBQqKiojIyMuLi4ZGRkgICAEBATOWYXAAAAAGnRSTlMAD7+fnz8/H7/ff18/77+vr5+fn39/b28fH2xSoKsAAACQSURBVBjTrYxJEsMgDARZZMAY73sgCcn/HxnhKtnk7j6oRq0psfuoyndZ/SuODkHPLzfVT6KeyPePnJ7KrnkRjWMXTn4SMnN8mXe2SSM3ts8L/ZUxxrbAULSYJJULE0Iw9pjpenoICcgcX61mGgTgtCv9Be99pzCoDhNQWQnchD1mup5++CYGcoQexajZbfwAj/0MD8ZOaUgAAAAASUVORK5CYII=";
Editor2.previousImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABmJLR0QA/wD/AP+gvaeTAAAAh0lEQVQ4je3UsQnCUBCA4U8hpa1NsoEjpHQJS0dxADdwEMuMIJkgA1hYChbGQgMi+JC8q4L/AB/vDu7x74cWWEZhJU44RmA1zujR5GIbXF9YNrjD/Q0bDRY4fEBZ4P4LlgTnCbAf84pUM8/9hY08tMUtEoQ1LpEgrNBFglChFXR6Q6GfwwR6AGKJMF74Vtt3AAAAAElFTkSuQmCC";
Editor2.nextImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABmJLR0QA/wD/AP+gvaeTAAAAi0lEQVQ4jeXUIQ7CUAwA0MeGxWI2yylwnALJUdBcgYvM7QYLmjOQIAkIPmJZghiIvypoUtX0tfnJL38X5ZfaEgUeUcManFBHgS0SLlhHggk3bCPBhCf2keCQR8wjwYTDp6YiZxJmOU1jGw7vGALescuBxsArNlOwd/CM1VSM/ut1qCIw+uOwiMJ+OF4CQzBCXm3hyAAAAABJRU5ErkJggg==";
Editor2.editImage = mxClient_default.IS_SVG ? "data:image/gif;base64,R0lGODlhCwALAIABAFdXV////yH5BAEAAAEALAAAAAALAAsAAAIZjB8AiKuc4jvLOGqzrjX6zmkWyChXaUJBAQA7" : IMAGE_PATH + "/edit.gif";
Editor2.zoomOutLargeImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAilBMVEUAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////2N2iNAAAALXRSTlMA+vTcKMM96GRBHwXxi0YaX1HLrKWhiHpWEOnOr52Vb2xKSDcT19PKv5l/Ngdk8+viAAABJklEQVQ4y4WT2XaDMAxEvWD2nSSUNEnTJN3r//+9Sj7ILAY6L0ijC4ONYVZRpo6cByrz2YKSUGorGTpz71lPVHvT+avoB5wIkU/mxk8veceSuNoLg44IzziXjvpih72wKQnm8yc2UoiP/LAd8jQfe2Xf4Pq+2EyYIvv9wbzHHCgwxDdlBtWZOdqDfTCVgqpygQpsZaojVAVc9UjQxnAJDIBhiQv84tq3gMQCAVTxVoSibXJf8tMuc7e1TB/DCmejBNg/w1Y3c+AM5vv4w7xM59/oXamrHaLVqPQ+OTCnmMZxgz0SdL5zji0/ld6j88qGa5KIiBB6WeJGKfUKwSMKLuXgvl1TW0tm5R9UQL/efSDYsnzxD8CinhBsTTdugJatKpJwf8v+ADb8QmvW7AeAAAAAAElFTkSuQmCC";
Editor2.zoomInLargeImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAilBMVEUAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////2N2iNAAAALXRSTlMA+vTcKMM96GRBHwXxi0YaX1HLrKWhiHpWEOnOr52Vb2xKSDcT19PKv5l/Ngdk8+viAAABKElEQVQ4y4WT6WKCMBCENwkBwn2oFKvWqr3L+79es4EkQIDOH2d3Pxk2ABiJlB8JCXjqw4LikHVGLHTm3nM3UeVN5690GBBN0GwyV/3kkrUQR+WeKnREeKpzaXWd77CmJiXGfPIEI4V4yQ9TIW/ntlcMBe731Vts9w5TWG8F5j3mQI4hvrKpdGeYA7CX9qAcl650gVJartxRuhyHVghF8idQAIbFLvCLu28BsQEC6aKtCK6Pyb3JT7PmbmtNH8Ny56CotD/2qOs5cJbuffxgXmCib+xddVU5RNOhkvvkhTlFehzVWCOh3++MYElOhfdovaImnRYVmqDdsuhNp1QrBBE6uGC2+3ZNjGdg5B94oD+9uyVgWT79BwAxEBTWdOu3bWBVgsn/N/AHUD9IC01Oe40AAAAASUVORK5CYII=";
Editor2.actualSizeLargeImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAilBMVEUAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////2N2iNAAAALXRSTlMA+vTcKMM96GRBHwXxi0YaX1HLrKWhiHpWEOnOr52Vb2xKSDcT19PKv5l/Ngdk8+viAAABIUlEQVQ4y4WT2XqDIBCFBxDc9yTWNEnTJN3r+79eGT4BEbXnaubMr8dBBaM450dCQp4LWFAascGIRd48eB4cNYE7f6XjgGiCFs5c+dml6CFN6j1V6IQIlHPpdV/usKcmJcV88gQTRXjLD9Mhb+fWq8YG9/uCmTCFjeeDeY85UGKIUGUuqzN42kv7oCouq9oHamlzVR1lVfpAIu1QVRiW+sAv7r4FpAYIZZVsRXB9TP5Dfpo1d1trCgzz1iiptH/sUbdz4CzN9+mLeXHn3+hdddd4RDegsrvzwZwSs2GLPRJidAqCLTlVwaMPqpYMWjTWBB2WRW86pVkhSKyDK2bdt2tmagZG4sBD/evdLQHLEvQfAOKRoLCmG1FAB6uKmby+gz+REDn7O5+EwQAAAABJRU5ErkJggg==";
Editor2.printLargeImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAXVBMVEUAAAD///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////9RKvvlAAAAHnRSTlMAydnl77qbMLT093H7K4Nd4Ktn082+lYt5bkklEgP44nQSAAAApUlEQVQ4y73P2Q6DIBRF0cOgbRHHzhP//5m9mBAQKjG1cT0Yc7ITAMu1LNQgUZiQ2DYoNQ0sCQb6qgHAfRx48opq3J9AZ6xuF7uOew8Ik1OsCZRS2UAC9V+D9a+QZYxNA45YFQftPtSkATOhw7dAc0vPBwKWiIOjP0JZ0yMuQJ27g36DipOUsqRAM0dR8KD1/ILHaHSE/w8DIx09E3g/BTce6rHUB5sAPKvfF+JdAAAAAElFTkSuQmCC";
Editor2.layersLargeImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAmVBMVEUAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////+/v7///+bnZkkAAAAMnRSTlMABPr8ByiD88KsTi/rvJb272mjeUA1CuPe1M/KjVxYHxMP6KZ0S9nYzGRGGRaznpGIbzaGUf0AAAHESURBVDjLbZLZYoIwEEVDgLCjbKIgAlqXqt3m/z+uNwu1rcyDhjl3ktnYL7OY254C0VX3yWFZfzDrOClbbgKxi0YDHjwl4jbnRkXxJS/C1YP3DbBhD1n7Ex4uaAqdVDb3yJ/4J/3nJD2to/ngQz/DfUvzMp4JJ5sSCaF5oXmemgQDfDxzbi+Kq4sU+vNcuAmx94JtyOP2DD4Epz2asWSCz4Z/4fECxyNj9zC9xNLHcdPEO+awDKeSaUu0W4twZQiO2hYVisTR3RCtK/c1X6t4xMEpiGqXqVntEBLolkZZsKY4QtwH6jzq67dEHlJysB1aNOD3XT7n1UkasQN59L4yC2RELMDSeCRtz3yV22Ub3ozIUTknYx8JWqDdQxbUes98cR2kZtUSveF/bAhcedwEWmlxIkpZUy4XOCb6VBjjxHvbwo/1lBAHHi2JCr0NI570QhyHq/DhJoE2lLgyA4RVe6KmZ47O/3b86MCP0HWa73A8/C3SUc5Qc1ajt6fgpXJ+RGpMvDSchepZDOOQRcZVIKcK90x2D7etqtI+56+u6n3sPriO6nfphitR4+O2m3EbM7lh3me1FM1o+LMI887rN+s3/wZdTFlpNVJiOAAAAABJRU5ErkJggg==";
Editor2.closeLargeImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAUVBMVEUAAAD///////////////////////////////////////////////////////////////////////////////////////////////////////8IN+deAAAAGnRSTlMAuvAIg/dDM/QlOeuFhj0S5s4vKgzjxJRQNiLSey0AAADNSURBVDjLfZLbEoMgDEQjRRRs1XqX///QNmOHJSnjPkHOGR7IEmeoGtJZstnwjqbRfIsmgEdtPCqe9Ynz7ZSc07rE2QiSc+qv8TvjRXA2PDUm3dpe82iJhOEUfxJJo3aCv+jKmRmH4lcCjCjeh9GWOdL/GZZkXH3PYYDrHBnfc4D/RVZf5sjoC1was+Y6HQxwaUxFvq/a0Pv343VCTxfBSRiB+ab3M3eiQZXmMNBJ3Y8pGRZtYQ7DgHMXJEdPLTaN/qBjzJOBc3nmNcbsA16bMR0oLqf+AAAAAElFTkSuQmCC";
Editor2.editLargeImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAgVBMVEUAAAD///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////9d3yJTAAAAKnRSTlMA+hzi3nRQWyXzkm0h2j3u54gzEgSXjlYoTBgJxL2loGpAOS3Jt7Wxm35Ga7gRAAAA6UlEQVQ4y63Q2XaCMBSF4Q0JBasoQ5DJqbXjfv8HbCK2BZNwo/8FXHx7rcMC7lQu0iX8qU/qtvAWCpoqH8dYzS0SwaV5eK/UAf8X9pd2CWKzuF5Jrftp1owXwnIGLUaL3PYndOHf4kNNXWrXK/m7CHunk7K8LE6YtBpcknwG9GKxnroY+ylBXcx4xKyx/u/EuXi509cP9V7OO1oyHnzrdFTcqLG/4ibBA5pIMr/4xvKzuQDkVy9wW8SgBFD6HDvuzMvrZcC9QlkfMzI7w64m+b4PqBMNHB05lH21PVxJo2/fBXxV4hB38PcD+5AkI4FuETsAAAAASUVORK5CYII=";
Editor2.previousLargeImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAPFBMVEUAAAD////////////////////////////////////////////////////////////////////////////YSWgTAAAAE3RSTlMA7fci493c0MW8uJ6CZks4MxQHEZL6ewAAAFZJREFUOMvdkskRgDAMA4lDwg2B7b9XOlge/KKvdsa25KFb5XlRvxXC/DNBEv8IFNjBgGdDgXtFgTyhwDXiQAUHCvwa4Uv6mR6UR+1led2mVonvl+tML45qCQNQLIx7AAAAAElFTkSuQmCC";
Editor2.nextLargeImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAPFBMVEUAAAD////////////////////////////////////////////////////////////////////////////YSWgTAAAAE3RSTlMA7fci493c0MW8uJ6CZks4MxQHEZL6ewAAAFRJREFUOMvd0skRgCAQBVEFwQ0V7fxzNQP6wI05v6pZ/kyj1b7FNgik2gQzzLcAwiUAigHOTwDHK4A1CmB5BJANJG1hQ9qafYcqFlZP3IFc9eVGrR+iIgkDQRUXIAAAAABJRU5ErkJggg==";
Editor2.refreshLargeImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAolBMVEUAAAD///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8ELnaCAAAANXRSTlMABfyE2QKU+dfNyyDyoVYKwnTv7N+6rntsYlFNQjEqEw316uSzf2c1JB3GvqebiVw6GAjQB4DQr10AAAE7SURBVDjLvZLXcoMwEABPIgRCx3TT3A3udqL//7UgAdGRcR4yk8k+idsdmgS/QyWEqD/axS2JDV33zlnzLHIzQ2MDq9OeJ3m8l76KKENYlxrmM/b65Ys1+8YxnTEZFIEY0vVhszFWfUGZDJpQTDznTgAe5k4XhQxILB7ruzBQn+kkyDXuHfRtjoYDEvH7J9Lz98dBZXXL94X0Ofco2PFlChKbjVzEdakoSlKjoNoqPYkJ/wUZAYwc+PpLj1Ei7+jdoBWlwQZoJv2H1w3CWgRvo7dd9DP5btgwCWz0M02+oVoxCcIWeY9PNmR6B++m9prMxYEISpCBYBlfy9bc745is7UUULAem1Ww7FfalsiA2uaJsgmWP3pQI9q9/yMLkaaHAp2fxhHff/cNq7dBdHXhGW7l+Mo2zU0Cf8knJ2xA0oJ8enwAAAAASUVORK5CYII=";
Editor2.backLargeImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAclBMVEUAAAD////////////////+/v7////////////////////////////////////////////+/v7///////////////////////////////////////////////////////////////////////////////8vKLfTAAAAJXRSTlMACh7h9gby3NLIwzwZ55uVJgH57b+8tbCljYV1RRMQ46FrTzQw+vtxOQAAAJ5JREFUOMuF00cWgzAQA1DRDQFCbwFSdf8rZpdVrNH2z3tuMv7mldZQ2WN2yi8x+TT8JvyTkqvwpiKvwsOIrA1fWr+XGTklfj8dOQR+D3KyUF6QufBkJN0hfCazEv6sZBRCJDUcPasGKpu1RLtYE8lkHAPBQLoTsK/SfAyRw5FjAuhCzC2MSj0gJ+66lHatgXdKboD9tfREB5m9/+3iC9jHDYvsGNcUAAAAAElFTkSuQmCC";
Editor2.fullscreenLargeImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAllBMVEUAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////AJcWoAAAAMXRSTlMA+wIFxPWPCIb446tnUxmsoIykgxTe29jQnpKBe2MNsZhVTR/KyLuWbFhEPjUq7L9z+bQj+gAAAWxJREFUOMttk4l2gkAMRTODCO4FtQgIbnWpS9v8/881iZFh8R51NO8GJ+gAjMN8zuTRFSw04cIOHQcqFHH6oaQFGxf0jeBjEgB8Y52TpW9Ag4zB5QICWOtHrgwGuFZBcw+gPP0MFS7+iiD5inOmDIQS9sZgTwUzwEzyxhxHVEEU7NdDUXsqUPtqjIgR2IZSCT4upzSeIeOdcMHnfDsx3giPoezfU6MrQGB5//SckLEG2xYscK4GfnUFqaix39zrwooaOD/cXoYuvHKQIc7pzd3HVPusp6t2FAW/RmjMonbl8vwHDeZo/GkleJC7e+p5XA/rAq1X/V10wKag04rBpa2/d0LL4OYYceOEtsG5jyMntI1wS+N1BGcQBl/CoLoPOl9ABrW/BP53e1bwSJHHlkIVchJwmHwyyfJ4kIvEnKtwkxNSEct83KSChT7WiWgDZ3ccZ0BM4tloJow2YUAtifNT3njnyD+y/pMsnP4DN3Y4yl1Gyk0AAAAASUVORK5CYII=";
Editor2.roughFillStyles = [
  { val: "auto", dispName: "Auto" },
  { val: "hachure", dispName: "Hachure" },
  { val: "solid", dispName: "Solid" },
  { val: "zigzag", dispName: "ZigZag" },
  { val: "cross-hatch", dispName: "Cross Hatch" },
  { val: "dots", dispName: "Dots" },
  { val: "dashed", dispName: "Dashed" },
  { val: "zigzag-line", dispName: "ZigZag Line" }
];
Editor2.themes = null;
Editor2.ctrlKey = mxClient_default.IS_MAC ? "Cmd" : "Ctrl";
Editor2.hintOffset = 20;
Editor2.popupsAllowed = true;
extend(Editor2, mxEventSource);
Editor2.prototype.originalNoForeignObject = mxClient_default.NO_FO;
Editor2.prototype.transparentImage = mxClient_default.IS_SVG ? "data:image/gif;base64,R0lGODlhMAAwAIAAAP///wAAACH5BAEAAAAALAAAAAAwADAAAAIxhI+py+0Po5y02ouz3rz7D4biSJbmiabqyrbuC8fyTNf2jef6zvf+DwwKh8Si8egpAAA7" : IMAGE_PATH + "/transparent.gif";
Editor2.prototype.extendCanvas = true;
Editor2.prototype.chromeless = false;
Editor2.prototype.cancelFirst = true;
Editor2.prototype.enabled = true;
Editor2.prototype.filename = null;
Editor2.prototype.modified = false;
Editor2.prototype.autosave = true;
Editor2.prototype.initialTopSpacing = 0;
Editor2.prototype.appName = document.title;
Editor2.prototype.editBlankUrl = window.location.protocol + "//" + window.location.host + "/";
Editor2.prototype.defaultGraphOverflow = "hidden";
Editor2.prototype.init = function() {
};
Editor2.prototype.isChromelessView = function() {
  return this.chromeless;
};
Editor2.prototype.setAutosave = function(value) {
  this.autosave = value;
  this.fireEvent(new mxEventObject2("autosaveChanged"));
};
Editor2.prototype.getEditBlankUrl = function(params) {
  return this.editBlankUrl + params;
};
Editor2.prototype.editAsNew = function(xml2, title) {
  var p = title != null ? "?title=" + encodeURIComponent(title) : "";
  if (urlParams["ui"] != null) {
    p += (p.length > 0 ? "&" : "?") + "ui=" + urlParams["ui"];
  }
  if (typeof window.postMessage !== "undefined" && (document.documentMode == null || document.documentMode >= 10)) {
    var wnd = null;
    var l = bind(this, function(evt) {
      if (evt.data == "ready" && evt.source == wnd) {
        mxEvent2.removeListener(window, "message", l);
        wnd.postMessage(xml2, "*");
      }
    });
    mxEvent2.addListener(window, "message", l);
    wnd = this.graph.openLink(this.getEditBlankUrl(p + (p.length > 0 ? "&" : "?") + "client=1"), null, true);
  } else {
    this.graph.openLink(this.getEditBlankUrl(p) + "#R" + encodeURIComponent(xml2));
  }
};
Editor2.prototype.createGraph = function(themes, model) {
  var graph = new Graph2(null, model, null, null, themes);
  graph.transparentBackground = false;
  if (!this.chromeless) {
    graph.isBlankLink = function(href) {
      return !this.isExternalProtocol(href);
    };
  }
  return graph;
};
Editor2.prototype.resetGraph = function() {
  this.graph.gridEnabled = !this.isChromelessView() || urlParams["grid"] == "1";
  this.graph.graphHandler.guidesEnabled = true;
  this.graph.setTooltips(true);
  this.graph.setConnectable(true);
  this.graph.foldingEnabled = true;
  this.graph.scrollbars = this.graph.defaultScrollbars;
  this.graph.pageVisible = this.graph.defaultPageVisible;
  this.graph.pageBreaksVisible = this.graph.pageVisible;
  this.graph.preferPageSize = this.graph.pageBreaksVisible;
  this.graph.background = null;
  this.graph.pageScale = Graph2.prototype.pageScale;
  this.graph.pageFormat = Graph2.prototype.pageFormat;
  this.graph.currentScale = 1;
  this.graph.currentTranslate.x = 0;
  this.graph.currentTranslate.y = 0;
  this.updateGraphComponents();
  this.graph.view.setScale(1);
};
Editor2.prototype.readGraphState = function(node) {
  this.graph.gridEnabled = node.getAttribute("grid") != "0" && (!this.isChromelessView() || urlParams["grid"] == "1");
  this.graph.gridSize = parseFloat(node.getAttribute("gridSize")) || Graph2.prototype.gridSize;
  this.graph.graphHandler.guidesEnabled = node.getAttribute("guides") != "0";
  this.graph.setTooltips(node.getAttribute("tooltips") != "0");
  this.graph.setConnectable(node.getAttribute("connect") != "0");
  this.graph.connectionArrowsEnabled = node.getAttribute("arrows") != "0";
  this.graph.foldingEnabled = node.getAttribute("fold") != "0";
  if (this.isChromelessView() && this.graph.foldingEnabled) {
    this.graph.foldingEnabled = urlParams["nav"] == "1";
    this.graph.cellRenderer.forceControlClickHandler = this.graph.foldingEnabled;
  }
  var ps = parseFloat(node.getAttribute("pageScale"));
  if (!isNaN(ps) && ps > 0) {
    this.graph.pageScale = ps;
  } else {
    this.graph.pageScale = Graph2.prototype.pageScale;
  }
  if (!this.graph.isLightboxView() && !this.graph.isViewer()) {
    var pv = node.getAttribute("page");
    if (pv != null) {
      this.graph.pageVisible = pv != "0";
    } else {
      this.graph.pageVisible = this.graph.defaultPageVisible;
    }
  } else {
    this.graph.pageVisible = false;
  }
  this.graph.pageBreaksVisible = this.graph.pageVisible;
  this.graph.preferPageSize = this.graph.pageBreaksVisible;
  var pw = parseFloat(node.getAttribute("pageWidth"));
  var ph = parseFloat(node.getAttribute("pageHeight"));
  if (!isNaN(pw) && !isNaN(ph)) {
    this.graph.pageFormat = new mxRectangle(0, 0, pw, ph);
  }
  var bg = node.getAttribute("background");
  if (bg != null && bg.length > 0) {
    this.graph.background = bg;
  } else {
    this.graph.background = null;
  }
};
Editor2.prototype.setGraphXml = function(node) {
  if (node != null) {
    var dec = new mxCodec(node.ownerDocument);
    if (node.nodeName == "mxGraphModel") {
      this.graph.model.beginUpdate();
      try {
        this.graph.model.clear();
        this.graph.view.scale = 1;
        this.readGraphState(node);
        this.updateGraphComponents();
        dec.decode(node, this.graph.getModel());
      } finally {
        this.graph.model.endUpdate();
      }
      this.fireEvent(new mxEventObject2("resetGraphView"));
    } else if (node.nodeName == "root") {
      this.resetGraph();
      var wrapper = dec.document.createElement("mxGraphModel");
      wrapper.appendChild(node);
      dec.decode(wrapper, this.graph.getModel());
      this.updateGraphComponents();
      this.fireEvent(new mxEventObject2("resetGraphView"));
    } else {
      throw {
        message: mxResources2.get("cannotOpenFile"),
        node,
        toString: function() {
          return this.message;
        }
      };
    }
  } else {
    this.resetGraph();
    this.graph.model.clear();
    this.fireEvent(new mxEventObject2("resetGraphView"));
  }
};
Editor2.prototype.getGraphXml = function(ignoreSelection) {
  ignoreSelection = ignoreSelection != null ? ignoreSelection : true;
  var node = null;
  if (ignoreSelection) {
    var enc = new mxCodec(createXmlDocument());
    node = enc.encode(this.graph.getModel());
  } else {
    node = this.graph.encodeCells(sortCells(this.graph.model.getTopmostCells(this.graph.getSelectionCells())));
  }
  if (this.graph.view.translate.x != 0 || this.graph.view.translate.y != 0) {
    node.setAttribute("dx", Math.round(this.graph.view.translate.x * 100) / 100);
    node.setAttribute("dy", Math.round(this.graph.view.translate.y * 100) / 100);
  }
  node.setAttribute("grid", this.graph.isGridEnabled() ? "1" : "0");
  node.setAttribute("gridSize", this.graph.gridSize);
  node.setAttribute("guides", this.graph.graphHandler.guidesEnabled ? "1" : "0");
  node.setAttribute("tooltips", this.graph.tooltipHandler.isEnabled() ? "1" : "0");
  node.setAttribute("connect", this.graph.connectionHandler.isEnabled() ? "1" : "0");
  node.setAttribute("arrows", this.graph.connectionArrowsEnabled ? "1" : "0");
  node.setAttribute("fold", this.graph.foldingEnabled ? "1" : "0");
  node.setAttribute("page", this.graph.pageVisible ? "1" : "0");
  node.setAttribute("pageScale", this.graph.pageScale);
  node.setAttribute("pageWidth", this.graph.pageFormat.width);
  node.setAttribute("pageHeight", this.graph.pageFormat.height);
  if (this.graph.background != null) {
    node.setAttribute("background", this.graph.background);
  }
  return node;
};
Editor2.prototype.updateGraphComponents = function() {
  var graph = this.graph;
  if (graph.container != null) {
    graph.view.validateBackground();
    graph.container.style.overflow = graph.scrollbars ? "auto" : this.defaultGraphOverflow;
    this.fireEvent(new mxEventObject2("updateGraphComponents"));
  }
};
Editor2.prototype.setModified = function(value) {
  this.modified = value;
};
Editor2.prototype.setFilename = function(value) {
  this.filename = value;
};
Editor2.prototype.createUndoManager = function(undoRedoManagerThreat) {
  var graph = this.graph;
  var undoMgr = new mxUndoManager();
  this.undoListener = function(sender, evt) {
    undoMgr.undoableEditHappened(evt.getProperty("edit"));
  };
  var listener = bind(this, function(sender, evt) {
    this.undoListener.apply(this, arguments);
  });
  graph.getModel().addListener(mxEvent2.UNDO, listener);
  graph.getView().addListener(mxEvent2.UNDO, listener);
  var undoHandler = function(sender, evt) {
    var eventName = evt.name;
    if (eventName === mxEvent2.UNDO) {
      undoRedoManagerThreat.undo();
    } else if (eventName === mxEvent2.REDO) {
      console.log("Processing REDO event in undoHandler...");
    }
    var cand = graph.getSelectionCellsForChanges(evt.getProperty("edit").changes, function(change) {
      return !(change instanceof mxChildChange2);
    });
    if (cand.length > 0) {
      var model = graph.getModel();
      var cells = [];
      for (var i = 0; i < cand.length; i++) {
        if (graph.view.getState(cand[i]) != null) {
          cells.push(cand[i]);
        }
      }
      graph.setSelectionCells(cells);
    }
    if (eventName === mxEvent2.UNDO) {
      console.log("Processing UNDO event...");
    } else if (eventName === mxEvent2.REDO) {
      console.log("Processing REDO event...");
    }
  };
  undoMgr.addListener(mxEvent2.UNDO, undoHandler);
  undoMgr.addListener(mxEvent2.REDO, undoHandler);
  return undoMgr;
};
Editor2.prototype.initStencilRegistry = function() {
};
Editor2.prototype.destroy = function() {
  if (this.graph != null) {
    this.graph.destroy();
    this.graph = null;
  }
};
var OpenFile = function(done) {
  this.producer = null;
  this.consumer = null;
  this.done = done;
  this.args = null;
};
OpenFile.prototype.setConsumer = function(value) {
  this.consumer = value;
  this.execute();
};
OpenFile.prototype.setData = function() {
  this.args = arguments;
  this.execute();
};
OpenFile.prototype.error = function(msg) {
  this.cancel(true);
  alert2(msg);
};
OpenFile.prototype.execute = function() {
  if (this.consumer != null && this.args != null) {
    this.cancel(false);
    this.consumer.apply(this, this.args);
  }
};
OpenFile.prototype.cancel = function(cancel) {
  if (this.done != null) {
    this.done(cancel != null ? cancel : true);
  }
};
function Dialog2(editorUi, elt, w2, h2, modal, closable, onClose, noScroll, transparent, onResize, ignoreBgClick) {
  var dx = 0;
  if (mxClient_default.IS_VML && (document.documentMode == null || document.documentMode < 8)) {
    dx = 80;
  }
  w2 += dx;
  h2 += dx;
  var w0 = w2;
  var h0 = h2;
  var ds = getDocumentSize();
  if (window.innerHeight != null) {
    ds.height = window.innerHeight;
  }
  var dh = ds.height;
  var left = Math.max(1, Math.round((ds.width - w2 - 64) / 2));
  var top = Math.max(1, Math.round((dh - h2 - editorUi.footerHeight) / 3));
  if (!mxClient_default.IS_QUIRKS) {
    elt.style.maxHeight = "100%";
  }
  w2 = document.body != null ? Math.min(w2, document.body.scrollWidth - 64) : w2;
  h2 = Math.min(h2, dh - 64);
  if (editorUi.dialogs.length > 0) {
    this.zIndex += editorUi.dialogs.length * 2;
  }
  if (this.bg == null) {
    this.bg = editorUi.createDiv("background");
    this.bg.style.position = "absolute";
    this.bg.style.background = Dialog2.backdropColor;
    this.bg.style.height = dh + "px";
    this.bg.style.right = "0px";
    this.bg.style.zIndex = this.zIndex - 2;
    setOpacity(this.bg, this.bgOpacity);
    if (mxClient_default.IS_QUIRKS) {
      new mxDivResizer2(this.bg);
    }
  }
  var origin = getDocumentScrollOrigin(document);
  this.bg.style.left = origin.x + "px";
  this.bg.style.top = origin.y + "px";
  left += origin.x;
  top += origin.y;
  if (modal) {
    document.body.appendChild(this.bg);
  }
  var div = editorUi.createDiv(transparent ? "geTransDialog" : "geDialog");
  var pos = this.getPosition(left, top, w2, h2);
  left = pos.x;
  top = pos.y;
  div.style.width = w2 + "px";
  div.style.height = h2 + "px";
  div.style.left = left + "px";
  div.style.top = top + "px";
  div.style.zIndex = this.zIndex;
  div.appendChild(elt);
  document.body.appendChild(div);
  if (!noScroll && elt.clientHeight > div.clientHeight - 64) {
    elt.style.overflowY = "auto";
  }
  if (closable) {
    var img = document.createElement("img");
    img.setAttribute("src", Dialog2.prototype.closeImage);
    img.setAttribute("title", mxResources2.get("close"));
    img.className = "geDialogClose";
    img.style.top = top + 14 + "px";
    img.style.left = left + w2 + 38 - dx + "px";
    img.style.zIndex = this.zIndex;
    mxEvent2.addListener(img, "click", bind(this, function() {
      editorUi.hideDialog(true);
    }));
    document.body.appendChild(img);
    this.dialogImg = img;
    if (!ignoreBgClick) {
      var mouseDownSeen = false;
      mxEvent2.addGestureListeners(this.bg, bind(this, function(evt) {
        mouseDownSeen = true;
      }), null, bind(this, function(evt) {
        if (mouseDownSeen) {
          editorUi.hideDialog(true);
          mouseDownSeen = false;
        }
      }));
    }
  }
  this.resizeListener = bind(this, function() {
    if (onResize != null) {
      var newWH = onResize();
      if (newWH != null) {
        w0 = w2 = newWH.w;
        h0 = h2 = newWH.h;
      }
    }
    var ds2 = getDocumentSize();
    dh = ds2.height;
    this.bg.style.height = dh + "px";
    left = Math.max(1, Math.round((ds2.width - w2 - 64) / 2));
    top = Math.max(1, Math.round((dh - h2 - editorUi.footerHeight) / 3));
    w2 = document.body != null ? Math.min(w0, document.body.scrollWidth - 64) : w0;
    h2 = Math.min(h0, dh - 64);
    var pos2 = this.getPosition(left, top, w2, h2);
    left = pos2.x;
    top = pos2.y;
    div.style.left = left + "px";
    div.style.top = top + "px";
    div.style.width = w2 + "px";
    div.style.height = h2 + "px";
    if (!noScroll && elt.clientHeight > div.clientHeight - 64) {
      elt.style.overflowY = "auto";
    }
    if (this.dialogImg != null) {
      this.dialogImg.style.top = top + 14 + "px";
      this.dialogImg.style.left = left + w2 + 38 - dx + "px";
    }
  });
  mxEvent2.addListener(window, "resize", this.resizeListener);
  this.onDialogClose = onClose;
  this.container = div;
  editorUi.editor.fireEvent(new mxEventObject2("showDialog"));
}
Dialog2.backdropColor = "white";
Dialog2.prototype.zIndex = mxPopupMenu.prototype.zIndex - 1;
Dialog2.prototype.noColorImage = !mxClient_default.IS_SVG ? IMAGE_PATH + "/nocolor.png" : "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyBpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkEzRDlBMUUwODYxMTExRTFCMzA4RDdDMjJBMEMxRDM3IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkEzRDlBMUUxODYxMTExRTFCMzA4RDdDMjJBMEMxRDM3Ij4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6QTNEOUExREU4NjExMTFFMUIzMDhEN0MyMkEwQzFEMzciIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6QTNEOUExREY4NjExMTFFMUIzMDhEN0MyMkEwQzFEMzciLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5xh3fmAAAABlBMVEX////MzMw46qqDAAAAGElEQVR42mJggAJGKGAYIIGBth8KAAIMAEUQAIElnLuQAAAAAElFTkSuQmCC";
Dialog2.prototype.closeImage = !mxClient_default.IS_SVG ? IMAGE_PATH + "/close.png" : "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJAQMAAADaX5RTAAAABlBMVEV7mr3///+wksspAAAAAnRSTlP/AOW3MEoAAAAdSURBVAgdY9jXwCDDwNDRwHCwgeExmASygSL7GgB12QiqNHZZIwAAAABJRU5ErkJggg==";
Dialog2.prototype.clearImage = !mxClient_default.IS_SVG ? IMAGE_PATH + "/clear.gif" : "data:image/gif;base64,R0lGODlhDQAKAIABAMDAwP///yH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS4wLWMwNjAgNjEuMTM0Nzc3LCAyMDEwLzAyLzEyLTE3OjMyOjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IFdpbmRvd3MiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUIzOEM1NzI4NjEyMTFFMUEzMkNDMUE3NjZERDE2QjIiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUIzOEM1NzM4NjEyMTFFMUEzMkNDMUE3NjZERDE2QjIiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QjM4QzU3MDg2MTIxMUUxQTMyQ0MxQTc2NkREMTZCMiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QjM4QzU3MTg2MTIxMUUxQTMyQ0MxQTc2NkREMTZCMiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PgH//v38+/r5+Pf29fTz8vHw7+7t7Ovq6ejn5uXk4+Lh4N/e3dzb2tnY19bV1NPS0dDPzs3My8rJyMfGxcTDwsHAv769vLu6ubi3trW0s7KxsK+urayrqqmop6alpKOioaCfnp2cm5qZmJeWlZSTkpGQj46NjIuKiYiHhoWEg4KBgH9+fXx7enl4d3Z1dHNycXBvbm1sa2ppaGdmZWRjYmFgX15dXFtaWVhXVlVUU1JRUE9OTUxLSklIR0ZFRENCQUA/Pj08Ozo5ODc2NTQzMjEwLy4tLCsqKSgnJiUkIyIhIB8eHRwbGhkYFxYVFBMSERAPDg0MCwoJCAcGBQQDAgEAACH5BAEAAAEALAAAAAANAAoAAAIXTGCJebD9jEOTqRlttXdrB32PJ2ncyRQAOw==";
Dialog2.prototype.lockedImage = !mxClient_default.IS_SVG ? IMAGE_PATH + "/locked.png" : "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAMAAABhq6zVAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MzdDMDZCODExNzIxMTFFNUI0RTk5NTg4OTcyMUUyODEiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MzdDMDZCODIxNzIxMTFFNUI0RTk5NTg4OTcyMUUyODEiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDozN0MwNkI3RjE3MjExMUU1QjRFOTk1ODg5NzIxRTI4MSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDozN0MwNkI4MDE3MjExMUU1QjRFOTk1ODg5NzIxRTI4MSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PvqMCFYAAAAVUExURZmZmb+/v7KysqysrMzMzLGxsf///4g8N1cAAAAHdFJOU////////wAaSwNGAAAAPElEQVR42lTMQQ4AIQgEwUa0//9kTQirOweYOgDqAMbZUr10AGlAwx4/BJ2QJ4U0L5brYjovvpv32xZgAHZaATFtMbu4AAAAAElFTkSuQmCC";
Dialog2.prototype.unlockedImage = !mxClient_default.IS_SVG ? IMAGE_PATH + "/unlocked.png" : "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAMAAABhq6zVAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MzdDMDZCN0QxNzIxMTFFNUI0RTk5NTg4OTcyMUUyODEiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MzdDMDZCN0UxNzIxMTFFNUI0RTk5NTg4OTcyMUUyODEiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDozN0MwNkI3QjE3MjExMUU1QjRFOTk1ODg5NzIxRTI4MSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDozN0MwNkI3QzE3MjExMUU1QjRFOTk1ODg5NzIxRTI4MSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PkKMpVwAAAAYUExURZmZmbKysr+/v6ysrOXl5czMzLGxsf///zHN5lwAAAAIdFJOU/////////8A3oO9WQAAADxJREFUeNpUzFESACAEBNBVsfe/cZJU+8Mzs8CIABCidtfGOndnYsT40HDSiCcbPdoJo10o9aI677cpwACRoAF3dFNlswAAAABJRU5ErkJggg==";
Dialog2.prototype.bgOpacity = 80;
Dialog2.prototype.getPosition = function(left, top) {
  return new mxPoint2(left, top);
};
Dialog2.prototype.close = function(cancel, isEsc) {
  if (this.onDialogClose != null) {
    if (this.onDialogClose(cancel, isEsc) == false) {
      return false;
    }
    this.onDialogClose = null;
  }
  if (this.dialogImg != null) {
    this.dialogImg.parentNode.removeChild(this.dialogImg);
    this.dialogImg = null;
  }
  if (this.bg != null && this.bg.parentNode != null) {
    this.bg.parentNode.removeChild(this.bg);
  }
  mxEvent2.removeListener(window, "resize", this.resizeListener);
  this.container.parentNode.removeChild(this.container);
};
var ErrorDialog = function(editorUi, title, message, buttonText, fn, retry, buttonText2, fn2, hide3, buttonText3, fn3) {
  hide3 = hide3 != null ? hide3 : true;
  var div = document.createElement("div");
  div.style.textAlign = "center";
  if (title != null) {
    var hd = document.createElement("div");
    hd.style.padding = "0px";
    hd.style.margin = "0px";
    hd.style.fontSize = "18px";
    hd.style.paddingBottom = "16px";
    hd.style.marginBottom = "10px";
    hd.style.borderBottom = "1px solid #c0c0c0";
    hd.style.color = "gray";
    hd.style.whiteSpace = "nowrap";
    hd.style.textOverflow = "ellipsis";
    hd.style.overflow = "hidden";
    write(hd, title);
    hd.setAttribute("title", title);
    div.appendChild(hd);
  }
  var p2 = document.createElement("div");
  p2.style.lineHeight = "1.2em";
  p2.style.padding = "6px";
  p2.innerHTML = message;
  div.appendChild(p2);
  var btns = document.createElement("div");
  btns.style.marginTop = "12px";
  btns.style.textAlign = "center";
  if (retry != null) {
    var retryBtn = button(mxResources2.get("tryAgain"), function() {
      editorUi.hideDialog();
      retry();
    });
    retryBtn.className = "geBtn";
    btns.appendChild(retryBtn);
    btns.style.textAlign = "center";
  }
  if (buttonText3 != null) {
    var btn3 = button(buttonText3, function() {
      if (fn3 != null) {
        fn3();
      }
    });
    btn3.className = "geBtn";
    btns.appendChild(btn3);
  }
  var btn = button(buttonText, function() {
    if (hide3) {
      editorUi.hideDialog();
    }
    if (fn != null) {
      fn();
    }
  });
  btn.className = "geBtn";
  btns.appendChild(btn);
  if (buttonText2 != null) {
    var mainBtn = button(buttonText2, function() {
      if (hide3) {
        editorUi.hideDialog();
      }
      if (fn2 != null) {
        fn2();
      }
    });
    mainBtn.className = "geBtn gePrimaryBtn";
    btns.appendChild(mainBtn);
  }
  this.init = function() {
    btn.focus();
  };
  div.appendChild(btns);
  this.container = div;
};
var PrintDialog = function(editorUi, title) {
  this.create(editorUi, title);
};
PrintDialog.prototype.create = function(editorUi) {
  var graph = editorUi.editor.graph;
  var row, td;
  var table = document.createElement("table");
  table.style.width = "100%";
  table.style.height = "100%";
  var tbody = document.createElement("tbody");
  row = document.createElement("tr");
  var onePageCheckBox = document.createElement("input");
  onePageCheckBox.setAttribute("type", "checkbox");
  td = document.createElement("td");
  td.setAttribute("colspan", "2");
  td.style.fontSize = "10pt";
  td.appendChild(onePageCheckBox);
  var span = document.createElement("span");
  write(span, " " + mxResources2.get("fitPage"));
  td.appendChild(span);
  mxEvent2.addListener(span, "click", function(evt) {
    onePageCheckBox.checked = !onePageCheckBox.checked;
    pageCountCheckBox.checked = !onePageCheckBox.checked;
    mxEvent2.consume(evt);
  });
  mxEvent2.addListener(onePageCheckBox, "change", function() {
    pageCountCheckBox.checked = !onePageCheckBox.checked;
  });
  row.appendChild(td);
  tbody.appendChild(row);
  row = row.cloneNode(false);
  var pageCountCheckBox = document.createElement("input");
  pageCountCheckBox.setAttribute("type", "checkbox");
  td = document.createElement("td");
  td.style.fontSize = "10pt";
  td.appendChild(pageCountCheckBox);
  var span = document.createElement("span");
  write(span, " " + mxResources2.get("posterPrint") + ":");
  td.appendChild(span);
  mxEvent2.addListener(span, "click", function(evt) {
    pageCountCheckBox.checked = !pageCountCheckBox.checked;
    onePageCheckBox.checked = !pageCountCheckBox.checked;
    mxEvent2.consume(evt);
  });
  row.appendChild(td);
  var pageCountInput = document.createElement("input");
  pageCountInput.setAttribute("value", "1");
  pageCountInput.setAttribute("type", "number");
  pageCountInput.setAttribute("min", "1");
  pageCountInput.setAttribute("size", "4");
  pageCountInput.setAttribute("disabled", "disabled");
  pageCountInput.style.width = "50px";
  td = document.createElement("td");
  td.style.fontSize = "10pt";
  td.appendChild(pageCountInput);
  write(td, " " + mxResources2.get("pages") + " (max)");
  row.appendChild(td);
  tbody.appendChild(row);
  mxEvent2.addListener(pageCountCheckBox, "change", function() {
    if (pageCountCheckBox.checked) {
      pageCountInput.removeAttribute("disabled");
    } else {
      pageCountInput.setAttribute("disabled", "disabled");
    }
    onePageCheckBox.checked = !pageCountCheckBox.checked;
  });
  row = row.cloneNode(false);
  td = document.createElement("td");
  write(td, mxResources2.get("pageScale") + ":");
  row.appendChild(td);
  td = document.createElement("td");
  var pageScaleInput = document.createElement("input");
  pageScaleInput.setAttribute("value", "100 %");
  pageScaleInput.setAttribute("size", "5");
  pageScaleInput.style.width = "50px";
  td.appendChild(pageScaleInput);
  row.appendChild(td);
  tbody.appendChild(row);
  row = document.createElement("tr");
  td = document.createElement("td");
  td.colSpan = 2;
  td.style.paddingTop = "20px";
  td.setAttribute("align", "right");
  function preview(print) {
    var autoOrigin = onePageCheckBox.checked || pageCountCheckBox.checked;
    var printScale = parseInt(pageScaleInput.value) / 100;
    if (isNaN(printScale)) {
      printScale = 1;
      pageScaleInput.value = "100%";
    }
    printScale *= 0.75;
    var pf = graph.pageFormat || mxConstants2.PAGE_FORMAT_A4_PORTRAIT;
    var scale = 1 / graph.pageScale;
    if (autoOrigin) {
      var pageCount = onePageCheckBox.checked ? 1 : parseInt(pageCountInput.value);
      if (!isNaN(pageCount)) {
        scale = getScaleForPageCount(pageCount, graph, pf);
      }
    }
    var gb = graph.getGraphBounds();
    var border = 0;
    var x0 = 0;
    var y0 = 0;
    pf = mxRectangle.fromRectangle(pf);
    pf.width = Math.ceil(pf.width * printScale);
    pf.height = Math.ceil(pf.height * printScale);
    scale *= printScale;
    if (!autoOrigin && graph.pageVisible) {
      var layout = graph.getPageLayout();
      x0 -= layout.x * pf.width;
      y0 -= layout.y * pf.height;
    } else {
      autoOrigin = true;
    }
    var preview2 = PrintDialog.createPrintPreview(graph, scale, pf, border, x0, y0, autoOrigin);
    preview2.open();
    if (print) {
      PrintDialog.printPreview(preview2);
    }
  }
  var cancelBtn = button(mxResources2.get("cancel"), function() {
    editorUi.hideDialog();
  });
  cancelBtn.className = "geBtn";
  if (editorUi.editor.cancelFirst) {
    td.appendChild(cancelBtn);
  }
  if (PrintDialog.previewEnabled) {
    var previewBtn = button(mxResources2.get("preview"), function() {
      editorUi.hideDialog();
      preview(false);
    });
    previewBtn.className = "geBtn";
    td.appendChild(previewBtn);
  }
  var printBtn = button(mxResources2.get(!PrintDialog.previewEnabled ? "ok" : "print"), function() {
    editorUi.hideDialog();
    preview(true);
  });
  printBtn.className = "geBtn gePrimaryBtn";
  td.appendChild(printBtn);
  if (!editorUi.editor.cancelFirst) {
    td.appendChild(cancelBtn);
  }
  row.appendChild(td);
  tbody.appendChild(row);
  table.appendChild(tbody);
  this.container = table;
};
PrintDialog.printPreview = function(preview) {
  try {
    if (preview.wnd != null) {
      var printFn = function() {
        preview.wnd.focus();
        preview.wnd.print();
        preview.wnd.close();
      };
      if (mxClient_default.IS_GC) {
        window.setTimeout(printFn, 500);
      } else {
        printFn();
      }
    }
  } catch (e) {
  }
};
PrintDialog.createPrintPreview = function(graph, scale, pf, border, x0, y0, autoOrigin) {
  var preview = new mxPrintPreview(graph, scale, pf, border, x0, y0);
  preview.title = mxResources2.get("preview");
  preview.printBackgroundImage = true;
  preview.autoOrigin = autoOrigin;
  var bg = graph.background;
  if (bg == null || bg == "" || bg == mxConstants2.NONE) {
    bg = "#ffffff";
  }
  preview.backgroundColor = bg;
  var writeHead = preview.writeHead;
  preview.writeHead = function(doc) {
    writeHead.apply(this, arguments);
    doc.writeln('<style type="text/css">');
    doc.writeln("@media screen {");
    doc.writeln("  body > div { padding:30px;box-sizing:content-box; }");
    doc.writeln("}");
    doc.writeln("</style>");
  };
  return preview;
};
PrintDialog.previewEnabled = true;
var PageSetupDialog = function(editorUi) {
  var graph = editorUi.editor.graph;
  var row, td;
  var table = document.createElement("table");
  table.style.width = "100%";
  table.style.height = "100%";
  var tbody = document.createElement("tbody");
  row = document.createElement("tr");
  td = document.createElement("td");
  td.style.verticalAlign = "top";
  td.style.fontSize = "10pt";
  write(td, mxResources2.get("paperSize") + ":");
  row.appendChild(td);
  td = document.createElement("td");
  td.style.verticalAlign = "top";
  td.style.fontSize = "10pt";
  var accessor = PageSetupDialog.addPageFormatPanel(td, "pagesetupdialog", graph.pageFormat);
  row.appendChild(td);
  tbody.appendChild(row);
  row = document.createElement("tr");
  td = document.createElement("td");
  write(td, mxResources2.get("background") + ":");
  row.appendChild(td);
  td = document.createElement("td");
  td.style.whiteSpace = "nowrap";
  var backgroundInput = document.createElement("input");
  backgroundInput.setAttribute("type", "text");
  var backgroundButton = document.createElement("button");
  backgroundButton.style.width = "18px";
  backgroundButton.style.height = "18px";
  backgroundButton.style.marginRight = "20px";
  backgroundButton.style.backgroundPosition = "center center";
  backgroundButton.style.backgroundRepeat = "no-repeat";
  var newBackgroundColor = graph.background;
  function updateBackgroundColor() {
    if (newBackgroundColor == null || newBackgroundColor == mxConstants2.NONE) {
      backgroundButton.style.backgroundColor = "";
      backgroundButton.style.backgroundImage = "url('" + Dialog2.prototype.noColorImage + "')";
    } else {
      backgroundButton.style.backgroundColor = newBackgroundColor;
      backgroundButton.style.backgroundImage = "";
    }
  }
  updateBackgroundColor();
  mxEvent2.addListener(backgroundButton, "click", function(evt) {
    editorUi.pickColor(newBackgroundColor || "none", function(color) {
      newBackgroundColor = color;
      updateBackgroundColor();
    });
    mxEvent2.consume(evt);
  });
  td.appendChild(backgroundButton);
  write(td, mxResources2.get("gridSize") + ":");
  var gridSizeInput = document.createElement("input");
  gridSizeInput.setAttribute("type", "number");
  gridSizeInput.setAttribute("min", "0");
  gridSizeInput.style.width = "40px";
  gridSizeInput.style.marginLeft = "6px";
  gridSizeInput.value = graph.getGridSize();
  td.appendChild(gridSizeInput);
  mxEvent2.addListener(gridSizeInput, "change", function() {
    var value = parseInt(gridSizeInput.value);
    gridSizeInput.value = Math.max(1, isNaN(value) ? graph.getGridSize() : value);
  });
  row.appendChild(td);
  tbody.appendChild(row);
  row = document.createElement("tr");
  td = document.createElement("td");
  write(td, mxResources2.get("image") + ":");
  row.appendChild(td);
  td = document.createElement("td");
  var changeImageLink = document.createElement("a");
  changeImageLink.style.textDecoration = "underline";
  changeImageLink.style.cursor = "pointer";
  changeImageLink.style.color = "#a0a0a0";
  var newBackgroundImage = graph.backgroundImage;
  function updateBackgroundImage() {
    if (newBackgroundImage == null) {
      changeImageLink.removeAttribute("title");
      changeImageLink.style.fontSize = "";
      changeImageLink.innerHTML = htmlEntities(mxResources2.get("change")) + "...";
    } else {
      changeImageLink.setAttribute("title", newBackgroundImage.src);
      changeImageLink.style.fontSize = "11px";
      changeImageLink.innerHTML = htmlEntities(newBackgroundImage.src.substring(0, 42)) + "...";
    }
  }
  mxEvent2.addListener(changeImageLink, "click", function(evt) {
    editorUi.showBackgroundImageDialog(function(image, failed) {
      if (!failed) {
        newBackgroundImage = image;
        updateBackgroundImage();
      }
    }, newBackgroundImage);
    mxEvent2.consume(evt);
  });
  updateBackgroundImage();
  td.appendChild(changeImageLink);
  row.appendChild(td);
  tbody.appendChild(row);
  row = document.createElement("tr");
  td = document.createElement("td");
  td.colSpan = 2;
  td.style.paddingTop = "16px";
  td.setAttribute("align", "right");
  var cancelBtn = button(mxResources2.get("cancel"), function() {
    editorUi.hideDialog();
  });
  cancelBtn.className = "geBtn";
  if (editorUi.editor.cancelFirst) {
    td.appendChild(cancelBtn);
  }
  var applyBtn = button(mxResources2.get("apply"), function() {
    editorUi.hideDialog();
    var gridSize = parseInt(gridSizeInput.value);
    if (!isNaN(gridSize) && graph.gridSize !== gridSize) {
      graph.setGridSize(gridSize);
    }
    var change = new ChangePageSetup(editorUi, newBackgroundColor, newBackgroundImage, accessor.get());
    change.ignoreColor = graph.background == newBackgroundColor;
    var oldSrc = graph.backgroundImage != null ? graph.backgroundImage.src : null;
    var newSrc = newBackgroundImage != null ? newBackgroundImage.src : null;
    change.ignoreImage = oldSrc === newSrc;
    if (graph.pageFormat.width != change.previousFormat.width || graph.pageFormat.height != change.previousFormat.height || !change.ignoreColor || !change.ignoreImage) {
      graph.model.execute(change);
    }
  });
  applyBtn.className = "geBtn gePrimaryBtn";
  td.appendChild(applyBtn);
  if (!editorUi.editor.cancelFirst) {
    td.appendChild(cancelBtn);
  }
  row.appendChild(td);
  tbody.appendChild(row);
  table.appendChild(tbody);
  this.container = table;
};
PageSetupDialog.addPageFormatPanel = function(div, namePostfix, pageFormat, pageFormatListener) {
  var formatName = "format-" + namePostfix;
  var portraitCheckBox = document.createElement("input");
  portraitCheckBox.setAttribute("name", formatName);
  portraitCheckBox.setAttribute("type", "radio");
  portraitCheckBox.setAttribute("value", "portrait");
  var landscapeCheckBox = document.createElement("input");
  landscapeCheckBox.setAttribute("name", formatName);
  landscapeCheckBox.setAttribute("type", "radio");
  landscapeCheckBox.setAttribute("value", "landscape");
  var paperSizeSelect = document.createElement("select");
  paperSizeSelect.style.marginBottom = "8px";
  paperSizeSelect.style.width = "202px";
  var formatDiv = document.createElement("div");
  formatDiv.style.marginLeft = "4px";
  formatDiv.style.width = "210px";
  formatDiv.style.height = "24px";
  portraitCheckBox.style.marginRight = "6px";
  formatDiv.appendChild(portraitCheckBox);
  var portraitSpan = document.createElement("span");
  portraitSpan.style.maxWidth = "100px";
  write(portraitSpan, mxResources2.get("portrait"));
  formatDiv.appendChild(portraitSpan);
  landscapeCheckBox.style.marginLeft = "10px";
  landscapeCheckBox.style.marginRight = "6px";
  formatDiv.appendChild(landscapeCheckBox);
  var landscapeSpan = document.createElement("span");
  landscapeSpan.style.width = "100px";
  write(landscapeSpan, mxResources2.get("landscape"));
  formatDiv.appendChild(landscapeSpan);
  var customDiv = document.createElement("div");
  customDiv.style.marginLeft = "4px";
  customDiv.style.width = "210px";
  customDiv.style.height = "24px";
  var widthInput = document.createElement("input");
  widthInput.setAttribute("size", "7");
  widthInput.style.textAlign = "right";
  customDiv.appendChild(widthInput);
  write(customDiv, " in x ");
  var heightInput = document.createElement("input");
  heightInput.setAttribute("size", "7");
  heightInput.style.textAlign = "right";
  customDiv.appendChild(heightInput);
  write(customDiv, " in");
  formatDiv.style.display = "none";
  customDiv.style.display = "none";
  var pf = new Object();
  var formats = PageSetupDialog.getFormats();
  for (var i = 0; i < formats.length; i++) {
    var f = formats[i];
    pf[f.key] = f;
    var paperSizeOption = document.createElement("option");
    paperSizeOption.setAttribute("value", f.key);
    write(paperSizeOption, f.title);
    paperSizeSelect.appendChild(paperSizeOption);
  }
  var customSize = false;
  function listener(sender, evt, force) {
    if (force || widthInput != document.activeElement && heightInput != document.activeElement) {
      var detected = false;
      for (var i2 = 0; i2 < formats.length; i2++) {
        var f2 = formats[i2];
        if (customSize) {
          if (f2.key == "custom") {
            paperSizeSelect.value = f2.key;
            customSize = false;
          }
        } else if (f2.format != null) {
          if (f2.key == "a4") {
            if (pageFormat.width == 826) {
              pageFormat = mxRectangle.fromRectangle(pageFormat);
              pageFormat.width = 827;
            } else if (pageFormat.height == 826) {
              pageFormat = mxRectangle.fromRectangle(pageFormat);
              pageFormat.height = 827;
            }
          } else if (f2.key == "a5") {
            if (pageFormat.width == 584) {
              pageFormat = mxRectangle.fromRectangle(pageFormat);
              pageFormat.width = 583;
            } else if (pageFormat.height == 584) {
              pageFormat = mxRectangle.fromRectangle(pageFormat);
              pageFormat.height = 583;
            }
          }
          if (pageFormat.width == f2.format.width && pageFormat.height == f2.format.height) {
            paperSizeSelect.value = f2.key;
            portraitCheckBox.setAttribute("checked", "checked");
            portraitCheckBox.defaultChecked = true;
            portraitCheckBox.checked = true;
            landscapeCheckBox.removeAttribute("checked");
            landscapeCheckBox.defaultChecked = false;
            landscapeCheckBox.checked = false;
            detected = true;
          } else if (pageFormat.width == f2.format.height && pageFormat.height == f2.format.width) {
            paperSizeSelect.value = f2.key;
            portraitCheckBox.removeAttribute("checked");
            portraitCheckBox.defaultChecked = false;
            portraitCheckBox.checked = false;
            landscapeCheckBox.setAttribute("checked", "checked");
            landscapeCheckBox.defaultChecked = true;
            landscapeCheckBox.checked = true;
            detected = true;
          }
        }
      }
      if (!detected) {
        widthInput.value = pageFormat.width / 100;
        heightInput.value = pageFormat.height / 100;
        portraitCheckBox.setAttribute("checked", "checked");
        paperSizeSelect.value = "custom";
        formatDiv.style.display = "none";
        customDiv.style.display = "";
      } else {
        formatDiv.style.display = "";
        customDiv.style.display = "none";
      }
    }
  }
  listener();
  div.appendChild(paperSizeSelect);
  br(div);
  div.appendChild(formatDiv);
  div.appendChild(customDiv);
  var currentPageFormat = pageFormat;
  var update = function(evt, selectChanged) {
    var f2 = pf[paperSizeSelect.value];
    if (f2.format != null) {
      widthInput.value = f2.format.width / 100;
      heightInput.value = f2.format.height / 100;
      customDiv.style.display = "none";
      formatDiv.style.display = "";
    } else {
      formatDiv.style.display = "none";
      customDiv.style.display = "";
    }
    var wi = parseFloat(widthInput.value);
    if (isNaN(wi) || wi <= 0) {
      widthInput.value = pageFormat.width / 100;
    }
    var hi = parseFloat(heightInput.value);
    if (isNaN(hi) || hi <= 0) {
      heightInput.value = pageFormat.height / 100;
    }
    var newPageFormat = new mxRectangle(0, 0, Math.floor(parseFloat(widthInput.value) * 100), Math.floor(parseFloat(heightInput.value) * 100));
    if (paperSizeSelect.value != "custom" && landscapeCheckBox.checked) {
      newPageFormat = new mxRectangle(0, 0, newPageFormat.height, newPageFormat.width);
    }
    if ((!selectChanged || !customSize) && (newPageFormat.width != currentPageFormat.width || newPageFormat.height != currentPageFormat.height)) {
      currentPageFormat = newPageFormat;
      if (pageFormatListener != null) {
        pageFormatListener(currentPageFormat);
      }
    }
  };
  mxEvent2.addListener(portraitSpan, "click", function(evt) {
    portraitCheckBox.checked = true;
    update(evt);
    mxEvent2.consume(evt);
  });
  mxEvent2.addListener(landscapeSpan, "click", function(evt) {
    landscapeCheckBox.checked = true;
    update(evt);
    mxEvent2.consume(evt);
  });
  mxEvent2.addListener(widthInput, "blur", update);
  mxEvent2.addListener(widthInput, "click", update);
  mxEvent2.addListener(heightInput, "blur", update);
  mxEvent2.addListener(heightInput, "click", update);
  mxEvent2.addListener(landscapeCheckBox, "change", update);
  mxEvent2.addListener(portraitCheckBox, "change", update);
  mxEvent2.addListener(paperSizeSelect, "change", function(evt) {
    customSize = paperSizeSelect.value == "custom";
    update(evt, true);
  });
  update();
  return {
    set: function(value) {
      pageFormat = value;
      listener(null, null, true);
    },
    get: function() {
      return currentPageFormat;
    },
    widthInput,
    heightInput
  };
};
PageSetupDialog.getFormats = function() {
  return [
    {
      key: "letter",
      title: 'US-Letter (8,5" x 11")',
      format: mxConstants2.PAGE_FORMAT_LETTER_PORTRAIT
    },
    {
      key: "legal",
      title: 'US-Legal (8,5" x 14")',
      format: new mxRectangle(0, 0, 850, 1400)
    },
    {
      key: "tabloid",
      title: 'US-Tabloid (11" x 17")',
      format: new mxRectangle(0, 0, 1100, 1700)
    },
    {
      key: "executive",
      title: 'US-Executive (7" x 10")',
      format: new mxRectangle(0, 0, 700, 1e3)
    },
    {
      key: "a0",
      title: "A0 (841 mm x 1189 mm)",
      format: new mxRectangle(0, 0, 3300, 4681)
    },
    {
      key: "a1",
      title: "A1 (594 mm x 841 mm)",
      format: new mxRectangle(0, 0, 2339, 3300)
    },
    {
      key: "a2",
      title: "A2 (420 mm x 594 mm)",
      format: new mxRectangle(0, 0, 1654, 2336)
    },
    {
      key: "a3",
      title: "A3 (297 mm x 420 mm)",
      format: new mxRectangle(0, 0, 1169, 1654)
    },
    {
      key: "a4",
      title: "A4 (210 mm x 297 mm)",
      format: mxConstants2.PAGE_FORMAT_A4_PORTRAIT
    },
    {
      key: "a5",
      title: "A5 (148 mm x 210 mm)",
      format: new mxRectangle(0, 0, 583, 827)
    },
    {
      key: "a6",
      title: "A6 (105 mm x 148 mm)",
      format: new mxRectangle(0, 0, 413, 583)
    },
    {
      key: "a7",
      title: "A7 (74 mm x 105 mm)",
      format: new mxRectangle(0, 0, 291, 413)
    },
    {
      key: "b4",
      title: "B4 (250 mm x 353 mm)",
      format: new mxRectangle(0, 0, 980, 1390)
    },
    {
      key: "b5",
      title: "B5 (176 mm x 250 mm)",
      format: new mxRectangle(0, 0, 690, 980)
    },
    {
      key: "16-9",
      title: "16:9 (1600 x 900)",
      format: new mxRectangle(0, 0, 900, 1600)
    },
    {
      key: "16-10",
      title: "16:10 (1920 x 1200)",
      format: new mxRectangle(0, 0, 1200, 1920)
    },
    {
      key: "4-3",
      title: "4:3 (1600 x 1200)",
      format: new mxRectangle(0, 0, 1200, 1600)
    },
    { key: "custom", title: mxResources2.get("custom"), format: null }
  ];
};
var FilenameDialog2 = function(editorUi, filename, buttonText, fn, label, validateFn, content, helpLink, closeOnBtn, cancelFn, hints, w2) {
  closeOnBtn = closeOnBtn != null ? closeOnBtn : true;
  var row, td;
  var table = document.createElement("table");
  var tbody = document.createElement("tbody");
  table.style.marginTop = "8px";
  row = document.createElement("tr");
  td = document.createElement("td");
  td.style.whiteSpace = "nowrap";
  td.style.fontSize = "10pt";
  td.style.width = hints ? "80px" : "120px";
  write(td, (label || mxResources2.get("filename")) + ":");
  row.appendChild(td);
  var nameInput = document.createElement("input");
  nameInput.setAttribute("value", filename || "");
  nameInput.style.marginLeft = "4px";
  nameInput.style.width = w2 != null ? w2 + "px" : "180px";
  var genericBtn = button(buttonText, function() {
    if (validateFn == null || validateFn(nameInput.value)) {
      if (closeOnBtn) {
        editorUi.hideDialog();
      }
      fn(nameInput.value);
    }
  });
  genericBtn.className = "geBtn gePrimaryBtn";
  this.init = function() {
    if (label == null && content != null) {
      return;
    }
    nameInput.focus();
    if (mxClient_default.IS_GC || mxClient_default.IS_FF || document.documentMode >= 5 || mxClient_default.IS_QUIRKS) {
      nameInput.select();
    } else {
      document.execCommand("selectAll", false, null);
    }
    if (Graph2.fileSupport) {
      var dlg = table.parentNode;
      if (dlg != null) {
        var graph = editorUi.editor.graph;
        var dropElt = null;
        mxEvent2.addListener(dlg, "dragleave", function(evt) {
          if (dropElt != null) {
            dropElt.style.backgroundColor = "";
            dropElt = null;
          }
          evt.stopPropagation();
          evt.preventDefault();
        });
        mxEvent2.addListener(dlg, "dragover", bind(this, function(evt) {
          if (dropElt == null && (!mxClient_default.IS_IE || document.documentMode > 10)) {
            dropElt = nameInput;
            dropElt.style.backgroundColor = "#ebf2f9";
          }
          evt.stopPropagation();
          evt.preventDefault();
        }));
        mxEvent2.addListener(dlg, "drop", bind(this, function(evt) {
          if (dropElt != null) {
            dropElt.style.backgroundColor = "";
            dropElt = null;
          }
          if (indexOf(evt.dataTransfer.types, "text/uri-list") >= 0) {
            nameInput.value = decodeURIComponent(evt.dataTransfer.getData("text/uri-list"));
            genericBtn.click();
          }
          evt.stopPropagation();
          evt.preventDefault();
        }));
      }
    }
  };
  td = document.createElement("td");
  td.style.whiteSpace = "nowrap";
  td.appendChild(nameInput);
  row.appendChild(td);
  if (label != null || content == null) {
    tbody.appendChild(row);
    if (hints != null) {
      if (editorUi.editor.diagramFileTypes != null) {
        var typeSelect = FilenameDialog2.createFileTypes(editorUi, nameInput, editorUi.editor.diagramFileTypes);
        typeSelect.style.marginLeft = "6px";
        typeSelect.style.width = "74px";
        td.appendChild(typeSelect);
        nameInput.style.width = w2 != null ? w2 - 40 + "px" : "140px";
      }
      td.appendChild(FilenameDialog2.createTypeHint(editorUi, nameInput, hints));
    }
  }
  if (content != null) {
    row = document.createElement("tr");
    td = document.createElement("td");
    td.colSpan = 2;
    td.appendChild(content);
    row.appendChild(td);
    tbody.appendChild(row);
  }
  row = document.createElement("tr");
  td = document.createElement("td");
  td.colSpan = 2;
  td.style.paddingTop = "20px";
  td.style.whiteSpace = "nowrap";
  td.setAttribute("align", "right");
  var cancelBtn = button(mxResources2.get("cancel"), function() {
    editorUi.hideDialog();
    if (cancelFn != null) {
      cancelFn();
    }
  });
  cancelBtn.className = "geBtn";
  if (editorUi.editor.cancelFirst) {
    td.appendChild(cancelBtn);
  }
  if (helpLink != null) {
    var helpBtn = button(mxResources2.get("help"), function() {
      editorUi.editor.graph.openLink(helpLink);
    });
    helpBtn.className = "geBtn";
    td.appendChild(helpBtn);
  }
  mxEvent2.addListener(nameInput, "keypress", function(e) {
    if (e.keyCode == 13) {
      genericBtn.click();
    }
  });
  td.appendChild(genericBtn);
  if (!editorUi.editor.cancelFirst) {
    td.appendChild(cancelBtn);
  }
  row.appendChild(td);
  tbody.appendChild(row);
  table.appendChild(tbody);
  this.container = table;
};
FilenameDialog2.filenameHelpLink = null;
FilenameDialog2.createTypeHint = function(ui, nameInput, hints) {
  var hint = document.createElement("img");
  hint.style.cssText = "vertical-align:top;height:16px;width:16px;margin-left:4px;background-repeat:no-repeat;background-position:center bottom;cursor:pointer;";
  setOpacity(hint, 70);
  var nameChanged = function() {
    hint.setAttribute("src", Editor2.helpImage);
    hint.setAttribute("title", mxResources2.get("help"));
    for (var i = 0; i < hints.length; i++) {
      if (hints[i].ext.length > 0 && nameInput.value.toLowerCase().substring(nameInput.value.length - hints[i].ext.length - 1) == "." + hints[i].ext) {
        hint.setAttribute("src", mxClient_default.imageBasePath + "/warning.png");
        hint.setAttribute("title", mxResources2.get(hints[i].title));
        break;
      }
    }
  };
  mxEvent2.addListener(nameInput, "keyup", nameChanged);
  mxEvent2.addListener(nameInput, "change", nameChanged);
  mxEvent2.addListener(hint, "click", function(evt) {
    var title = hint.getAttribute("title");
    if (hint.getAttribute("src") == Editor2.helpImage) {
      ui.editor.graph.openLink(FilenameDialog2.filenameHelpLink);
    } else if (title != "") {
      ui.showError(null, title, mxResources2.get("help"), function() {
        ui.editor.graph.openLink(FilenameDialog2.filenameHelpLink);
      }, null, mxResources2.get("ok"), null, null, null, 340, 90);
    }
    mxEvent2.consume(evt);
  });
  nameChanged();
  return hint;
};
FilenameDialog2.createFileTypes = function(editorUi, nameInput, types) {
  var typeSelect = document.createElement("select");
  for (var i = 0; i < types.length; i++) {
    var typeOption = document.createElement("option");
    typeOption.setAttribute("value", i);
    write(typeOption, mxResources2.get(types[i].description) + " (." + types[i].extension + ")");
    typeSelect.appendChild(typeOption);
  }
  mxEvent2.addListener(typeSelect, "change", function(evt) {
    var ext = types[typeSelect.value].extension;
    var idx = nameInput.value.lastIndexOf(".");
    if (idx > 0) {
      var ext = types[typeSelect.value].extension;
      nameInput.value = nameInput.value.substring(0, idx + 1) + ext;
    } else {
      nameInput.value = nameInput.value + "." + ext;
    }
    if ("createEvent" in document) {
      var changeEvent = document.createEvent("HTMLEvents");
      changeEvent.initEvent("change", false, true);
      nameInput.dispatchEvent(changeEvent);
    } else {
      nameInput.fireEvent("onchange");
    }
  });
  var nameInputChanged = function(evt) {
    var idx = nameInput.value.lastIndexOf(".");
    var active = 0;
    if (idx > 0) {
      var ext = nameInput.value.toLowerCase().substring(idx + 1);
      for (var i2 = 0; i2 < types.length; i2++) {
        if (ext == types[i2].extension) {
          active = i2;
          break;
        }
      }
    }
    typeSelect.value = active;
  };
  mxEvent2.addListener(nameInput, "change", nameInputChanged);
  mxEvent2.addListener(nameInput, "keyup", nameInputChanged);
  nameInputChanged();
  return typeSelect;
};
(function() {
  mxGraphView.prototype.validateBackgroundPage = function() {
    var graph = this.graph;
    if (graph.container != null && !graph.transparentBackground) {
      if (graph.pageVisible) {
        var bounds = this.getBackgroundPageBounds();
        if (this.backgroundPageShape == null) {
          var firstChild = graph.container.firstChild;
          while (firstChild != null && firstChild.nodeType != mxConstants2.NODETYPE_ELEMENT) {
            firstChild = firstChild.nextSibling;
          }
          if (firstChild != null) {
            this.backgroundPageShape = this.createBackgroundPageShape(bounds);
            this.backgroundPageShape.scale = 1;
            this.backgroundPageShape.isShadow = !mxClient_default.IS_QUIRKS;
            this.backgroundPageShape.dialect = mxConstants2.DIALECT_STRICTHTML;
            this.backgroundPageShape.init(graph.container);
            firstChild.style.position = "absolute";
            graph.container.insertBefore(this.backgroundPageShape.node, firstChild);
            this.backgroundPageShape.redraw();
            this.backgroundPageShape.node.className = "geBackgroundPage";
            mxEvent2.addListener(this.backgroundPageShape.node, "dblclick", bind(this, function(evt) {
              graph.dblClick(evt);
            }));
            mxEvent2.addGestureListeners(this.backgroundPageShape.node, bind(this, function(evt) {
              graph.fireMouseEvent(mxEvent2.MOUSE_DOWN, new mxMouseEvent2(evt));
            }), bind(this, function(evt) {
              if (graph.tooltipHandler != null && graph.tooltipHandler.isHideOnHover()) {
                graph.tooltipHandler.hide();
              }
              if (graph.isMouseDown && !mxEvent2.isConsumed(evt)) {
                graph.fireMouseEvent(mxEvent2.MOUSE_MOVE, new mxMouseEvent2(evt));
              }
            }), bind(this, function(evt) {
              graph.fireMouseEvent(mxEvent2.MOUSE_UP, new mxMouseEvent2(evt));
            }));
          }
        } else {
          this.backgroundPageShape.scale = 1;
          this.backgroundPageShape.bounds = bounds;
          this.backgroundPageShape.redraw();
        }
      } else if (this.backgroundPageShape != null) {
        this.backgroundPageShape.destroy();
        this.backgroundPageShape = null;
      }
      this.validateBackgroundStyles();
    }
  };
  mxGraphView.prototype.validateBackgroundStyles = function() {
    var graph = this.graph;
    var color = graph.background == null || graph.background == mxConstants2.NONE ? graph.defaultPageBackgroundColor : graph.background;
    var gridColor = color != null && this.gridColor != color.toLowerCase() ? this.gridColor : "#ffffff";
    var image = "none";
    var position = "";
    if (graph.isGridEnabled()) {
      var phase = 10;
      if (mxClient_default.IS_SVG) {
        image = unescape(encodeURIComponent(this.createSvgGrid(gridColor)));
        image = window.btoa ? btoa(image) : Base64.encode(image, true);
        image = "url(data:image/svg+xml;base64," + image + ")";
        phase = graph.gridSize * this.scale * this.gridSteps;
      } else {
        image = "url(" + this.gridImage + ")";
      }
      var x0 = 0;
      var y0 = 0;
      if (graph.view.backgroundPageShape != null) {
        var bds = this.getBackgroundPageBounds();
        x0 = 1 + bds.x;
        y0 = 1 + bds.y;
      }
      position = -Math.round(phase - mod(this.translate.x * this.scale - x0, phase)) + "px " + -Math.round(phase - mod(this.translate.y * this.scale - y0, phase)) + "px";
    }
    var canvas = graph.view.canvas;
    if (canvas.ownerSVGElement != null) {
      canvas = canvas.ownerSVGElement;
    }
    if (graph.view.backgroundPageShape != null) {
      graph.view.backgroundPageShape.node.style.backgroundPosition = position;
      graph.view.backgroundPageShape.node.style.backgroundImage = image;
      graph.view.backgroundPageShape.node.style.backgroundColor = color;
      graph.container.className = "geDiagramContainer geDiagramBackdrop";
      canvas.style.backgroundImage = "none";
      canvas.style.backgroundColor = "";
    } else {
      graph.container.className = "geDiagramContainer";
      canvas.style.backgroundPosition = position;
      canvas.style.backgroundColor = color;
      canvas.style.backgroundImage = image;
    }
  };
  mxGraphView.prototype.createSvgGrid = function(color) {
    var tmp = this.graph.gridSize * this.scale;
    while (tmp < this.minGridSize) {
      tmp *= 2;
    }
    var tmp2 = this.gridSteps * tmp;
    var d = [];
    for (var i = 1; i < this.gridSteps; i++) {
      var tmp3 = i * tmp;
      d.push("M 0 " + tmp3 + " L " + tmp2 + " " + tmp3 + " M " + tmp3 + " 0 L " + tmp3 + " " + tmp2);
    }
    var size = tmp2;
    var svg = '<svg width="' + size + '" height="' + size + '" xmlns="' + mxConstants2.NS_SVG + '"><defs><pattern id="grid" width="' + tmp2 + '" height="' + tmp2 + '" patternUnits="userSpaceOnUse"><path d="' + d.join(" ") + '" fill="none" stroke="' + color + '" opacity="0.2" stroke-width="1"/><path d="M ' + tmp2 + " 0 L 0 0 0 " + tmp2 + '" fill="none" stroke="' + color + '" stroke-width="1"/></pattern></defs><rect width="100%" height="100%" fill="url(#grid)"/></svg>';
    return svg;
  };
  var mxGraphPanGraph = Graph2.prototype.panGraph;
  Graph2.prototype.panGraph = function(dx, dy) {
    mxGraphPanGraph.apply(this, arguments);
    if (this.shiftPreview1 != null) {
      var canvas = this.view.canvas;
      if (canvas.ownerSVGElement != null) {
        canvas = canvas.ownerSVGElement;
      }
      var phase = this.gridSize * this.view.scale * this.view.gridSteps;
      var position = -Math.round(phase - mod(this.view.translate.x * this.view.scale + dx, phase)) + "px " + -Math.round(phase - mod(this.view.translate.y * this.view.scale + dy, phase)) + "px";
      canvas.style.backgroundPosition = position;
    }
  };
  Graph2.prototype.updatePageBreaks = function(visible, width, height) {
    var scale = this.view.scale;
    var tr = this.view.translate;
    var fmt = this.pageFormat;
    var ps = scale * this.pageScale;
    var bounds2 = this.view.getBackgroundPageBounds();
    width = bounds2.width;
    height = bounds2.height;
    var bounds = new mxRectangle(scale * tr.x, scale * tr.y, fmt.width * ps, fmt.height * ps);
    visible = visible && Math.min(bounds.width, bounds.height) > this.minPageBreakDist;
    var horizontalCount = visible ? Math.ceil(height / bounds.height) - 1 : 0;
    var verticalCount = visible ? Math.ceil(width / bounds.width) - 1 : 0;
    var right = bounds2.x + width;
    var bottom = bounds2.y + height;
    if (this.horizontalPageBreaks == null && horizontalCount > 0) {
      this.horizontalPageBreaks = [];
    }
    if (this.verticalPageBreaks == null && verticalCount > 0) {
      this.verticalPageBreaks = [];
    }
    var drawPageBreaks = bind(this, function(breaks) {
      if (breaks != null) {
        var count = breaks == this.horizontalPageBreaks ? horizontalCount : verticalCount;
        for (var i = 0; i <= count; i++) {
          var pts = breaks == this.horizontalPageBreaks ? [
            new mxPoint2(Math.round(bounds2.x), Math.round(bounds2.y + (i + 1) * bounds.height)),
            new mxPoint2(Math.round(right), Math.round(bounds2.y + (i + 1) * bounds.height))
          ] : [
            new mxPoint2(Math.round(bounds2.x + (i + 1) * bounds.width), Math.round(bounds2.y)),
            new mxPoint2(Math.round(bounds2.x + (i + 1) * bounds.width), Math.round(bottom))
          ];
          if (breaks[i] != null) {
            breaks[i].points = pts;
            breaks[i].redraw();
          } else {
            var pageBreak = new mxPolyline(pts, this.pageBreakColor);
            pageBreak.dialect = this.dialect;
            pageBreak.isDashed = this.pageBreakDashed;
            pageBreak.pointerEvents = false;
            pageBreak.init(this.view.backgroundPane);
            pageBreak.redraw();
            breaks[i] = pageBreak;
          }
        }
        for (var i = count; i < breaks.length; i++) {
          breaks[i].destroy();
        }
        breaks.splice(count, breaks.length - count);
      }
    });
    drawPageBreaks(this.horizontalPageBreaks);
    drawPageBreaks(this.verticalPageBreaks);
  };
  var mxGraphHandlerShouldRemoveCellsFromParent = mxGraphHandler.prototype.shouldRemoveCellsFromParent;
  mxGraphHandler.prototype.shouldRemoveCellsFromParent = function(parent2, cells, evt) {
    for (var i = 0; i < cells.length; i++) {
      if (this.graph.isTableCell(cells[i]) || this.graph.isTableRow(cells[i])) {
        return false;
      } else if (this.graph.getModel().isVertex(cells[i])) {
        var geo = this.graph.getCellGeometry(cells[i]);
        if (geo != null && geo.relative) {
          return false;
        }
      }
    }
    return mxGraphHandlerShouldRemoveCellsFromParent.apply(this, arguments);
  };
  var mxConnectionHandlerCreateMarker = mxConnectionHandler.prototype.createMarker;
  mxConnectionHandler.prototype.createMarker = function() {
    var marker = mxConnectionHandlerCreateMarker.apply(this, arguments);
    marker.intersects = bind(this, function(state2, evt) {
      if (this.isConnecting()) {
        return true;
      }
      return mxCellMarker.prototype.intersects.apply(marker, arguments);
    });
    return marker;
  };
  mxGraphView.prototype.createBackgroundPageShape = function(bounds) {
    return new mxRectangleShape(bounds, "#ffffff", this.graph.defaultPageBorderColor);
  };
  mxGraphView.prototype.getBackgroundPageBounds = function() {
    var gb = this.getGraphBounds();
    var x = gb.width > 0 ? gb.x / this.scale - this.translate.x : 0;
    var y = gb.height > 0 ? gb.y / this.scale - this.translate.y : 0;
    var w2 = gb.width / this.scale;
    var h2 = gb.height / this.scale;
    var fmt = this.graph.pageFormat;
    var ps = this.graph.pageScale;
    var pw = fmt.width * ps;
    var ph = fmt.height * ps;
    var x0 = Math.floor(Math.min(0, x) / pw);
    var y0 = Math.floor(Math.min(0, y) / ph);
    var xe = Math.ceil(Math.max(1, x + w2) / pw);
    var ye = Math.ceil(Math.max(1, y + h2) / ph);
    var rows = xe - x0;
    var cols = ye - y0;
    var bounds = new mxRectangle(this.scale * (this.translate.x + x0 * pw), this.scale * (this.translate.y + y0 * ph), this.scale * rows * pw, this.scale * cols * ph);
    return bounds;
  };
  var graphPanGraph = Graph2.prototype.panGraph;
  Graph2.prototype.panGraph = function(dx, dy) {
    graphPanGraph.apply(this, arguments);
    if (this.dialect != mxConstants2.DIALECT_SVG && this.view.backgroundPageShape != null && (!this.useScrollbarsForPanning || !hasScrollbars(this.container))) {
      this.view.backgroundPageShape.node.style.marginLeft = dx + "px";
      this.view.backgroundPageShape.node.style.marginTop = dy + "px";
    }
  };
  var mxPopupMenuAddItem = mxPopupMenu.prototype.addItem;
  mxPopupMenu.prototype.addItem = function(title, image, funct, parent2, iconCls, enabled) {
    var result2 = mxPopupMenuAddItem.apply(this, arguments);
    if (enabled != null && !enabled) {
      mxEvent2.addListener(result2, "mousedown", function(evt) {
        mxEvent2.consume(evt);
      });
    }
    return result2;
  };
  var mxGraphHandlerIsPropagateSelectionCell = mxGraphHandler.prototype.isPropagateSelectionCell;
  mxGraphHandler.prototype.isPropagateSelectionCell = function(cell2, immediate, me) {
    var result2 = false;
    var parent2 = this.graph.model.getParent(cell2);
    if (immediate) {
      var geo = this.graph.model.isEdge(cell2) ? null : this.graph.getCellGeometry(cell2);
      result2 = !this.graph.model.isEdge(parent2) && !this.graph.isSiblingSelected(cell2) && (geo != null && geo.relative || !this.graph.isContainer(parent2) || this.graph.isPart(cell2));
    } else {
      result2 = mxGraphHandlerIsPropagateSelectionCell.apply(this, arguments);
      if (this.graph.isTableCell(cell2) || this.graph.isTableRow(cell2)) {
        var table = parent2;
        if (!this.graph.isTable(table)) {
          table = this.graph.model.getParent(table);
        }
        result2 = !this.graph.selectionCellsHandler.isHandled(table) || this.graph.isCellSelected(table) && this.graph.isToggleEvent(me.getEvent()) || this.graph.isCellSelected(cell2) && !this.graph.isToggleEvent(me.getEvent()) || this.graph.isTableCell(cell2) && this.graph.isCellSelected(parent2);
      }
    }
    return result2;
  };
  mxPopupMenuHandler.prototype.getCellForPopupEvent = function(me) {
    var cell2 = me.getCell();
    var model = this.graph.getModel();
    var parent2 = model.getParent(cell2);
    var state2 = this.graph.view.getState(parent2);
    var selected = this.graph.isCellSelected(cell2);
    while (state2 != null && (model.isVertex(parent2) || model.isEdge(parent2))) {
      var temp2 = this.graph.isCellSelected(parent2);
      selected = selected || temp2;
      if (temp2 || !selected && (this.graph.isTableCell(cell2) || this.graph.isTableRow(cell2))) {
        cell2 = parent2;
      }
      parent2 = model.getParent(parent2);
    }
    return cell2;
  };
})();
Editor2.prototype.findThreagileElementForCell = function(cell2) {
  const logPrefix = "[FIND_THREAGILE_MULTI]";
  if (!cell2) {
    console.warn(`${logPrefix} Input cell is null or undefined.`);
    return null;
  }
  const cellId = cell2.getId();
  if (!this.graph || !this.graph.getModel()) {
    console.warn(`${logPrefix} Prerequisite missing: graph or graphModel for cell ${cellId}.`);
    return null;
  }
  const model = this.graph.getModel();
  const threagileModel = model.threagile;
  if (!threagileModel) {
    console.warn(`${logPrefix} Prerequisite missing: graph.model.threagile is not available for cell ${cellId}.`);
    return null;
  }
  if (typeof threagileModel.getIn !== "function") {
    console.error(`${logPrefix} Prerequisite missing: graph.model.threagile does not have a 'getIn' method for cell ${cellId}. Cannot retrieve data.`);
    return null;
  }
  let elementInfo = null;
  let threagileRawData = void 0;
  let dataPath = null;
  const deepCopyThreagileData = (rawData) => {
    if (rawData === null || typeof rawData === "undefined") {
      return null;
    }
    try {
      const dataToCopy = typeof rawData.toJSON === "function" ? rawData.toJSON() : rawData;
      if (dataToCopy !== null && typeof dataToCopy !== "undefined") {
        return JSON.parse(JSON.stringify(dataToCopy));
      }
    } catch (e) {
      console.error(`${logPrefix} Error during deep copy:`, e, "Raw data:", rawData);
    }
    return null;
  };
  try {
    if (model.isEdge(cell2)) {
      console.log(`${logPrefix} Cell ${cellId} is an Edge. Checking for Communication Link.`);
      const sourceCell = model.getTerminal(cell2, true);
      const sourceAssetKey = sourceCell?.value?.technicalAsset?.key;
      const commLinkKey = cell2.value?.communicationAsset?.key ?? cell2.communicationAssetKey;
      if (sourceAssetKey && commLinkKey) {
        console.log(`${logPrefix} Comm Link keys found: sourceAssetKey=${sourceAssetKey}, commLinkKey=${commLinkKey}`);
        dataPath = ["technical_assets", sourceAssetKey, "communication_links", commLinkKey];
        threagileRawData = threagileModel.getIn(dataPath);
        const deepCopiedData = deepCopyThreagileData(threagileRawData);
        if (deepCopiedData) {
          elementInfo = {
            id: commLinkKey,
            type: "communicationLink",
            data: deepCopiedData,
            context: { sourceAssetKey }
          };
          console.log(`${logPrefix} Found Communication Link data for ${commLinkKey}.`);
        }
      } else {
        console.warn(`${logPrefix} Edge ${cellId} missing sourceAssetKey (${sourceAssetKey}) or commLinkKey (${commLinkKey}). Check cell/source cell value properties.`);
      }
    } else if (model.isVertex(cell2)) {
      console.log(`${logPrefix} Cell ${cellId} is a Vertex. Checking for Trust Boundary or Technical Asset.`);
      const trustBoundaryKey = cell2.trust_boundarieskey;
      if (trustBoundaryKey) {
        console.log(`${logPrefix} Vertex key found: trustBoundaryKey=${trustBoundaryKey}`);
        dataPath = ["trust_boundaries", trustBoundaryKey];
        threagileRawData = threagileModel.getIn(dataPath);
        const deepCopiedData = deepCopyThreagileData(threagileRawData);
        if (deepCopiedData) {
          elementInfo = {
            id: trustBoundaryKey,
            type: "trustBoundary",
            data: deepCopiedData
          };
          console.log(`${logPrefix} Found Trust Boundary data for ${trustBoundaryKey}.`);
        }
      } else {
        const assetKey = cell2.technicalAsset?.key;
        if (assetKey) {
          console.log(`${logPrefix} Vertex key found: assetKey=${assetKey}`);
          dataPath = ["technical_assets", assetKey];
          threagileRawData = threagileModel.getIn(dataPath);
          const deepCopiedData = deepCopyThreagileData(threagileRawData);
          if (deepCopiedData) {
            elementInfo = {
              id: assetKey,
              type: "technicalAsset",
              data: deepCopiedData
            };
            console.log(`${logPrefix} Found Technical Asset data for ${assetKey}.`);
          }
        } else {
          console.warn(`${logPrefix} Vertex ${cellId} is not identified as a linked Trust Boundary or Technical Asset. Missing relevant key in cell value.`);
        }
      }
    } else {
      console.log(`${logPrefix} Cell ${cellId} is not an Edge or Vertex. Type: ${cell2.constructor.name}. Ignoring for Threagile data.`);
    }
    if (dataPath && !elementInfo) {
      console.log(`${logPrefix} Data retrieval failed or data was invalid/empty for path: ${dataPath.join(".")}`);
    }
  } catch (error2) {
    const pathInfo = dataPath ? ` at path ${dataPath.join(".")}` : "";
    console.error(`${logPrefix} Error processing cell ${cellId}${pathInfo}:`, error2);
    return null;
  }
  if (elementInfo) {
    console.log(`${logPrefix} Success: Returning elementInfo for cell ${cellId}`, elementInfo);
  } else {
    console.log(`${logPrefix} Finished processing cell ${cellId}. No associated Threagile element data found.`);
  }
  return elementInfo;
};
function findIdInTrustBoundaryAssets(model, idToFind) {
  console.log(`>>> Starting search for Asset ID '${idToFind}' within trust boundary assets...`);
  const foundPaths = [];
  const isYAMLMap = (val) => val && typeof val.get === "function";
  const isYAMLSequence = (val) => val && val.items && Array.isArray(val.items);
  if (!model || !model.has || !model.has("trust_boundaries")) {
    console.log("  No 'trust_boundaries' section found in the model.");
    return foundPaths;
  }
  const trustBoundariesYAML = model.get("trust_boundaries");
  if (!isYAMLMap(trustBoundariesYAML)) {
    console.warn("  'trust_boundaries' section is not a valid YAML map. Cannot search.");
    return foundPaths;
  }
  const trustBoundariesJS = trustBoundariesYAML.toJSON();
  Object.keys(trustBoundariesJS).forEach((boundaryKey) => {
    const boundaryYAML = trustBoundariesYAML.get(boundaryKey);
    if (!isYAMLMap(boundaryYAML)) {
      console.warn(`    Skipping trust boundary [${boundaryKey}]: Not a valid YAML map.`);
      return;
    }
    if (boundaryYAML.has("technical_assets_inside")) {
      const assetsInsideSeq = boundaryYAML.get("technical_assets_inside", true);
      if (isYAMLSequence(assetsInsideSeq)) {
        console.log(`    Checking 'technical_assets_inside' list within [${boundaryKey}] for ID: ${idToFind}`);
        for (let index = assetsInsideSeq.items.length - 1; index >= 0; index--) {
          const item = assetsInsideSeq.items[index];
          const itemValue = item && typeof item.value !== "undefined" && item.constructor?.name === "Scalar" ? item.value : item;
          if (itemValue === idToFind) {
            const fullPath = `trust_boundaries[${boundaryKey}].technical_assets_inside[${index}]`;
            console.log(`      FOUND reference to ID '${idToFind}' at path: ${fullPath}. Removing...`);
            foundPaths.push(fullPath);
            const deleted = assetsInsideSeq.delete(index);
            if (deleted) {
              console.log(`      Successfully removed item originally at index ${index}.`);
            } else {
              console.error(`      Failed to remove item at index ${index}.`);
            }
          }
        }
      } else {
        console.log(`    'technical_assets_inside' in [${boundaryKey}] is not a sequence.`);
      }
    }
  });
  console.log(`>>> Trust boundary asset search finished for '${idToFind}'. Found ${foundPaths.length} occurrences.`);
  return foundPaths;
}
function parsePathString(pathString) {
  if (!pathString)
    return [];
  const segments = [];
  const regex = /\.([^.[\]]+)|\[([^\]]+)]/g;
  let lastIndex = 0;
  const firstDelimiter = pathString.search(/[.[]/);
  if (firstDelimiter === 0) {
  } else if (firstDelimiter === -1) {
    segments.push(pathString);
    lastIndex = pathString.length;
  } else {
    segments.push(pathString.substring(0, firstDelimiter));
    lastIndex = firstDelimiter;
  }
  let match2;
  regex.lastIndex = lastIndex;
  while ((match2 = regex.exec(pathString)) !== null) {
    const segment = match2[1] || match2[2];
    if (match2[2] && /^\d+$/.test(segment)) {
      segments.push(parseInt(segment, 10));
    } else {
      segments.push(segment);
    }
    lastIndex = regex.lastIndex;
  }
  return segments;
}

// js/graph/mxClipboard.js
var mxClipboard = {
  STEPSIZE: 10,
  insertCount: 1,
  cells: null,
  setCells: function(cells) {
    mxClipboard.cells = cells;
  },
  getCells: function() {
    return mxClipboard.cells;
  },
  isEmpty: function() {
    return mxClipboard.getCells() == null;
  },
  cut: function(graph, cells) {
    cells = mxClipboard.copy(graph, cells);
    mxClipboard.insertCount = 0;
    mxClipboard.removeCells(graph, cells);
    return cells;
  },
  removeCells: function(graph, cells) {
    graph.removeCells(cells);
  },
  copy: function(graph, cells) {
    cells = cells || graph.getSelectionCells();
    const result2 = graph.getExportableCells(graph.model.getTopmostCells(cells));
    mxClipboard.insertCount = 1;
    mxClipboard.setCells(graph.cloneCells(result2));
    return result2;
  },
  paste: function(graph) {
    let cells = null;
    if (!mxClipboard.isEmpty()) {
      cells = graph.getImportableCells(mxClipboard.getCells());
      const delta = mxClipboard.insertCount * mxClipboard.STEPSIZE;
      const parent2 = graph.getDefaultParent();
      cells = graph.importCells(cells, delta, delta, parent2);
      mxClipboard.insertCount++;
      graph.setSelectionCells(cells);
    }
    return cells;
  }
};

// js/Actions.js
var ASSET_IMAGE_MAP = {
  by_tag: {
    "role:cloud-architect": { image: "images/cloud_architect.png", width: 60 },
    "service-type:frontend": { image: "images/web_frontend_icon.png" },
    "pii-storage": { image: "images/pii_data_icon.png", height: 50 }
  },
  by_technology: {}
};
function getCustomAssetImage(assetKey, threagileModel) {
  const assetData = threagileModel?.getIn(["technical_assets", assetKey])?.toJSON();
  if (!assetData) {
    return null;
  }
  const assetTags = assetData.tags || [];
  const assetTechnology = assetData.technology;
  const imageMaps = ASSET_IMAGE_MAP;
  if (imageMaps.by_tag && typeof imageMaps.by_tag === "object") {
    for (const tag of assetTags) {
      if (imageMaps.by_tag.hasOwnProperty(tag)) {
        const config = imageMaps.by_tag[tag];
        if (config && typeof config.image === "string") {
          return config;
        }
      }
    }
  }
  if (imageMaps.by_technology && typeof imageMaps.by_technology === "object" && assetTechnology) {
    if (imageMaps.by_technology.hasOwnProperty(assetTechnology)) {
      const config = imageMaps.by_technology[assetTechnology];
      if (config && typeof config.image === "string") {
        return config;
      }
    }
  }
  return null;
}
function checkIdExists(graph, id) {
  var exists = graph.model.threagile.getIn(["technical_assets", id, "id"]);
  return !!exists;
}
function generateUniquedataId(graph) {
  var newId;
  do {
    newId = generateRandomId("da-", 25);
  } while (checkIdExists(graph, newId));
  return newId;
}
function generateRandomId(prefix, totalLength) {
  let randomPart = "";
  while (randomPart.length + prefix.length < totalLength) {
    randomPart += Math.random().toString(36).substr(2);
  }
  return prefix + randomPart.substring(0, totalLength - prefix.length);
}
function normalizeTrustBoundaryListsOnDocument(doc) {
  console.log("Normalizing trust boundary lists (technical_assets_inside, trust_boundaries_nested) on Document object...");
  if (!doc || !doc.contents || typeof doc.hasIn !== "function") {
    console.warn("Input is not a valid YAML Document object or has no contents.");
    return doc;
  }
  const trustBoundariesPath = ["trust_boundaries"];
  if (doc.hasIn(trustBoundariesPath)) {
    const trustBoundariesNode = doc.getIn(trustBoundariesPath, true);
    if (trustBoundariesNode && typeof trustBoundariesNode.items !== "undefined" && Array.isArray(trustBoundariesNode.items)) {
      const boundaryIds = trustBoundariesNode.items.map((pair) => {
        if (pair.key && typeof pair.key.value !== "undefined") {
          return pair.key.value;
        }
        return null;
      }).filter((id) => id !== null);
      boundaryIds.forEach((boundaryId) => {
        console.log(`Checking boundary: ${boundaryId}`);
        const basePath2 = ["trust_boundaries", boundaryId];
        const assetsPath = [...basePath2, "technical_assets_inside"];
        const currentAssetsValue = doc.getIn(assetsPath);
        if (currentAssetsValue == null) {
          console.log(`  - Found null/undefined 'technical_assets_inside' for ${boundaryId}. Setting to empty sequence node.`);
          doc.setIn(assetsPath, doc.createNode([]));
        }
        const nestedPath = [...basePath2, "trust_boundaries_nested"];
        const currentNestedValue = doc.getIn(nestedPath);
        if (currentNestedValue == null) {
          console.log(`  - Found null/undefined 'trust_boundaries_nested' for ${boundaryId}. Setting to empty sequence node.`);
          doc.setIn(nestedPath, doc.createNode([]));
        }
      });
    } else {
      console.warn("Trust boundaries node is not a recognized map structure.");
    }
  } else {
    console.log("No 'trust_boundaries' key found at the document root.");
  }
  console.log("Normalization on Document object complete.");
  return doc;
}
function Actions(editorUi) {
  this.editorUi = editorUi;
  this.actions = new Object();
  this.init();
}
function camelToSnakeCase(str) {
  return str;
}
function keysToSnakeCase(obj, depth = 0) {
  if (typeof obj !== "object" || obj === null)
    return obj;
  if (Array.isArray(obj)) {
    return obj.map((item) => keysToSnakeCase(item, depth));
  }
  const recurseKeys = [
    "DataAssets",
    "TechnicalAssets",
    "TrustBoundaries",
    "SharedRuntime",
    "RiskTracking"
  ];
  return Object.keys(obj).reduce((accum, key) => {
    const newKey = camelToSnakeCase(key);
    if (depth < 2 && typeof obj[key] === "object" && obj[key] !== null) {
      accum[newKey] = keysToSnakeCase(obj[key], recurseKeys.includes(newKey) ? depth + 1 : depth);
    } else {
      accum[newKey] = obj[key];
    }
    return accum;
  }, {});
}
Actions.prototype.init = function() {
  var MyAction = this;
  var ui = this.editorUi;
  var editor = ui.editor;
  var graph = editor.graph;
  var isGraphEnabled = function() {
    return Action.prototype.isEnabled.apply(this, arguments) && graph.isEnabled();
  };
  this.addAction("new...", function() {
    graph.openLink(ui.getUrl());
  });
  this.addAction("open...", function() {
    window.openNew = true;
    window.openKey = "open";
    ui.openFile();
  });
  this.addAction("import...", function() {
    window.openNew = false;
    window.openKey = "import";
    window.openFile = new OpenFile(bind(this, function() {
      ui.hideDialog();
    }));
    function addStyles() {
      const style = document.createElement("style");
      style.textContent = `
          .loading-bar-container {
              position: fixed;
              top: 50%;
              left: 50%;
              transform: translate(-50%, -50%);
              width: 60%;
              background: #fff;
              padding: 20px;
              box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
              border-radius: 5px;
              text-align: center;
              z-index: 1000;
          }
  
          .loading-bar {
              width: 100%;
              height: 20px;
              background: #ddd;
              margin-top: 10px;
              border-radius: 5px;
              overflow: hidden;
          }
  
          .loading-bar-progress {
              height: 100%;
              width: 0%;
              background: linear-gradient(to right, #4caf50, #81c784);
              transition: width 0.4s ease;
          }
  
          .loading-text {
              font-size: 16px;
              color: #333;
          }
      `;
      document.head.appendChild(style);
    }
    function createLoadingBar() {
      addStyles();
      const container = document.createElement("div");
      container.className = "loading-bar-container";
      container.innerHTML = `
        <div class="loading-text">Initializing import...</div>
        <div class="loading-bar">
            <div class="loading-bar-progress"></div>
        </div>
    `;
      document.body.appendChild(container);
      const progressBar = container.querySelector(".loading-bar-progress");
      const loadingText = container.querySelector(".loading-text");
      function updateProgress(percent, message) {
        progressBar.style.width = `${percent}%`;
        loadingText.textContent = message;
      }
      function hideLoadingBar() {
        document.body.removeChild(container);
      }
      return { updateProgress, hideLoadingBar };
    }
    window.openFile.setConsumer(bind(this, function(xml2, filename) {
      let eventsEnabled = graph.isEventsEnabled();
      graph.setEventsEnabled(false);
      let layoutEnabled = graph.isEnabled();
      graph.setEnabled(false);
      try {
        if (filename.endsWith(".yaml")) {
          let applyTransform = function(coord, scale, translate) {
            return coord * scale + translate;
          };
          const loadingBar = createLoadingBar();
          const startTime = performance.now();
          try {
            graph.model.threagile = normalizeTrustBoundaryListsOnDocument(YAML.parseDocument(xml2));
          } catch (error2) {
            setTimeout(loadingBar.hideLoadingBar, 500);
            console.error("Can not parse: ", error2);
          }
          let jsonObj;
          try {
            let temp2 = window.parseModelViaString(xml2);
            if (temp2 && !temp2.technicalAssets && temp2.includes("$$__ERROR__$$")) {
              setTimeout(loadingBar.hideLoadingBar, 500);
              let errorMessage = temp2.split("$$__ERROR__$$")[1];
              Swal.fire({
                title: '<span style="color: #333; font-family: Arial, sans-serif;">Error Detected!</span>',
                html: `<span style="font-family: Arial, sans-serif;">An error occurred while parsing the JSON object:<br/><strong>Error:</strong> ${errorMessage}</span>`,
                icon: "error",
                iconColor: "#555",
                confirmButtonText: "Close",
                confirmButtonColor: "#aaa",
                confirmButtonAriaLabel: "Close the dialog",
                buttonsStyling: false,
                customClass: {
                  confirmButton: "custom-confirm-button-style",
                  popup: "custom-popup-style"
                },
                background: "#f0f0f0",
                backdrop: "rgba(50, 50, 50, 0.4)",
                didRender: function() {
                  const styleTag = document.createElement("style");
                  styleTag.innerHTML = `
            .custom-confirm-button-style {
                background-color: #aaa;  // More neutral button color
                color: #fff;
                border: none;
                border-radius: 5px;
                padding: 10px 20px;
                font-size: 16px;
                transition: background-color 0.3s ease;
            }
            .custom-confirm-button-style:hover {
                background-color: #999;  // Darker hover effect
            }
            .custom-popup-style {
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
                border-radius: 8px;
            }
        `;
                  document.head.appendChild(styleTag);
                }
              });
              return;
            }
            jsonObj = temp2;
          } catch (error2) {
            console.error("Couldn't parse JSON-Object: ", error2);
            setTimeout(loadingBar.hideLoadingBar, 500);
            alert("Error while parsing JSON-Object: " + error2);
            return;
          }
          let dot = window.printDataFlowDiagramGraphvizDOT();
          let dotJson = window.DOTParser(dot);
          jsonObj = keysToSnakeCase(jsonObj);
          let cnt = 0;
          graph.getModel().diagramData = new Object();
          graph.getModel().diagramData.data_assets = /* @__PURE__ */ new Map();
          loadingBar.updateProgress(30, "Loading data_assets...");
          let cells = [];
          let nodeIdMap = {};
          var vizInstance = window.Viz();
          vizInstance.then(function(vizRendererObject) {
            const svg = vizRendererObject.renderString(dot, {
              format: "svg",
              engine: "dot"
            });
            let parser = new DOMParser();
            let svgDoc = parser.parseFromString(svg, "image/svg+xml");
            let edgeSVGs = svgDoc.querySelectorAll(".edge");
            let nodes = svgDoc.querySelectorAll(".node");
            let coordinates = {};
            graph.getModel().clear();
            let clusters = svgDoc.querySelectorAll(".cluster");
            graph.getModel().beginUpdate();
            for (var i = 0; i < clusters.length; i++) {
              let cluster = clusters[i];
              let polygon = cluster.querySelector("polygon");
              let points = polygon.getAttribute("points");
              let title = cluster.querySelector("title").textContent;
              let titleCluster = cluster.querySelector('text[font-weight="bold"]');
              let fill = polygon.getAttribute("fill");
              let stroke = polygon.getAttribute("stroke");
              let strokeWidth = polygon.getAttribute("stroke-width");
              let coordinatesArray = points.split(" ").map(function(point) {
                var coords = point.split(",");
                var x = parseFloat(coords[0]);
                var y = parseFloat(coords[1]);
                return { x, y };
              });
              let minX = Math.min.apply(null, coordinatesArray.map((coord) => coord.x));
              let maxX = Math.max.apply(null, coordinatesArray.map((coord) => coord.x));
              let minY = Math.min.apply(null, coordinatesArray.map((coord) => coord.y));
              let maxY = Math.max.apply(null, coordinatesArray.map((coord) => coord.y));
              let width = maxX - minX;
              let height = maxY - minY;
              if (!title.includes("space_boundary")) {
                let textWithCoords = ` (x: ${minX}, y: ${minY}) width: ${width} height: ${height}`;
                let clusterStyle = mxConstants2.STYLE_SHAPE + "=rectangle;dashed=1;verticalAlign=top;fontStyle=1;fontSize=18;fillColor=" + fill + ";strokeColor=" + stroke + ";strokeWidth=" + strokeWidth;
                let clusterVertex = graph.insertVertex(null, titleCluster.textContent, titleCluster.textContent, minX, minY, width, height, clusterStyle);
                clusterVertex.setConnectable(false);
                if (titleCluster.textContent) {
                  clusterVertex.trust_boundarieskey = titleCluster.textContent;
                }
              }
            }
            for (var i = 0; i < nodes.length; i++) {
              let node = nodes[i];
              let nodeId = node.getAttribute("id");
              let nodeTitle = node.querySelector("title").textContent;
              let paths = node.querySelectorAll("path");
              let is3DCylinder = paths.length === 2;
              if (node.querySelector("ellipse") != null) {
                let ellipse = node.querySelector("ellipse");
                let cx = parseFloat(ellipse.getAttribute("cx"));
                let cy = parseFloat(ellipse.getAttribute("cy"));
                let rx = parseFloat(ellipse.getAttribute("rx"));
                let ry = parseFloat(ellipse.getAttribute("ry"));
                let fill = ellipse.getAttribute("fill");
                let stroke = ellipse.getAttribute("stroke");
                let strokeWidth = ellipse.getAttribute("stroke-width");
                let x = cx - rx;
                let y = cy - ry;
                let width = 2 * rx;
                let height = 2 * ry;
                coordinates[nodeId] = {
                  x,
                  y,
                  width,
                  height,
                  nodeTitle,
                  shape: "ellipse",
                  fill,
                  stroke,
                  strokeWidth
                };
              } else if (node.querySelector("polygon") != null) {
                let points = node.querySelector("polygon").getAttribute("points");
                let polygon = node.querySelector("polygon");
                let coordinatesArray = points.split(" ").map(function(point) {
                  let coords = point.split(",");
                  let x = parseFloat(coords[0]);
                  let y = parseFloat(coords[1]);
                  return { x, y };
                });
                let fill = polygon.getAttribute("fill");
                let stroke = polygon.getAttribute("stroke");
                let strokeWidth = polygon.getAttribute("stroke-width");
                let minX = Math.min.apply(null, coordinatesArray.map((coord) => coord.x));
                let maxX = Math.max.apply(null, coordinatesArray.map((coord) => coord.x));
                let minY = Math.min.apply(null, coordinatesArray.map((coord) => coord.y));
                let maxY = Math.max.apply(null, coordinatesArray.map((coord) => coord.y));
                let width = maxX - minX;
                let height = maxY - minY;
                console.log(maxY);
                coordinates[nodeId] = {
                  x: minX,
                  y: minY,
                  width,
                  height,
                  nodeTitle,
                  shape: "hexagon",
                  fill,
                  stroke,
                  strokeWidth
                };
              } else if (is3DCylinder) {
                let firstPath = paths[0];
                let d = firstPath.getAttribute("d");
                let values = d.match(/-?[0-9]*\.?[0-9]+/g);
                let valuesFloat = values.map(parseFloat);
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                for (let i2 = 0; i2 < valuesFloat.length; i2 += 2) {
                  let x = valuesFloat[i2];
                  let y = valuesFloat[i2 + 1];
                  minX = Math.min(minX, x);
                  maxX = Math.max(maxX, x);
                  minY = Math.min(minY, y);
                  maxY = Math.max(maxY, y);
                }
                let width = maxX - minX;
                let height = maxY - minY;
                let fill = firstPath.getAttribute("fill");
                let stroke = firstPath.getAttribute("stroke");
                let strokeWidth = firstPath.getAttribute("stroke-width");
                coordinates[nodeId] = {
                  x: minX,
                  y: minY,
                  width,
                  height,
                  nodeTitle,
                  shape: "datastore",
                  fill,
                  stroke,
                  strokeWidth
                };
              }
            }
            let style = graph.getStylesheet().getDefaultEdgeStyle();
            style[mxConstants2.STYLE_EDGE] = mxEdgeStyle.TopToBottom;
            let parent2 = graph.getDefaultParent();
            const defaultStrokeWidth = 2;
            for (let nodeId in coordinates) {
              let nodeCoords = coordinates[nodeId];
              let minX, minY, maxX, maxY;
              minX = nodeCoords.x;
              minY = nodeCoords.y;
              let originalSvgWidth = Math.abs(nodeCoords.width);
              let originalSvgHeight = Math.abs(nodeCoords.height);
              maxX = nodeCoords.x + nodeCoords.width;
              maxY = nodeCoords.y + nodeCoords.height;
              console.log(nodeCoords);
              let nodeElement = svgDoc.querySelector("#" + nodeId);
              let textElement = nodeElement.querySelector('text[font-weight="bold"]');
              if (!textElement) {
                textElement = nodeElement.querySelector('text[text-anchor="start"]');
              }
              let text = textElement.textContent;
              const assetKey = text;
              console.log(text);
              console.log(nodeCoords);
              let vertex;
              const customImageConfig = getCustomAssetImage(assetKey, graph.model.threagile);
              let finalStyleString;
              let currentStrokeWidth = nodeCoords.strokeWidth === null || typeof nodeCoords.strokeWidth === "undefined" ? defaultStrokeWidth : parseFloat(nodeCoords.strokeWidth);
              let commonTextStyle = "fontStyle=1;fontSize=18;";
              let commonStrokeStyle = "strokeColor=" + (nodeCoords.stroke || "black") + ";strokeWidth=" + currentStrokeWidth + ";";
              let commonFillStyle = "fillColor=" + (nodeCoords.fill || "white") + ";";
              let finalVertexWidth = Math.abs(maxX - minX);
              let finalVertexHeight = Math.abs(maxY - minY);
              if (customImageConfig && customImageConfig.image) {
                finalStyleString = "shape=image;image=" + customImageConfig.image + ";verticalLabelPosition=bottom;verticalAlign=top;" + commonTextStyle + commonStrokeStyle + commonFillStyle + "shadow=1;imageAspect=0;";
                if (customImageConfig.width !== void 0) {
                  finalVertexWidth = customImageConfig.width;
                }
                if (customImageConfig.height !== void 0) {
                  finalVertexHeight = customImageConfig.height;
                }
              } else {
                let shapeSpecificStyle;
                if (nodeCoords.shape === "datastore") {
                  shapeSpecificStyle = "shape=datastore;";
                } else if (nodeCoords.shape === "ellipse") {
                  shapeSpecificStyle = "shape=ellipse;";
                } else {
                  shapeSpecificStyle = "shape=" + (nodeCoords.shape || "hexagon") + ";";
                }
                finalStyleString = shapeSpecificStyle + "shadow=1;" + commonTextStyle + commonStrokeStyle + commonFillStyle;
              }
              vertex = graph.insertVertex(parent2, null, text, minX, minY, finalVertexWidth, finalVertexHeight, finalStyleString);
              vertex.technicalAsset = {};
              const idFromModel = graph.model.threagile.getIn(["technical_assets", assetKey, "id"]);
              vertex.technicalAsset["id"] = idFromModel;
              vertex.technicalAsset["key"] = assetKey;
              loadingBar.updateProgress(60, "Loading technical_assets...");
              vertex.setVertex(true);
              nodeIdMap[nodeCoords.nodeTitle] = vertex;
              let bounds = graph.getCellGeometry(vertex);
              let textMetrics = getSizeForString(text, 18, mxConstants2.DEFAULT_FONTFAMILY);
              let textWidth = textMetrics.width;
              let textHeight = textMetrics.height;
              let padding = 20;
              if (bounds.width < textWidth + padding) {
                bounds.width = textWidth + padding;
              }
              if (customImageConfig) {
              } else {
                if (bounds.height < textHeight + padding) {
                  bounds.height = textHeight + padding;
                }
              }
              graph.resizeCell(vertex, bounds);
            }
            const mainGraphObject = dotJson.children?.[0];
            const edgeStmts = mainGraphObject?.children?.filter((child) => child.type === "Edge") ?? [];
            edgeStmts.forEach((edgeStmt, index) => {
              let sourceTitle = edgeStmt.targets?.[0]?.id?.value;
              let targetTitle = edgeStmt.targets?.[1]?.id?.value;
              if (!sourceTitle || !targetTitle) {
                console.warn("Could not extract source or target ID from edge statement:", edgeStmt);
                return;
              }
              let edgeStyle = "edgeStyle=orthogonalEdgeStyle;";
              edgeStyle += "shape=flexArrow;";
              edgeStyle += "endArrow=" + mxConstants2.ARROW_CLASSIC + ";";
              const attributes = edgeStmt.children?.filter((child) => child.type === "Attribute") ?? [];
              const xlabelAttr = attributes.find((attr2) => attr2.key?.value === "xlabel");
              let dotEdgeProtocol = xlabelAttr?.value?.value;
              if (!dotEdgeProtocol) {
                const labelAttr = attributes.find((attr2) => attr2.key?.value === "label");
                dotEdgeProtocol = labelAttr?.value?.value;
                if (!dotEdgeProtocol) {
                  console.warn("DOT edge statement missing 'xlabel' (or 'label') for protocol, cannot reliably match to communication link. Skipping:", edgeStmt);
                  return;
                } else {
                  console.log(`Using 'label' attribute as protocol for edge: ${sourceTitle} -> ${targetTitle}`);
                }
              }
              dotEdgeProtocol = dotEdgeProtocol.replace(/^"(.*)"$/, "$1").replace(/^<.*>$/, "");
              console.log(`Processing DOT edge: ${sourceTitle} -> ${targetTitle} with protocol: ${dotEdgeProtocol}`);
              if (!(sourceTitle in nodeIdMap) || !(targetTitle in nodeIdMap)) {
                console.warn("Invalid edge source or target title found in DOT edge statement, skipping:", sourceTitle, "->", targetTitle);
                return;
              }
              let sourceVertex = nodeIdMap[sourceTitle];
              let targetVertex = nodeIdMap[targetTitle];
              let matchingCommLinkKey = void 0;
              let matchingCommLinkData = void 0;
              if (sourceVertex.technicalAsset?.key && targetVertex.technicalAsset?.id) {
                let sourceAssetKey = sourceVertex.technicalAsset.key;
                let targetAssetId = targetVertex.technicalAsset.id;
                let allLinksForSource = graph.model.threagile.getIn(["technical_assets", sourceAssetKey, "communication_links"]);
                if (allLinksForSource) {
                  let linksData = allLinksForSource.toJSON();
                  matchingCommLinkKey = Object.keys(linksData).find((commLinkKey) => {
                    const link2 = linksData[commLinkKey];
                    return link2.target === targetAssetId && link2.protocol?.toLowerCase() === dotEdgeProtocol.toLowerCase();
                  });
                  if (matchingCommLinkKey) {
                    matchingCommLinkData = linksData[matchingCommLinkKey];
                    console.log(`Matched DOT edge protocol '${dotEdgeProtocol}' to comm link key: ${matchingCommLinkKey}`);
                  } else {
                    console.warn(`Could not find matching communication link in Threagile model for ${sourceAssetKey} -> ${targetAssetId} with protocol '${dotEdgeProtocol}'`);
                  }
                } else {
                  console.warn("No communication_links found in model for source asset:", sourceAssetKey);
                }
              } else {
                console.warn("Source or target vertex missing technicalAsset data for edge matching:", sourceTitle, "->", targetTitle);
              }
              let edge = graph.insertEdge(parent2, null, dotEdgeProtocol, sourceVertex, targetVertex, edgeStyle);
              if (matchingCommLinkKey && matchingCommLinkData) {
                edge.communicationAssetKey = matchingCommLinkKey;
                edge.communicationAsset = graph.model.threagile.getIn(["technical_assets", sourceVertex.technicalAsset.key, "communication_links", matchingCommLinkKey]);
              } else {
                edge.error_no_match = true;
                console.error(`Failed to associate Threagile data to edge: ${sourceTitle} -> ${targetTitle} (${dotEdgeProtocol})`);
              }
              let pathPoints = void 0;
              edgeSVGs.forEach((edgeSVG) => {
                let svgTitle = edgeSVG.querySelector("title")?.textContent;
                let pathElement = edgeSVG.querySelector("path");
                let textElements = edgeSVG.querySelectorAll("text");
                let svgEdgeLabel = "";
                if (textElements && textElements.length > 0) {
                  svgEdgeLabel = textElements[0].textContent;
                }
                let potentialSvgTitle = `${sourceTitle}->${targetTitle}`;
                if (svgTitle === potentialSvgTitle && svgEdgeLabel.toLowerCase() === dotEdgeProtocol.toLowerCase() && pathElement) {
                  let svgPath = pathElement.getAttribute("d");
                  if (svgPath) {
                    let pointsStr = svgPath.match(/([MC L])([^MC L]+)/g);
                    if (pointsStr) {
                      pointsStr.shift();
                      if (pointsStr.length > 0 && !pointsStr[pointsStr.length - 1].includes(",")) {
                        pointsStr.pop();
                      }
                      pathPoints = pointsStr.map((pointString) => {
                        let coords = pointString.trim().split(/[ ,]+/);
                        let x = parseFloat(coords[0]);
                        let y = parseFloat(coords[1]);
                        return new mxPoint2(x, y);
                      }).filter((pt) => !isNaN(pt.x) && !isNaN(pt.y));
                    }
                  }
                  return;
                }
              });
              if (pathPoints && pathPoints.length > 0) {
                let edgeGeometry = edge.getGeometry();
                if (!edgeGeometry) {
                  edgeGeometry = new mxGeometry();
                  edgeGeometry.relative = true;
                }
                edgeGeometry = edgeGeometry.clone();
                edgeGeometry.points = pathPoints;
                graph.getModel().setGeometry(edge, edgeGeometry);
                console.log(`Applied waypoints to edge: ${sourceTitle} -> ${targetTitle} (${dotEdgeProtocol})`);
              } else {
                console.log(`No specific waypoints found/applied for edge: ${sourceTitle} -> ${targetTitle} (${dotEdgeProtocol})`);
              }
            });
            const endTime = performance.now();
            console.log(`Call to doSomething took ${endTime - startTime} milliseconds.`);
            loadingBar.updateProgress(100, "Import complete.");
            setTimeout(loadingBar.hideLoadingBar, 500);
            let cells2 = graph.getModel().cells;
            for (let id in cells2) {
              let cell2 = cells2[id];
              if (cell2.technicalAsset) {
                if (cell2.technicalAsset.communication_links) {
                  delete cell2.technicalAsset.communication_links;
                }
              }
            }
            graph.getModel().endUpdate();
            graph.fit();
            graph.refresh();
            graph.view.revalidate();
            const animator = MyAction.editorUi.communicationAnimator;
            if (animator) {
              let collectCells = function(cell2) {
                allCellsInGraph.push(cell2);
                for (let i2 = 0; i2 < model.getChildCount(cell2); i2++) {
                  collectCells(model.getChildAt(cell2, i2));
                }
              };
              console.log("Triggering animations for imported edges...");
              const model = graph.getModel();
              const allCellsInGraph = [];
              collectCells(model.getRoot());
              allCellsInGraph.forEach((currentCell) => {
                if (currentCell.isEdge()) {
                  animator.triggerAnimationForCell(currentCell);
                }
              });
              console.log("Finished attempting to trigger animations.");
            } else {
              console.warn("CommunicationAnimator instance not found. Animations will not be triggered for import.");
            }
          }).catch(function(error2) {
            setTimeout(loadingBar.hideLoadingBar, 500);
            console.error(error2);
          });
        } else {
        }
      } catch (e) {
        console.log(e);
      } finally {
        graph.setEnabled(layoutEnabled);
        graph.setEventsEnabled(eventsEnabled);
        graph.fit();
        graph.refresh();
        graph.view.revalidate();
      }
    }));
    function getPolygonPoints(coordinates) {
      var points = [];
      for (var i = 0; i < coordinates.length; i++) {
        points.push(coordinates[i].x + "," + coordinates[i].y);
      }
      return points.join(" ");
    }
    function downloadSVG(svgData, fileName) {
      var blob = new Blob([svgData], { type: "image/svg+xml" });
      var url = URL.createObjectURL(blob);
      var link2 = document.createElement("a");
      link2.href = url;
      link2.download = fileName;
      document.body.appendChild(link2);
      link2.click();
      document.body.removeChild(link2);
      URL.revokeObjectURL(url);
    }
    ui.showDialog(new OpenDialog(this).container, 320, 220, true, true, function() {
      window.openFile = null;
    });
  }).isEnabled = isGraphEnabled;
  this.addAction("save", function() {
    ui.saveFile(false);
  }, null, null, Editor2.ctrlKey + "+S").isEnabled = isGraphEnabled;
  this.addAction("saveAs...", function() {
    ui.saveFile(true);
  }, null, null, Editor2.ctrlKey + "+Shift+S").isEnabled = isGraphEnabled;
  this.addAction("export...", function() {
    ui.showDialog(new ExportDialog(ui).container, 300, 296, true, true);
  });
  this.addAction("editDiagram...", function() {
    var dlg = new EditDiagramDialog(ui);
    ui.showDialog(dlg.container, 620, 420, true, false);
    dlg.init();
  });
  this.addAction("pageSetup...", function() {
    ui.showDialog(new PageSetupDialog(ui).container, 320, 220, true, true);
  }).isEnabled = isGraphEnabled;
  this.addAction("print...", function() {
    ui.showDialog(new PrintDialog(ui).container, 300, 180, true, true);
  }, null, "sprite-print", Editor2.ctrlKey + "+P");
  this.addAction("preview", function() {
    show(graph, null, 10, 10);
  });
  this.addAction("undo", function() {
    ui.undo();
  }, null, "sprite-undo", Editor2.ctrlKey + "+Z");
  this.addAction("redo", function() {
    ui.redo();
  }, null, "sprite-redo", !mxClient_default.IS_WIN ? Editor2.ctrlKey + "+Shift+Z" : Editor2.ctrlKey + "+Y");
  this.addAction("cut", function() {
    mxClipboard.cut(graph);
  }, null, "sprite-cut", Editor2.ctrlKey + "+X");
  this.addAction("copy", function() {
    try {
      mxClipboard.copy(graph);
    } catch (e) {
      ui.handleError(e);
    }
  }, null, "sprite-copy", Editor2.ctrlKey + "+C");
  this.addAction("paste", function() {
    if (graph.isEnabled() && !graph.isCellLocked(graph.getDefaultParent())) {
      mxClipboard.paste(graph);
    }
  }, false, "sprite-paste", Editor2.ctrlKey + "+V");
  this.addAction("pasteHere", function(evt) {
    if (graph.isEnabled() && !graph.isCellLocked(graph.getDefaultParent())) {
      graph.getModel().beginUpdate();
      try {
        var cells = mxClipboard.paste(graph);
        if (cells != null) {
          var includeEdges = true;
          for (var i = 0; i < cells.length && includeEdges; i++) {
            includeEdges = includeEdges && graph.model.isEdge(cells[i]);
          }
          var t = graph.view.translate;
          var s = graph.view.scale;
          var dx = t.x;
          var dy = t.y;
          var bb = null;
          if (cells.length == 1 && includeEdges) {
            var geo = graph.getCellGeometry(cells[0]);
            if (geo != null) {
              bb = geo.getTerminalPoint(true);
            }
          }
          bb = bb != null ? bb : graph.getBoundingBoxFromGeometry(cells, includeEdges);
          if (bb != null) {
            var x = Math.round(graph.snap(graph.popupMenuHandler.triggerX / s - dx));
            var y = Math.round(graph.snap(graph.popupMenuHandler.triggerY / s - dy));
            graph.cellsMoved(cells, x - bb.x, y - bb.y);
          }
        }
      } finally {
        graph.getModel().endUpdate();
      }
    }
  });
  this.addAction("copySize", function(evt) {
    var cell2 = graph.getSelectionCell();
    if (graph.isEnabled() && cell2 != null && graph.getModel().isVertex(cell2)) {
      var geo = graph.getCellGeometry(cell2);
      if (geo != null) {
        ui.copiedSize = new mxRectangle(geo.x, geo.y, geo.width, geo.height);
      }
    }
  }, null, null, "Alt+Shift+X");
  this.addAction("pasteSize", function(evt) {
    if (graph.isEnabled() && !graph.isSelectionEmpty() && ui.copiedSize != null) {
      graph.getModel().beginUpdate();
      try {
        var cells = graph.getSelectionCells();
        for (var i = 0; i < cells.length; i++) {
          if (graph.getModel().isVertex(cells[i])) {
            var geo = graph.getCellGeometry(cells[i]);
            if (geo != null) {
              geo = geo.clone();
              geo.width = ui.copiedSize.width;
              geo.height = ui.copiedSize.height;
              graph.getModel().setGeometry(cells[i], geo);
            }
          }
        }
      } finally {
        graph.getModel().endUpdate();
      }
    }
  }, null, null, "Alt+Shift+V");
  function deleteCells(includeEdges) {
    graph.escape();
    var select = graph.deleteCells(graph.getDeletableCells(graph.getSelectionCells()), includeEdges);
    if (select != null) {
      graph.setSelectionCells(select);
    }
  }
  this.addAction("delete", function(evt) {
    deleteCells(evt != null && mxEvent2.isControlDown(evt));
  }, null, null, "Delete");
  this.addAction("deleteAll", function() {
    if (!graph.isSelectionEmpty()) {
      graph.getModel().beginUpdate();
      try {
        var cells = graph.getSelectionCells();
        for (var i = 0; i < cells.length; i++) {
          graph.cellLabelChanged(cells[i], "");
        }
      } finally {
        graph.getModel().endUpdate();
      }
    }
  });
  this.addAction("deleteLabels", function() {
    if (!graph.isSelectionEmpty()) {
      graph.getModel().beginUpdate();
      try {
        var cells = graph.getSelectionCells();
        for (var i = 0; i < cells.length; i++) {
          graph.cellLabelChanged(cells[i], "");
        }
      } finally {
        graph.getModel().endUpdate();
      }
    }
  }, null, null, Editor2.ctrlKey + "+Delete");
  this.addAction("duplicate", function() {
    try {
      graph.setSelectionCells(graph.duplicateCells());
      graph.scrollCellToVisible(graph.getSelectionCell());
    } catch (e) {
      ui.handleError(e);
    }
  }, null, null, Editor2.ctrlKey + "+D");
  this.put("turn", new Action(mxResources2.get("turn") + " / " + mxResources2.get("reverse"), function(evt) {
    graph.turnShapes(graph.getSelectionCells(), evt != null ? mxEvent2.isShiftDown(evt) : false);
  }, null, null, Editor2.ctrlKey + "+R"));
  this.addAction("selectVertices", function() {
    graph.selectVertices(null, true);
  }, null, null, Editor2.ctrlKey + "+Shift+I");
  this.addAction("selectEdges", function() {
    graph.selectEdges();
  }, null, null, Editor2.ctrlKey + "+Shift+E");
  this.addAction("selectAll", function() {
    graph.selectAll(null, true);
  }, null, null, Editor2.ctrlKey + "+A");
  this.addAction("selectNone", function() {
    graph.clearSelection();
  }, null, null, Editor2.ctrlKey + "+Shift+A");
  this.addAction("lockUnlock", function() {
    if (!graph.isSelectionEmpty()) {
      graph.getModel().beginUpdate();
      try {
        var defaultValue = graph.isCellMovable(graph.getSelectionCell()) ? 1 : 0;
        graph.toggleCellStyles(mxConstants2.STYLE_MOVABLE, defaultValue);
        graph.toggleCellStyles(mxConstants2.STYLE_RESIZABLE, defaultValue);
        graph.toggleCellStyles(mxConstants2.STYLE_ROTATABLE, defaultValue);
        graph.toggleCellStyles(mxConstants2.STYLE_DELETABLE, defaultValue);
        graph.toggleCellStyles(mxConstants2.STYLE_EDITABLE, defaultValue);
        graph.toggleCellStyles("connectable", defaultValue);
      } finally {
        graph.getModel().endUpdate();
      }
    }
  }, null, null, Editor2.ctrlKey + "+L");
  this.addAction("home", function() {
    graph.home();
  }, null, null, "Shift+Home");
  this.addAction("exitGroup", function() {
    graph.exitGroup();
  }, null, null, Editor2.ctrlKey + "+Shift+Home");
  this.addAction("enterGroup", function() {
    graph.enterGroup();
  }, null, null, Editor2.ctrlKey + "+Shift+End");
  this.addAction("collapse", function() {
    graph.foldCells(true);
  }, null, null, Editor2.ctrlKey + "+Home");
  this.addAction("expand", function() {
    graph.foldCells(false);
  }, null, null, Editor2.ctrlKey + "+End");
  this.addAction("toFront", function() {
    graph.orderCells(false);
  }, null, null, Editor2.ctrlKey + "+Shift+F");
  this.addAction("toBack", function() {
    graph.orderCells(true);
  }, null, null, Editor2.ctrlKey + "+Shift+B");
  this.addAction("group", function() {
    if (graph.isEnabled()) {
      var cells = sortCells(graph.getSelectionCells(), true);
      if (cells.length == 1 && !graph.isTable(cells[0]) && !graph.isTableRow(cells[0])) {
        graph.setCellStyles("container", "1");
      } else {
        cells = graph.getCellsForGroup(cells);
        if (cells.length > 1) {
          graph.setSelectionCell(graph.groupCells(null, 0, cells));
        }
      }
    }
  }, null, null, Editor2.ctrlKey + "+G");
  this.addAction("ungroup", function() {
    if (graph.isEnabled()) {
      var cells = graph.getSelectionCells();
      graph.model.beginUpdate();
      try {
        var temp2 = graph.ungroupCells();
        if (cells != null) {
          for (var i = 0; i < cells.length; i++) {
            if (graph.model.contains(cells[i])) {
              if (graph.model.getChildCount(cells[i]) == 0 && graph.model.isVertex(cells[i])) {
                graph.setCellStyles("container", "0", [cells[i]]);
              }
              temp2.push(cells[i]);
            }
          }
        }
      } finally {
        graph.model.endUpdate();
      }
      graph.setSelectionCells(temp2);
    }
  }, null, null, Editor2.ctrlKey + "+Shift+U");
  this.addAction("removeFromGroup", function() {
    if (graph.isEnabled()) {
      var cells = graph.getSelectionCells();
      if (cells != null) {
        var temp2 = [];
        for (var i = 0; i < cells.length; i++) {
          if (!graph.isTableRow(cells[i]) && !graph.isTableCell(cells[i])) {
            temp2.push(cells[i]);
          }
        }
        graph.removeCellsFromParent(temp2);
      }
    }
  });
  this.addAction("edit", function() {
    if (graph.isEnabled()) {
      graph.startEditingAtCell();
    }
  }, null, null, "F2/Enter");
  this.addAction("editData...", function() {
    var cell2 = graph.getSelectionCell() || graph.getModel().getRoot();
    ui.showDataDialog(cell2);
  }, null, null, Editor2.ctrlKey + "+M");
  this.addAction("editTooltip...", function() {
    if (graph.isEnabled() && !graph.isSelectionEmpty()) {
      var cell2 = graph.getSelectionCell();
      var tooltip = "";
      if (isNode(cell2.value)) {
        var tmp = null;
        if (Graph.translateDiagram && Graph.diagramLanguage != null && cell2.value.hasAttribute("tooltip_" + Graph.diagramLanguage)) {
          tmp = cell2.value.getAttribute("tooltip_" + Graph.diagramLanguage);
        }
        if (tmp == null) {
          tmp = cell2.value.getAttribute("tooltip");
        }
        if (tmp != null) {
          tooltip = tmp;
        }
      }
      var dlg = new TextareaDialog2(ui, mxResources2.get("editTooltip") + ":", tooltip, function(newValue) {
        graph.setTooltipForCell(cell2, newValue);
      });
      ui.showDialog(dlg.container, 320, 200, true, true);
      dlg.init();
    }
  }, null, null, "Alt+Shift+T");
  this.addAction("openLink", function() {
    var link2 = graph.getLinkForCell(graph.getSelectionCell());
    if (link2 != null) {
      graph.openLink(link2);
    }
  });
  this.addAction("editLink...", function() {
    if (graph.isEnabled() && !graph.isSelectionEmpty()) {
      var cell2 = graph.getSelectionCell();
      var value = graph.getLinkForCell(cell2) || "";
      ui.showLinkDialog(value, mxResources2.get("apply"), function(link2) {
        link2 = trim(link2);
        graph.setLinkForCell(cell2, link2.length > 0 ? link2 : null);
      });
    }
  }, null, null, "Alt+Shift+L");
  this.put("insertImage", new Action(mxResources2.get("image") + "...", function() {
    if (graph.isEnabled() && !graph.isCellLocked(graph.getDefaultParent())) {
      graph.clearSelection();
      ui.actions.get("image").funct();
    }
  })).isEnabled = isGraphEnabled;
  this.put("insertLink", new Action(mxResources2.get("link") + "...", function() {
    if (graph.isEnabled() && !graph.isCellLocked(graph.getDefaultParent())) {
      ui.showLinkDialog("", mxResources2.get("insert"), function(link2, docs) {
        link2 = trim(link2);
        if (link2.length > 0) {
          var icon = null;
          var title = graph.getLinkTitle(link2);
          if (docs != null && docs.length > 0) {
            icon = docs[0].iconUrl;
            title = docs[0].name || docs[0].type;
            title = title.charAt(0).toUpperCase() + title.substring(1);
            if (title.length > 30) {
              title = title.substring(0, 30) + "...";
            }
          }
          var linkCell = new mxCell(title, new mxGeometry(0, 0, 100, 40), "fontColor=#0000EE;fontStyle=4;rounded=1;overflow=hidden;" + (icon != null ? "shape=label;imageWidth=16;imageHeight=16;spacingLeft=26;align=left;image=" + icon : "spacing=10;"));
          linkCell.vertex = true;
          var pt = graph.getCenterInsertPoint(graph.getBoundingBoxFromGeometry([linkCell], true));
          linkCell.geometry.x = pt.x;
          linkCell.geometry.y = pt.y;
          graph.setLinkForCell(linkCell, link2);
          graph.cellSizeUpdated(linkCell, true);
          graph.getModel().beginUpdate();
          try {
            linkCell = graph.addCell(linkCell);
            graph.fireEvent(new mxEventObject2("cellsInserted", "cells", [linkCell]));
          } finally {
            graph.getModel().endUpdate();
          }
          graph.setSelectionCell(linkCell);
          graph.scrollCellToVisible(graph.getSelectionCell());
        }
      });
    }
  })).isEnabled = isGraphEnabled;
  this.addAction("link...", bind(this, function() {
    if (graph.isEnabled()) {
      if (graph.cellEditor.isContentEditing()) {
        var elt = graph.getSelectedElement();
        var link2 = graph.getParentByName(elt, "A", graph.cellEditor.textarea);
        var oldValue = "";
        if (link2 == null && elt != null && elt.getElementsByTagName != null) {
          var links = elt.getElementsByTagName("a");
          for (var i = 0; i < links.length && link2 == null; i++) {
            if (links[i].textContent == elt.textContent) {
              link2 = links[i];
            }
          }
        }
        if (link2 != null && link2.nodeName == "A") {
          oldValue = link2.getAttribute("href") || "";
          graph.selectNode(link2);
        }
        var selState = graph.cellEditor.saveSelection();
        ui.showLinkDialog(oldValue, mxResources2.get("apply"), bind(this, function(value) {
          graph.cellEditor.restoreSelection(selState);
          if (value != null) {
            graph.insertLink(value);
          }
        }));
      } else if (graph.isSelectionEmpty()) {
        this.get("insertLink").funct();
      } else {
        this.get("editLink").funct();
      }
    }
  })).isEnabled = isGraphEnabled;
  this.addAction("autosize", function() {
    var cells = graph.getSelectionCells();
    if (cells != null) {
      graph.getModel().beginUpdate();
      try {
        for (var i = 0; i < cells.length; i++) {
          var cell2 = cells[i];
          if (graph.getModel().getChildCount(cell2)) {
            graph.updateGroupBounds([cell2], 20);
          } else {
            var state2 = graph.view.getState(cell2);
            var geo = graph.getCellGeometry(cell2);
            if (graph.getModel().isVertex(cell2) && state2 != null && state2.text != null && geo != null && graph.isWrapping(cell2)) {
              geo = geo.clone();
              geo.height = state2.text.boundingBox.height / graph.view.scale;
              graph.getModel().setGeometry(cell2, geo);
            } else {
              graph.updateCellSize(cell2);
            }
          }
        }
      } finally {
        graph.getModel().endUpdate();
      }
    }
  }, null, null, Editor2.ctrlKey + "+Shift+Y");
  this.addAction("formattedText", function() {
    var refState = graph.getView().getState(graph.getSelectionCell());
    if (refState != null) {
      graph.stopEditing();
      var value = refState.style["html"] == "1" ? null : "1";
      graph.getModel().beginUpdate();
      try {
        var cells = graph.getSelectionCells();
        for (var i = 0; i < cells.length; i++) {
          state = graph.getView().getState(cells[i]);
          if (state != null) {
            var html = getValue(state.style, "html", "0");
            if (html == "1" && value == null) {
              var label = graph.convertValueToString(state.cell);
              if (getValue(state.style, "nl2Br", "1") != "0") {
                label = label.replace(/\n/g, "").replace(/<br\s*.?>/g, "\n");
              }
              var temp2 = document.createElement("div");
              temp2.innerHTML = graph.sanitizeHtml(label);
              label = extractTextWithWhitespace(temp2.childNodes);
              graph.cellLabelChanged(state.cell, label);
              graph.setCellStyles("html", value, [cells[i]]);
            } else if (html == "0" && value == "1") {
              var label = htmlEntities(graph.convertValueToString(state.cell), false);
              if (getValue(state.style, "nl2Br", "1") != "0") {
                label = label.replace(/\n/g, "<br/>");
              }
              graph.cellLabelChanged(state.cell, graph.sanitizeHtml(label));
              graph.setCellStyles("html", value, [cells[i]]);
            }
          }
        }
        ui.fireEvent(new mxEventObject2("styleChanged", "keys", ["html"], "values", [value != null ? value : "0"], "cells", cells));
      } finally {
        graph.getModel().endUpdate();
      }
    }
  });
  this.addAction("wordWrap", function() {
    var state2 = graph.getView().getState(graph.getSelectionCell());
    var value = "wrap";
    graph.stopEditing();
    if (state2 != null && state2.style[mxConstants2.STYLE_WHITE_SPACE] == "wrap") {
      value = null;
    }
    graph.setCellStyles(mxConstants2.STYLE_WHITE_SPACE, value);
  });
  this.addAction("rotation", function() {
    var value = "0";
    var state2 = graph.getView().getState(graph.getSelectionCell());
    if (state2 != null) {
      value = state2.style[mxConstants2.STYLE_ROTATION] || value;
    }
    var dlg = new FilenameDialog2(ui, value, mxResources2.get("apply"), function(newValue) {
      if (newValue != null && newValue.length > 0) {
        graph.setCellStyles(mxConstants2.STYLE_ROTATION, newValue);
      }
    }, mxResources2.get("enterValue") + " (" + mxResources2.get("rotation") + " 0-360)");
    ui.showDialog(dlg.container, 375, 80, true, true);
    dlg.init();
  });
  this.addAction("resetView", function() {
    graph.zoomTo(1);
    ui.resetScrollbars();
  }, null, null, "Home");
  this.addAction("zoomIn", function(evt) {
    if (graph.isFastZoomEnabled()) {
      graph.lazyZoom(true, true, ui.buttonZoomDelay);
    } else {
      graph.zoomIn();
    }
  }, null, null, Editor2.ctrlKey + " + (Numpad) / Alt+Mousewheel");
  this.addAction("zoomOut", function(evt) {
    if (graph.isFastZoomEnabled()) {
      graph.lazyZoom(false, true, ui.buttonZoomDelay);
    } else {
      graph.zoomOut();
    }
  }, null, null, Editor2.ctrlKey + " - (Numpad) / Alt+Mousewheel");
  this.addAction("fitWindow", function() {
    var bounds = graph.isSelectionEmpty() ? graph.getGraphBounds() : graph.getBoundingBox(graph.getSelectionCells());
    var t = graph.view.translate;
    var s = graph.view.scale;
    bounds.x = bounds.x / s - t.x;
    bounds.y = bounds.y / s - t.y;
    bounds.width /= s;
    bounds.height /= s;
    if (graph.backgroundImage != null) {
      bounds.add(new mxRectangle(0, 0, graph.backgroundImage.width, graph.backgroundImage.height));
    }
    if (bounds.width == 0 || bounds.height == 0) {
      graph.zoomTo(1);
      ui.resetScrollbars();
    } else {
      graph.fitWindow(bounds);
    }
  }, null, null, Editor2.ctrlKey + "+Shift+H");
  this.addAction("fitPage", bind(this, function() {
    if (!graph.pageVisible) {
      this.get("pageView").funct();
    }
    var fmt = graph.pageFormat;
    var ps = graph.pageScale;
    var cw = graph.container.clientWidth - 10;
    var ch = graph.container.clientHeight - 10;
    var scale = Math.floor(20 * Math.min(cw / fmt.width / ps, ch / fmt.height / ps)) / 20;
    graph.zoomTo(scale);
    if (hasScrollbars(graph.container)) {
      var pad = graph.getPagePadding();
      graph.container.scrollTop = pad.y * graph.view.scale - 1;
      graph.container.scrollLeft = Math.min(pad.x * graph.view.scale, (graph.container.scrollWidth - graph.container.clientWidth) / 2) - 1;
    }
  }), null, null, Editor2.ctrlKey + "+J");
  this.addAction("fitTwoPages", bind(this, function() {
    if (!graph.pageVisible) {
      this.get("pageView").funct();
    }
    var fmt = graph.pageFormat;
    var ps = graph.pageScale;
    var cw = graph.container.clientWidth - 10;
    var ch = graph.container.clientHeight - 10;
    var scale = Math.floor(20 * Math.min(cw / (2 * fmt.width) / ps, ch / fmt.height / ps)) / 20;
    graph.zoomTo(scale);
    if (hasScrollbars(graph.container)) {
      var pad = graph.getPagePadding();
      graph.container.scrollTop = Math.min(pad.y, (graph.container.scrollHeight - graph.container.clientHeight) / 2);
      graph.container.scrollLeft = Math.min(pad.x, (graph.container.scrollWidth - graph.container.clientWidth) / 2);
    }
  }), null, null, Editor2.ctrlKey + "+Shift+J");
  this.addAction("fitPageWidth", bind(this, function() {
    if (!graph.pageVisible) {
      this.get("pageView").funct();
    }
    var fmt = graph.pageFormat;
    var ps = graph.pageScale;
    var cw = graph.container.clientWidth - 10;
    var scale = Math.floor(20 * cw / fmt.width / ps) / 20;
    graph.zoomTo(scale);
    if (hasScrollbars(graph.container)) {
      var pad = graph.getPagePadding();
      graph.container.scrollLeft = Math.min(pad.x * graph.view.scale, (graph.container.scrollWidth - graph.container.clientWidth) / 2);
    }
  }));
  this.put("customZoom", new Action(mxResources2.get("custom") + "...", bind(this, function() {
    var dlg = new FilenameDialog2(this.editorUi, parseInt(graph.getView().getScale() * 100), mxResources2.get("apply"), bind(this, function(newValue) {
      var val = parseInt(newValue);
      if (!isNaN(val) && val > 0) {
        graph.zoomTo(val / 100);
      }
    }), mxResources2.get("zoom") + " (%)");
    this.editorUi.showDialog(dlg.container, 300, 80, true, true);
    dlg.init();
  }), null, null, Editor2.ctrlKey + "+0"));
  this.addAction("pageScale...", bind(this, function() {
    var dlg = new FilenameDialog2(this.editorUi, parseInt(graph.pageScale * 100), mxResources2.get("apply"), bind(this, function(newValue) {
      var val = parseInt(newValue);
      if (!isNaN(val) && val > 0) {
        var change = new ChangePageSetup2(ui, null, null, null, val / 100);
        change.ignoreColor = true;
        change.ignoreImage = true;
        graph.model.execute(change);
      }
    }), mxResources2.get("pageScale") + " (%)");
    this.editorUi.showDialog(dlg.container, 300, 80, true, true);
    dlg.init();
  }));
  var action = null;
  action = this.addAction("grid", function() {
    graph.setGridEnabled(!graph.isGridEnabled());
    ui.fireEvent(new mxEventObject2("gridEnabledChanged"));
  }, null, null, Editor2.ctrlKey + "+Shift+G");
  action.setToggleAction(true);
  action.setSelectedCallback(function() {
    return graph.isGridEnabled();
  });
  action.setEnabled(false);
  action = this.addAction("guides", function() {
    graph.graphHandler.guidesEnabled = !graph.graphHandler.guidesEnabled;
    ui.fireEvent(new mxEventObject2("guidesEnabledChanged"));
  });
  action.setToggleAction(true);
  action.setSelectedCallback(function() {
    return graph.graphHandler.guidesEnabled;
  });
  action.setEnabled(false);
  action = this.addAction("tooltips", function() {
    graph.tooltipHandler.setEnabled(!graph.tooltipHandler.isEnabled());
    ui.fireEvent(new mxEventObject2("tooltipsEnabledChanged"));
  });
  action.setToggleAction(true);
  action.setSelectedCallback(function() {
    return graph.tooltipHandler.isEnabled();
  });
  action = this.addAction("collapseExpand", function() {
    var change = new ChangePageSetup2(ui);
    change.ignoreColor = true;
    change.ignoreImage = true;
    change.foldingEnabled = !graph.foldingEnabled;
    graph.model.execute(change);
  });
  action.setToggleAction(true);
  action.setSelectedCallback(function() {
    return graph.foldingEnabled;
  });
  action.isEnabled = isGraphEnabled;
  action = this.addAction("scrollbars", function() {
    ui.setScrollbars(!ui.hasScrollbars());
  });
  action.setToggleAction(true);
  action.setSelectedCallback(function() {
    return graph.scrollbars;
  });
  action = this.addAction("pageView", bind(this, function() {
    ui.setPageVisible(!graph.pageVisible);
  }));
  action.setToggleAction(true);
  action.setSelectedCallback(function() {
    return graph.pageVisible;
  });
  action = this.addAction("connectionArrows", function() {
    graph.connectionArrowsEnabled = !graph.connectionArrowsEnabled;
    ui.fireEvent(new mxEventObject2("connectionArrowsChanged"));
  }, null, null, "Alt+Shift+A");
  action.setToggleAction(true);
  action.setSelectedCallback(function() {
    return graph.connectionArrowsEnabled;
  });
  action = this.addAction("connectionPoints", function() {
    graph.setConnectable(!graph.connectionHandler.isEnabled());
    ui.fireEvent(new mxEventObject2("connectionPointsChanged"));
  }, null, null, "Alt+Shift+P");
  action.setToggleAction(true);
  action.setSelectedCallback(function() {
    return graph.connectionHandler.isEnabled();
  });
  action = this.addAction("copyConnect", function() {
    graph.connectionHandler.setCreateTarget(!graph.connectionHandler.isCreateTarget());
    ui.fireEvent(new mxEventObject2("copyConnectChanged"));
  });
  action.setToggleAction(true);
  action.setSelectedCallback(function() {
    return graph.connectionHandler.isCreateTarget();
  });
  action.isEnabled = isGraphEnabled;
  action = this.addAction("autosave", function() {
    ui.editor.setAutosave(!ui.editor.autosave);
  });
  action.setToggleAction(true);
  action.setSelectedCallback(function() {
    return ui.editor.autosave;
  });
  action.isEnabled = isGraphEnabled;
  action.visible = false;
  this.addAction("help", function() {
    var ext = "";
    if (mxResources2.isLanguageSupported(mxClient_default.language)) {
      ext = "_" + mxClient_default.language;
    }
    graph.openLink(RESOURCES_PATH + "/help" + ext + ".html");
  });
  var showingAbout = false;
  this.put("about", new Action(mxResources2.get("about") + " Threagile+...", function() {
    if (!showingAbout) {
      ui.showDialog(new AboutDialog(ui).container, 320, 380, true, true, function() {
        showingAbout = false;
      });
      showingAbout = true;
    }
  }));
  var toggleFontStyle = bind(this, function(key, style, fn, shortcut) {
    return this.addAction(key, function() {
      if (fn != null && graph.cellEditor.isContentEditing()) {
        fn();
      } else {
        graph.stopEditing(false);
        graph.getModel().beginUpdate();
        try {
          var cells = graph.getSelectionCells();
          graph.toggleCellStyleFlags(mxConstants2.STYLE_FONTSTYLE, style, cells);
          if ((style & mxConstants2.FONT_BOLD) == mxConstants2.FONT_BOLD) {
            graph.updateLabelElements(graph.getSelectionCells(), function(elt) {
              elt.style.fontWeight = null;
              if (elt.nodeName == "B") {
                graph.replaceElement(elt);
              }
            });
          } else if ((style & mxConstants2.FONT_ITALIC) == mxConstants2.FONT_ITALIC) {
            graph.updateLabelElements(graph.getSelectionCells(), function(elt) {
              elt.style.fontStyle = null;
              if (elt.nodeName == "I") {
                graph.replaceElement(elt);
              }
            });
          } else if ((style & mxConstants2.FONT_UNDERLINE) == mxConstants2.FONT_UNDERLINE) {
            graph.updateLabelElements(graph.getSelectionCells(), function(elt) {
              elt.style.textDecoration = null;
              if (elt.nodeName == "U") {
                graph.replaceElement(elt);
              }
            });
          }
          for (var i = 0; i < cells.length; i++) {
            if (graph.model.getChildCount(cells[i]) == 0) {
              graph.autoSizeCell(cells[i], false);
            }
          }
        } finally {
          graph.getModel().endUpdate();
        }
      }
    }, null, null, shortcut);
  });
  toggleFontStyle("bold", mxConstants2.FONT_BOLD, function() {
    document.execCommand("bold", false, null);
  }, Editor2.ctrlKey + "+B");
  toggleFontStyle("italic", mxConstants2.FONT_ITALIC, function() {
    document.execCommand("italic", false, null);
  }, Editor2.ctrlKey + "+I");
  toggleFontStyle("underline", mxConstants2.FONT_UNDERLINE, function() {
    document.execCommand("underline", false, null);
  }, Editor2.ctrlKey + "+U");
  this.addAction("fontColor...", function() {
    ui.menus.pickColor(mxConstants2.STYLE_FONTCOLOR, "forecolor", "000000");
  });
  this.addAction("strokeColor...", function() {
    ui.menus.pickColor(mxConstants2.STYLE_STROKECOLOR);
  });
  this.addAction("fillColor...", function() {
    ui.menus.pickColor(mxConstants2.STYLE_FILLCOLOR);
  });
  this.addAction("gradientColor...", function() {
    ui.menus.pickColor(mxConstants2.STYLE_GRADIENTCOLOR);
  });
  this.addAction("backgroundColor...", function() {
    ui.menus.pickColor(mxConstants2.STYLE_LABEL_BACKGROUNDCOLOR, "backcolor");
  });
  this.addAction("borderColor...", function() {
    ui.menus.pickColor(mxConstants2.STYLE_LABEL_BORDERCOLOR);
  });
  this.addAction("vertical", function() {
    ui.menus.toggleStyle(mxConstants2.STYLE_HORIZONTAL, true);
  });
  this.addAction("shadow", function() {
    ui.menus.toggleStyle(mxConstants2.STYLE_SHADOW);
  });
  this.addAction("solid", function() {
    graph.getModel().beginUpdate();
    try {
      graph.setCellStyles(mxConstants2.STYLE_DASHED, null);
      graph.setCellStyles(mxConstants2.STYLE_DASH_PATTERN, null);
      ui.fireEvent(new mxEventObject2("styleChanged", "keys", [mxConstants2.STYLE_DASHED, mxConstants2.STYLE_DASH_PATTERN], "values", [null, null], "cells", graph.getSelectionCells()));
    } finally {
      graph.getModel().endUpdate();
    }
  });
  this.addAction("dashed", function() {
    graph.getModel().beginUpdate();
    try {
      graph.setCellStyles(mxConstants2.STYLE_DASHED, "1");
      graph.setCellStyles(mxConstants2.STYLE_DASH_PATTERN, null);
      ui.fireEvent(new mxEventObject2("styleChanged", "keys", [mxConstants2.STYLE_DASHED, mxConstants2.STYLE_DASH_PATTERN], "values", ["1", null], "cells", graph.getSelectionCells()));
    } finally {
      graph.getModel().endUpdate();
    }
  });
  this.addAction("dotted", function() {
    graph.getModel().beginUpdate();
    try {
      graph.setCellStyles(mxConstants2.STYLE_DASHED, "1");
      graph.setCellStyles(mxConstants2.STYLE_DASH_PATTERN, "1 4");
      ui.fireEvent(new mxEventObject2("styleChanged", "keys", [mxConstants2.STYLE_DASHED, mxConstants2.STYLE_DASH_PATTERN], "values", ["1", "1 4"], "cells", graph.getSelectionCells()));
    } finally {
      graph.getModel().endUpdate();
    }
  });
  this.addAction("sharp", function() {
    graph.getModel().beginUpdate();
    try {
      graph.setCellStyles(mxConstants2.STYLE_ROUNDED, "0");
      graph.setCellStyles(mxConstants2.STYLE_CURVED, "0");
      ui.fireEvent(new mxEventObject2("styleChanged", "keys", [mxConstants2.STYLE_ROUNDED, mxConstants2.STYLE_CURVED], "values", ["0", "0"], "cells", graph.getSelectionCells()));
    } finally {
      graph.getModel().endUpdate();
    }
  });
  this.addAction("rounded", function() {
    graph.getModel().beginUpdate();
    try {
      graph.setCellStyles(mxConstants2.STYLE_ROUNDED, "1");
      graph.setCellStyles(mxConstants2.STYLE_CURVED, "0");
      ui.fireEvent(new mxEventObject2("styleChanged", "keys", [mxConstants2.STYLE_ROUNDED, mxConstants2.STYLE_CURVED], "values", ["1", "0"], "cells", graph.getSelectionCells()));
    } finally {
      graph.getModel().endUpdate();
    }
  });
  this.addAction("toggleRounded", function() {
    if (!graph.isSelectionEmpty() && graph.isEnabled()) {
      graph.getModel().beginUpdate();
      try {
        var cells = graph.getSelectionCells();
        var style = graph.getCurrentCellStyle(cells[0]);
        var value = getValue(style, mxConstants2.STYLE_ROUNDED, "0") == "1" ? "0" : "1";
        graph.setCellStyles(mxConstants2.STYLE_ROUNDED, value);
        graph.setCellStyles(mxConstants2.STYLE_CURVED, null);
        ui.fireEvent(new mxEventObject2("styleChanged", "keys", [mxConstants2.STYLE_ROUNDED, mxConstants2.STYLE_CURVED], "values", [value, "0"], "cells", graph.getSelectionCells()));
      } finally {
        graph.getModel().endUpdate();
      }
    }
  });
  this.addAction("curved", function() {
    graph.getModel().beginUpdate();
    try {
      graph.setCellStyles(mxConstants2.STYLE_ROUNDED, "0");
      graph.setCellStyles(mxConstants2.STYLE_CURVED, "1");
      ui.fireEvent(new mxEventObject2("styleChanged", "keys", [mxConstants2.STYLE_ROUNDED, mxConstants2.STYLE_CURVED], "values", ["0", "1"], "cells", graph.getSelectionCells()));
    } finally {
      graph.getModel().endUpdate();
    }
  });
  this.addAction("collapsible", function() {
    var state2 = graph.view.getState(graph.getSelectionCell());
    var value = "1";
    if (state2 != null && graph.getFoldingImage(state2) != null) {
      value = "0";
    }
    graph.setCellStyles("collapsible", value);
    ui.fireEvent(new mxEventObject2("styleChanged", "keys", ["collapsible"], "values", [value], "cells", graph.getSelectionCells()));
  });
  this.addAction("editDataAssets", bind(this, function() {
    var model = graph.getModel();
    var dlg = new TextareaDialog2(this.editorUi, "DataAssets:", "SomeStuff", function(newValue) {
      console.log("Neuer Wert:", newValue);
    }, null, null, 400, 220);
    var scrollbar = new graph.mxUtils.scrollbar(dlg.container);
    scrollbar.style.height = "100%";
    scrollbar.style.width = "100%";
    dlg.container.appendChild(scrollbar);
    this.editorUi.showDialog(dlg.container, 420, 800, true, true);
    dlg.init();
  }), null, null, Editor2.ctrlKey + "+E");
  this.addAction("addDataAssets", bind(this, function(list, menu) {
    var listItem = document.createElement("li");
    listItem.style.display = "flex";
    listItem.style.flexDirection = "column";
    listItem.style.padding = "8px";
    listItem.style.borderBottom = "1px solid #ccc";
    var textContainer = document.createElement("div");
    textContainer.style.display = "flex";
    textContainer.style.alignItems = "center";
    textContainer.style.marginBottom = "8px";
    var arrowIcon = document.createElement("img");
    arrowIcon.src = " data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAAagAAAGoB3Bi5tQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAEUSURBVDiNjdO9SgNBFIbhJ4YkhZ2W2tgmphYEsTJiY2Vjk0YbMYVeiKAo2mjlHVhpDBaCoPGnEjtvQLAWRIjF7sJmM9nk7WbO+b6Zc+ZMwSB1bGMRhXivhwec4z2gARWcoo0VlFKxEhq4xQnKIXEbO8PcU+ziJmtyNqY4oYXjZFGPHbNMo5hj0kEVDkU1Z2niCpNDDFZxAF39DUuzgUfMBmJlPMFLzjVhGW+YC8ReJ0aIR9FjvBJmArEKukXU8IfPTEITm1jHd8CgkRw8L5qwLFPyn/EO1SK+sCBq0nMq4UdcY4B9/OIy2SiLhqmVc2LCHq4F+lYWjWdHNCTpWa9gLb72UVpcMEgNW1jS/53vcYGPdPI/rfEvjAsiqsMAAAAASUVORK5CYII=";
    arrowIcon.style.width = "15px";
    arrowIcon.style.height = "15px";
    arrowIcon.style.marginRight = "5px";
    arrowIcon.style.transform = "rotate(270deg)";
    textContainer.insertBefore(arrowIcon, dataText);
    var dataText = document.createElement("div");
    const dataUnique = menu.getAttribute("data-info");
    dataText.textContent = dataUnique + ":";
    const data = {
      id: generateUniquedataId(graph),
      description: "Data blabla.",
      usage: "devops",
      tags: [],
      origin: "Company XYZ",
      owner: "Company XYZ",
      quantity: "very-few",
      confidentiality: "strictly-confidential",
      integrity: "critical",
      availability: "critical",
      justification_cia_rating: "justify"
    };
    const basePath2 = ["data_assets", dataUnique];
    Object.entries(data).forEach(([key, value]) => {
      graph.model.threagile.setIn([...basePath2, key], value);
    });
    var xButton = document.createElement("button");
    xButton.innerHTML = '<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJAQMAAADaX5RTAAAABlBMVEV7mr3///+wksspAAAAAnRSTlP/AOW3MEoAAAAdSURBVAgdY9jXwCDDwNDRwHCwgeExmASygSL7GgB12QiqNHZZIwAAAABJRU5ErkJggg==" alt="X">';
    xButton.style.marginLeft = "auto";
    xButton.style.padding = "5px";
    xButton.style.backgroundColor = "transparent";
    xButton.style.border = "none";
    xButton.style.cursor = "pointer";
    xButton.addEventListener("click", function() {
      var parentListItem = xButton.parentNode.parentNode;
      var parentList = parentListItem.parentNode;
      parentList.removeChild(parentListItem);
      var menuId = graph.model.diagramData.DataAssets.delete(menuId);
    });
    textContainer.appendChild(dataText);
    textContainer.appendChild(xButton);
    listItem.appendChild(textContainer);
    listItem.appendChild(menu);
    function toggleContent() {
      var isHidden = listItem.style.backgroundColor === "lightgray";
      if (isHidden) {
        listItem.style.backgroundColor = "";
        arrowIcon.style.transform = "rotate(270deg)";
        xButton.style.display = "inline-block";
        menu.style.display = "block";
      } else {
        listItem.style.backgroundColor = "lightgray";
        arrowIcon.style.transform = "rotate(90deg)";
        xButton.style.display = "none";
        menu.style.display = "none";
      }
    }
    arrowIcon.addEventListener("click", toggleContent);
    dataText.addEventListener("click", toggleContent);
    list.appendChild(listItem);
  }), null, null, Editor2.ctrlKey + "+E");
  this.addAction("editAssetJustificationOutOfScope...", bind(this, function() {
    var cells = graph.getSelectionCells();
    if (cells != null && cells.length > 0) {
      var cell2 = graph.getSelectionCell();
      if (!cell2.technicalAsset) {
        cell2.technicalAsset = {
          justificationoutofscope: ""
        };
      }
      var descriptionData = cell2.technicalAsset.justificationoutofscope;
      var dlg = new TextareaDialog2(this.editorUi, "Justifcation out of Scope:", descriptionData, function(newValue) {
        if (newValue != null) {
          console.log(newValue);
          cell2.technicalAsset.justificationoutofscope = newValue;
        }
      }, null, null, 400, 220);
      this.editorUi.showDialog(dlg.container, 420, 300, true, true);
      dlg.init();
    }
  }), null, null, Editor2.ctrlKey + "+E");
  this.addAction("editAssetJustificationOftheRating...", bind(this, function() {
    var cells = graph.getSelectionCells();
    if (cells != null && cells.length > 0) {
      var cell2 = graph.getSelectionCell();
      if (!cell2.technicalAsset) {
        cell2.technicalAsset = {
          justificationoftherating: ""
        };
      }
      var descriptionData = cell2.technicalAsset.justificationoftherating;
      var dlg = new TextareaDialog2(this.editorUi, "Justifcation of the rating:", descriptionData, function(newValue) {
        if (newValue != null) {
          console.log(newValue);
          cell2.technicalAsset.justificationoftherating = newValue;
        }
      }, null, null, 400, 220);
      this.editorUi.showDialog(dlg.container, 420, 300, true, true);
      dlg.init();
    }
  }), null, null, Editor2.ctrlKey + "+E");
  this.addAction("editAssetOwner...", bind(this, function() {
    var cells = graph.getSelectionCells();
    if (cells != null && cells.length > 0) {
      var cell2 = graph.getSelectionCell();
      if (!cell2.technicalAsset) {
        cell2.technicalAsset = {
          owner: ""
        };
      }
      var descriptionData = cell2.technicalAsset.owner;
      var dlg = new TextareaDialog2(this.editorUi, "Owner:", descriptionData, function(newValue) {
        if (newValue != null) {
          console.log(newValue);
          cell2.technicalAsset.owner = newValue;
        }
      }, null, null, 400, 220);
      this.editorUi.showDialog(dlg.container, 420, 300, true, true);
      dlg.init();
    }
  }), null, null, Editor2.ctrlKey + "+E");
  this.addAction("editDataDescription...", bind(this, function(evt) {
    var menuId = evt.target.parentNode.id;
    var current2 = graph.model.diagramData.DataAssets.get(menuId);
    if (!current2.description) {
      current2.description = "";
    }
    var descriptionData = current2.description;
    var dlg = new TextareaDialog2(this.editorUi, "Description:", descriptionData, function(newValue) {
      if (newValue != null) {
        current2.description = newValue;
      }
    }, null, null, 400, 220);
    this.editorUi.showDialog(dlg.container, 420, 300, true, true);
    dlg.init();
  }), null, null, Editor2.ctrlKey + "+E");
  this.addAction("editAssetDescription...", bind(this, function() {
    var cells = graph.getSelectionCells();
    if (cells != null && cells.length > 0) {
      var cell2 = graph.getSelectionCell();
      if (!cell2.technicalAsset) {
        cell2.technicalAsset = {
          description: ""
        };
      }
      var descriptionData = cell2.technicalAsset.description;
      var dlg = new TextareaDialog2(this.editorUi, "Description:", descriptionData, function(newValue) {
        if (newValue != null) {
          console.log(newValue);
          cell2.technicalAsset.description = newValue;
        }
      }, null, null, 400, 220);
      this.editorUi.showDialog(dlg.container, 420, 300, true, true);
      dlg.init();
    }
  }), null, null, Editor2.ctrlKey + "+E");
  this.addAction("editStyle...", bind(this, function() {
    var cells = graph.getSelectionCells();
    if (cells != null && cells.length > 0) {
      var model = graph.getModel();
      var dlg = new TextareaDialog2(this.editorUi, mxResources2.get("editStyle") + ":", model.getStyle(cells[0]) || "", function(newValue) {
        if (newValue != null) {
          graph.setCellStyle(trim(newValue), cells);
        }
      }, null, null, 400, 220);
      this.editorUi.showDialog(dlg.container, 420, 300, true, true);
      dlg.init();
    }
  }), null, null, Editor2.ctrlKey + "+E");
  this.addAction("setAsDefaultStyle", function() {
    if (graph.isEnabled() && !graph.isSelectionEmpty()) {
      ui.setDefaultStyle(graph.getSelectionCell());
    }
  }, null, null, Editor2.ctrlKey + "+Shift+D");
  this.addAction("clearDefaultStyle", function() {
    if (graph.isEnabled()) {
      ui.clearDefaultStyle();
    }
  }, null, null, Editor2.ctrlKey + "+Shift+R");
  this.addAction("addWaypoint", function() {
    var cell2 = graph.getSelectionCell();
    if (cell2 != null && graph.getModel().isEdge(cell2)) {
      var handler = editor.graph.selectionCellsHandler.getHandler(cell2);
      if (handler instanceof mxEdgeHandler2) {
        var t = graph.view.translate;
        var s = graph.view.scale;
        var dx = t.x;
        var dy = t.y;
        var parent2 = graph.getModel().getParent(cell2);
        var pgeo = graph.getCellGeometry(parent2);
        while (graph.getModel().isVertex(parent2) && pgeo != null) {
          dx += pgeo.x;
          dy += pgeo.y;
          parent2 = graph.getModel().getParent(parent2);
          pgeo = graph.getCellGeometry(parent2);
        }
        var x = Math.round(graph.snap(graph.popupMenuHandler.triggerX / s - dx));
        var y = Math.round(graph.snap(graph.popupMenuHandler.triggerY / s - dy));
        handler.addPointAt(handler.state, x, y);
      }
    }
  });
  this.addAction("removeWaypoint", function() {
    var rmWaypointAction = ui.actions.get("removeWaypoint");
    if (rmWaypointAction.handler != null) {
      rmWaypointAction.handler.removePoint(rmWaypointAction.handler.state, rmWaypointAction.index);
    }
  });
  this.addAction("clearWaypoints", function() {
    var cells = graph.getSelectionCells();
    if (cells != null) {
      cells = graph.addAllEdges(cells);
      graph.getModel().beginUpdate();
      try {
        for (var i = 0; i < cells.length; i++) {
          var cell2 = cells[i];
          if (graph.getModel().isEdge(cell2)) {
            var geo = graph.getCellGeometry(cell2);
            if (geo != null) {
              geo = geo.clone();
              geo.points = null;
              graph.getModel().setGeometry(cell2, geo);
            }
          }
        }
      } finally {
        graph.getModel().endUpdate();
      }
    }
  }, null, null, "Alt+Shift+C");
  action = this.addAction("subscript", bind(this, function() {
    if (graph.cellEditor.isContentEditing()) {
      document.execCommand("subscript", false, null);
    }
  }), null, null, Editor2.ctrlKey + "+,");
  action = this.addAction("superscript", bind(this, function() {
    if (graph.cellEditor.isContentEditing()) {
      document.execCommand("superscript", false, null);
    }
  }), null, null, Editor2.ctrlKey + "+.");
  action = this.addAction("indent", bind(this, function() {
    if (graph.cellEditor.isContentEditing()) {
      document.execCommand("indent", false, null);
    }
  }), null, null, "Shift+Tab");
  this.addAction("image...", function() {
    if (graph.isEnabled() && !graph.isCellLocked(graph.getDefaultParent())) {
      var title = mxResources2.get("image") + " (" + mxResources2.get("url") + "):";
      var state2 = graph.getView().getState(graph.getSelectionCell());
      var value = "";
      if (state2 != null) {
        value = state2.style[mxConstants2.STYLE_IMAGE] || value;
      }
      var selectionState = graph.cellEditor.saveSelection();
      ui.showImageDialog(title, value, function(newValue, w2, h2) {
        if (graph.cellEditor.isContentEditing()) {
          graph.cellEditor.restoreSelection(selectionState);
          graph.insertImage(newValue, w2, h2);
        } else {
          var cells = graph.getSelectionCells();
          if (newValue != null && (newValue.length > 0 || cells.length > 0)) {
            var select = null;
            graph.getModel().beginUpdate();
            try {
              if (cells.length == 0) {
                cells = [
                  graph.insertVertex(graph.getDefaultParent(), null, "", 0, 0, w2, h2, "shape=image;imageAspect=0;aspect=fixed;verticalLabelPosition=bottom;verticalAlign=top;")
                ];
                var pt = graph.getCenterInsertPoint(graph.getBoundingBoxFromGeometry(cells, true));
                cells[0].geometry.x = pt.x;
                cells[0].geometry.y = pt.y;
                select = cells;
                graph.fireEvent(new mxEventObject2("cellsInserted", "cells", select));
              }
              graph.setCellStyles(mxConstants2.STYLE_IMAGE, newValue.length > 0 ? newValue : null, cells);
              var style = graph.getCurrentCellStyle(cells[0]);
              if (style[mxConstants2.STYLE_SHAPE] != "image" && style[mxConstants2.STYLE_SHAPE] != "label") {
                graph.setCellStyles(mxConstants2.STYLE_SHAPE, "image", cells);
              } else if (newValue.length == 0) {
                graph.setCellStyles(mxConstants2.STYLE_SHAPE, null, cells);
              }
              if (graph.getSelectionCount() == 1) {
                if (w2 != null && h2 != null) {
                  var cell2 = cells[0];
                  var geo = graph.getModel().getGeometry(cell2);
                  if (geo != null) {
                    geo = geo.clone();
                    geo.width = w2;
                    geo.height = h2;
                    graph.getModel().setGeometry(cell2, geo);
                  }
                }
              }
            } finally {
              graph.getModel().endUpdate();
            }
            if (select != null) {
              graph.setSelectionCells(select);
              graph.scrollCellToVisible(select[0]);
            }
          }
        }
      }, graph.cellEditor.isContentEditing(), !graph.cellEditor.isContentEditing());
    }
  }).isEnabled = isGraphEnabled;
  action = this.addAction("layers", bind(this, function() {
    if (this.layersWindow == null) {
      this.layersWindow = new LayersWindow(ui, document.body.offsetWidth - 280, 120, 220, 196);
      this.layersWindow.window.addListener("show", function() {
        ui.fireEvent(new mxEventObject2("layers"));
      });
      this.layersWindow.window.addListener("hide", function() {
        ui.fireEvent(new mxEventObject2("layers"));
      });
      this.layersWindow.window.setVisible(true);
      ui.fireEvent(new mxEventObject2("layers"));
      this.layersWindow.init();
    } else {
      this.layersWindow.window.setVisible(!this.layersWindow.window.isVisible());
    }
  }), null, null, Editor2.ctrlKey + "+Shift+L");
  action.setToggleAction(true);
  action.setSelectedCallback(bind(this, function() {
    return this.layersWindow != null && this.layersWindow.window.isVisible();
  }));
  action = this.addAction("formatPanel", bind(this, function() {
    ui.toggleFormatPanel();
  }), null, null, Editor2.ctrlKey + "+Shift+P");
  action.setToggleAction(true);
  action.setSelectedCallback(bind(this, function() {
    return ui.formatWidth > 0;
  }));
  action = this.addAction("outline", bind(this, function() {
    if (this.outlineWindow == null) {
      this.outlineWindow = new OutlineWindow(ui, document.body.offsetWidth - 260, 100, 180, 180);
      this.outlineWindow.window.addListener("show", function() {
        ui.fireEvent(new mxEventObject2("outline"));
      });
      this.outlineWindow.window.addListener("hide", function() {
        ui.fireEvent(new mxEventObject2("outline"));
      });
      this.outlineWindow.window.setVisible(true);
      ui.fireEvent(new mxEventObject2("outline"));
    } else {
      this.outlineWindow.window.setVisible(!this.outlineWindow.window.isVisible());
    }
  }), null, null, Editor2.ctrlKey + "+Shift+O");
  action.setToggleAction(true);
  action.setSelectedCallback(bind(this, function() {
    return this.outlineWindow != null && this.outlineWindow.window.isVisible();
  }));
};
Actions.prototype.addAction = function(key, funct, enabled, iconCls, shortcut) {
  var title;
  if (key.substring(key.length - 3) == "...") {
    key = key.substring(0, key.length - 3);
    title = mxResources2.get(key) + "...";
  } else {
    title = mxResources2.get(key);
  }
  return this.put(key, new Action(title, funct, enabled, iconCls, shortcut));
};
Actions.prototype.put = function(name, action) {
  this.actions[name] = action;
  return action;
};
Actions.prototype.get = function(name) {
  return this.actions[name];
};
function Action(label, funct, enabled, iconCls, shortcut) {
  mxEventSource.call(this);
  this.label = label;
  this.funct = this.createFunction(funct);
  this.enabled = enabled != null ? enabled : true;
  this.iconCls = iconCls;
  this.shortcut = shortcut;
  this.visible = true;
}
extend(Action, mxEventSource);
Action.prototype.createFunction = function(funct) {
  return funct;
};
Action.prototype.setEnabled = function(value) {
  if (this.enabled != value) {
    this.enabled = value;
    this.fireEvent(new mxEventObject2("stateChanged"));
  }
};
Action.prototype.isEnabled = function() {
  return this.enabled;
};
Action.prototype.setToggleAction = function(value) {
  this.toggleAction = value;
};
Action.prototype.setSelectedCallback = function(funct) {
  this.selectedCallback = funct;
};
Action.prototype.isSelected = function() {
  return this.selectedCallback();
};

// js/animators/CommunicationAnimator.js
var _CommunicationAnimator = class {
  constructor(editorUi) {
    this.editorUi = editorUi;
    this.graph = editorUi.editor.graph;
    this.managedAnimations = /* @__PURE__ */ new Map();
    this.activeAnimatingCellIds = /* @__PURE__ */ new Set();
    this.isPageVisible = !document.hidden;
    this._boundHandleVisibilityChange = this._handleVisibilityChange.bind(this);
    document.addEventListener("visibilitychange", this._boundHandleVisibilityChange, false);
  }
  destroy() {
    document.removeEventListener("visibilitychange", this._boundHandleVisibilityChange);
    this.stopAllAnimations();
  }
  _handleVisibilityChange() {
    if (document.hidden) {
      this.isPageVisible = false;
      this.managedAnimations.forEach((animControl) => {
        animControl._loopActiveState = false;
        if (animControl.timeoutId) {
          clearTimeout(animControl.timeoutId);
          animControl.timeoutId = null;
        }
        const packetsToCancel = new Set(animControl.activePackets);
        packetsToCancel.forEach((packetInstance) => packetInstance?.cancel?.());
        animControl.activePackets.clear();
      });
    } else {
      this.isPageVisible = true;
      const cellIdsToRestart = new Set(this.activeAnimatingCellIds);
      cellIdsToRestart.forEach((cellId) => {
        const cell2 = this.graph.model.getCell(cellId);
        if (cell2 && this.graph.model.contains(cell2)) {
          this.stopAnimationForCell(cellId, false);
          this.triggerAnimationForCell(cell2);
        } else {
          this.activeAnimatingCellIds.delete(cellId);
          this.managedAnimations.delete(cellId);
        }
      });
    }
  }
  mapRiskLevel(value, category) {
    const categoryMap = _CommunicationAnimator.RISK_LEVEL_MAPPINGS[category];
    if (!categoryMap)
      return 0;
    const processedValue = typeof value === "string" ? value.toLowerCase().replace(/[- ]/g, "") : "";
    return categoryMap.hasOwnProperty(processedValue) ? categoryMap[processedValue] : 0;
  }
  _getBoxWidth(el) {
    if (!el)
      return 1;
    let width = el.offsetWidth;
    return width > 0 ? width : parseFloat(_CommunicationAnimator.BASE_PACKET_APPEARANCE.BASE_MIN_WIDTH_PX * this.graph.view.scale) || 1;
  }
  _getBoxHeight(el) {
    if (!el)
      return 1;
    let height = el.offsetHeight;
    return height > 0 ? height : parseFloat(_CommunicationAnimator.BASE_PACKET_APPEARANCE.BASE_HEIGHT_PX * this.graph.view.scale) || 1;
  }
  _generateGibberish(minLength, maxLength) {
    const length = Math.floor(Math.random() * (maxLength - minLength + 1)) + minLength;
    let result2 = "";
    for (let i = 0; i < length; i++) {
      result2 += _CommunicationAnimator.GIBBERISH_CHARSET.charAt(Math.floor(Math.random() * _CommunicationAnimator.GIBBERISH_CHARSET.length));
    }
    return result2.toUpperCase();
  }
  triggerAnimationForCell(cell2) {
    if (!cell2 || typeof cell2.isEdge !== "function" || !cell2.isEdge() || !cell2.value) {
      return;
    }
    this.activeAnimatingCellIds.add(cell2.id);
    if (!this.isPageVisible) {
      return;
    }
    this.stopAnimationForCell(cell2.id, false);
    if (cell2.communicationAssetKey === null || cell2.communicationAssetKey === void 0) {
      this.activeAnimatingCellIds.delete(cell2.id);
      return;
    }
    const commAssetJson = this._getCommunicationAssetJSONObject(cell2);
    if (!commAssetJson) {
      this.activeAnimatingCellIds.delete(cell2.id);
      return;
    }
    const protocol = (commAssetJson.protocol || "").toLowerCase();
    if (!protocol) {
      this.activeAnimatingCellIds.delete(cell2.id);
      return;
    }
    const allThreagileDataAssets = this.editorUi.editor.graph.model.threagile?.toJSON()?.data_assets;
    if (!allThreagileDataAssets) {
      this.activeAnimatingCellIds.delete(cell2.id);
      return;
    }
    const carriedAssetsDetails = this._getCarriedDataAssetsCIA(commAssetJson, allThreagileDataAssets);
    if (carriedAssetsDetails.length === 0) {
      this.activeAnimatingCellIds.delete(cell2.id);
      return;
    }
    const primaryDataAssetCIA = carriedAssetsDetails[0];
    const animationParams = this._determineAnimationParameters(protocol, primaryDataAssetCIA, commAssetJson);
    const sourceCell = this.graph.model.getTerminal(cell2, true);
    const targetCell = this.graph.model.getTerminal(cell2, false);
    if (!sourceCell || !targetCell) {
      this.activeAnimatingCellIds.delete(cell2.id);
      return;
    }
    const animationControl = {
      _loopActiveState: true,
      timeoutId: null,
      activePackets: /* @__PURE__ */ new Set(),
      stop: () => {
        animationControl._loopActiveState = false;
        if (animationControl.timeoutId) {
          clearTimeout(animationControl.timeoutId);
          animationControl.timeoutId = null;
        }
        const packetsToCancel = new Set(animationControl.activePackets);
        packetsToCancel.forEach((packet) => packet?.cancel?.());
        animationControl.activePackets.clear();
      }
    };
    this.managedAnimations.set(cell2.id, animationControl);
    const sendNextPacket = () => {
      if (!this.isPageVisible || !animationControl._loopActiveState) {
        if (animationControl.timeoutId)
          clearTimeout(animationControl.timeoutId);
        animationControl.timeoutId = null;
        return;
      }
      if (!this.graph.model.contains(cell2) || !this.graph.view.getState(cell2)) {
        this.stopAnimationForCell(cell2.id);
        return;
      }
      const packetInstance = this._animate(protocol, cell2, sourceCell, targetCell, animationParams, (eventType, completedInstance) => {
        const currentCellAnimControl = this.managedAnimations.get(cell2.id);
        if (currentCellAnimControl && completedInstance) {
          currentCellAnimControl.activePackets.delete(completedInstance);
        }
      });
      if (packetInstance?.cancel) {
        if (animationControl._loopActiveState && this.isPageVisible) {
          animationControl.activePackets.add(packetInstance);
        } else {
          packetInstance.cancel();
          return;
        }
      } else if (!packetInstance) {
        if (!_CommunicationAnimator.STREAM_ANIMATION_PROTOCOLS.includes(protocol)) {
          this.stopAnimationForCell(cell2.id);
          return;
        }
      }
      if (animationControl._loopActiveState && this.isPageVisible) {
        animationControl.timeoutId = setTimeout(sendNextPacket, animationParams.packetIntervalMs);
      }
    };
    if (this.isPageVisible) {
      sendNextPacket();
    }
  }
  _getCommunicationAssetJSONObject(cell2) {
    const commAssetProperty = cell2.communicationAsset;
    if (commAssetProperty === null || commAssetProperty === void 0)
      return null;
    let jsonObject = null;
    try {
      if (typeof commAssetProperty === "string")
        jsonObject = JSON.parse(commAssetProperty);
      else if (typeof commAssetProperty === "object") {
        if (typeof commAssetProperty.toJSON === "function") {
          const resultOfToJSON = commAssetProperty.toJSON();
          if (typeof resultOfToJSON === "string")
            jsonObject = JSON.parse(resultOfToJSON);
          else if (typeof resultOfToJSON === "object" && resultOfToJSON !== null)
            jsonObject = resultOfToJSON;
          else {
            console.error("commAsset.toJSON() returned invalid type.", { cellId: cell2.id, returned: resultOfToJSON });
            return null;
          }
        } else
          jsonObject = commAssetProperty;
      } else {
        console.error("communicationAsset is not a string or object.", { cellId: cell2.id, type: typeof commAssetProperty });
        return null;
      }
    } catch (e) {
      console.error("Error parsing communicationAsset JSON:", { cellId: cell2.id, error: e, asset: commAssetProperty });
      return null;
    }
    if (typeof jsonObject !== "object" || jsonObject === null) {
      console.error("Could not resolve communicationAsset to a valid JSON object.", { cellId: cell2.id, resolved: jsonObject });
      return null;
    }
    return jsonObject;
  }
  _getCarriedDataAssetsCIA(commAssetJson, allDataAssetsMap) {
    const carriedDetails = [];
    const receivedAssets = commAssetJson.data_assets_received || [];
    const sentAssets = commAssetJson.data_assets_sent || [];
    const allCarriedAssetNames = [.../* @__PURE__ */ new Set([...receivedAssets, ...sentAssets])];
    for (const assetName of allCarriedAssetNames) {
      let dataAsset;
      for (let keyInMap in allDataAssetsMap) {
        if (allDataAssetsMap[keyInMap].id == assetName) {
          dataAsset = allDataAssetsMap[keyInMap];
          break;
        }
      }
      if (dataAsset) {
        carriedDetails.push({ name: assetName, confidentiality: dataAsset.confidentiality || "medium", integrity: dataAsset.integrity || "medium", availability: dataAsset.availability || "medium", quantity: typeof dataAsset.quantity === "string" ? dataAsset.quantity.toLowerCase().replace(/[-_ ]/g, "") : "medium" });
      } else
        console.warn(`Data asset '${assetName}' not found by id in threagile data_assets.`);
    }
    return carriedDetails;
  }
  _determineAnimationParameters(protocol, dataAssetDetails, commAssetJson) {
    const cImpactLevel = this.mapRiskLevel(dataAssetDetails.confidentiality, "impact");
    const iImpactLevel = this.mapRiskLevel(dataAssetDetails.integrity, "impact");
    const aImpactLevel = this.mapRiskLevel(dataAssetDetails.availability, "impact");
    const highImpactThreshold = this.mapRiskLevel("high", "impact");
    const isHighCIARisk = cImpactLevel >= highImpactThreshold || iImpactLevel >= highImpactThreshold || aImpactLevel >= highImpactThreshold;
    const isHighlyConfidential = cImpactLevel >= highImpactThreshold;
    let contentText = "";
    const isEncrypted = _CommunicationAnimator.INHERENTLY_ENCRYPTED_PROTOCOLS.includes(protocol);
    if (isHighlyConfidential && !isEncrypted)
      contentText = _CommunicationAnimator.SENSITIVE_DATA_PLACEHOLDER;
    else if (isEncrypted)
      contentText = this._generateGibberish(2, 4);
    else {
      if (protocol && protocol.length > 0 && protocol.length <= 4)
        contentText = protocol.toUpperCase();
      else if (protocol === _CommunicationAnimator.PROTOCOLS.UnknownProtocol)
        contentText = "???";
      else
        contentText = this._generateGibberish(1, 3);
    }
    const corruptData = !isEncrypted && iImpactLevel < this.mapRiskLevel("medium", "impact");
    let speedFactor, packetIntervalMs;
    const mappedALevel = aImpactLevel || this.mapRiskLevel("medium", "impact");
    if (mappedALevel <= this.mapRiskLevel("low", "impact")) {
      speedFactor = 0.45;
      packetIntervalMs = 3e3;
    } else if (mappedALevel <= this.mapRiskLevel("medium", "impact")) {
      speedFactor = 0.7;
      packetIntervalMs = 1800;
    } else {
      speedFactor = 1.3;
      packetIntervalMs = 700;
    }
    const quantityKey = dataAssetDetails.quantity || "default";
    const sizeMultiplier = _CommunicationAnimator.QUANTITY_SIZE_MULTIPLIERS[quantityKey] || _CommunicationAnimator.QUANTITY_SIZE_MULTIPLIERS["default"];
    const brightnessMultiplier = _CommunicationAnimator.QUANTITY_BRIGHTNESS_MULTIPLIERS[quantityKey] || _CommunicationAnimator.QUANTITY_BRIGHTNESS_MULTIPLIERS["default"];
    return { protocol, text: contentText, isEncrypted, isHighCIARisk, corruptData, speedFactor, durationMs: Math.max(400, 2500 / speedFactor), packetIntervalMs, sizeMultiplier, brightnessMultiplier };
  }
  _corruptText(text) {
    if (!text || text.length === 0)
      return text;
    const chars = text.split("");
    const corruptionChance = 0.4;
    for (let i = 0; i < chars.length; i++) {
      if (Math.random() < corruptionChance) {
        if (Math.random() < 0.7)
          chars[i] = _CommunicationAnimator.CORRUPTION_COMMON_CHARS.charAt(Math.floor(Math.random() * _CommunicationAnimator.CORRUPTION_COMMON_CHARS.length));
        else
          chars[i] = _CommunicationAnimator.CORRUPTION_SYMBOLS[Math.floor(Math.random() * _CommunicationAnimator.CORRUPTION_SYMBOLS.length)];
      }
    }
    return chars.join("");
  }
  _animate(protocol, edge, sourceCell, targetCell, params, onPacketLifecycleEvent) {
    if (_CommunicationAnimator.STREAM_ANIMATION_PROTOCOLS.includes(protocol))
      return this._animateStream(edge, params, onPacketLifecycleEvent);
    else {
      if (protocol !== _CommunicationAnimator.PROTOCOLS.UnknownProtocol && protocol !== _CommunicationAnimator.PROTOCOLS.LocalFileAccess && protocol !== _CommunicationAnimator.PROTOCOLS.InProcessLibraryCall && protocol !== _CommunicationAnimator.PROTOCOLS.ContainerSpawning) {
        console.warn(`No animator registered or _animateStream not suitable for protocol: ${protocol}`);
      }
      if (onPacketLifecycleEvent)
        onPacketLifecycleEvent("cancelled", null);
      return null;
    }
  }
  _animateStream(edge, params, onPacketLifecycleEvent) {
    const graph = this.graph;
    const view = graph.view;
    const initialEdgeState = view.getState(edge, true);
    if (!initialEdgeState || !initialEdgeState.absolutePoints || initialEdgeState.absolutePoints.length === 0) {
      if (onPacketLifecycleEvent)
        onPacketLifecycleEvent("cancelled", null);
      return null;
    }
    const el = document.createElement("div");
    const baseStyle = _CommunicationAnimator.BASE_PACKET_APPEARANCE;
    Object.assign(el.style, { position: "absolute", fontFamily: baseStyle.FONT_FAMILY, zIndex: baseStyle.Z_INDEX, pointerEvents: baseStyle.POINTER_EVENTS, overflow: baseStyle.OVERFLOW, textOverflow: baseStyle.TEXT_OVERFLOW, whiteSpace: baseStyle.WHITE_SPACE, textAlign: baseStyle.TEXT_ALIGN, display: baseStyle.DISPLAY, alignItems: baseStyle.ALIGN_ITEMS, justifyContent: baseStyle.JUSTIFY_CONTENT, borderStyle: baseStyle.BORDER_STYLE || "none" });
    const theme = params.isHighCIARisk ? _CommunicationAnimator.HIGH_RISK_CIA_THEME : _CommunicationAnimator.NORMAL_CIA_THEME;
    Object.assign(el.style, { backgroundColor: theme.BACKGROUND_COLOR, color: theme.COLOR });
    if (theme.BOX_SHADOW) {
      const shadowString = theme.BOX_SHADOW;
      const mainMatch = shadowString.match(/^(.*?)\s+(rgba?\(.*\))$/);
      const brightnessMultiplier = params.brightnessMultiplier || 1;
      if (mainMatch && mainMatch.length === 3) {
        const dimensionString = mainMatch[1];
        const colorString = mainMatch[2];
        let newColorString = colorString;
        const colorValuesMatch = colorString.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
        if (colorValuesMatch) {
          const r = colorValuesMatch[1], g = colorValuesMatch[2], b = colorValuesMatch[3], originalAlpha = parseFloat(colorValuesMatch[4] || "1");
          let newAlpha = Math.min(1, Math.max(0, originalAlpha * brightnessMultiplier));
          newColorString = `rgba(${r}, ${g}, ${b}, ${newAlpha.toFixed(2)})`;
        }
        let newDimensionString = dimensionString;
        const dimensions = dimensionString.split(/\s+/);
        if (dimensions.length >= 4) {
          const offsetX = dimensions[0], offsetY = dimensions[1], blurRadiusStr = dimensions[2], spreadRadiusStr = dimensions[3];
          const originalBlur = parseFloat(blurRadiusStr), originalSpread = parseFloat(spreadRadiusStr);
          if (!isNaN(originalBlur) && !isNaN(originalSpread)) {
            let newSpread = Math.max(0, originalSpread * brightnessMultiplier), newBlur = Math.max(0, originalBlur * (1 + (brightnessMultiplier - 1) * 0.25));
            newDimensionString = `${offsetX} ${offsetY} ${newBlur.toFixed(1)}px ${newSpread.toFixed(1)}px`;
            if (dimensions.length > 4)
              newDimensionString += " " + dimensions.slice(4).join(" ");
          }
        }
        el.style.boxShadow = `${newDimensionString} ${newColorString}`;
      } else
        el.style.boxShadow = theme.BOX_SHADOW;
    }
    el.textContent = params.text;
    let isCancelled = false, rafId = null;
    const packetInstance = { element: el, cancel: null };
    let lastFrameClientTimestamp = null, accumulatedMotionTimeMs = 0;
    let lastFlickerTimestamp = 0, flickerState = 0;
    const SENSITIVE_DATA_PLACEHOLDER_FLICKER_INTERVAL = 250;
    let lastAppliedScale = -1;
    const cancelAnimationInstance = () => {
      if (isCancelled)
        return;
      isCancelled = true;
      if (rafId)
        cancelAnimationFrame(rafId);
      if (el.parentNode)
        el.parentNode.removeChild(el);
      if (onPacketLifecycleEvent)
        onPacketLifecycleEvent("cancelled", packetInstance);
    };
    packetInstance.cancel = cancelAnimationInstance;
    const step = (currentFrameClientTimestamp) => {
      if (isCancelled)
        return;
      if (!graph.model.contains(edge)) {
        cancelAnimationInstance();
        return;
      }
      const currentEdgeState = view.getState(edge);
      if (!currentEdgeState || !currentEdgeState.absolutePoints || currentEdgeState.absolutePoints.length === 0) {
        cancelAnimationInstance();
        return;
      }
      if (!el.parentNode) {
        if (graph.container) {
          graph.container.appendChild(el);
          lastFrameClientTimestamp = currentFrameClientTimestamp;
        } else {
          cancelAnimationInstance();
          return;
        }
      }
      if (lastFrameClientTimestamp === null)
        lastFrameClientTimestamp = currentFrameClientTimestamp;
      const rawDeltaTimeMs = currentFrameClientTimestamp - lastFrameClientTimestamp;
      lastFrameClientTimestamp = currentFrameClientTimestamp;
      const MAX_FRAME_DELTA_MS = 100;
      const deltaTimeMs = Math.min(rawDeltaTimeMs, MAX_FRAME_DELTA_MS);
      if (rawDeltaTimeMs > 5e3 && params.durationMs < rawDeltaTimeMs) {
        cancelAnimationInstance();
        return;
      }
      accumulatedMotionTimeMs += deltaTimeMs;
      const currentScale = view.scale;
      const sizeFactor = params.sizeMultiplier || 1;
      if (currentScale !== lastAppliedScale) {
        Object.assign(el.style, {
          fontSize: `${Math.max(1, baseStyle.BASE_FONT_SIZE_PX * currentScale * sizeFactor)}px`,
          padding: `${Math.max(0.25, baseStyle.BASE_PADDING_TB_PX * currentScale * sizeFactor)}px ${Math.max(0.5, baseStyle.BASE_PADDING_LR_PX * currentScale * sizeFactor)}px`,
          borderRadius: typeof baseStyle.BASE_BORDER_RADIUS_PX === "string" && baseStyle.BASE_BORDER_RADIUS_PX.includes("%") ? baseStyle.BASE_BORDER_RADIUS_PX : `${Math.max(0.5, parseFloat(baseStyle.BASE_BORDER_RADIUS_PX) * currentScale * (sizeFactor > 1 ? 1 : sizeFactor))}px`,
          height: `${Math.max(1, baseStyle.BASE_HEIGHT_PX * currentScale * sizeFactor)}px`,
          minWidth: `${Math.max(1, baseStyle.BASE_MIN_WIDTH_PX * currentScale * sizeFactor)}px`
        });
        el.style.lineHeight = el.style.height;
        lastAppliedScale = currentScale;
      }
      const boxWidth = this._getBoxWidth(el);
      const boxHeight = this._getBoxHeight(el);
      const fadeInDuration = params.durationMs * _CommunicationAnimator.FADE_IN_DURATION_PERCENT;
      const fadeOutStartOffset = params.durationMs * (1 - _CommunicationAnimator.FADE_OUT_DURATION_PERCENT);
      let currentOpacity = 1;
      if (accumulatedMotionTimeMs < fadeInDuration)
        currentOpacity = fadeInDuration > 0 ? accumulatedMotionTimeMs / fadeInDuration : 1;
      else if (accumulatedMotionTimeMs > fadeOutStartOffset && params.durationMs > fadeInDuration) {
        const timeIntoFadeOut = accumulatedMotionTimeMs - fadeOutStartOffset;
        const fadeOutActualDuration = params.durationMs - fadeOutStartOffset;
        currentOpacity = fadeOutActualDuration > 0 ? 1 - timeIntoFadeOut / fadeOutActualDuration : 0;
      }
      el.style.opacity = Math.max(0, Math.min(1, currentOpacity)).toFixed(2);
      const currentPoints = currentEdgeState.absolutePoints;
      const currentTotalPathDistance = this._calculatePathDistance(currentPoints);
      if (currentTotalPathDistance <= 0.1) {
        const pointData = this._getPointAndAngleAtDistance(currentPoints, 0);
        if (pointData?.point) {
          el.style.left = `${pointData.point.x - boxWidth / 2}px`;
          el.style.top = `${pointData.point.y - boxHeight / 2}px`;
          el.style.transform = `rotate(0rad)`;
        } else {
          cancelAnimationInstance();
          return;
        }
      } else {
        let conceptualProgress = Math.min(1, params.durationMs > 0 ? accumulatedMotionTimeMs / params.durationMs : 1);
        const currentDistanceOnPath = conceptualProgress * currentTotalPathDistance;
        const pathData = this._getPointAndAngleAtDistance(currentPoints, currentDistanceOnPath);
        if (!pathData || !pathData.point) {
          cancelAnimationInstance();
          return;
        }
        el.style.left = `${pathData.point.x - boxWidth / 2}px`;
        el.style.top = `${pathData.point.y - boxHeight / 2}px`;
        el.style.transform = `rotate(${pathData.angle}rad)`;
      }
      el.style.webkitMaskImage = "none";
      el.style.maskImage = "none";
      let newTextContent = params.text;
      if (params.text === _CommunicationAnimator.SENSITIVE_DATA_PLACEHOLDER && params.isHighCIARisk && !params.isEncrypted) {
        if (currentFrameClientTimestamp - lastFlickerTimestamp > SENSITIVE_DATA_PLACEHOLDER_FLICKER_INTERVAL) {
          lastFlickerTimestamp = currentFrameClientTimestamp;
          flickerState = (flickerState + 1) % 3;
        }
        if (flickerState === 0)
          newTextContent = "\u2593\u2593\u2593";
        else if (flickerState === 1)
          newTextContent = "\u2592\u2592\u2592";
        else
          newTextContent = "\u2591\u2591\u2591";
      } else if (params.corruptData && !params.isEncrypted) {
        if (Math.random() < 0.05)
          newTextContent = this._corruptText(params.text);
        else if (el.textContent !== params.text && Math.random() < 0.15)
          newTextContent = params.text;
        else
          newTextContent = el.textContent;
      }
      if (el.textContent !== newTextContent)
        el.textContent = newTextContent;
      if (accumulatedMotionTimeMs < params.durationMs)
        rafId = requestAnimationFrame(step);
      else {
        if (el.parentNode)
          el.parentNode.removeChild(el);
        if (onPacketLifecycleEvent)
          onPacketLifecycleEvent("completed", packetInstance);
      }
    };
    rafId = requestAnimationFrame(step);
    return packetInstance;
  }
  _calculatePathDistance(points) {
    if (!points || points.length < 2)
      return 0;
    let d = 0;
    for (let i = 0; i < points.length - 1; i++)
      d += Math.hypot(points[i + 1].x - points[i].x, points[i + 1].y - points[i].y);
    return d;
  }
  _getPointAndAngleAtDistance(points, distance) {
    if (!points || points.length === 0)
      return null;
    const firstPoint = new mxPoint2(points[0].x, points[0].y);
    let angle = 0;
    if (points.length > 1)
      angle = Math.atan2(points[1].y - firstPoint.y, points[1].x - firstPoint.x);
    else
      return { point: firstPoint, angle: 0 };
    if (distance <= 0)
      return { point: firstPoint, angle };
    let accumulatedDistance = 0;
    for (let i = 0; i < points.length - 1; i++) {
      const p1 = points[i], p2 = points[i + 1];
      const segmentDistance = Math.hypot(p2.x - p1.x, p2.y - p1.y);
      if (segmentDistance > 0)
        angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
      if (accumulatedDistance + segmentDistance >= distance) {
        const remainingDistance = distance - accumulatedDistance;
        const ratio = segmentDistance === 0 ? 0 : remainingDistance / segmentDistance;
        return { point: new mxPoint2(p1.x + ratio * (p2.x - p1.x), p1.y + ratio * (p2.y - p1.y)), angle };
      }
      accumulatedDistance += segmentDistance;
    }
    const lastPoint = points[points.length - 1];
    return { point: new mxPoint2(lastPoint.x, lastPoint.y), angle };
  }
  stopAnimationForCell(cellId, removeFromActiveList = true) {
    if (this.managedAnimations.has(cellId)) {
      const animControl = this.managedAnimations.get(cellId);
      animControl?.stop?.();
      this.managedAnimations.delete(cellId);
    }
    if (removeFromActiveList)
      this.activeAnimatingCellIds.delete(cellId);
  }
  stopAllAnimations() {
    Array.from(this.managedAnimations.keys()).forEach((cellId) => this.stopAnimationForCell(cellId, true));
  }
};
var CommunicationAnimator = _CommunicationAnimator;
__publicField(CommunicationAnimator, "RISK_LEVEL_MAPPINGS", {
  "severity": { "low": 1, "medium": 2, "elevated": 3, "high": 4, "critical": 5 },
  "impact": { "low": 1, "medium": 2, "high": 3, "veryhigh": 4, "public": 1, "internal": 1, "restricted": 2, "confidential": 3, "strictlyconfidential": 4, "operationaldisruption": 1, "missioncritical": 4, "archive": 1, "critical": 4 },
  "likelihood": { "unlikely": 1, "likely": 3, "verylikely": 4, "frequent": 5 },
  "probability": { "improbable": 1, "possible": 2, "probable": 3 }
});
__publicField(CommunicationAnimator, "QUANTITY_SIZE_MULTIPLIERS", { "very_low": 0.7, "low": 0.85, "medium": 1, "high": 1.15, "very_high": 1.3, "verylow": 0.7, "veryhigh": 1.3, "default": 1 });
__publicField(CommunicationAnimator, "QUANTITY_BRIGHTNESS_MULTIPLIERS", { "verylow": 0.6, "low": 0.8, "medium": 1, "high": 1.25, "veryhigh": 1.5, "default": 1 });
__publicField(CommunicationAnimator, "GIBBERISH_CHARSET", "abc");
__publicField(CommunicationAnimator, "SENSITIVE_DATA_PLACEHOLDER", "\u2593\u2593\u2593");
__publicField(CommunicationAnimator, "CORRUPTION_COMMON_CHARS", "01!?#");
__publicField(CommunicationAnimator, "CORRUPTION_SYMBOLS", ["*", "!", "?"]);
__publicField(CommunicationAnimator, "BASE_PACKET_APPEARANCE", { FONT_FAMILY: 'Menlo, Monaco, "Courier New", monospace', Z_INDEX: "1000", POINTER_EVENTS: "none", OVERFLOW: "visible", TEXT_OVERFLOW: "clip", WHITE_SPACE: "nowrap", TEXT_ALIGN: "center", DISPLAY: "flex", ALIGN_ITEMS: "center", JUSTIFY_CONTENT: "center", BASE_FONT_SIZE_PX: 8, BASE_PADDING_LR_PX: 5, BASE_PADDING_TB_PX: 1, BASE_BORDER_WIDTH_PX: 0, BASE_BORDER_RADIUS_PX: "10px", BASE_MIN_WIDTH_PX: 10, BASE_HEIGHT_PX: 12 });
__publicField(CommunicationAnimator, "HIGH_RISK_CIA_THEME", { BACKGROUND_COLOR: "rgba(220, 20, 60, 0.85)", COLOR: "rgba(255, 255, 240, 1)", BOX_SHADOW: "0 0 7px 2px rgba(240, 50, 80, 0.7)" });
__publicField(CommunicationAnimator, "NORMAL_CIA_THEME", { BACKGROUND_COLOR: "rgba(60, 179, 113, 0.85)", COLOR: "rgba(240, 248, 255, 1)", BOX_SHADOW: "0 0 7px 2px rgba(70, 200, 130, 0.7)" });
__publicField(CommunicationAnimator, "PROTOCOLS", { UnknownProtocol: "unknown-protocol", HTTP: "http", HTTPS: "https", WS: "ws", WSS: "wss", ReverseProxyWebProtocol: "reverse-proxy-web-protocol", ReverseProxyWebProtocolEncrypted: "reverse-proxy-web-protocol-encrypted", MQTT: "mqtt", JDBC: "jdbc", JDBCEncrypted: "jdbc-encrypted", ODBC: "odbc", ODBCEncrypted: "odbc-encrypted", SQLAccessProtocol: "sql-access-protocol", SQLAccessProtocolEncrypted: "sql-access-protocol-encrypted", NoSQLAccessProtocol: "nosql-access-protocol", NoSQLAccessProtocolEncrypted: "nosql-access-protocol-encrypted", BINARY: "binary", BINARYEncrypted: "binary-encrypted", TEXT: "text", TEXTEncrypted: "text-encrypted", SSH: "ssh", SSHTunnel: "ssh-tunnel", SMTP: "smtp", SMTPEncrypted: "smtp-encrypted", POP3: "pop3", POP3Encrypted: "pop3-encrypted", IMAP: "imap", IMAPEncrypted: "imap-encrypted", FTP: "ftp", FTPS: "ftps", SFTP: "sftp", SCP: "scp", LDAP: "ldap", LDAPS: "ldaps", JMS: "jms", NFS: "nfs", SMB: "smb", SMBEncrypted: "smb-encrypted", LocalFileAccess: "local-file-access", NRPE: "nrpe", XMPP: "xmpp", IIOP: "iiop", IIOPEncrypted: "iiop-encrypted", JRMP: "jrmp", JRMPEncrypted: "jrmp-encrypted", InProcessLibraryCall: "in-process-library-call", ContainerSpawning: "container-spawning" });
__publicField(CommunicationAnimator, "INHERENTLY_ENCRYPTED_PROTOCOLS", [_CommunicationAnimator.PROTOCOLS.HTTPS, _CommunicationAnimator.PROTOCOLS.WSS, _CommunicationAnimator.PROTOCOLS.ReverseProxyWebProtocolEncrypted, _CommunicationAnimator.PROTOCOLS.JDBCEncrypted, _CommunicationAnimator.PROTOCOLS.ODBCEncrypted, _CommunicationAnimator.PROTOCOLS.SQLAccessProtocolEncrypted, _CommunicationAnimator.PROTOCOLS.NoSQLAccessProtocolEncrypted, _CommunicationAnimator.PROTOCOLS.BINARYEncrypted, _CommunicationAnimator.PROTOCOLS.TEXTEncrypted, _CommunicationAnimator.PROTOCOLS.SSH, _CommunicationAnimator.PROTOCOLS.SSHTunnel, _CommunicationAnimator.PROTOCOLS.SMTPEncrypted, _CommunicationAnimator.PROTOCOLS.POP3Encrypted, _CommunicationAnimator.PROTOCOLS.IMAPEncrypted, _CommunicationAnimator.PROTOCOLS.FTPS, _CommunicationAnimator.PROTOCOLS.SFTP, _CommunicationAnimator.PROTOCOLS.LDAPS, _CommunicationAnimator.PROTOCOLS.SMBEncrypted, _CommunicationAnimator.PROTOCOLS.IIOPEncrypted, _CommunicationAnimator.PROTOCOLS.JRMPEncrypted, _CommunicationAnimator.PROTOCOLS.SCP]);
__publicField(CommunicationAnimator, "STREAM_ANIMATION_PROTOCOLS", [_CommunicationAnimator.PROTOCOLS.HTTP, _CommunicationAnimator.PROTOCOLS.HTTPS, _CommunicationAnimator.PROTOCOLS.WS, _CommunicationAnimator.PROTOCOLS.WSS, _CommunicationAnimator.PROTOCOLS.SSH, _CommunicationAnimator.PROTOCOLS.SSHTunnel, _CommunicationAnimator.PROTOCOLS.FTP, _CommunicationAnimator.PROTOCOLS.FTPS, _CommunicationAnimator.PROTOCOLS.SFTP, _CommunicationAnimator.PROTOCOLS.SCP, _CommunicationAnimator.PROTOCOLS.SMTP, _CommunicationAnimator.PROTOCOLS.SMTPEncrypted, _CommunicationAnimator.PROTOCOLS.POP3, _CommunicationAnimator.PROTOCOLS.POP3Encrypted, _CommunicationAnimator.PROTOCOLS.IMAP, _CommunicationAnimator.PROTOCOLS.IMAPEncrypted, _CommunicationAnimator.PROTOCOLS.LDAP, _CommunicationAnimator.PROTOCOLS.LDAPS, _CommunicationAnimator.PROTOCOLS.MQTT, _CommunicationAnimator.PROTOCOLS.ReverseProxyWebProtocol, _CommunicationAnimator.PROTOCOLS.ReverseProxyWebProtocolEncrypted, _CommunicationAnimator.PROTOCOLS.JDBC, _CommunicationAnimator.PROTOCOLS.JDBCEncrypted, _CommunicationAnimator.PROTOCOLS.ODBC, _CommunicationAnimator.PROTOCOLS.ODBCEncrypted, _CommunicationAnimator.PROTOCOLS.SQLAccessProtocol, _CommunicationAnimator.PROTOCOLS.SQLAccessProtocolEncrypted, _CommunicationAnimator.PROTOCOLS.NoSQLAccessProtocol, _CommunicationAnimator.PROTOCOLS.NoSQLAccessProtocolEncrypted, _CommunicationAnimator.PROTOCOLS.BINARY, _CommunicationAnimator.PROTOCOLS.BINARYEncrypted, _CommunicationAnimator.PROTOCOLS.TEXT, _CommunicationAnimator.PROTOCOLS.TEXTEncrypted, _CommunicationAnimator.PROTOCOLS.XMPP, _CommunicationAnimator.PROTOCOLS.IIOP, _CommunicationAnimator.PROTOCOLS.IIOPEncrypted, _CommunicationAnimator.PROTOCOLS.JRMP, _CommunicationAnimator.PROTOCOLS.JRMPEncrypted, _CommunicationAnimator.PROTOCOLS.SMB, _CommunicationAnimator.PROTOCOLS.SMBEncrypted, _CommunicationAnimator.PROTOCOLS.NFS, _CommunicationAnimator.PROTOCOLS.NRPE, _CommunicationAnimator.PROTOCOLS.JMS]);
__publicField(CommunicationAnimator, "FADE_IN_DURATION_PERCENT", 0.15);
__publicField(CommunicationAnimator, "FADE_OUT_DURATION_PERCENT", 0.2);

// js/BaseFormatPanel.js
var BaseFormatPanel = function(format, editorUi, container) {
  this.format = format;
  this.editorUi = editorUi;
  this.container = container;
  this.listeners = [];
};
BaseFormatPanel.prototype.createCollapsiblePanel = function(titleText, initiallyExpanded = true) {
  var format = this.format;
  var panelContainer = document.createElement("div");
  panelContainer.className = "geFormatSection geCollapsibleSection";
  var header = document.createElement("div");
  header.className = "geCollapsibleHeader";
  header.style.padding = "8px 18px";
  header.style.fontWeight = "bold";
  header.style.cursor = "pointer";
  header.style.display = "flex";
  header.style.justifyContent = "space-between";
  header.style.alignItems = "center";
  header.style.borderBottom = "1px solid #e0e0e0";
  header.style.backgroundColor = "#f5f5f5";
  var titleSpan = document.createElement("span");
  write(titleSpan, titleText);
  header.appendChild(titleSpan);
  var toggleIcon = document.createElement("span");
  toggleIcon.className = "geCollapsibleToggleIcon";
  toggleIcon.style.fontSize = "12px";
  toggleIcon.innerHTML = initiallyExpanded ? "\u25BC" : "\u25BA";
  header.appendChild(toggleIcon);
  var contentDiv = document.createElement("div");
  contentDiv.className = "geCollapsibleContent";
  contentDiv.style.padding = "6px 18px 10px 18px";
  contentDiv.style.borderTop = "none";
  contentDiv.style.display = initiallyExpanded ? "" : "none";
  panelContainer._isExpanded = initiallyExpanded;
  mxEvent2.addListener(header, "click", function() {
    panelContainer._isExpanded = !panelContainer._isExpanded;
    contentDiv.style.display = panelContainer._isExpanded ? "" : "none";
    toggleIcon.innerHTML = panelContainer._isExpanded ? "\u25BC" : "\u25BA";
  });
  panelContainer.appendChild(header);
  panelContainer.appendChild(contentDiv);
  return {
    container: panelContainer,
    content: contentDiv
  };
};
BaseFormatPanel.prototype.buttonBackgroundColor = "white";
BaseFormatPanel.prototype.getSelectionState = function() {
  var graph = this.editorUi.editor.graph;
  var cells = graph.getSelectionCells();
  var shape = null;
  for (var i = 0; i < cells.length; i++) {
    var state2 = graph.view.getState(cells[i]);
    if (state2 != null) {
      var tmp = getValue(state2.style, mxConstants2.STYLE_SHAPE, null);
      if (tmp != null) {
        if (shape == null) {
          shape = tmp;
        } else if (shape != tmp) {
          return null;
        }
      }
    }
  }
  return shape;
};
BaseFormatPanel.prototype.installInputHandler = function(input, key, defaultValue, min, max, unit, textEditFallback, isFloat) {
  unit = unit != null ? unit : "";
  isFloat = isFloat != null ? isFloat : false;
  var ui = this.editorUi;
  var graph = ui.editor.graph;
  min = min != null ? min : 1;
  max = max != null ? max : 999;
  var selState = null;
  var updating = false;
  var update = bind(this, function(evt) {
    var value = isFloat ? parseFloat(input.value) : parseInt(input.value);
    if (!isNaN(value) && key == mxConstants2.STYLE_ROTATION) {
      value = mod(Math.round(value * 100), 36e3) / 100;
    }
    value = Math.min(max, Math.max(min, isNaN(value) ? defaultValue : value));
    if (graph.cellEditor.isContentEditing() && textEditFallback) {
      if (!updating) {
        updating = true;
        if (selState != null) {
          graph.cellEditor.restoreSelection(selState);
          selState = null;
        }
        textEditFallback(value);
        input.value = value + unit;
        updating = false;
      }
    } else if (value != getValue(this.format.getSelectionState().style, key, defaultValue)) {
      if (graph.isEditing()) {
        graph.stopEditing(true);
      }
      graph.getModel().beginUpdate();
      try {
        var cells = graph.getSelectionCells();
        graph.setCellStyles(key, value, cells);
        if (key == mxConstants2.STYLE_FONTSIZE) {
          graph.updateLabelElements(graph.getSelectionCells(), function(elt) {
            elt.style.fontSize = value + "px";
            elt.removeAttribute("size");
          });
        }
        for (var i = 0; i < cells.length; i++) {
          if (graph.model.getChildCount(cells[i]) == 0) {
            graph.autoSizeCell(cells[i], false);
          }
        }
        ui.fireEvent(new mxEventObject("styleChanged", "keys", [key], "values", [value], "cells", cells));
      } finally {
        graph.getModel().endUpdate();
      }
    }
    input.value = value + unit;
    mxEvent2.consume(evt);
  });
  if (textEditFallback && graph.cellEditor.isContentEditing()) {
    mxEvent2.addListener(input, "mousedown", function() {
      if (document.activeElement == graph.cellEditor.textarea) {
        selState = graph.cellEditor.saveSelection();
      }
    });
    mxEvent2.addListener(input, "touchstart", function() {
      if (document.activeElement == graph.cellEditor.textarea) {
        selState = graph.cellEditor.saveSelection();
      }
    });
  }
  mxEvent2.addListener(input, "change", update);
  mxEvent2.addListener(input, "blur", update);
  return update;
};
BaseFormatPanel.prototype.createPanel = function() {
  var div = document.createElement("div");
  div.className = "geFormatSection";
  div.style.padding = "12px 0px 12px 18px";
  return div;
};
BaseFormatPanel.prototype.createTitle = function(title) {
  var div = document.createElement("div");
  div.style.padding = "0px 0px 6px 0px";
  div.style.whiteSpace = "nowrap";
  div.style.overflow = "hidden";
  div.style.width = "200px";
  div.style.fontWeight = "bold";
  write(div, title);
  return div;
};
BaseFormatPanel.prototype.createStepper = function(input, update, step, height, disableFocus, defaultValue, isFloat) {
  step = step != null ? step : 1;
  height = height != null ? height : 8;
  if (mxClient_default.IS_QUIRKS) {
    height = height - 2;
  } else if (mxClient_default.IS_MT || document.documentMode >= 8) {
    height = height + 1;
  }
  var stepper = document.createElement("div");
  setPrefixedStyle(stepper.style, "borderRadius", "3px");
  stepper.style.border = "1px solid rgb(192, 192, 192)";
  stepper.style.position = "absolute";
  var up = document.createElement("div");
  up.style.borderBottom = "1px solid rgb(192, 192, 192)";
  up.style.position = "relative";
  up.style.height = height + "px";
  up.style.width = "10px";
  up.className = "geBtnUp";
  stepper.appendChild(up);
  var down = up.cloneNode(false);
  down.style.border = "none";
  down.style.height = height + "px";
  down.className = "geBtnDown";
  stepper.appendChild(down);
  mxEvent2.addListener(down, "click", function(evt) {
    if (input.value == "") {
      input.value = defaultValue || "2";
    }
    var val = isFloat ? parseFloat(input.value) : parseInt(input.value);
    if (!isNaN(val)) {
      input.value = val - step;
      if (update != null) {
        update(evt);
      }
    }
    mxEvent2.consume(evt);
  });
  mxEvent2.addListener(up, "click", function(evt) {
    if (input.value == "") {
      input.value = defaultValue || "0";
    }
    var val = isFloat ? parseFloat(input.value) : parseInt(input.value);
    if (!isNaN(val)) {
      input.value = val + step;
      if (update != null) {
        update(evt);
      }
    }
    mxEvent2.consume(evt);
  });
  if (disableFocus) {
    var currentSelection = null;
    mxEvent2.addGestureListeners(stepper, function(evt) {
      if (mxClient_default.IS_QUIRKS || document.documentMode == 8) {
        currentSelection = document.selection.createRange();
      }
      mxEvent2.consume(evt);
    }, null, function(evt) {
      if (currentSelection != null) {
        try {
          currentSelection.select();
        } catch (e) {
        }
        currentSelection = null;
        mxEvent2.consume(evt);
      }
    });
  }
  return stepper;
};
BaseFormatPanel.prototype.createOption = function(label, isCheckedFn, setCheckedFn, listener, fn) {
  var div = document.createElement("div");
  div.style.padding = "6px 0px 1px 0px";
  div.style.whiteSpace = "nowrap";
  div.style.overflow = "hidden";
  div.style.width = "200px";
  div.style.height = mxClient_default.IS_QUIRKS ? "27px" : "18px";
  var cb = document.createElement("input");
  cb.setAttribute("type", "checkbox");
  cb.style.margin = "0px 6px 0px 0px";
  div.appendChild(cb);
  var span = document.createElement("span");
  span.style.fontWeight = "bold";
  write(span, label);
  div.appendChild(span);
  var applying = false;
  var value = isCheckedFn();
  var apply = function(newValue) {
    if (!applying) {
      applying = true;
      if (newValue) {
        cb.setAttribute("checked", "checked");
        cb.defaultChecked = true;
        cb.checked = true;
      } else {
        cb.removeAttribute("checked");
        cb.defaultChecked = false;
        cb.checked = false;
      }
      if (value != newValue) {
        value = newValue;
        if (isCheckedFn() != value) {
          setCheckedFn(value);
        }
      }
      applying = false;
    }
  };
  mxEvent2.addListener(div, "click", function(evt) {
    if (cb.getAttribute("disabled") != "disabled") {
      var source = mxEvent2.getSource(evt);
      if (source == div || source == span) {
        cb.checked = !cb.checked;
      }
      apply(cb.checked);
    }
  });
  apply(value);
  if (listener != null) {
    listener.install(apply);
    this.listeners.push(listener);
  }
  if (fn != null) {
    fn(div);
  }
  return div;
};
BaseFormatPanel.prototype.createCellOption = function(label, key, defaultValue, enabledValue, disabledValue, fn, action, stopEditing) {
  enabledValue = enabledValue != null ? enabledValue == "null" ? null : enabledValue : "1";
  disabledValue = disabledValue != null ? disabledValue == "null" ? null : disabledValue : "0";
  var ui = this.editorUi;
  var editor = ui.editor;
  var graph = editor.graph;
  return this.createOption(label, function() {
    var state2 = graph.view.getState(graph.getSelectionCell());
    if (state2 != null) {
      return getValue(state2.style, key, defaultValue) != disabledValue;
    }
    return null;
  }, function(checked) {
    if (stopEditing) {
      graph.stopEditing();
    }
    if (action != null) {
      action.funct();
    } else {
      graph.getModel().beginUpdate();
      try {
        var value = checked ? enabledValue : disabledValue;
        graph.setCellStyles(key, value, graph.getSelectionCells());
        if (fn != null) {
          fn(graph.getSelectionCells(), value);
        }
        ui.fireEvent(new mxEventObject("styleChanged", "keys", [key], "values", [value], "cells", graph.getSelectionCells()));
      } finally {
        graph.getModel().endUpdate();
      }
    }
  }, {
    install: function(apply) {
      this.listener = function() {
        var state2 = graph.view.getState(graph.getSelectionCell());
        if (state2 != null) {
          apply(getValue(state2.style, key, defaultValue) != disabledValue);
        }
      };
      graph.getModel().addListener(mxEvent2.CHANGE, this.listener);
    },
    destroy: function() {
      graph.getModel().removeListener(this.listener);
    }
  });
};
BaseFormatPanel.prototype.createColorOption = function(label, getColorFn, setColorFn, defaultColor, listener, callbackFn, hideCheckbox) {
  var div = document.createElement("div");
  div.style.padding = "6px 0px 1px 0px";
  div.style.whiteSpace = "nowrap";
  div.style.overflow = "hidden";
  div.style.width = "200px";
  div.style.height = mxClient_default.IS_QUIRKS ? "27px" : "18px";
  var cb = document.createElement("input");
  cb.setAttribute("type", "checkbox");
  cb.style.margin = "0px 6px 0px 0px";
  if (!hideCheckbox) {
    div.appendChild(cb);
  }
  var span = document.createElement("span");
  write(span, label);
  div.appendChild(span);
  var value = getColorFn();
  var applying = false;
  var btn = null;
  var apply = function(color, disableUpdate, forceUpdate) {
    if (!applying) {
      applying = true;
      color = /(^#?[a-zA-Z0-9]*$)/.test(color) ? color : defaultColor;
      btn.innerHTML = '<div style="width:' + (mxClient_default.IS_QUIRKS ? "30" : "36") + "px;height:12px;margin:3px;border:1px solid black;background-color:" + htmlEntities(color != null && color != mxConstants2.NONE ? color : defaultColor) + ';"></div>';
      if (mxClient_default.IS_QUIRKS || document.documentMode == 8) {
        btn.firstChild.style.margin = "0px";
      }
      if (color != null && color != mxConstants2.NONE) {
        cb.setAttribute("checked", "checked");
        cb.defaultChecked = true;
        cb.checked = true;
      } else {
        cb.removeAttribute("checked");
        cb.defaultChecked = false;
        cb.checked = false;
      }
      btn.style.display = cb.checked || hideCheckbox ? "" : "none";
      if (callbackFn != null) {
        callbackFn(color);
      }
      if (!disableUpdate) {
        value = color;
        if (forceUpdate || hideCheckbox || getColorFn() != value) {
          setColorFn(value);
        }
      }
      applying = false;
    }
  };
  btn = button("", bind(this, function(evt) {
    this.editorUi.pickColor(value, function(color) {
      apply(color, null, true);
    });
    mxEvent2.consume(evt);
  }));
  btn.style.position = "absolute";
  btn.style.marginTop = "-4px";
  btn.style.right = mxClient_default.IS_QUIRKS ? "0px" : "20px";
  btn.style.height = "22px";
  btn.className = "geColorBtn";
  btn.style.display = cb.checked || hideCheckbox ? "" : "none";
  div.appendChild(btn);
  mxEvent2.addListener(div, "click", function(evt) {
    var source = mxEvent2.getSource(evt);
    if (source == cb || source.nodeName != "INPUT") {
      if (source != cb) {
        cb.checked = !cb.checked;
      }
      if (!cb.checked && value != null && value != mxConstants2.NONE && defaultColor != mxConstants2.NONE) {
        defaultColor = value;
      }
      apply(cb.checked ? defaultColor : mxConstants2.NONE);
    }
  });
  apply(value, true);
  if (listener != null) {
    listener.install(apply);
    this.listeners.push(listener);
  }
  return div;
};
BaseFormatPanel.prototype.createCellColorOption = function(label, colorKey, defaultColor, callbackFn, setStyleFn) {
  var ui = this.editorUi;
  var editor = ui.editor;
  var graph = editor.graph;
  return this.createColorOption(label, function() {
    var state2 = graph.view.getState(graph.getSelectionCell());
    if (state2 != null) {
      return getValue(state2.style, colorKey, null);
    }
    return null;
  }, function(color) {
    graph.getModel().beginUpdate();
    try {
      graph.setCellStyles(colorKey, color, graph.getSelectionCells());
      if (setStyleFn != null) {
        setStyleFn(color);
      }
      ui.fireEvent(new mxEventObject("styleChanged", "keys", [colorKey], "values", [color], "cells", graph.getSelectionCells()));
    } finally {
      graph.getModel().endUpdate();
    }
  }, defaultColor || mxConstants2.NONE, {
    install: function(apply) {
      this.listener = function() {
        var state2 = graph.view.getState(graph.getSelectionCell());
        if (state2 != null) {
          apply(getValue(state2.style, colorKey, null));
        }
      };
      graph.getModel().addListener(mxEvent2.CHANGE, this.listener);
    },
    destroy: function() {
      graph.getModel().removeListener(this.listener);
    }
  }, callbackFn);
};
BaseFormatPanel.prototype.addArrow = function(elt, height) {
  height = height != null ? height : 10;
  var arrow = document.createElement("div");
  arrow.style.display = mxClient_default.IS_QUIRKS ? "inline" : "inline-block";
  arrow.style.padding = "6px";
  arrow.style.paddingRight = "4px";
  var m = 10 - height;
  if (m == 2) {
    arrow.style.paddingTop = 6 + "px";
  } else if (m > 0) {
    arrow.style.paddingTop = 6 - m + "px";
  } else {
    arrow.style.marginTop = "-2px";
  }
  arrow.style.height = height + "px";
  arrow.style.borderLeft = "1px solid #a0a0a0";
  arrow.innerHTML = '<img border="0" src="' + (mxClient_default.IS_SVG ? "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAHBJREFUeNpidHB2ZyAGsACxDRBPIKCuA6TwCBB/h2rABu4A8SYmKCcXiP/iUFgAxL9gCi8A8SwsirZCMQMTkmANEH9E4v+CmsaArvAdyNFI/FlQ92EoBIE+qCRIUz168DBgsU4OqhinQpgHMABAgAEALY4XLIsJ20oAAAAASUVORK5CYII=" : IMAGE_PATH + "/dropdown.png") + '" style="margin-bottom:4px;">';
  setOpacity(arrow, 70);
  var symbol = elt.getElementsByTagName("div")[0];
  if (symbol != null) {
    symbol.style.paddingRight = "6px";
    symbol.style.marginLeft = "4px";
    symbol.style.marginTop = "-1px";
    symbol.style.display = mxClient_default.IS_QUIRKS ? "inline" : "inline-block";
    setOpacity(symbol, 60);
  }
  setOpacity(elt, 100);
  elt.style.border = "1px solid #a0a0a0";
  elt.style.backgroundColor = this.buttonBackgroundColor;
  elt.style.backgroundImage = "none";
  elt.style.width = "auto";
  elt.className += " geColorBtn";
  setPrefixedStyle(elt.style, "borderRadius", "3px");
  elt.appendChild(arrow);
  return symbol;
};
BaseFormatPanel.prototype.addUnitInput = function(container, unit, right, width, update, step, marginTop, disableFocus, isFloat) {
  marginTop = marginTop != null ? marginTop : 0;
  var input = document.createElement("input");
  input.style.position = "absolute";
  input.style.textAlign = "right";
  input.style.marginTop = "-2px";
  input.style.right = right + 12 + "px";
  input.style.width = width + "px";
  container.appendChild(input);
  var stepper = this.createStepper(input, update, step, null, disableFocus, null, isFloat);
  stepper.style.marginTop = marginTop - 2 + "px";
  stepper.style.right = right + "px";
  container.appendChild(stepper);
  return input;
};
BaseFormatPanel.prototype.createRelativeOption = function(label, key, width, handler, init2) {
  width = width != null ? width : 44;
  var graph = this.editorUi.editor.graph;
  var div = this.createPanel();
  div.style.paddingTop = "10px";
  div.style.paddingBottom = "10px";
  write(div, label);
  div.style.fontWeight = "bold";
  var update = bind(this, function(evt) {
    if (handler != null) {
      handler(input);
    } else {
      var value = parseInt(input.value);
      value = Math.min(100, Math.max(0, isNaN(value) ? 100 : value));
      var state2 = graph.view.getState(graph.getSelectionCell());
      if (state2 != null && value != getValue(state2.style, key, 100)) {
        if (value == 100) {
          value = null;
        }
        graph.setCellStyles(key, value, graph.getSelectionCells());
        this.editorUi.fireEvent(new mxEventObject("styleChanged", "keys", [key], "values", [value], "cells", graph.getSelectionCells()));
      }
      input.value = (value != null ? value : "100") + " %";
    }
    mxEvent2.consume(evt);
  });
  var input = this.addUnitInput(div, "%", 20, width, update, 10, -15, handler != null);
  if (key != null) {
    var listener = bind(this, function(sender, evt, force) {
      if (force || input != document.activeElement) {
        var ss = this.format.getSelectionState();
        var tmp = parseInt(getValue(ss.style, key, 100));
        input.value = isNaN(tmp) ? "" : tmp + " %";
      }
    });
    mxEvent2.addListener(input, "keydown", function(e) {
      if (e.keyCode == 13) {
        graph.container.focus();
        mxEvent2.consume(e);
      } else if (e.keyCode == 27) {
        listener(null, null, true);
        graph.container.focus();
        mxEvent2.consume(e);
      }
    });
    graph.getModel().addListener(mxEvent2.CHANGE, listener);
    this.listeners.push({
      destroy: function() {
        graph.getModel().removeListener(listener);
      }
    });
    listener();
  }
  mxEvent2.addListener(input, "blur", update);
  mxEvent2.addListener(input, "change", update);
  if (init2 != null) {
    init2(input);
  }
  return div;
};
BaseFormatPanel.prototype.addLabel = function(div, title, right, width) {
  width = width != null ? width : 61;
  var label = document.createElement("div");
  write(label, title);
  label.style.position = "absolute";
  label.style.right = right + "px";
  label.style.width = width + "px";
  label.style.marginTop = "6px";
  label.style.textAlign = "center";
  div.appendChild(label);
};
BaseFormatPanel.prototype.addKeyHandler = function(input, listener) {
  mxEvent2.addListener(input, "keydown", bind(this, function(e) {
    if (e.keyCode == 13) {
      this.editorUi.editor.graph.container.focus();
      mxEvent2.consume(e);
    } else if (e.keyCode == 27) {
      if (listener != null) {
        listener(null, null, true);
      }
      this.editorUi.editor.graph.container.focus();
      mxEvent2.consume(e);
    }
  }));
};
BaseFormatPanel.prototype.styleButtons = function(elts) {
  for (var i = 0; i < elts.length; i++) {
    setPrefixedStyle(elts[i].style, "borderRadius", "3px");
    setOpacity(elts[i], 100);
    elts[i].style.border = "1px solid #a0a0a0";
    elts[i].style.padding = "4px";
    elts[i].style.paddingTop = "3px";
    elts[i].style.paddingRight = "1px";
    elts[i].style.margin = "1px";
    elts[i].style.width = "24px";
    elts[i].style.height = "20px";
    elts[i].className += " geColorBtn";
  }
};
BaseFormatPanel.prototype.destroy = function() {
  if (this.listeners != null) {
    for (var i = 0; i < this.listeners.length; i++) {
      this.listeners[i].destroy();
    }
    this.listeners = null;
  }
};
BaseFormatPanel.prototype.getUnit = function() {
  var unit = this.editorUi.editor.graph.view.unit;
  switch (unit) {
    case mxConstants2.POINTS:
      return "pt";
    case mxConstants2.INCHES:
      return '"';
    case mxConstants2.MILLIMETERS:
      return "mm";
  }
};
BaseFormatPanel.prototype.inUnit = function(pixels) {
  return this.editorUi.editor.graph.view.formatUnitText(pixels);
};
BaseFormatPanel.prototype.fromUnit = function(value) {
  var unit = this.editorUi.editor.graph.view.unit;
  switch (unit) {
    case mxConstants2.POINTS:
      return value;
    case mxConstants2.INCHES:
      return value * mxConstants2.PIXELS_PER_INCH;
    case mxConstants2.MILLIMETERS:
      return value * mxConstants2.PIXELS_PER_MM;
  }
};
BaseFormatPanel.prototype.isFloatUnit = function() {
  return this.editorUi.editor.graph.view.unit != mxConstants2.POINTS;
};
BaseFormatPanel.prototype.getUnitStep = function() {
  var unit = this.editorUi.editor.graph.view.unit;
  switch (unit) {
    case mxConstants2.POINTS:
      return 1;
    case mxConstants2.INCHES:
      return 0.1;
    case mxConstants2.MILLIMETERS:
      return 0.5;
  }
};

// js/Utils.js
function restartWasm() {
  window.initModelState();
}
function checkIdExists2(graph, id) {
  var exists = graph.model.threagile.getIn(["technical_assets", id, "id"]);
  return !!exists;
}
function generateRandomId2(prefix, totalLength) {
  let randomPart = "";
  while (randomPart.length + prefix.length < totalLength) {
    randomPart += Math.random().toString(36).substr(2);
  }
  return prefix + randomPart.substring(0, totalLength - prefix.length);
}
function generateUniqueCommkeyData(graph) {
  var newId;
  do {
    newId = generateRandomId2("Com-", 10);
  } while (checkIdExists2(graph, newId));
  return newId;
}
function generateUniqueId(graph) {
  var newId;
  do {
    newId = generateRandomId2("ta-", 25);
  } while (checkIdExists2(graph, newId));
  return newId;
}
function generateUniquekey(graph) {
  var newId;
  do {
    newId = generateRandomId2("key-", 15);
  } while (checkIdExists2(graph, newId));
  return newId;
}
function generateUniquekeyData(graph) {
  var newId;
  do {
    newId = generateRandomId2("DATA-", 10);
  } while (checkIdExists2(graph, newId));
  return newId;
}
function createSection(title) {
  var section = document.createElement("div");
  section.style.padding = "6px 0px 6px 0px";
  section.style.marginTop = "8px";
  section.style.borderTop = "1px solid rgb(192, 192, 192)";
  section.innerHTML = title;
  section.style.whiteSpace = "nowrap";
  section.style.overflow = "hidden";
  section.style.width = "200px";
  section.style.fontWeight = "bold";
  return section;
}
function createCustomOption2(self, parameter) {
  return function() {
    var cells = self.editorUi.editor.graph.getSelectionCells();
    if (cells != null && cells.length > 0) {
      var cell2 = self.editorUi.editor.graph.getSelectionCell();
      if (cell2.technicalAsset === void 0) {
        return void 0;
      } else {
        return self.editorUi.editor.graph.model.threagile.getIn(["technical_assets", cell2.technicalAsset.key, parameter]);
      }
    }
    return false;
  };
}
function setCustomOption2(self, parameter) {
  return function(checked) {
    var cells = self.editorUi.editor.graph.getSelectionCells();
    if (cells != null && cells.length > 0) {
      var cell2 = self.editorUi.editor.graph.getSelectionCell();
      const path = ["technical_assets", cell2.technicalAsset.key, parameter];
      self.editorUi.editor.graph.model.threagile.setIn(path, checked);
    }
  };
}

// js/InspectionFormatPanel.js
var InspectionFormatPanel = function(format, editorUi, container) {
  BaseFormatPanel.call(this, format, editorUi, container);
  this.init();
};
extend(InspectionFormatPanel, BaseFormatPanel);
InspectionFormatPanel.prototype.init = function() {
  var ui = this.editorUi;
  let self = this;
  var editor = ui.editor;
  var graph = editor.graph;
  var ss = this.format.getSelectionState();
  let yaml = "";
  let cellsBegin = self.editorUi && self.editorUi.editor && self.editorUi.editor.graph ? self.editorUi.editor.graph.getSelectionCells() : null;
  let cellBegin = cellsBegin && cellsBegin.length > 0 ? cellsBegin[0] : null;
  var riskViewButton = button("Show Advanced Risk View", function(evt) {
    const selectedAssetKey = typeof technicalAssetId === "object" && technicalAssetId !== null ? technicalAssetId.key : technicalAssetId;
    const assetUniqueID = graph.model.threagile.getIn(["technical_assets", selectedAssetKey, "id"]);
    const assetDetails = jsonObj.technicalAssets[assetUniqueID];
    const assetRisks = [];
    for (const riskArray of yaml.values()) {
      for (const risk of riskArray) {
        if (risk && risk.syntheticId && risk.syntheticId.includes(assetUniqueID)) {
          risk.category = risk.category || risk.id;
          assetRisks.push(risk);
        }
      }
    }
    const dataForIframe = {
      title: assetDetails.title || "Untitled Asset",
      raa: assetDetails.raa,
      risks: assetRisks
    };
    const findDetailsById = (map, id) => {
      for (const key2 of map.keys()) {
        if (key2.id === id) {
          return key2;
        }
      }
      return null;
    };
    function showRiskDetailsView(categoryId, allPresentStrides) {
      const details = findDetailsById(yaml, categoryId);
      if (!details) {
        alert("Could not find risk category details for: " + categoryId);
        console.error("Failed to find details for ID:", categoryId, "in yaml map:", yaml);
        return;
      }
      const detailsOverlay = document.createElement("div");
      detailsOverlay.style.position = "fixed";
      detailsOverlay.style.top = "0";
      detailsOverlay.style.left = "0";
      detailsOverlay.style.width = "100vw";
      detailsOverlay.style.height = "100vh";
      detailsOverlay.style.backgroundColor = "rgba(255, 255, 255, 0.9)";
      detailsOverlay.style.zIndex = "10003";
      detailsOverlay.style.padding = "40px";
      detailsOverlay.style.boxSizing = "border-box";
      detailsOverlay.style.overflowY = "auto";
      const detailsIframe = document.createElement("iframe");
      detailsIframe.style.width = "100%";
      detailsIframe.style.height = "100%";
      detailsIframe.style.border = "1px solid #ccc";
      detailsIframe.style.borderRadius = "8px";
      detailsIframe.style.boxShadow = "0 8px 25px rgba(0,0,0,0.15)";
      detailsIframe.src = "about:blank";
      const detailsCloseButton = document.createElement("button");
      detailsCloseButton.innerHTML = "\xD7";
      detailsCloseButton.style.position = "fixed";
      detailsCloseButton.style.top = "10px";
      detailsCloseButton.style.right = "10px";
      detailsCloseButton.style.fontSize = "32px";
      detailsCloseButton.style.color = "#333";
      detailsCloseButton.style.backgroundColor = "transparent";
      detailsCloseButton.style.border = "none";
      detailsCloseButton.style.cursor = "pointer";
      detailsCloseButton.title = "Close Details";
      detailsCloseButton.style.zIndex = "10004";
      detailsCloseButton.onclick = function() {
        if (detailsOverlay.parentNode) {
          detailsOverlay.parentNode.removeChild(detailsOverlay);
        }
      };
      detailsOverlay.appendChild(detailsIframe);
      detailsOverlay.insertBefore(detailsCloseButton, detailsIframe);
      document.body.appendChild(detailsOverlay);
      detailsIframe.onload = function() {
        const doc = detailsIframe.contentWindow.document;
        const createSection2 = (title, content, isHtml = false) => {
          if (!content)
            return "";
          const section = doc.createElement("div");
          section.className = "detail-section";
          const h4 = doc.createElement("h4");
          h4.textContent = title;
          const p = doc.createElement("p");
          if (isHtml)
            p.innerHTML = content;
          else
            p.textContent = content;
          section.appendChild(h4);
          section.appendChild(p);
          return section;
        };
        const createStrideDiagram = (activeStride, presentStrides) => {
          const diagram = doc.createElement("div");
          diagram.className = "stride-diagram";
          const allStrides = ["Spoofing", "Tampering", "Repudiation", "Information Disclosure", "Denial of Service", "Elevation of Privilege"];
          allStrides.forEach((s) => {
            const item = doc.createElement("div");
            item.className = "stride-item";
            const name = doc.createElement("span");
            name.textContent = s;
            item.appendChild(name);
            if (s.toLowerCase() === (activeStride || "").toLowerCase()) {
              item.classList.add("active");
              item.title = "This is the STRIDE category for the selected risk.";
            } else if (presentStrides.has(s.toLowerCase())) {
              item.classList.add("present");
              item.title = "Other risks for this asset fall into this STRIDE category.";
            }
            diagram.appendChild(item);
          });
          return diagram;
        };
        doc.head.innerHTML = `
            <title>Risk Details: ${details.title}</title> <!-- <<< 'details' IS USED HERE -->
            <style>
                body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; color: #333; margin: 0; padding: 2em; background-color: #fafafa; }
                .container { display: grid; grid-template-columns: 320px 1fr; gap: 40px; max-width: 1400px; margin: 0 auto; }
                .sidebar { display: flex; flex-direction: column; gap: 20px; }
                .main-content { display: flex; flex-direction: column; gap: 15px; }
                h2 { font-size: 1.8em; color: #0056b3; margin: 0 0 5px 0; border-bottom: 2px solid #eee; padding-bottom: 10px; }
                h3 { font-size: 1.1em; color: #555; margin: 0 0 20px 0; font-weight: normal; }
                h4 { font-size: 1em; color: #000; margin: 0 0 5px 0; font-weight: 600; }
                p { margin: 0; line-height: 1.6; color: #444; }
                .detail-section { margin-bottom: 15px; }
                .meta-box { background: #fff; border: 1px solid #e0e0e0; border-radius: 6px; padding: 15px; }
                .meta-box p { font-size: 0.9em; }
                .meta-box b { color: #000; }
                a { color: #007bff; text-decoration: none; } a:hover { text-decoration: underline; }
                .stride-diagram { display: flex; flex-direction: column; gap: 8px; }
                .stride-item { padding: 10px 15px; border: 1px solid #ccc; border-radius: 5px; background-color: #f0f0f0; color: #888; transition: all 0.2s ease; }
                .stride-item.present { background-color: #e3f2fd; border-color: #90caf9; color: #1e88e5; font-weight: 500; }
                .stride-item.active { background-color: #0056b3; border-color: #004494; color: white; font-weight: bold; transform: scale(1.05); box-shadow: 0 4px 10px rgba(0, 86, 179, 0.3); }
            </style>
        `;
        doc.body.innerHTML = "";
        const titleEl = doc.createElement("h2");
        titleEl.textContent = details.title;
        const idEl = doc.createElement("h3");
        idEl.textContent = `ID: ${details.id}`;
        const container = doc.createElement("div");
        container.className = "container";
        const sidebar = doc.createElement("div");
        sidebar.className = "sidebar";
        const mainContent = doc.createElement("div");
        mainContent.className = "main-content";
        container.appendChild(sidebar);
        container.appendChild(mainContent);
        doc.body.appendChild(titleEl);
        doc.body.appendChild(idEl);
        doc.body.appendChild(container);
        const strideBox = doc.createElement("div");
        strideBox.className = "meta-box";
        strideBox.appendChild(createSection2("STRIDE Category", ""));
        strideBox.appendChild(createStrideDiagram(details.stride, allPresentStrides));
        sidebar.appendChild(strideBox);
        const metaBox = doc.createElement("div");
        metaBox.className = "meta-box";
        metaBox.appendChild(createSection2("Function", details.function || "N/A"));
        metaBox.appendChild(createSection2("CWE", details.cwe ? `<a href="https://cwe.mitre.org/data/definitions/${details.cwe}.html" target="_blank">${details.cwe}</a>` : "N/A", true));
        metaBox.appendChild(createSection2("ASVS", details.asvs || "N/A"));
        metaBox.appendChild(createSection2("Cheat Sheet", details.cheatSheet ? `<a href="${details.cheatSheet}" target="_blank">Open Link</a>` : "N/A", true));
        sidebar.appendChild(metaBox);
        mainContent.appendChild(createSection2("Description", details.description));
        mainContent.appendChild(createSection2("Impact", details.impact));
        mainContent.appendChild(createSection2("Action / Mitigation", details.mitigation || details.action));
        mainContent.appendChild(createSection2("How to Check", details.check));
        mainContent.appendChild(createSection2("Detection Logic", details.detectionLogic));
        mainContent.appendChild(createSection2("Risk Assessment", details.riskAssessment));
        mainContent.appendChild(createSection2("Potential False Positives", details.falsePositives));
      };
    }
    const riskListOverlay = document.createElement("div");
    var overlay = document.createElement("div");
    riskListOverlay.style.position = "fixed";
    riskListOverlay.style.top = "0";
    riskListOverlay.style.left = "0";
    riskListOverlay.style.width = "100vw";
    riskListOverlay.style.height = "100vh";
    riskListOverlay.style.backgroundColor = "rgba(245, 245, 245, 0.98)";
    riskListOverlay.style.zIndex = "10001";
    riskListOverlay.style.padding = "20px";
    riskListOverlay.style.boxSizing = "border-box";
    riskListOverlay.style.overflowY = "auto";
    const riskListIframe = document.createElement("iframe");
    riskListIframe.style.width = "100%";
    riskListIframe.style.height = "100%";
    riskListIframe.style.border = "none";
    riskListIframe.style.backgroundColor = "#fff";
    riskListIframe.src = "about:blank";
    const riskListCloseButton = document.createElement("button");
    riskListCloseButton.innerHTML = "\xD7";
    riskListCloseButton.style.position = "fixed";
    riskListCloseButton.style.top = "15px";
    riskListCloseButton.style.right = "20px";
    riskListCloseButton.style.fontSize = "32px";
    riskListCloseButton.style.fontWeight = "bold";
    riskListCloseButton.style.color = "#555";
    riskListCloseButton.style.backgroundColor = "transparent";
    riskListCloseButton.style.border = "none";
    riskListCloseButton.style.cursor = "pointer";
    riskListCloseButton.title = "Close";
    riskListCloseButton.style.zIndex = "10002";
    riskListCloseButton.onclick = function() {
      if (riskListOverlay.parentNode) {
        riskListOverlay.parentNode.removeChild(riskListOverlay);
      }
    };
    riskListOverlay.appendChild(riskListIframe);
    document.body.appendChild(riskListOverlay);
    document.body.appendChild(riskListCloseButton);
    riskListIframe.onload = function() {
      try {
        var doc = riskListIframe.contentWindow.document;
        const presentStrides = new Set(dataForIframe.risks.map((r) => (r.stride || "").toLowerCase()).filter(Boolean));
        const getRAAStyle = (raa) => {
          if (raa >= 75)
            return { className: "raa-critical", icon: "\u{1F4B0}" };
          if (raa >= 50)
            return { className: "raa-high", icon: "\u26A0\uFE0F" };
          if (raa >= 25)
            return { className: "raa-medium", icon: "" };
          return { className: "raa-low", icon: "" };
        };
        const createDetailItem = (label, value) => {
          const item = doc.createElement("div");
          item.className = "detail-item";
          const displayValue = value || "N/A";
          item.innerHTML = `<b>${label}:</b> <span>${displayValue}</span>`;
          return item;
        };
        doc.head.innerHTML = `
            <title>Advanced Risk View: ${dataForIframe.title}</title>
            <style>
                body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; color: #333; background-color: #fff; margin: 0; padding: 2.5em; }
                .header { border-bottom: 2px solid #eee; padding-bottom: 15px; margin-bottom: 25px; }
                h1 { color: #0056b3; margin: 0; font-size: 2em; }
                .raa-score { font-size: 1.2em; color: #555; display: flex; align-items: center; gap: 8px; }
                .raa-score b { font-size: 1.2em; padding: 2px 6px; border-radius: 4px; color: white; }
                .raa-low { background-color: #43a047; }
                .raa-medium { background-color: #fdd835; color: #333 !important; }
                .raa-high { background-color: #fb8c00; }
                .raa-critical { background-color: #b71c1c; }
                .raa-icon { font-size: 1.5em; }
                h2 { color: #444; margin-top: 40px; }
                .risk-list { display: grid; grid-template-columns: repeat(auto-fill, minmax(400px, 1fr)); gap: 25px; }
                .risk-card { background-color: #fdfdfd; border: 1px solid #ddd; border-left: 5px solid; border-radius: 5px; padding: 15px 20px; box-shadow: 0 4px 8px rgba(0,0,0,0.08); display: flex; flex-direction: column; }
                .risk-card-header { display: flex; justify-content: space-between; align-items: flex-start; gap: 10px; margin-bottom: 15px; }
                .risk-card h3 { margin: 0; font-size: 1.1em; color: #222; flex-grow: 1; }
                .risk-status { font-size: 0.8em; font-weight: bold; text-transform: uppercase; padding: 3px 8px; border-radius: 12px; background-color: #e0e0e0; color: #555; white-space: nowrap; }
                .risk-status-unchecked { background-color: #ffcdd2; color: #c62828; }
                .risk-status-unknown { background-color: #eeeeee; color: #616161; } /* Style for unknown status */
                .risk-details-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px 16px; font-size: 0.9em; margin-bottom: 15px; }
                .detail-item b { color: #000; }
                .detail-item span { color: #555; }
                .risk-card-footer { margin-top: auto; padding-top: 10px; border-top: 1px solid #eee; font-size: 0.75em; color: #888; font-family: monospace; }
                .severity-critical { border-color: #b71c1c; } .severity-high { border-color: #e53935; } .severity-elevated { border-color: #fb8c00; } .severity-medium { border-color: #fdd835; } .severity-low { border-color: #43a047; }
            </style>
        `;
        doc.body.innerHTML = "";
        const header = doc.createElement("div");
        header.className = "header";
        const h1 = doc.createElement("h1");
        h1.textContent = dataForIframe.title;
        const raaP = doc.createElement("p");
        raaP.className = "raa-score";
        const raaStyle = getRAAStyle(dataForIframe.raa);
        raaP.innerHTML = `Relative Attacker Attractiveness (RAA): <b class="${raaStyle.className}">${dataForIframe.raa.toFixed(2)}</b> <span class="raa-icon">${raaStyle.icon}</span>`;
        header.appendChild(h1);
        header.appendChild(raaP);
        doc.body.appendChild(header);
        const h2 = doc.createElement("h2");
        h2.textContent = "Identified Risks";
        doc.body.appendChild(h2);
        const riskContainer = doc.createElement("div");
        riskContainer.className = "risk-list";
        doc.body.appendChild(riskContainer);
        if (!dataForIframe.risks || dataForIframe.risks.length === 0) {
          riskContainer.innerHTML = "<p>No specific risks identified for this asset.</p>";
        } else {
          dataForIframe.risks.forEach((risk) => {
            const card = doc.createElement("div");
            card.className = `risk-card severity-${(risk.severity || "low").toLowerCase()}`;
            card.style.cursor = "pointer";
            card.title = "Click to see risk category details";
            card.dataset.category = risk.categoryId;
            card.addEventListener("click", () => {
              showRiskDetailsView(card.dataset.category, presentStrides);
            });
            const cardHeader = doc.createElement("div");
            cardHeader.className = "risk-card-header";
            const riskTitle = doc.createElement("h3");
            riskTitle.innerHTML = risk.title || "Untitled Risk";
            const riskStatus = doc.createElement("span");
            const statusValue = risk.risk_status || "unknown";
            riskStatus.className = `risk-status risk-status-${statusValue.toLowerCase()}`;
            riskStatus.textContent = statusValue.replace("_", " ");
            cardHeader.appendChild(riskTitle);
            cardHeader.appendChild(riskStatus);
            const detailsGrid = doc.createElement("div");
            detailsGrid.className = "risk-details-grid";
            detailsGrid.appendChild(createDetailItem("Severity", risk.severity));
            detailsGrid.appendChild(createDetailItem("Impact", risk.exploitationImpact));
            detailsGrid.appendChild(createDetailItem("Likelihood", risk.exploitationLikelihood));
            detailsGrid.appendChild(createDetailItem("Data Breach Probability", risk.data_breach_probability));
            const cardFooter = doc.createElement("div");
            cardFooter.className = "risk-card-footer";
            cardFooter.textContent = risk.synthetic_id || "No Synthetic ID";
            card.appendChild(cardHeader);
            card.appendChild(detailsGrid);
            card.appendChild(cardFooter);
            riskContainer.appendChild(card);
          });
        }
      } catch (e) {
        console.error("Error populating iframe with DOM APIs:", e);
        if (iframe.contentWindow.document.body) {
          iframe.contentWindow.document.body.innerHTML = '<p style="color:red; font-weight:bold;">Error loading risk data. Check the console for details.</p>';
        }
      }
    };
  });
  riskViewButton.style.marginBottom = "10px";
  riskViewButton.style.width = "100%";
  riskViewButton.className = "geBtn";
  this.container.appendChild(riskViewButton);
  const undefinedAsset = cellsBegin[0].technicalAsset === void 0;
  var technicalAssetId = !undefinedAsset ? cellsBegin[0].technicalAsset : generateUniquekey(graph);
  if (undefinedAsset) {
    const path = ["technical_assets", technicalAssetId];
    const uniqueID = generateUniqueId(graph);
    if (!graph.model.threagile.hasIn(path)) {
      const assetProperties = {
        id: uniqueID,
        description: "Tech Asset",
        type: "external-entity",
        usage: "business",
        used_as_client_by_human: false,
        out_of_scope: false,
        justification_out_of_scope: "Owned and managed by enduser customer",
        size: "component",
        technology: "browser",
        machine: "physical",
        encryption: "none",
        owner: "Customer",
        confidentiality: "internal",
        integrity: "operational",
        availability: "operational",
        justification_cia_rating: "The client used by the customer to access the system.",
        multi_tenant: false,
        redundant: false,
        custom_developed_parts: false
      };
      Object.keys(assetProperties).forEach((property2) => {
        graph.model.threagile.setIn([...path, property2], assetProperties[property2]);
      });
      let cells2 = self.editorUi.editor.graph.getSelectionCells();
      let cell3 = cells2 && cells2.length > 0 ? cells2[0] : null;
      if (!cell3.technicalAsset) {
        cell3.technicalAsset = {};
        cell3.technicalAsset["id"] = uniqueID;
        cell3.technicalAsset["key"] = technicalAssetId;
      }
    }
    if (graph.model.threagile.hasIn(["technical_assets", "__DELETE_ME__"])) {
      graph.model.threagile.deleteIn(["technical_assets", "__DELETE_ME__"]);
    }
    let cells = self.editorUi.editor.graph.getSelectionCells();
    let cell2 = cells && cells.length > 0 ? cells[0] : null;
    let model = self.editorUi.editor.graph.model;
    model.beginUpdate();
    try {
      model.setValue(cell2, technicalAssetId);
      self.editorUi.editor.graph.refresh(cell2);
      self.editorUi.editor.graph.refresh();
    } finally {
      model.endUpdate();
    }
  }
  let start, end;
  start = performance.now();
  let threagileString = graph.model.threagile.toString();
  end = performance.now();
  console.log("toString() time: " + (end - start) + " ms");
  start = performance.now();
  let parsedString = window.parseModelViaString(threagileString);
  end = performance.now();
  console.log("parseModelViaString() time: " + (end - start) + " ms");
  start = performance.now();
  if (!parsedString.technicalAssets && parsedString.includes("$$__ERROR__$$")) {
    let errorMessage = parsedString.split("$$__ERROR__$$")[1];
    Swal.fire({
      title: '<span style="color: #333; font-family: Arial, sans-serif;">Error Detected!</span>',
      html: `<span style="font-family: Arial, sans-serif;">An error occurred while parsing the JSON object:<br/><strong>Error:</strong> ${errorMessage}</span>`,
      icon: "error",
      iconColor: "#555",
      confirmButtonText: "Close",
      confirmButtonColor: "#aaa",
      confirmButtonAriaLabel: "Close the dialog",
      buttonsStyling: false,
      customClass: {
        confirmButton: "custom-confirm-button-style",
        popup: "custom-popup-style"
      },
      background: "#f0f0f0",
      backdrop: "rgba(50, 50, 50, 0.4)",
      didRender: function() {
        const styleTag = document.createElement("style");
        styleTag.innerHTML = `
              .custom-confirm-button-style {
                  background-color: #aaa;  // More neutral button color
                  color: #fff;
                  border: none;
                  border-radius: 5px;
                  padding: 10px 20px;
                  font-size: 16px;
                  transition: background-color 0.3s ease;
              }
              .custom-confirm-button-style:hover {
                  background-color: #999;  // Darker hover effect
              }
              .custom-popup-style {
                  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
                  border-radius: 8px;
              }
          `;
        document.head.appendChild(styleTag);
      }
    });
  }
  let jsonObj = parsedString;
  end = performance.now();
  console.log("JSON.parse() time: " + (end - start) + " ms");
  window.applyRAAJS();
  yaml = window.applyRiskGenerationJS();
  let span = document.createElement("span");
  span.innerHTML = "<b>Relative Attacker Attractivness:</b> ";
  this.container.appendChild(span);
  let listContainer = document.createElement("div");
  listContainer.style.maxWidth = "400px";
  listContainer.style.margin = "0 auto";
  var list = document.createElement("ul");
  list.style.listStyleType = "none";
  list.style.padding = "0";
  var items = [];
  for (let i2 = 0; i2 < items.length; i2++) {
    listItem.textContent = items[i2];
    listItem.style.display = "flex";
    listItem.style.alignItems = "center";
    listItem.style.padding = "8px";
    listItem.style.borderBottom = "1px solid #ccc";
    let xButton = document.createElement("button");
    xButton.innerHTML = '<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJAQMAAADaX5RTAAAABlBMVEV7mr3///+wksspAAAAAnRSTlP/AOW3MEoAAAAdSURBVAgdY9jXwCDDwNDRwHCwgeExmASygSL7GgB12QiqNHZZIwAAAABJRU5ErkJggg==" alt="X">';
    xButton.style.marginLeft = "auto";
    xButton.style.padding = "5px";
    xButton.style.backgroundColor = "transparent";
    xButton.style.border = "none";
    xButton.style.cursor = "pointer";
    listItem.appendChild(xButton);
    list.appendChild(listItem);
  }
  function interpolateColorForRisks(minColor, maxColor, minVal, maxVal, val) {
    var step = (val - minVal) / (maxVal - minVal);
    step = Math.max(0, Math.min(1, step));
    const lowRiskColor2 = [76, 175, 80];
    const medRiskColor = [255, 152, 0];
    const highRiskColor2 = [183, 28, 28];
    let red, green, blue;
    if (step < 0.5) {
      const normalizedStep = step * 2;
      red = Math.round(lowRiskColor2[0] + normalizedStep * (medRiskColor[0] - lowRiskColor2[0]));
      green = Math.round(lowRiskColor2[1] + normalizedStep * (medRiskColor[1] - lowRiskColor2[1]));
      blue = Math.round(lowRiskColor2[2] + normalizedStep * (medRiskColor[2] - lowRiskColor2[2]));
    } else {
      const normalizedStep = (step - 0.5) * 2;
      red = Math.round(medRiskColor[0] + normalizedStep * (highRiskColor2[0] - medRiskColor[0]));
      green = Math.round(medRiskColor[1] + normalizedStep * (highRiskColor2[1] - medRiskColor[1]));
      blue = Math.round(medRiskColor[2] + normalizedStep * (highRiskColor2[2] - medRiskColor[2]));
    }
    return `rgb(${red}, ${green}, ${blue})`;
  }
  function mapRiskLevel(value, category) {
    const mappings = {
      "severity": {
        "low": 1,
        "medium": 2,
        "elevated": 3,
        "high": 4,
        "critical": 5
      },
      "impact": {
        "low": 1,
        "medium": 2,
        "high": 3,
        "very-high": 4
      },
      "likelihood": {
        "unlikely": 1,
        "likely": 3,
        "very-likely": 4,
        "frequent": 5
      },
      "probability": {
        "improbable": 1,
        "possible": 2,
        "probable": 3
      }
    };
    return mappings[category][value.toLowerCase().replace("-", "")] || 0;
  }
  const lowRiskColor = [0, 255, 0];
  const highRiskColor = [255, 0, 0];
  if (yaml != "" && technicalAssetId != "" && technicalAssetId !== void 0) {
    let filteredArray = [];
    let gaugeElement = document.createElement("div");
    gaugeElement.id = "gaugeElement";
    gaugeElement.style.width = "234px";
    gaugeElement.style.height = "130px";
    this.container.appendChild(gaugeElement);
    if (typeof technicalAssetId === "object" && technicalAssetId !== null) {
      technicalAssetId = technicalAssetId.key;
    }
    let id = graph.model.threagile.getIn(["technical_assets", technicalAssetId, "id"]);
    if (id === void 0) {
      const technicalAsset = graph.model.threagile.getIn(["technical_assets", technicalAssetId]);
      if (graph.model.threagile.getIn(["technical_assets", technicalAssetId, "id"]) === void 0) {
        let threat = self.editorUi.editor.graph.model.threagile.getIn(["technical_assets", technicalAssetId]);
        if (typeof threat.toJSON === "function") {
          threat = threat.toJSON();
        }
        id = threat.id;
      } else {
        id = technicalAsset ? technicalAsset.title : void 0;
      }
    }
    let RAA = jsonObj.technicalAssets[id].raa;
    let gauge = new JustGage({
      id: "gaugeElement",
      value: RAA == 1 ? 0 : RAA,
      min: 0,
      max: 100,
      decimals: 2,
      gaugeWidthScale: 0.6
    });
    for (const riskArray of yaml.values()) {
      for (const risk of riskArray) {
        if (risk && risk.syntheticId && typeof risk.syntheticId === "string") {
          if (risk.syntheticId.includes(id)) {
            filteredArray.push(risk);
          }
        } else {
        }
      }
    }
    for (let jsonData in filteredArray) {
      let toggleContent = function() {
        if (!current2.visible) {
          console.log("Expanding: Removing background color");
          listItem.style.backgroundColor = "";
          arrowIcon.style.transform = "rotate(270deg)";
          clonedMenu.style.display = "block";
          listItem.focus();
        } else {
          console.log("Collapsing: Setting background color to", listItem.dataset.initialColor);
          listItem.style.backgroundColor = listItem.dataset.initialColor;
          arrowIcon.style.transform = "rotate(90deg)";
          clonedMenu.style.display = "none";
        }
        current2.visible = !current2.visible;
      }, handleFocusIn = function() {
        console.log("Item focused");
        listItem.style.outline = "2px solid blue";
        const separators = /[@><]/;
        function findCommunicationLinkName(communicationLink, graphJson) {
          const { source, target } = communicationLink;
          const technicalAssets = graphJson.technical_assets;
          for (let key3 in technicalAssets) {
            if (technicalAssets[key3].id === source) {
              sourceAsset = technicalAssets[key3];
              break;
            }
          }
          if (!sourceAsset) {
            return null;
          }
          let matchingLink = null;
          for (let key3 in sourceAsset.communication_links) {
            if (sourceAsset.communication_links[key3].target === target) {
              matchingLink = sourceAsset.communication_links[key3];
              break;
            }
          }
          if (matchingLink) {
            return matchingLink;
          } else {
            return null;
          }
        }
        function extractComponents(link2) {
          let separatorIndex = link2.indexOf(">");
          if (separatorIndex === -1) {
            return null;
          }
          let source = link2.substring(0, separatorIndex);
          let target = link2.substring(separatorIndex + 1);
          return {
            source,
            target
          };
        }
        const elements = listItem.metaData.synthetic_id.split(separators);
        const comm = listItem.metaData.most_relevant_communication_link;
        const components = extractComponents(comm);
        let communicationLinkName;
        if (components != null) {
          let threat = self.editorUi.editor.graph.model.threagile;
          if (typeof threat.toJSON === "function") {
            threat = threat.toJSON();
          }
          communicationLinkName = findCommunicationLinkName(components, threat);
        }
        var model = graph.getModel();
        var allCells = model.cells;
        function highlightCell(cell3) {
          var graph2 = this.editorUi.editor.graph;
          let highlight2 = new mxCellHighlight(graph2, "#FF0000", 8);
          highlight2.opacity = 90;
          highlight2.highlight(graph2.view.getState(cell3));
          highlight2.highlight(graph2.view.getState(cell3));
          if (!graph2.highlightedCells) {
            graph2.highlightedCells = [];
          }
          graph2.highlightedCells.push(highlight2);
        }
        self.editorUi.editor.graph.model.beginUpdate();
        for (var key2 in allCells) {
          if (allCells.hasOwnProperty(key2)) {
            var cell2 = allCells[key2];
            if (communicationLinkName && model.isEdge(cell2)) {
              let object = cell2.communicationAsset;
              if (typeof object.toJSON === "function") {
                object = object.toJSON();
              }
              if (communicationLinkName.description === object.description && communicationLinkName.target === object.target) {
                highlightCell(cell2);
              }
            } else if (model.isVertex(cell2)) {
              var style = cell2.getStyle();
              if (style && !style.includes("shape=rectangle")) {
                var technicalAssetId2 = cell2.technicalAsset.id;
                if (elements.includes(technicalAssetId2)) {
                  highlightCell(cell2);
                }
              }
            }
          }
        }
        self.editorUi.editor.graph.model.endUpdate();
      }, handleFocusOut = function() {
        console.log("Item focus out");
        listItem.style.outline = "none";
        let highlightedCells = self.editorUi.editor.graph.highlightedCells;
        function removeHighlight(cell2) {
          cell2.destroy();
        }
        self.editorUi.editor.graph.model.beginUpdate();
        highlightedCells.forEach((cell2) => {
          removeHighlight(cell2);
        });
        self.editorUi.editor.graph.model.endUpdate();
        highlightedCells = [];
      };
      let value = filteredArray[jsonData];
      let riskScore = 0;
      let currentRiskItem = filteredArray[jsonData];
      let itemTitleForLog = currentRiskItem.title || `Risk Item (key: ${jsonData}, syntheticId: ${currentRiskItem.syntheticId || "N/A"})`;
      if (currentRiskItem.severity === void 0) {
        console.error(`[RISK CALCULATION LOOP] 'severity' is undefined for risk item titled: "${currentRiskItem.title || "Title N/A"}" (key: ${jsonData}, syntheticId: ${currentRiskItem.syntheticId || "N/A"}). Item details:`, JSON.parse(JSON.stringify(currentRiskItem)));
      }
      riskScore += mapRiskLevel(currentRiskItem.severity, "severity", itemTitleForLog);
      if (currentRiskItem.exploitationImpact === void 0) {
        console.error(`[RISK CALCULATION LOOP] 'exploitationImpact' is undefined for risk item titled: "${currentRiskItem.title || "Title N/A"}" (key: ${jsonData}, syntheticId: ${currentRiskItem.syntheticId || "N/A"}). Item details:`, JSON.parse(JSON.stringify(currentRiskItem)));
      }
      riskScore += mapRiskLevel(currentRiskItem.exploitationImpact, "impact", itemTitleForLog);
      if (currentRiskItem.exploitationLikelihood === void 0) {
        console.error(`[RISK CALCULATION LOOP] 'exploitationLikelihood' is undefined for risk item titled: "${currentRiskItem.title || "Title N/A"}" (key: ${jsonData}, syntheticId: ${currentRiskItem.syntheticId || "N/A"}). Item details:`, JSON.parse(JSON.stringify(currentRiskItem)));
      }
      riskScore += mapRiskLevel(currentRiskItem.exploitationLikelihood, "likelihood", itemTitleForLog);
      if (currentRiskItem.dataBreachProbability === void 0) {
        console.error(`[RISK CALCULATION LOOP] 'dataBreachProbability' is undefined for risk item titled: "${currentRiskItem.title || "Title N/A"}" (key: ${jsonData}, syntheticId: ${currentRiskItem.syntheticId || "N/A"}). Item details:`, JSON.parse(JSON.stringify(currentRiskItem)));
      }
      riskScore *= mapRiskLevel(currentRiskItem.dataBreachProbability, "probability", itemTitleForLog);
      let maxRiskScore = (5 + 4 + 5) * 3;
      let regex = /<b>(.*?)<\/b>/i;
      let match2 = regex.exec(filteredArray[jsonData].title);
      let property2 = "";
      if (match2 && match2[1]) {
        property2 = match2[1];
      }
      let clonedMenu = this.addInspectionMenu(this.createPanel(), filteredArray[jsonData]);
      clonedMenu.id = property2;
      var listItem = document.createElement("li");
      listItem.style.display = "flex";
      listItem.style.flexDirection = "column";
      listItem.style.padding = "8px";
      listItem.style.borderBottom = "1px solid #ccc";
      let initialColor = interpolateColorForRisks(lowRiskColor, highRiskColor, 0, 25, riskScore);
      listItem.style.backgroundColor = initialColor;
      listItem.dataset.initialColor = initialColor;
      listItem.metaData = value;
      let parentNode = clonedMenu.childNodes[0];
      for (var key in value) {
        if (value.hasOwnProperty(key)) {
          var childNode = value[key];
          for (var i = 0; i < parentNode.childNodes.length; i++) {
            var currentChildNode = parentNode.childNodes[i];
            if (currentChildNode.nodeType === Node.ELEMENT_NODE) {
              if (currentChildNode.id && currentChildNode.id.startsWith("exploitation_")) {
                console.log("Original ID:", currentChildNode.id);
                currentChildNode.id = currentChildNode.id.substring("exploitation_".length);
                console.log("Updated ID:", currentChildNode.id);
              }
              if (currentChildNode.children.length > 0) {
                let exploit_prefix = "exploitation_" + currentChildNode.children[0].textContent;
                let data_breach_prefix = "data_breach_" + currentChildNode.children[0].textContent;
                if (currentChildNode.children[0].textContent === key || exploit_prefix === key || data_breach_prefix == key) {
                  if (currentChildNode.children.length > 1 && currentChildNode.childNodes.length > 0) {
                    let nextChildNode = currentChildNode.children[1].children[0];
                    for (let i2 = 0; i2 < nextChildNode.options.length; i2++) {
                      if (nextChildNode.options[i2].value === childNode) {
                        nextChildNode.selectedIndex = i2;
                        break;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      let textContainer = document.createElement("div");
      textContainer.style.display = "flex";
      textContainer.style.alignItems = "center";
      textContainer.style.marginBottom = "8px";
      let arrowIcon = document.createElement("img");
      textContainer.style.color = "black";
      textContainer.style.fontWeight = "bold";
      arrowIcon.src = " data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAAagAAAGoB3Bi5tQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAEUSURBVDiNjdO9SgNBFIbhJ4YkhZ2W2tgmphYEsTJiY2Vjk0YbMYVeiKAo2mjlHVhpDBaCoPGnEjtvQLAWRIjF7sJmM9nk7WbO+b6Zc+ZMwSB1bGMRhXivhwec4z2gARWcoo0VlFKxEhq4xQnKIXEbO8PcU+ziJmtyNqY4oYXjZFGPHbNMo5hj0kEVDkU1Z2niCpNDDFZxAF39DUuzgUfMBmJlPMFLzjVhGW+YC8ReJ0aIR9FjvBJmArEKukXU8IfPTEITm1jHd8CgkRw8L5qwLFPyn/EO1SK+sCBq0nMq4UdcY4B9/OIy2SiLhqmVc2LCHq4F+lYWjWdHNCTpWa9gLb72UVpcMEgNW1jS/53vcYGPdPI/rfEvjAsiqsMAAAAASUVORK5CYII=";
      arrowIcon.style.width = "15px";
      arrowIcon.style.height = "15px";
      arrowIcon.style.marginRight = "5px";
      let dataText = document.createElement("div");
      dataText.textContent = property2;
      arrowIcon.style.transform = "rotate(270deg)";
      textContainer.appendChild(arrowIcon);
      textContainer.appendChild(dataText);
      textContainer.appendChild(dataText);
      let current2 = { visible: false };
      if (current2.visible) {
        listItem.style.backgroundColor = "";
        arrowIcon.style.transform = "rotate(270deg)";
        clonedMenu.style.display = "block";
      } else {
        listItem.style.backgroundColor = listItem.dataset.initialColor;
        arrowIcon.style.transform = "rotate(90deg)";
        clonedMenu.style.display = "none";
      }
      listItem.appendChild(textContainer);
      listItem.appendChild(clonedMenu);
      arrowIcon.addEventListener("click", toggleContent);
      dataText.addEventListener("click", toggleContent);
      listItem.setAttribute("tabindex", "0");
      if (self.editorUi.editor.graph.highlightedCells === void 0) {
        self.editorUi.editor.graph.highlightedCells = [];
      }
      listItem.addEventListener("focusin", handleFocusIn);
      listItem.addEventListener("focusout", handleFocusOut);
      list.appendChild(listItem);
    }
  }
  let generalHeader = document.createElement("div");
  generalHeader.innerHTML = "Risks:";
  generalHeader.style.padding = "10px 0px 6px 0px";
  generalHeader.style.whiteSpace = "nowrap";
  generalHeader.style.overflow = "hidden";
  generalHeader.style.width = "200px";
  generalHeader.style.fontWeight = "bold";
  this.container.appendChild(generalHeader);
  listContainer.appendChild(list);
  this.container.appendChild(listContainer);
  let listContainer2 = document.createElement("div");
  listContainer2.style.maxWidth = "400px";
  listContainer2.style.margin = "0 auto";
  let list2 = document.createElement("ul");
  list2.style.listStyleType = "none";
  list2.style.padding = "0";
  let riskTracking = document.createElement("div");
  riskTracking.innerHTML = "RisksTracking:";
  riskTracking.style.padding = "10px 0px 6px 0px";
  riskTracking.style.whiteSpace = "nowrap";
  riskTracking.style.overflow = "hidden";
  riskTracking.style.width = "200px";
  riskTracking.style.fontWeight = "bold";
  this.container.appendChild(riskTracking);
  listContainer2.appendChild(list2);
  this.container.appendChild(listContainer2);
  if (yaml != "") {
    let cellsBegin2 = self.editorUi.editor.graph.getSelectionCells();
    let cellBegin2 = cellsBegin2 && cellsBegin2.length > 0 ? cellsBegin2[0] : null;
    let technicalAssetId2 = cellBegin2.technicalAsset["id"];
    let filteredArray = [];
    for (var i = 0; i < yaml.length; i++) {
      let obj = yaml[i];
      if (obj.synthetic_id.includes(technicalAssetId2)) {
        filteredArray.push(obj);
      }
    }
    for (let jsonData in filteredArray) {
      let toggleContent = function() {
        let state3 = current2;
        current2 = !current2;
        if (!state3) {
          listItem2.style.backgroundColor = "";
          arrowIcon.style.transform = "rotate(270deg)";
          clonedMenu.style.display = "block";
        } else {
          listItem2.style.backgroundColor = "lightgray";
          arrowIcon.style.transform = "rotate(90deg)";
          clonedMenu.style.display = "none";
        }
      };
      let value = filteredArray[jsonData];
      let regex = /<b>(.*?)<\/b>/i;
      let match2 = regex.exec(filteredArray[jsonData].title);
      let property2 = "";
      if (match2 && match2[1]) {
        property2 = match2[1];
      }
      let clonedMenu = this.addInspectionMenu2(this.createPanel(), filteredArray[jsonData]);
      clonedMenu.id = property2;
      let listItem2 = document.createElement("li");
      listItem2.style.display = "flex";
      listItem2.style.flexDirection = "column";
      listItem2.style.padding = "8px";
      listItem2.style.borderBottom = "1px solid #ccc";
      let parentNode = clonedMenu.childNodes[0];
      for (var key in value) {
        if (value.hasOwnProperty(key)) {
          var childNode = value[key];
          for (var i = 0; i < parentNode.childNodes.length; i++) {
            var currentChildNode = parentNode.childNodes[i];
            if (currentChildNode.nodeType === Node.ELEMENT_NODE && currentChildNode.children.length > 0 && currentChildNode.children[0].textContent === key) {
              if (currentChildNode.children.length > 1 && currentChildNode.childNodes.length > 0) {
                let nextChildNode = currentChildNode.children[1].children[0];
                if (nextChildNode.nodeName === "SELECT") {
                  nextChildNode.selectedIndex = childNode;
                }
              }
            }
          }
        }
      }
      let textContainer = document.createElement("div");
      textContainer.style.display = "flex";
      textContainer.style.alignItems = "center";
      textContainer.style.marginBottom = "8px";
      let arrowIcon = document.createElement("img");
      arrowIcon.src = " data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAAagAAAGoB3Bi5tQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAEUSURBVDiNjdO9SgNBFIbhJ4YkhZ2W2tgmphYEsTJiY2Vjk0YbMYVeiKAo2mjlHVhpDBaCoPGnEjtvQLAWRIjF7sJmM9nk7WbO+b6Zc+ZMwSB1bGMRhXivhwec4z2gARWcoo0VlFKxEhq4xQnKIXEbO8PcU+ziJmtyNqY4oYXjZFGPHbNMo5hj0kEVDkU1Z2niCpNDDFZxAF39DUuzgUfMBmJlPMFLzjVhGW+YC8ReJ0aIR9FjvBJmArEKukXU8IfPTEITm1jHd8CgkRw8L5qwLFPyn/EO1SK+sCBq0nMq4UdcY4B9/OIy2SiLhqmVc2LCHq4F+lYWjWdHNCTpWa9gLb72UVpcMEgNW1jS/53vcYGPdPI/rfEvjAsiqsMAAAAASUVORK5CYII=";
      arrowIcon.style.width = "15px";
      arrowIcon.style.height = "15px";
      arrowIcon.style.marginRight = "5px";
      let dataText = document.createElement("div");
      dataText.textContent = property2;
      arrowIcon.style.transform = "rotate(270deg)";
      textContainer.appendChild(arrowIcon);
      textContainer.appendChild(dataText);
      textContainer.appendChild(dataText);
      let current2 = false;
      let state2 = current2;
      if (state2) {
        listItem2.style.backgroundColor = "";
        arrowIcon.style.transform = "rotate(270deg)";
        clonedMenu.style.display = "block";
      } else {
        listItem2.style.backgroundColor = "lightgray";
        arrowIcon.style.transform = "rotate(90deg)";
        clonedMenu.style.display = "none";
      }
      listItem2.appendChild(textContainer);
      listItem2.appendChild(clonedMenu);
      arrowIcon.addEventListener("click", toggleContent);
      dataText.addEventListener("click", toggleContent);
      list2.appendChild(listItem2);
    }
  }
};
InspectionFormatPanel.prototype.addInspectionFormatMenuDynamic = function(container, graph, yaml) {
  var self = this;
  let jsonContainer = document.createElement("div");
  let cellsBegin = self.editorUi.editor.graph.getSelectionCells();
  let cellBegin = cellsBegin && cellsBegin.length > 0 ? cellsBegin[0] : null;
  let technicalAssetId = cellBegin.technicalAsset["id"];
  var filteredArray = [];
  for (var i = 0; i < yaml.length; i++) {
    var obj = yaml[i];
    if (obj.synthetic_id.includes(technicalAssetId)) {
      filteredArray.push(obj);
    }
  }
  for (let jsonData in filteredArray) {
    for (let key in filteredArray[jsonData]) {
      let value = filteredArray[jsonData][key];
      let propertyName2 = document.createElement("span");
      propertyName2.innerHTML = key;
      propertyName2.style.width = "100px";
      propertyName2.style.marginRight = "10px";
      let propertyValue = document.createElement("span");
      propertyValue.innerHTML = value;
      jsonContainer.appendChild(propertyName2);
      jsonContainer.appendChild(propertyValue);
      jsonContainer.appendChild(document.createElement("br"));
    }
    container.appendChild(jsonContainer);
  }
  var propertiesSection = createSection("Properties");
  container.appendChild(propertiesSection);
  var typeProperties = {
    id: {
      description: "ID",
      type: "button",
      tooltip: "The unique identifier for the element",
      defaultValue: "E.g. Element1"
    },
    description: {
      description: "Description",
      type: "button",
      tooltip: "Provide a brief description of the element",
      defaultValue: "E.g. This element is responsible for..."
    },
    usage: {
      description: "Usage",
      type: "select",
      options: ["business", "devops"],
      tooltip: "Indicates whether the element is used for business or devops purposes",
      defaultValue: "business"
    },
    tags: {
      description: "Tags",
      type: "array",
      uniqueItems: true,
      items: {
        type: "button"
      },
      tooltip: "Provide tags to help categorize the element",
      defaultValue: "E.g. Tag1"
    },
    origin: {
      description: "Origin",
      type: "button",
      tooltip: "Specifies the origin of the element",
      defaultValue: "E.g. Internal Development"
    },
    owner: {
      description: "Owner",
      type: "button",
      tooltip: "Specifies the owner of the element",
      defaultValue: "E.g. Marketing Team"
    },
    quantity: {
      description: "Quantity",
      type: "select",
      options: ["very-few", "few", "many", "very-many"],
      tooltip: "Specifies the quantity of the element",
      defaultValue: "few"
    },
    confidentiality: {
      description: "Confidentiality",
      type: "select",
      options: [
        "public",
        "internal",
        "restricted",
        "confidential",
        "strictly-confidential"
      ],
      tooltip: "Specifies the level of confidentiality of the element",
      defaultValue: "internal"
    },
    integrity: {
      description: "Integrity",
      type: "select",
      options: [
        "archive",
        "operational",
        "important",
        "critical",
        "mission-critical"
      ],
      tooltip: "Specifies the level of integrity of the element",
      defaultValue: "operational"
    },
    availability: {
      description: "Availability",
      type: "select",
      options: [
        "archive",
        "operational",
        "important",
        "critical",
        "mission-critical"
      ],
      tooltip: "Specifies the level of availability of the element",
      defaultValue: "operational"
    },
    justification_cia_rating: {
      description: "Justification of the rating",
      type: "button",
      tooltip: "Justify the confidentiality, integrity, and availability rating",
      defaultValue: "E.g. This rating is due to..."
    }
  };
  var customListener2 = {
    install: function(apply) {
      this.listener = function() {
      };
    },
    destroy: function() {
    }
  };
  var self = this;
  var typePropertiesMap = {};
  for (let property2 in typeProperties) {
    var typeItem = document.createElement("li");
    typeItem.style.display = "flex";
    typeItem.style.alignItems = "baseline";
    typeItem.style.marginBottom = "8px";
    var propertyName = document.createElement("span");
    propertyName.innerHTML = property2;
    propertyName.style.width = "100px";
    propertyName.style.marginRight = "10px";
    var propertyType = typeProperties[property2].type;
    if (propertyType === "select") {
      const propertySelect = property2;
      typeItem.appendChild(propertyName);
      var selectContainer = document.createElement("div");
      selectContainer.style.display = "flex";
      selectContainer.style.alignItems = "center";
      selectContainer.style.marginLeft = "auto";
      var selectDropdown = document.createElement("select");
      selectDropdown.style.width = "100px";
      selectDropdown.title = typeProperties[property2].tooltip;
      selectContainer.appendChild(selectDropdown);
      var options = typeProperties[property2].options;
      for (var i = 0; i < options.length; i++) {
        var option = document.createElement("option");
        option.value = options[i];
        option.text = options[i];
        selectDropdown.appendChild(option);
      }
      var createChangeListener = function(selectDropdown2, property3) {
        var self2 = this.editorUi;
        return function(evt) {
          var dataAssetId = evt.target.parentNode.parentNode.parentNode.parentNode.textContent.split(":")[0];
          let dataAsset = graph.model.threagile.getIn(["data_assets", dataAssetId]);
          let current2 = dataAsset;
          var newValue = selectDropdown2.value;
          currentValue = newValue;
          if (!current2[property3]) {
            current2[property3] = "";
          }
          if (newValue != null) {
            current2[property3] = newValue;
          }
        };
      }.bind(this);
      mxEvent2.addListener(selectDropdown, "change", createChangeListener(selectDropdown, property2));
      typeItem.appendChild(selectContainer);
    } else if (propertyType === "checkbox") {
      let optionElement = this.createOption(property2, createCustomOption(self, property2), setCustomOption(self, property2), customListener2);
      optionElement.querySelector('input[type="checkbox"]').title = typeProperties[property2].tooltip;
      container.appendChild(optionElement);
    } else if (propertyType === "button") {
      let functionName = "editData" + property2.charAt(0).toUpperCase() + property2.slice(1);
      let button2 = button(property2, bind(this, function(evt) {
        var dataAssetId = evt.target.parentNode.parentNode.parentNode.parentNode.textContent.split(":")[0];
        let current2 = graph.model.threagile.getIn(["data_assets", dataAssetId]);
        if (!current2[property2]) {
          current2[property2] = typeProperties[property2].defaultValue;
        }
        var dataValue = current2[property2];
        var dlg = new TextareaDialog(this.editorUi, property2 + ":", dataValue, function(newValue) {
          if (newValue != null) {
            current2[property2] = newValue;
          }
        }, null, null, 400, 220);
        this.editorUi.showDialog(dlg.container, 420, 300, true, true);
        dlg.init();
        try {
          if (dlg.textarea) {
            let textareaId = `threagile-dialog-${property2}-textarea`;
            dlg.textarea.id = textareaId;
            console.log(`Added ID to textarea: ${textareaId}`);
          } else {
            console.warn(`Could not find dlg.textarea for property '${property2}'.`);
          }
        } catch (e) {
          console.error("Error adding ID to dialog textarea:", e);
        }
        try {
          let buttonContainer = dlg.container.querySelector(".geDialogButtons");
          let buttons = buttonContainer ? buttonContainer.querySelectorAll("button") : dlg.container.querySelectorAll("button");
          if (buttons && buttons.length > 0) {
            const applyText = mxResources.get("apply") || "Apply";
            const cancelText = mxResources.get("cancel") || "Cancel";
            let applyFound = false;
            let cancelFound = false;
            buttons.forEach((btn) => {
              if (!applyFound && (btn.textContent.trim() === applyText || btn.textContent.trim() === (mxResources.get("ok") || "OK"))) {
                btn.id = `threagile-dialog-${property2}-apply-button`;
                applyFound = true;
              } else if (!cancelFound && btn.textContent.trim() === cancelText) {
                btn.id = `threagile-dialog-${property2}-cancel-button`;
                cancelFound = true;
              }
            });
          } else {
            console.warn("Could not find buttons in TextareaDialog container for property:", property2);
          }
        } catch (e) {
          console.error("Error adding IDs to dialog buttons:", e);
        }
      }));
      button2.title = typeProperties[property2].tooltip;
      button2.style.width = "200px";
      typeItem.appendChild(button2);
    }
    propertiesSection.appendChild(typeItem);
  }
  return container;
};
InspectionFormatPanel.prototype.addInspectionMenu2 = function(container, value) {
  let self = this;
  var propertiesSection = createSection("risk_identified:");
  container.appendChild(propertiesSection);
  let typeProperties = {
    status: {
      description: "Status",
      type: "select",
      options: [
        "unchecked",
        "in-discussion",
        "accepted",
        "in-progress",
        "mitigated",
        "false-positive"
      ],
      tooltip: "The status indicates the current stage of processing for the risk.",
      defaultValue: "unchecked"
    },
    justification: {
      description: "Justification",
      type: "button",
      defaultValue: "",
      tooltip: "The justification describes why the risk is considered relevant or explains the reasoning behind specific actions taken."
    },
    ticket: {
      description: "Ticket",
      type: "button",
      defaultValue: "",
      tooltip: "The ticket refers to the associated issue tracking system where additional details or activities related to the risk can be recorded."
    },
    date: {
      description: "Date",
      type: "button",
      format: "date",
      defaultValue: "",
      tooltip: "The date indicates when the risk was captured or last updated."
    },
    checked_by: {
      description: "Checked by",
      type: "button",
      defaultValue: "",
      tooltip: "The 'Checked by' field specifies the individual or team responsible for verifying the risk mitigation measures."
    }
  };
  var customListener2 = {
    install: function(apply) {
      this.listener = function() {
      };
    },
    destroy: function() {
    }
  };
  var typePropertiesMap = {};
  for (let property2 in typeProperties) {
    var typeItem = document.createElement("li");
    typeItem.style.display = "flex";
    typeItem.style.alignItems = "baseline";
    typeItem.style.marginBottom = "8px";
    var propertyName = document.createElement("span");
    propertyName.innerHTML = property2;
    propertyName.style.width = "100px";
    propertyName.style.marginRight = "10px";
    propertyName.innerHTML = property2.replace(/exploitation_|data_breach_/g, "");
    var propertyType = typeProperties[property2].type;
    if (propertyType === "select") {
      const propertySelect = property2;
      typeItem.appendChild(propertyName);
      var selectContainer = document.createElement("div");
      selectContainer.style.display = "flex";
      selectContainer.style.alignItems = "center";
      selectContainer.style.marginLeft = "auto";
      var selectDropdown = document.createElement("select");
      selectDropdown.style.width = "100px";
      selectDropdown.title = typeProperties[property2].tooltip;
      var options = typeProperties[property2].options;
      for (var i = 0; i < options.length; i++) {
        var option = document.createElement("option");
        option.value = options[i];
        option.text = options[i];
        selectDropdown.appendChild(option);
      }
      selectContainer.appendChild(selectDropdown);
      var createChangeListener = function(selectDropdown2, property3) {
        var self2 = this.editorUi;
        return function(evt) {
          let str = evt.target.parentNode.parentNode.parentNode.parentNode.textContent;
          str = str.slice(0, str.indexOf(":"));
          var newValue = selectDropdown2.value;
          currentValue = newValue;
          let current2 = self2.graph.model.threagile.getIn(["data_assets", str]);
          if (!current2) {
            self2.graph.model.threagile.setIn(["data_assets", str, property3], "");
          }
          if (newValue != null) {
            self2.graph.model.threagile.setIn(["data_assets", str, property3], newValue);
          }
        };
      }.bind(this);
      mxEvent2.addListener(selectDropdown, "change", createChangeListener(selectDropdown, property2));
      typeItem.appendChild(selectContainer);
    } else if (propertyType === "checkbox") {
      let optionElement = this.createOption(property2, createCustomOption(self, property2), setCustomOption(self, property2), customListener2);
      optionElement.querySelector('input[type="checkbox"]').title = typeProperties[property2].tooltip;
      container.appendChild(optionElement);
    } else if (propertyType === "button") {
      let functionName = "editData" + property2.charAt(0).toUpperCase() + property2.slice(1);
      let button2 = button(property2, bind(this, function(evt) {
        var menuId = evt.target.parentNode.parentNode.parentNode.id;
        current = value;
        if (!current[property2]) {
          current[property2] = typeProperties[property2].defaultValue;
        }
        var dataValue = current[property2];
        var dlg = new TextareaDialog(this.editorUi, property2 + ":", dataValue, function(newValue) {
          if (newValue != null) {
            current[property2] = newValue;
          }
        }, null, null, 400, 220);
        this.editorUi.showDialog(dlg.container, 420, 300, true, true);
        dlg.init();
        try {
          if (dlg.textarea) {
            let textareaId = `threagile-dialog-${property2}-textarea`;
            dlg.textarea.id = textareaId;
            console.log(`Added ID to textarea: ${textareaId}`);
          } else {
            console.warn(`Could not find dlg.textarea for property '${property2}'.`);
          }
        } catch (e) {
          console.error("Error adding ID to dialog textarea:", e);
        }
        try {
          let buttonContainer = dlg.container.querySelector(".geDialogButtons");
          let buttons = buttonContainer ? buttonContainer.querySelectorAll("button") : dlg.container.querySelectorAll("button");
          if (buttons && buttons.length > 0) {
            const applyText = mxResources.get("apply") || "Apply";
            const cancelText = mxResources.get("cancel") || "Cancel";
            let applyFound = false;
            let cancelFound = false;
            buttons.forEach((btn) => {
              if (!applyFound && (btn.textContent.trim() === applyText || btn.textContent.trim() === (mxResources.get("ok") || "OK"))) {
                btn.id = `threagile-dialog-${property2}-apply-button`;
                applyFound = true;
              } else if (!cancelFound && btn.textContent.trim() === cancelText) {
                btn.id = `threagile-dialog-${property2}-cancel-button`;
                cancelFound = true;
              }
            });
          } else {
            console.warn("Could not find buttons in TextareaDialog container for property:", property2);
          }
        } catch (e) {
          console.error("Error adding IDs to dialog buttons:", e);
        }
      }));
      button2.title = typeProperties[property2].tooltip;
      button2.style.width = "200px";
      typeItem.appendChild(button2);
    }
    propertiesSection.appendChild(typeItem);
  }
  return container;
};
InspectionFormatPanel.prototype.addInspectionMenu = function(container, value) {
  let self = this;
  var propertiesSection = createSection("risk_identified:");
  container.appendChild(propertiesSection);
  let typeProperties = {
    severity: {
      description: "Severity",
      type: "select",
      options: ["low", "medium", "elevated", "high", "critical"],
      tooltip: "Specifies the severity level",
      defaultValue: "low"
    },
    exploitation_likelihood: {
      description: "Exploitation Likelihood",
      type: "select",
      options: ["unlikely", "likely", "very-likely", "frequent"],
      tooltip: "Specifies the likelihood of exploitation",
      defaultValue: "unlikely"
    },
    exploitation_impact: {
      description: "Exploitation Impact",
      type: "select",
      options: ["low", "medium", "high", "very-high"],
      tooltip: "Specifies the impact of exploitation",
      defaultValue: "low"
    },
    data_breach_probability: {
      description: "Data Breach Probability",
      type: "select",
      options: ["improbable", "possible", "probable"],
      tooltip: "Specifies the probability of a data breach",
      defaultValue: "improbable"
    },
    data_breach_technical_assets: {
      description: "Data Breach Technical Assets",
      type: "array",
      uniqueItems: true,
      items: {
        type: "button"
      },
      tooltip: "List of technical asset IDs which might have data breach",
      defaultValue: []
    },
    most_relevant_data_asset: {
      description: "Most Relevant Data Asset",
      type: "button",
      tooltip: "Specifies the most relevant data asset",
      defaultValue: ""
    },
    most_relevant_technical_asset: {
      description: "Most Relevant Technical Asset",
      type: "button",
      tooltip: "Specifies the most relevant technical asset",
      defaultValue: ""
    },
    most_relevant_communication_link: {
      description: "Most Relevant Communication Link",
      type: "button",
      tooltip: "Specifies the most relevant communication link",
      defaultValue: ""
    },
    most_relevant_trust_boundary: {
      description: "Most Relevant Trust Boundary",
      type: "button",
      tooltip: "Specifies the most relevant trust boundary",
      defaultValue: ""
    },
    most_relevant_shared_runtime: {
      description: "Most Relevant Shared Runtime",
      type: "button",
      tooltip: "Specifies the most relevant shared runtime",
      defaultValue: ""
    }
  };
  var customListener2 = {
    install: function(apply) {
      this.listener = function() {
      };
    },
    destroy: function() {
    }
  };
  var typePropertiesMap = {};
  for (let property2 in typeProperties) {
    var typeItem = document.createElement("li");
    typeItem.style.display = "flex";
    typeItem.style.alignItems = "baseline";
    typeItem.style.marginBottom = "8px";
    var propertyName = document.createElement("span");
    propertyName.innerHTML = property2;
    propertyName.style.width = "100px";
    propertyName.style.marginRight = "10px";
    propertyName.innerHTML = property2.replace(/exploitation_|data_breach_/g, "");
    var propertyType = typeProperties[property2].type;
    if (propertyType === "select") {
      const propertySelect = property2;
      typeItem.appendChild(propertyName);
      var selectContainer = document.createElement("div");
      selectContainer.style.display = "flex";
      selectContainer.style.alignItems = "center";
      selectContainer.style.marginLeft = "auto";
      var selectDropdown = document.createElement("select");
      selectDropdown.style.width = "100px";
      selectDropdown.title = typeProperties[property2].tooltip;
      var options = typeProperties[property2].options;
      for (var i = 0; i < options.length; i++) {
        var option = document.createElement("option");
        option.value = options[i];
        option.text = options[i];
        selectDropdown.appendChild(option);
      }
      selectContainer.appendChild(selectDropdown);
      var createChangeListener = function(selectDropdown2, property3) {
        var self2 = this.editorUi;
        return function(evt) {
          var menuId = evt.target.parentNode.parentNode.parentNode.parentNode.id;
          var newValue = selectDropdown2.value;
          currentValue = newValue;
          let current2 = value;
          if (!current2[property3]) {
            current2[property3] = "";
          }
          if (newValue != null) {
            current2[property3] = newValue;
          }
        };
      }.bind(this);
      mxEvent2.addListener(selectDropdown, "change", createChangeListener(selectDropdown, property2));
      typeItem.appendChild(selectContainer);
    } else if (propertyType === "checkbox") {
      let optionElement = this.createOption(property2, createCustomOption(self, property2), setCustomOption(self, property2), customListener2);
      optionElement.querySelector('input[type="checkbox"]').title = typeProperties[property2].tooltip;
      container.appendChild(optionElement);
    } else if (propertyType === "button") {
      let functionName = "editData" + property2.charAt(0).toUpperCase() + property2.slice(1);
      let button2 = button(property2, bind(this, function(evt) {
        var menuId = evt.target.parentNode.parentNode.parentNode.id;
        current = value;
        if (!current[property2]) {
          current[property2] = typeProperties[property2].defaultValue;
        }
        var dataValue = current[property2];
        var dlg = new TextareaDialog(this.editorUi, property2 + ":", dataValue, function(newValue) {
          if (newValue != null) {
            current[property2] = newValue;
          }
        }, null, null, 400, 220);
        this.editorUi.showDialog(dlg.container, 420, 300, true, true);
        dlg.init();
        try {
          if (dlg.textarea) {
            let textareaId = `threagile-dialog-${property2}-textarea`;
            dlg.textarea.id = textareaId;
            console.log(`Added ID to textarea: ${textareaId}`);
          } else {
            console.warn(`Could not find dlg.textarea for property '${property2}'.`);
          }
        } catch (e) {
          console.error("Error adding ID to dialog textarea:", e);
        }
        try {
          let buttonContainer = dlg.container.querySelector(".geDialogButtons");
          let buttons = buttonContainer ? buttonContainer.querySelectorAll("button") : dlg.container.querySelectorAll("button");
          if (buttons && buttons.length > 0) {
            const applyText = mxResources.get("apply") || "Apply";
            const cancelText = mxResources.get("cancel") || "Cancel";
            let applyFound = false;
            let cancelFound = false;
            buttons.forEach((btn) => {
              if (!applyFound && (btn.textContent.trim() === applyText || btn.textContent.trim() === (mxResources.get("ok") || "OK"))) {
                btn.id = `threagile-dialog-${property2}-apply-button`;
                applyFound = true;
              } else if (!cancelFound && btn.textContent.trim() === cancelText) {
                btn.id = `threagile-dialog-${property2}-cancel-button`;
                cancelFound = true;
              }
            });
          } else {
            console.warn("Could not find buttons in TextareaDialog container for property:", property2);
          }
        } catch (e) {
          console.error("Error adding IDs to dialog buttons:", e);
        }
      }));
      button2.title = typeProperties[property2].tooltip;
      button2.style.width = "200px";
      typeItem.appendChild(button2);
    }
    propertiesSection.appendChild(typeItem);
  }
  return container;
};

// js/BoundaryFormatPanel.js
var BoundaryFormatPanel = function(format, editorUi, container) {
  BaseFormatPanel.call(this, format, editorUi, container);
  this.init();
};
extend(BoundaryFormatPanel, BaseFormatPanel);
BoundaryFormatPanel.prototype.init = function() {
  var ui = this.editorUi;
  var editor = ui.editor;
  var graph = editor.graph;
  var ss = this.format.getSelectionState();
  this.container.appendChild(this.addBoundaryMenuDynamic(this.createPanel(), graph));
};
BoundaryFormatPanel.prototype.addBoundaryMenuDynamic = function(container, graph) {
  var self = this;
  var typeProperties = {
    key: {
      description: "key",
      type: "button",
      tooltip: "The identifier for the yaml element",
      defaultValue: "<Your title>",
      section: "General"
    },
    id: {
      description: "Id",
      type: "button",
      section: "General",
      tooltip: "All id attribute values must be unique ",
      defaultValue: "<Your ID>"
    },
    description: {
      description: "Description",
      type: "button",
      section: "General",
      tooltip: "Provide a brief description of the trust boundary. ",
      defaultValue: ""
    },
    type: {
      description: "Type",
      type: "select",
      options: [
        {
          group: "Category 1",
          options: [
            "network-on-prem",
            "network-dedicated-hoster",
            "network-virtual-lan",
            "network-cloud-provider",
            "network-cloud-security-group",
            "network-policy-namespace-isolation",
            "execution-environment"
          ],
          defaultValue: "external-entity"
        }
      ],
      section: "Properties",
      tooltip: ""
    }
  };
  let cell2 = self.editorUi.editor.graph.getSelectionCell();
  if (cell2 && !cell2.trust_boundarieskey) {
    cell2.trust_boundarieskey = generateUniqueTrustkeyData(self.editorUi.editor.graph);
    const trustBoundary = {
      id: generateUniqueTrustId(self.editorUi.editor.graph),
      description: "Boundary protecting critical internal services.",
      type: "network-cloud-provider",
      tags: [],
      technical_assets_inside: [],
      trust_boundaries_nested: []
    };
    const path = ["trust_boundaries", cell2.trust_boundarieskey];
    Object.keys(trustBoundary).forEach((property2) => {
      self.editorUi.editor.graph.model.threagile.setIn([...path, property2], trustBoundary[property2]);
    });
  }
  let sections = {};
  for (let property2 in typeProperties) {
    let sectionName = typeProperties[property2].section;
    if (!sections[sectionName]) {
      sections[sectionName] = createSection(sectionName);
    }
    let typeItem = document.createElement("li");
    typeItem.style.display = "flex";
    typeItem.style.alignItems = "baseline";
    typeItem.style.marginBottom = "8px";
    let propertyName = document.createElement("span");
    propertyName.innerHTML = property2;
    propertyName.style.width = "100px";
    propertyName.style.marginRight = "10px";
    let propertyType = typeProperties[property2].type;
    if (propertyType === "select") {
      const propertySelect = property2;
      typeItem.appendChild(propertyName);
      let selectContainer = document.createElement("div");
      selectContainer.style.display = "flex";
      selectContainer.style.alignItems = "center";
      selectContainer.style.marginLeft = "auto";
      let selectDropdown = document.createElement("select");
      selectDropdown.style.width = "100px";
      selectDropdown.title = typeProperties[property2].tooltip;
      selectContainer.appendChild(selectDropdown);
      let optionGroups = typeProperties[property2].options;
      for (var i = 0; i < optionGroups.length; i++) {
        let optgroup = document.createElement("optgroup");
        optgroup.label = optionGroups[i].group;
        let options = optionGroups[i].options;
        for (let j = 0; j < options.length; j++) {
          let option = document.createElement("option");
          option.value = options[j];
          option.text = options[j];
          optgroup.appendChild(option);
        }
        selectDropdown.appendChild(optgroup);
      }
      if (cell2 && cell2.trust_boundarieskey && self.editorUi.editor.graph.model.threagile.getIn(["trust_boundaries", cell2.trust_boundarieskey, propertySelect])) {
        selectDropdown.value = self.editorUi.editor.graph.model.threagile.getIn(["trust_boundaries", cell2.trust_boundarieskey, propertySelect]);
      }
      let createChangeListener = function(selectDropdown2, propertySelect2) {
        return function(evt) {
          var vals = selectDropdown2.value;
          if (vals != null) {
            self.editorUi.editor.graph.model.threagile.setIn(["trust_boundaries", cell2.trust_boundarieskey, propertySelect2], vals);
          }
          mxEvent2.consume(evt);
        };
      };
      mxEvent2.addListener(selectDropdown, "change", createChangeListener(selectDropdown, propertySelect));
      typeItem.appendChild(selectContainer);
      sections[sectionName].appendChild(typeItem);
    } else if (propertyType === "checkbox") {
      let createCustomOptionTrust = function(self2, parameter) {
        return function() {
          var cells = self2.editorUi.editor.graph.getSelectionCells();
          if (cells != null && cells.length > 0) {
            let cell3 = self2.editorUi.editor.graph.getSelectionCell();
            return self2.editorUi.editor.graph.model.threagile.getIn(["trust_boundaries", cell3.trust_boundarieskey, parameter]);
          }
        };
      }, setCustomOptionTrust = function(self2, parameter) {
        return function(checked) {
          var cells = self2.editorUi.editor.graph.getSelectionCells();
          if (cells != null && cells.length > 0) {
            let cell3 = self2.editorUi.editor.graph.getSelectionCell();
            self2.editorUi.editor.graph.model.threagile.setIn(["trust_boundaries", cell3.trust_boundarieskey, parameter], checked);
          }
        };
      };
      let optionElement = this.createOption(property2, createCustomOptionTrust(self, property2), setCustomOptionTrust(self, property2), customListener);
      optionElement.querySelector('input[type="checkbox"]').title = typeProperties[property2].tooltip;
      sections[sectionName].appendChild(optionElement);
    } else if (propertyType === "button") {
      let button2 = button(property2, bind(this, function(evt) {
        let cells = self.editorUi.editor.graph.getSelectionCells();
        let cell3 = cells && cells.length > 0 ? cells[0] : null;
        let dataValue = cell3 && cell3.trust_boundarieskey && self.editorUi.editor.graph.model.threagile.getIn(["trust_boundaries", cell3.trust_boundarieskey, property2]) ? self.editorUi.editor.graph.model.threagile.getIn(["trust_boundaries", cell3.trust_boundarieskey, property2]) : typeProperties[property2].defaultValue;
        if (property2 == "key") {
          dataValue = cell3.trust_boundarieskey;
        }
        var dlg = new TextareaDialog(this.editorUi, property2 + ":", dataValue, function(newValue) {
          if (newValue != null) {
            if (cell3) {
              if (property2 === "Id") {
                var adjustedValue = newValue.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                let model = self.editorUi.editor.graph.model;
                model.beginUpdate();
                try {
                  model.setValue(cell3, adjustedValue);
                  self.editorUi.editor.graph.refresh(cell3);
                  self.editorUi.editor.graph.refresh();
                } finally {
                  model.endUpdate();
                }
              }
              if (property2 == "key") {
                restartWasm();
                let oldassetPath = ["trust_boundaries", cell3.trust_boundarieskey];
                let object = JSON.parse(JSON.stringify(self.editorUi.editor.graph.model.threagile.getIn(oldassetPath)));
                self.editorUi.editor.graph.model.threagile.deleteIn(oldassetPath);
                cell3.trust_boundarieskey = newValue;
                let newassetPath = ["trust_boundaries", cell3.trust_boundarieskey];
                let objectNode = self.editorUi.editor.graph.model.threagile.createNode(object);
                self.editorUi.editor.graph.model.threagile.setIn(newassetPath, objectNode);
              } else {
                self.editorUi.editor.graph.model.threagile.setIn(["trust_boundaries", cell3.trust_boundarieskey, property2], newValue);
              }
            }
          }
        }, null, null, 400, 220);
        this.editorUi.showDialog(dlg.container, 420, 300, true, true);
        dlg.init();
        try {
          if (dlg.textarea) {
            let textareaId = `threagile-dialog-${property2}-textarea`;
            dlg.textarea.id = textareaId;
            console.log(`Added ID to textarea: ${textareaId}`);
          } else {
            console.warn(`Could not find dlg.textarea for property '${property2}'.`);
          }
        } catch (e) {
          console.error("Error adding ID to dialog textarea:", e);
        }
        try {
          let buttonContainer = dlg.container.querySelector(".geDialogButtons");
          let buttons = buttonContainer ? buttonContainer.querySelectorAll("button") : dlg.container.querySelectorAll("button");
          if (buttons && buttons.length > 0) {
            const applyText = mxResources.get("apply") || "Apply";
            const cancelText = mxResources.get("cancel") || "Cancel";
            let applyFound = false;
            let cancelFound = false;
            buttons.forEach((btn) => {
              if (!applyFound && (btn.textContent.trim() === applyText || btn.textContent.trim() === (mxResources.get("ok") || "OK"))) {
                btn.id = `threagile-dialog-${property2}-apply-button`;
                applyFound = true;
              } else if (!cancelFound && btn.textContent.trim() === cancelText) {
                btn.id = `threagile-dialog-${property2}-cancel-button`;
                cancelFound = true;
              }
            });
          } else {
            console.warn("Could not find buttons in TextareaDialog container for property:", property2);
          }
        } catch (e) {
          console.error("Error adding IDs to dialog buttons:", e);
        }
      }));
      button2.title = typeProperties[property2].tooltip;
      button2.style.width = "200px";
      typeItem.appendChild(button2);
      sections[sectionName].appendChild(typeItem);
    }
  }
  for (let sectionName in sections) {
    container.appendChild(sections[sectionName]);
  }
  if (cell2.isVertex()) {
    var cellGeometry = cell2.getGeometry();
    if (cellGeometry != null) {
      let isVertexInsideAnyRectangle = function(vertex, rectangles) {
        var vertexGeometry = vertex.getGeometry();
        for (let i2 = 0; i2 < rectangles.length; i2++) {
          let rectangle = rectangles[i2];
          let rectangleGeometry = rectangle.getGeometry();
          if (vertexGeometry.x >= rectangleGeometry.x && vertexGeometry.y >= rectangleGeometry.y && vertexGeometry.x + vertexGeometry.width <= rectangleGeometry.x + rectangleGeometry.width && vertexGeometry.y + vertexGeometry.height <= rectangleGeometry.y + rectangleGeometry.height) {
            return true;
          }
        }
        return false;
      }, addVertexToTable = function(vertex) {
        var row = document.createElement("tr");
        var cellValue = document.createElement("td");
        cellValue.textContent = vertex.getValue();
        cellValue.style.padding = "8px";
        cellValue.style.width = "200px";
        row.appendChild(cellValue);
        let id = self.editorUi.editor.graph.model.threagile.getIn(["technical_assets", cellValue.textContent, "id"]);
        technicalAssetsArray.push(id);
        table.appendChild(row);
      };
      var cellX = cellGeometry.x;
      var cellY = cellGeometry.y;
      var cellWidth = cellGeometry.width;
      var cellHeight = cellGeometry.height;
      var tableContainer = document.createElement("div");
      tableContainer.style.maxWidth = "300px";
      var table = document.createElement("table");
      table.id = "TrustBoundaryTechnicalAssetsInside";
      table.style.borderCollapse = "collapse";
      table.style.width = "90%";
      table.style.tableLayout = "fixed";
      var headerRow = document.createElement("tr");
      var headerCell = document.createElement("th");
      headerCell.textContent = "Technical Assets Inside:";
      headerCell.style.border = "1px solid #ccc";
      headerCell.style.padding = "8px";
      headerCell.style.backgroundColor = "#f0f0f0";
      headerCell.style.textAlign = "left";
      headerCell.colSpan = 2;
      headerRow.appendChild(headerCell);
      table.appendChild(headerRow);
      var vertices = graph.getChildVertices(graph.getDefaultParent());
      var innerRectangles = vertices.filter(function(vertex) {
        var vertexGeometry = vertex.getGeometry();
        var style = graph.getModel().getStyle(vertex);
        return vertexGeometry != null && vertex !== cell2 && (style.includes("rounded=1") || style.includes("rounded=0") || style.includes("shape=rectangle")) && vertexGeometry.x >= cellX && vertexGeometry.y >= cellY && vertexGeometry.x + vertexGeometry.width <= cellX + cellWidth && vertexGeometry.y + vertexGeometry.height <= cellY + cellHeight;
      });
      var technicalAssetsArray = [];
      vertices.forEach(function(vertex) {
        var vertexGeometry = vertex.getGeometry();
        var style = graph.getModel().getStyle(vertex);
        if (vertexGeometry != null && vertex !== cell2 && !(style.includes("rounded=1") || style.includes("rounded=0") || style.includes("shape=rectangle")) && vertexGeometry.x >= cellX && vertexGeometry.y >= cellY && vertexGeometry.x + vertexGeometry.width <= cellX + cellWidth && vertexGeometry.y + vertexGeometry.height <= cellY + cellHeight && !isVertexInsideAnyRectangle(vertex, innerRectangles)) {
          addVertexToTable(vertex);
        }
      });
      self.editorUi.editor.graph.model.threagile.setIn(["trust_boundaries", cell2.trust_boundarieskey, "technical_assets_inside"], technicalAssetsArray);
      tableContainer.appendChild(table);
      container.appendChild(tableContainer);
    }
  }
  var nestedTableContainer = document.createElement("div");
  nestedTableContainer.style.maxWidth = "300px";
  nestedTableContainer.id = "TrustBoundaryNestedID";
  var nestedTable = document.createElement("table");
  nestedTable.style.borderCollapse = "collapse";
  nestedTable.style.width = "90%";
  nestedTable.style.tableLayout = "fixed";
  var nestedHeaderRow = document.createElement("tr");
  var nestedHeaderCell = document.createElement("th");
  nestedHeaderCell.textContent = "Trust boundaries nested:";
  nestedHeaderCell.style.border = "1px solid #ccc";
  nestedHeaderCell.style.padding = "8px";
  nestedHeaderCell.style.backgroundColor = "#f0f0f0";
  nestedHeaderCell.style.textAlign = "left";
  nestedHeaderCell.colSpan = 2;
  nestedHeaderRow.appendChild(nestedHeaderCell);
  nestedTable.appendChild(nestedHeaderRow);
  var rectanglesArray = [];
  innerRectangles.forEach(function(rectangle) {
    var row = document.createElement("tr");
    var cellValue = document.createElement("td");
    cellValue.textContent = rectangle.getValue();
    cellValue.style.padding = "8px";
    cellValue.style.width = "200px";
    cellValue.style.boxSizing = "border-box";
    row.appendChild(cellValue);
    let id = self.editorUi.editor.graph.model.threagile.getIn(["trust_boundaries", cellValue.textContent, "id"]);
    rectanglesArray.push(id);
    nestedTable.appendChild(row);
  });
  self.editorUi.editor.graph.model.threagile.setIn(["trust_boundaries", cell2.trust_boundarieskey, "trust_boundaries_nested"], rectanglesArray);
  nestedTableContainer.appendChild(nestedTable);
  container.appendChild(nestedTableContainer);
  return container;
};

// js/DiagramFormatPanel.js
var DiagramFormatPanel = function(format, editorUi, container) {
  BaseFormatPanel.call(this, format, editorUi, container);
  this.init();
};
extend(DiagramFormatPanel, BaseFormatPanel);
DiagramFormatPanel.prototype.init = function() {
  console.log("wow");
  function removeIdFromArray(arr, idToRemove, path) {
    if (!arr) {
      return;
    }
    let removed = false;
    if (Array.isArray(arr)) {
      for (let i2 = arr.length - 1; i2 >= 0; i2--) {
        if (arr[i2] === idToRemove) {
          console.log(`      Removing ID at ${path}[${i2}]: "${idToRemove}" (JS Array)`);
          arr.splice(i2, 1);
          removed = true;
        }
      }
    } else if (typeof arr.get === "function" && typeof arr.delete === "function" && Array.isArray(arr.items)) {
      for (let i2 = arr.items.length - 1; i2 >= 0; i2--) {
        const currentNodeOrValue = arr.get(i2);
        let currentValue2;
        if (currentNodeOrValue && typeof currentNodeOrValue === "object" && currentNodeOrValue.hasOwnProperty("value")) {
          currentValue2 = currentNodeOrValue.value;
        } else {
          currentValue2 = currentNodeOrValue;
        }
        if (currentValue2 === idToRemove) {
          console.log(`      Removing ID at ${path}[${i2}]: Value "${idToRemove}" (YAML Seq)`);
          arr.delete(i2);
          removed = true;
        }
      }
    } else if (typeof arr.get === "function" && typeof arr.delete === "function" && typeof arr.size === "number") {
      console.warn(`    Path "${path}": Attempting removal in map-like sequence for "${idToRemove}". Logic assumes sequence behavior.`);
      console.warn(`    Path "${path}": Encountered map-like structure with get/delete/size but no 'items' array. Cannot reliably perform indexed removal. Skipping removal for this specific type.`);
    } else {
      console.warn(`    Skipping removal for path "${path}": Unsupported collection type or structure for removal. Type: ${typeof arr}`, arr);
      return;
    }
  }
  function removeReferences(model, idToRemove) {
    console.log(`>>> Starting reference removal for Data Asset ID: ${idToRemove}`);
    const isProcessableArray = (val) => {
      if (Array.isArray(val)) {
        return true;
      }
      if (val && typeof val.get === "function" && typeof val.delete === "function" && Array.isArray(val.items)) {
        return true;
      }
      return false;
    };
    if (model.has("technical_assets")) {
      const techAssetsYAML = model.get("technical_assets");
      if (techAssetsYAML && typeof techAssetsYAML.toJSON === "function") {
        const techAssetsJS = techAssetsYAML.toJSON();
        Object.keys(techAssetsJS).forEach((assetKey) => {
          console.log(`  Checking Technical Asset: [${assetKey}] for removal of "${idToRemove}"`);
          const assetYAML = techAssetsYAML.get(assetKey);
          if (!assetYAML) {
            console.warn(`    Skipping asset [${assetKey}]: Could not retrieve original YAML object.`);
            return;
          }
          if (assetYAML.has("data_assets_processed")) {
            const processedSeq = assetYAML.get("data_assets_processed");
            if (isProcessableArray(processedSeq)) {
              removeIdFromArray(processedSeq, idToRemove, `technical_assets[${assetKey}].data_assets_processed`);
            } else if (processedSeq) {
              console.warn(`    Skipping removal in technical_assets[${assetKey}].data_assets_processed: Not a processable array/sequence.`);
            }
          }
          if (assetYAML.has("data_assets_stored")) {
            const storedSeq = assetYAML.get("data_assets_stored");
            if (isProcessableArray(storedSeq)) {
              removeIdFromArray(storedSeq, idToRemove, `technical_assets[${assetKey}].data_assets_stored`);
            } else if (storedSeq) {
              console.warn(`    Skipping removal in technical_assets[${assetKey}].data_assets_stored: Not a processable array/sequence.`);
            }
          }
          if (assetYAML.has("communication_links")) {
            const nestedCommLinksYAML = assetYAML.get("communication_links");
            if (nestedCommLinksYAML && typeof nestedCommLinksYAML.toJSON === "function") {
              const nestedCommLinksJS = nestedCommLinksYAML.toJSON();
              console.log(`    Checking Nested Communication Links within [${assetKey}] for removal of "${idToRemove}"...`);
              Object.keys(nestedCommLinksJS).forEach((linkKey) => {
                console.log(`      Checking Nested Link: [${linkKey}]`);
                const linkYAML = nestedCommLinksYAML.get(linkKey);
                if (!linkYAML) {
                  console.warn(`      Skipping nested link [${linkKey}]: Could not retrieve original YAML object.`);
                  return;
                }
                if (linkYAML.has("data_assets_sent")) {
                  const sentSeq = linkYAML.get("data_assets_sent");
                  if (isProcessableArray(sentSeq)) {
                    removeIdFromArray(sentSeq, idToRemove, `technical_assets[${assetKey}].communication_links[${linkKey}].data_assets_sent`);
                  } else if (sentSeq) {
                    console.warn(`      Skipping removal in ...communication_links[${linkKey}].data_assets_sent: Not a processable array/sequence.`);
                  }
                }
                if (linkYAML.has("data_assets_received")) {
                  const receivedSeq = linkYAML.get("data_assets_received");
                  if (isProcessableArray(receivedSeq)) {
                    removeIdFromArray(receivedSeq, idToRemove, `technical_assets[${assetKey}].communication_links[${linkKey}].data_assets_received`);
                  } else if (receivedSeq) {
                    console.warn(`      Skipping removal in ...communication_links[${linkKey}].data_assets_received: Not a processable array/sequence.`);
                  }
                }
              });
            }
          }
        });
      } else {
        console.warn(`Could not iterate over 'technical_assets' for removal: Not a recognized YAML collection or is null.`);
      }
    } else {
      console.log("  No 'technical_assets' section found, skipping removal within.");
    }
    if (model.has("communication_links")) {
      const topLevelCommLinksYAML = model.get("communication_links");
      if (topLevelCommLinksYAML && typeof topLevelCommLinksYAML.toJSON === "function") {
        const topLevelCommLinksJS = topLevelCommLinksYAML.toJSON();
        console.log(`  Checking Top-Level Communication Links for removal of "${idToRemove}"...`);
        Object.keys(topLevelCommLinksJS).forEach((linkKey) => {
          console.log(`    Checking Top-Level Link: [${linkKey}]`);
          const linkYAML = topLevelCommLinksYAML.get(linkKey);
          if (!linkYAML) {
            console.warn(`    Skipping top-level link [${linkKey}]: Could not retrieve original YAML object.`);
            return;
          }
          if (linkYAML.has("data_assets_sent")) {
            const sentSeq = linkYAML.get("data_assets_sent");
            if (isProcessableArray(sentSeq)) {
              removeIdFromArray(sentSeq, idToRemove, `communication_links[${linkKey}].data_assets_sent`);
            } else if (sentSeq) {
              console.warn(`    Skipping removal in communication_links[${linkKey}].data_assets_sent: Not a processable array/sequence.`);
            }
          }
          if (linkYAML.has("data_assets_received")) {
            const receivedSeq = linkYAML.get("data_assets_received");
            if (isProcessableArray(receivedSeq)) {
              removeIdFromArray(receivedSeq, idToRemove, `communication_links[${linkKey}].data_assets_received`);
            } else if (receivedSeq) {
              console.warn(`    Skipping removal in communication_links[${linkKey}].data_assets_received: Not a processable array/sequence.`);
            }
          }
        });
      } else {
        console.warn(`Could not iterate over 'communication_links' for removal: Not a recognized YAML collection or is null.`);
      }
    } else {
      console.log("  No top-level 'communication_links' section found, skipping removal within.");
    }
    if (model.has("risk_tracking")) {
      console.log(`  Checking 'risk_tracking': Removal logic for risk keys containing "${idToRemove}" is NOT IMPLEMENTED.`);
    } else {
      console.log("  No 'risk_tracking' section found.");
    }
    console.log(`>>> Reference removal finished for ID: ${idToRemove}`);
  }
  var ui = this.editorUi;
  var editor = ui.editor;
  var graph = editor.graph;
  var listContainer = document.createElement("div");
  listContainer.style.maxWidth = "400px";
  listContainer.style.margin = "0 auto";
  var list = document.createElement("ul");
  list.style.listStyleType = "none";
  list.style.padding = "0";
  list.id = "threagileDataAssetList";
  var items = [];
  for (var i = 0; i < items.length; i++) {
    var listItem = document.createElement("li");
    listItem.textContent = items[i];
    listItem.style.display = "flex";
    listItem.style.alignItems = "center";
    listItem.style.padding = "8px";
    listItem.style.borderBottom = "1px solid #ccc";
    var xButton = document.createElement("button");
    xButton.innerHTML = '<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJAQMAAADaX5RTAAAABlBMVEV7mr3///+wksspAAAAAnRSTlP/AOW3MEoAAAAdSURBVAgdY9jXwCDDwNDRwHCwgeExmASygSL7GgB12QiqNHZZIwAAAABJRU5ErkJggg==" alt="X">';
    xButton.style.marginLeft = "auto";
    xButton.style.padding = "5px";
    xButton.style.backgroundColor = "transparent";
    xButton.style.border = "none";
    xButton.style.cursor = "pointer";
    listItem.appendChild(xButton);
    list.appendChild(listItem);
  }
  if (typeof graph.model.threagile.getIn(["data_assets"]) !== "undefined" && typeof this.editorUi.editor.graph.model.threagile.getIn(["data_assets"]) !== "undefined") {
    let interpolateColorForRisks = function(minColor, maxColor, minVal, maxVal, val) {
      function interpolate(start, end, step2) {
        return start + (end - start) * step2;
      }
      var step = (val - minVal) / (maxVal - minVal);
      step = Math.max(0, Math.min(1, step));
      var red = interpolate(minColor[0], maxColor[0], step);
      var green = interpolate(minColor[1], maxColor[1], step);
      var blue = interpolate(minColor[2], maxColor[2], step);
      if (step > 0.5) {
        green *= 1 - step * 2;
      }
      return `rgb(${Math.round(red)}, ${Math.round(green)}, ${Math.round(blue)})`;
    }, mapRiskLevel = function(value, category) {
      const mappings = {
        "quantity": {
          "very-few": 1,
          "few": 2,
          "many": 3,
          "very-many": 4
        },
        "confidentiality": {
          "public": 1,
          "internal": 2,
          "restricted": 3,
          "confidential": 4,
          "strictly-confidential": 5
        },
        "integrity": {
          "archive": 1,
          "operational": 2,
          "important": 3,
          "critical": 4,
          "mission-critical": 5
        },
        "availability": {
          "archive": 1,
          "operational": 2,
          "important": 3,
          "critical": 4,
          "mission-critical": 5
        }
      };
      return mappings[category][value.toLowerCase().replace("-", "")] || 0;
    };
    let data_assets_map = graph.model.threagile.getIn(["data_assets"]).toJSON();
    const lowRiskColor = [0, 255, 0];
    const highRiskColor = [255, 0, 0];
    let assetsToDisplay = [];
    Object.entries(data_assets_map).forEach(([assetKey, assetValue]) => {
      let cVal = mapRiskLevel(assetValue.confidentiality, "confidentiality");
      let iVal = mapRiskLevel(assetValue.integrity, "integrity");
      let aVal = mapRiskLevel(assetValue.availability, "availability");
      let riskScore = (cVal + iVal) * aVal;
      assetsToDisplay.push({
        key: assetKey,
        value: assetValue,
        riskScore
      });
    });
    assetsToDisplay.sort((a, b) => a.riskScore - b.riskScore);
    console.log(assetsToDisplay);
    const sorted_data_assets_map = /* @__PURE__ */ new Map();
    assetsToDisplay.forEach((item) => {
      sorted_data_assets_map.set(item.property, item.value);
    });
    sorted_data_assets_map.entries(data_assets_map).forEach(([property2, value]) => {
      let data_asset = this.editorUi.editor.graph.model.threagile.getIn(["data_assets", property2]);
      var clonedMenu = this.addDataMenu(this.createPanel(), property2);
      let orginalProperty = property2;
      property2 = property2 + ":";
      clonedMenu.id = property2;
      var listItem2 = document.createElement("li");
      listItem2.style.display = "flex";
      listItem2.style.flexDirection = "column";
      listItem2.style.padding = "8px";
      listItem2.style.borderBottom = "1px solid #ccc";
      listItem2.dataset.visible = "false";
      var parentNode = clonedMenu.childNodes[0];
      let riskScore = 0;
      console.log(value.quantity);
      console.log(value.confidentiality);
      console.log(value.integrity);
      console.log(value.availability);
      if (value.quantity !== void 0)
        riskScore *= mapRiskLevel(value.quantity, "quantity");
      if (value.confidentiality !== void 0)
        riskScore += mapRiskLevel(value.confidentiality, "confidentiality");
      if (value.integrity !== void 0)
        riskScore += mapRiskLevel(value.integrity, "integrity");
      if (value.availability !== void 0)
        riskScore *= mapRiskLevel(value.availability, "availability");
      for (var key in value) {
        if (value.hasOwnProperty(key)) {
          var childNode = value[key];
          for (var i2 = 0; i2 < parentNode.childNodes.length; i2++) {
            var currentChildNode = parentNode.childNodes[i2];
            if (currentChildNode.nodeName === "INPUT") {
              if ("__tagify" in currentChildNode) {
                let tags = graph.model.threagile.getIn(["data_assets", orginalProperty, "tags"]) || [];
              }
            } else {
              if (currentChildNode.nodeType === Node.ELEMENT_NODE && currentChildNode.children.length > 0 && currentChildNode.children[0].textContent === key) {
                if (currentChildNode.children.length > 1 && currentChildNode.childNodes.length > 0) {
                  let nextChildNode = currentChildNode.children[1].children[0];
                  if (nextChildNode.nodeName === "SELECT") {
                    for (let i3 = 0; i3 < nextChildNode.options.length; i3++) {
                      if (nextChildNode.options[i3].value === childNode) {
                        nextChildNode.selectedIndex = i3;
                        break;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      var textContainer = document.createElement("div");
      textContainer.style.display = "flex";
      textContainer.style.alignItems = "center";
      textContainer.style.marginBottom = "8px";
      textContainer.style.color = "black";
      textContainer.style.fontWeight = "bold";
      let arrowIcon = document.createElement("img");
      arrowIcon.src = " data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAAagAAAGoB3Bi5tQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAEUSURBVDiNjdO9SgNBFIbhJ4YkhZ2W2tgmphYEsTJiY2Vjk0YbMYVeiKAo2mjlHVhpDBaCoPGnEjtvQLAWRIjF7sJmM9nk7WbO+b6Zc+ZMwSB1bGMRhXivhwec4z2gARWcoo0VlFKxEhq4xQnKIXEbO8PcU+ziJmtyNqY4oYXjZFGPHbNMo5hj0kEVDkU1Z2niCpNDDFZxAF39DUuzgUfMBmJlPMFLzjVhGW+YC8ReJ0aIR9FjvBJmArEKukXU8IfPTEITm1jHd8CgkRw8L5qwLFPyn/EO1SK+sCBq0nMq4UdcY4B9/OIy2SiLhqmVc2LCHq4F+lYWjWdHNCTpWa9gLb72UVpcMEgNW1jS/53vcYGPdPI/rfEvjAsiqsMAAAAASUVORK5CYII=";
      arrowIcon.style.width = "15px";
      arrowIcon.style.height = "15px";
      arrowIcon.style.marginRight = "5px";
      arrowIcon.style.transform = "rotate(270deg)";
      textContainer.insertBefore(arrowIcon, dataText);
      var dataText = document.createElement("div");
      dataText.textContent = property2;
      var xButton2 = document.createElement("button");
      xButton2.innerHTML = '<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJAQMAAADaX5RTAAAABlBMVEV7mr3///+wksspAAAAAnRSTlP/AOW3MEoAAAAdSURBVAgdY9jXwCDDwNDRwHCwgeExmASygSL7GgB12QiqNHZZIwAAAABJRU5ErkJggg==" alt="X">';
      xButton2.style.marginLeft = "auto";
      xButton2.style.padding = "5px";
      xButton2.style.backgroundColor = "transparent";
      xButton2.style.border = "none";
      xButton2.style.cursor = "pointer";
      xButton2.addEventListener("click", function(event2) {
        event2.stopPropagation();
        const dataAssetKeyToDelete = clonedMenu.id.slice(0, -1);
        const uiListItem = xButton2.parentNode.parentNode;
        const uiList = uiListItem.parentNode;
        const model = graph.model;
        const dataAssetIdToDeleteID = model.threagile.getIn(["data_assets", dataAssetKeyToDelete], true).toJSON().id;
        if (!model || !model.threagile) {
          console.error("Threagile model data not found!");
          Swal.fire({
            title: "Error",
            text: "Could not find Threagile model data to perform deletion.",
            icon: "error"
          });
          return;
        }
        const dependents = [];
        const dataAssets = model.threagile.toJSON().data_assets || {};
        for (const assetId in dataAssets) {
          if (assetId === dataAssetKeyToDelete)
            continue;
          const asset = dataAssets[assetId];
          if (asset && asset["<<"]) {
            let referencedId = "";
            if (typeof asset["<<"] === "string") {
              referencedId = asset["<<"];
            } else if (typeof asset["<<"] === "object" && asset["<<"] !== null && asset["<<"].id) {
              referencedId = asset["<<"].id;
            }
            if (referencedId === dataAssetIdToDeleteID) {
              dependents.push({
                id: assetId,
                type: "data_assets",
                name: asset.description || assetId
              });
            }
          }
        }
        const performSingleDeletion = (itemId, itemType, diagramKey) => {
          console.log(`Attempting to delete ${itemType}: ${itemId} (UI key: ${diagramKey})`);
          let modelDeleted = false;
          let uiDeleted = false;
          const model2 = graph.model;
          try {
            const modelPath = [itemType, itemId];
            if (model2.threagile.hasIn(modelPath)) {
              if (model2.threagile.deleteIn) {
                model2.threagile.deleteIn(modelPath);
                console.log(`  Successfully deleted from model: ${modelPath.join(".")}`);
                modelDeleted = true;
              } else {
                console.error(`  Cannot delete from model: 'deleteIn' method not available.`);
              }
            } else {
              console.warn(`  Skipping model deletion: ${itemId} not found in ${itemType}. It might have been deleted already.`);
              modelDeleted = true;
            }
            if (diagramKey && graph.model.diagramData && graph.model.diagramData[diagramKey]) {
              console.log(`  Deleting ${diagramKey} from diagramData`);
              delete graph.model.diagramData[diagramKey];
            }
            const listContainer2 = document.getElementById("threagileDataAssetList");
            if (!listContainer2) {
              console.error("  Cannot remove UI element: Could not find the list container with id='threagileDataAssetList'.");
            } else {
              let listItemToRemove = null;
              const listItems = listContainer2.getElementsByTagName("li");
              for (let i3 = 0; i3 < listItems.length; i3++) {
                const li = listItems[i3];
                if (li.children.length > 1 && li.children[1] && li.children[1].id === diagramKey) {
                  listItemToRemove = li;
                  break;
                }
              }
              if (listItemToRemove) {
                listContainer2.removeChild(listItemToRemove);
                console.log(`  Successfully removed UI list item (<li>) associated with key: ${diagramKey}`);
                uiDeleted = true;
              } else {
                console.warn(`  Could not find the UI list item (<li>) to remove for key: ${diagramKey}. It might have been removed already or the structure is incorrect.`);
              }
            }
          } catch (error2) {
            console.error(`Error during deletion process for ${itemType} ${itemId}:`, error2);
            Swal.fire("Deletion Error", `Failed to fully delete ${itemId}. Check console for details.`, "error");
          } finally {
            if (modelDeleted && uiDeleted) {
              console.log(`Deletion process completed successfully for ${itemId}.`);
            } else {
              console.warn(`Deletion process for ${itemId} might be incomplete (Model Deleted: ${modelDeleted}, UI Deleted: ${uiDeleted}).`);
            }
          }
        };
        if (dependents.length > 0) {
          const dependentNames = dependents.map((item) => `- ${item.name} (Data Asset)`).join("<br/>");
          const message = `The data asset "<b>${dataAssetKeyToDelete}</b>" is used as an anchor (<code><<</code>) by the following data assets:<br/><br/>${dependentNames}<br/><br/>How do you want to proceed?`;
          Swal.fire({
            title: "Confirm Deletion",
            html: message,
            icon: "warning",
            showCancelButton: true,
            confirmButtonText: "Delete Item + Dependents",
            confirmButtonColor: "#d33",
            cancelButtonText: "Cancel",
            showDenyButton: true,
            denyButtonText: "Delete Item Only(May break graph)",
            denyButtonColor: "#ffae42",
            buttonsStyling: false,
            customClass: {
              confirmButton: "swal-confirm-button-style",
              denyButton: "swal-deny-button-style",
              cancelButton: "swal-cancel-button-style",
              popup: "custom-popup-style"
            },
            didRender: () => {
              if (!document.getElementById("swal-custom-button-styles")) {
                const styleTag = document.createElement("style");
                styleTag.id = "swal-custom-button-styles";
                styleTag.innerHTML = `
                                 .swal-confirm-button-style, .swal-deny-button-style, .swal-cancel-button-style {
                                     color: #fff;
                                     border: none;
                                     border-radius: 5px;
                                     padding: 10px 20px;
                                     font-size: 14px;
                                     margin: 5px;
                                     transition: background-color 0.3s ease;
                                 }
                                 .swal-confirm-button-style { background-color: #d33; } /* Red */
                                 .swal-confirm-button-style:hover { background-color: #c82333; }
                                 .swal-deny-button-style { background-color: #ffae42; } /* Orange */
                                 .swal-deny-button-style:hover { background-color: #f49d2c; }
                                 .swal-cancel-button-style { background-color: #aaa; } /* Grey */
                                 .swal-cancel-button-style:hover { background-color: #999; }
                                 .custom-popup-style {
                                     box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
                                     border-radius: 8px;
                                     background: #f0f0f0; /* Your background */
                                 }
                             `;
                document.head.appendChild(styleTag);
              }
            }
          }).then((result2) => {
            if (result2.isConfirmed) {
              console.log("User chose to DELETE ALL (item and dependents).");
              removeReferences(graph.model.threagile, dataAssetIdToDeleteID);
              dependents.forEach((item) => {
                performSingleDeletion(item.id, item.type, null);
              });
              performSingleDeletion(dataAssetKeyToDelete, "data_assets", clonedMenu.id);
              console.log(`Data asset ${dataAssetKeyToDelete} and its dependents deleted.`);
            } else if (result2.isDenied) {
              console.log("User chose to DELETE ITEM ONLY.");
              removeReferences(graph.model.threagile, dataAssetIdToDeleteID);
              performSingleDeletion(dataAssetKeyToDelete, "data_assets", clonedMenu.id);
              console.log(`Data asset ${dataAssetKeyToDelete} deleted. Dependents were NOT deleted.`);
            } else {
              console.log("User cancelled deletion.");
            }
          });
        } else {
          console.log(`No dependencies found for ${dataAssetKeyToDelete}. Deleting directly.`);
          performSingleDeletion(dataAssetKeyToDelete, "data_assets", clonedMenu.id);
          removeReferences(graph.model.threagile, dataAssetIdToDeleteID);
          console.log(`Data asset ${dataAssetKeyToDelete} deleted.`);
        }
      });
      textContainer.appendChild(dataText);
      textContainer.appendChild(xButton2);
      let initialColor = interpolateColorForRisks(lowRiskColor, highRiskColor, 0, 25, riskScore);
      if (listItem2.dataset.visible === "true") {
        listItem2.style.backgroundColor = "";
        arrowIcon.style.transform = "rotate(270deg)";
        xButton2.style.display = "inline-block";
        clonedMenu.style.display = "block";
      } else {
        listItem2.style.backgroundColor = initialColor;
        listItem2.dataset.initialColor = initialColor;
        arrowIcon.style.transform = "rotate(90deg)";
        xButton2.style.display = "none";
        clonedMenu.style.display = "none";
      }
      listItem2.appendChild(textContainer);
      listItem2.appendChild(clonedMenu);
      function toggleContent() {
        let isVisible = listItem2.dataset.visible === "true";
        listItem2.dataset.visible = !isVisible;
        if (!isVisible) {
          listItem2.style.backgroundColor = "";
          arrowIcon.style.transform = "rotate(270deg)";
          xButton2.style.display = "inline-block";
          clonedMenu.style.display = "block";
        } else {
          listItem2.style.backgroundColor = initialColor;
          listItem2.dataset.initialColor = initialColor;
          arrowIcon.style.transform = "rotate(90deg)";
          xButton2.style.display = "none";
          clonedMenu.style.display = "none";
        }
      }
      arrowIcon.addEventListener("click", toggleContent);
      dataText.addEventListener("click", toggleContent);
      list.appendChild(listItem2);
    });
  }
  var generalHeader = document.createElement("div");
  generalHeader.innerHTML = "Data:";
  generalHeader.style.padding = "10px 0px 6px 0px";
  generalHeader.style.whiteSpace = "nowrap";
  generalHeader.style.overflow = "hidden";
  generalHeader.style.width = "200px";
  generalHeader.style.fontWeight = "bold";
  this.container.appendChild(generalHeader);
  var addButton = button("Add Data Asset", bind(this, function(evt) {
    this.editorUi.actions.get("addDataAssets").funct(list, this.addDataMenu(this.createPanel()));
  }));
  addButton.innerHTML = `
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-database-fill" viewBox="0 0 16 16">
  <path d="M3 2a7 7 0 0 0 10 0v1c0 .542-.229 1.04-.61 1.465C11.105 5.352 9.342 6 8 6c-1.342 0-3.105-.648-4.39-1.535A2.877 2.877 0 0 1 3 3V2zm0 3c0 .542.229 1.04.61 1.465C4.895 7.352 6.658 8 8 8c1.342 0 3.105-.648 4.39-1.535A2.877 2.877 0 0 0 13 5V4c-1.285.887-3.048 1.535-4.39 1.535C7.658 5.535 5.895 4.887 4.61 4A2.877 2.877 0 0 1 3 4v1zm0 2c0 .542.229 1.04.61 1.465C4.895 9.352 6.658 10 8 10c1.342 0 3.105-.648 4.39-1.535A2.877 2.877 0 0 0 13 8V7c-1.285.887-3.048 1.535-4.39 1.535C7.658 8.535 5.895 7.887 4.61 7A2.877 2.877 0 0 1 3 7v1zm0 2c0 .542.229 1.04.61 1.465C4.895 11.352 6.658 12 8 12c1.342 0 3.105-.648 4.39-1.535A2.877 2.877 0 0 0 13 10V9c-1.285.887-3.048 1.535-4.39 1.535C7.658 10.535 5.895 9.887 4.61 9A2.877 2.877 0 0 1 3 9v1zm0 2c0 .542.229 1.04.61 1.465C4.895 13.352 6.658 14 8 14c1.342 0 3.105-.648 4.39-1.535A2.877 2.877 0 0 0 13 12v1a7 7 0 0 1-10 0v-1z"/>
</svg> Add Data Asset`;
  addButton.style.cssText = `
    margin: 0 auto;
    display: block;
    margin-top: 8px;
    padding: 8px 12px;
    background-color: #4CAF50; // More vibrant color
    color: #fff;
    border: none;
    border-radius: 5px; // Rounded corners
    cursor: pointer;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); // Subtle shadow
    transition: background-color 0.3s; // Smooth transition for hover effect
`;
  addButton.setAttribute("aria-label", "Add data assets");
  addButton.onmouseover = function() {
    this.style.backgroundColor = "#45a049";
  };
  addButton.onmouseout = function() {
    this.style.backgroundColor = "#4CAF50";
  };
  listContainer.appendChild(list);
  listContainer.appendChild(addButton);
  this.container.appendChild(listContainer);
  var styleHeader = document.createElement("div");
  styleHeader.innerHTML = "Style:";
  styleHeader.style.padding = "10px 0px 6px 0px";
  styleHeader.style.whiteSpace = "nowrap";
  styleHeader.style.overflow = "hidden";
  styleHeader.style.width = "200px";
  styleHeader.style.fontWeight = "bold";
  this.container.appendChild(styleHeader);
  if (graph.isEnabled()) {
    this.container.appendChild(this.addOptions(this.createPanel()));
    this.container.appendChild(this.addPaperSize(this.createPanel()));
    this.container.appendChild(this.addStyleOps(this.createPanel()));
  }
  let self = this;
  this.graph = graph;
};
DiagramFormatPanel.prototype.addDataMenu = function(container, UUID = void 0) {
  function updateIdInArray(arr, oldId, newId, path) {
    if (!arr) {
      return;
    }
    let updated = false;
    if (Array.isArray(arr)) {
      for (let i2 = 0; i2 < arr.length; i2++) {
        if (arr[i2] === oldId) {
          console.log(`      Updating ID at ${path}[${i2}]: "${oldId}" -> "${newId}" (JS Array)`);
          arr[i2] = newId;
          updated = true;
        }
      }
    } else if (typeof arr.get === "function" && typeof arr.set === "function" && Array.isArray(arr.items)) {
      for (let i2 = 0; i2 < arr.items.length; i2++) {
        const currentNode = arr.get(i2);
        if (currentNode && typeof currentNode !== "undefined" && currentNode === oldId) {
          console.log(`      Updating ID at ${path}[${i2}]: Node value "${oldId}" -> "${newId}" (YAML Seq)`);
          arr.set(i2, newId);
          updated = true;
        }
      }
    } else if (typeof arr.get === "function" && typeof arr.set === "function" && typeof arr.size === "number") {
      console.warn(`    Path "${path}": Encountered map-like sequence, specific update logic may be needed.`);
    } else {
      console.warn(`    Skipping update for path "${path}": Unsupported collection type or structure. Type: ${typeof arr}`, arr);
      return;
    }
  }
  function updateAnchorsAndAliases(docOrNode, oldAnchorName, newAnchorName) {
    console.log(`>>> Starting anchor/alias update: &${oldAnchorName} / *${oldAnchorName} -> &${newAnchorName} / *${newAnchorName}`);
    let result2 = {
      anchorUpdated: false,
      aliasesUpdatedCount: 0
    };
    YAML.visit(docOrNode, {
      Map: (key, node, path) => {
        if (!(node instanceof YAML.YAMLMap)) {
          return void 0;
        }
        if (node.anchor === oldAnchorName) {
          const pathStr = path.map((p) => p?.key?.toString() ?? p?.value?.toString() ?? "?").join(".");
          console.log(`  Updating anchor definition on Map at path [${pathStr || "root"}]: &${node.anchor} -> &${newAnchorName}`);
          node.anchor = newAnchorName;
          result2.anchorUpdated = true;
        }
        return void 0;
      },
      Seq: (key, node, path) => {
        if (!(node instanceof YAML.YAMLSeq)) {
          return void 0;
        }
        if (node.anchor === oldAnchorName) {
          const pathStr = path.map((p) => p?.key?.toString() ?? p?.value?.toString() ?? "?").join(".");
          console.log(`  Updating anchor definition on Sequence at path [${pathStr || "root"}]: &${node.anchor} -> &${newAnchorName}`);
          node.anchor = newAnchorName;
          result2.anchorUpdated = true;
        }
        return void 0;
      },
      Scalar: (key, node, path) => {
        if (!(node instanceof YAML.Scalar)) {
          return void 0;
        }
        if (node.anchor === oldAnchorName) {
          const pathStr = path.map((p) => p?.key?.toString() ?? p?.value?.toString() ?? "?").join(".");
          console.log(`  Updating anchor definition on Scalar at path [${pathStr || "root"}]: &${node.anchor} -> &${newAnchorName}`);
          node.anchor = newAnchorName;
          result2.anchorUpdated = true;
        }
        return void 0;
      },
      Alias: (key, node, path) => {
        if (!(node instanceof YAML.Alias)) {
          return void 0;
        }
        if (node.source === oldAnchorName) {
          const pathStr = path.map((p) => p?.key?.toString() ?? p?.value?.toString() ?? "?").join(".");
          console.log(`  Updating alias reference at path [${pathStr || "root"}]: *${node.source} -> *${newAnchorName}`);
          node.source = newAnchorName;
          result2.aliasesUpdatedCount++;
        }
        return void 0;
      }
    });
    if (!result2.anchorUpdated && result2.aliasesUpdatedCount === 0) {
      console.log(`  Note: Anchor '&${oldAnchorName}' definition not found, and no aliases '*${oldAnchorName}' found.`);
    } else {
      if (!result2.anchorUpdated) {
        console.log(`  Note: Anchor '&${oldAnchorName}' definition not found or didn't need update.`);
      }
      if (result2.aliasesUpdatedCount > 0) {
        console.log(`  Updated ${result2.aliasesUpdatedCount} alias(es) referencing '*${oldAnchorName}'.`);
      } else {
        console.log(`  No aliases referencing '*${oldAnchorName}' found.`);
      }
    }
    console.log(`>>> Anchor/alias update finished for ${oldAnchorName}.`);
    return result2;
  }
  function updateReferences(model, oldId, newId) {
    console.log(`>>> Starting reference update for Data Asset: ${oldId} -> ${newId}`);
    const isYAMLCollection = (val) => val && (typeof val.get === "function" || Array.isArray(val.items));
    if (model.has("technical_assets")) {
      const techAssetsYAML = model.get("technical_assets");
      if (techAssetsYAML && typeof techAssetsYAML.toJSON === "function") {
        const techAssetsJS = techAssetsYAML.toJSON();
        Object.keys(techAssetsJS).forEach((assetKey) => {
          console.log(`  Checking Technical Asset: [${assetKey}]`);
          const assetYAML = techAssetsYAML.get(assetKey);
          if (!assetYAML) {
            console.warn(`    Skipping asset [${assetKey}]: Could not retrieve original YAML object.`);
            return;
          }
          if (assetYAML.has("data_assets_processed")) {
            const processedSeq = assetYAML.get("data_assets_processed");
            if (isYAMLCollection(processedSeq)) {
              updateIdInArray(processedSeq, oldId, newId, `technical_assets[${assetKey}].data_assets_processed`);
            }
          }
          if (assetYAML.has("data_assets_stored")) {
            const storedSeq = assetYAML.get("data_assets_stored");
            if (isYAMLCollection(storedSeq)) {
              updateIdInArray(storedSeq, oldId, newId, `technical_assets[${assetKey}].data_assets_stored`);
            }
          }
          if (assetYAML.has("communication_links")) {
            const nestedCommLinksYAML = assetYAML.get("communication_links");
            if (nestedCommLinksYAML && typeof nestedCommLinksYAML.toJSON === "function") {
              const nestedCommLinksJS = nestedCommLinksYAML.toJSON();
              console.log(`    Checking Nested Communication Links within [${assetKey}]...`);
              Object.keys(nestedCommLinksJS).forEach((linkKey) => {
                console.log(`      Checking Nested Link: [${linkKey}]`);
                const linkYAML = nestedCommLinksYAML.get(linkKey);
                if (!linkYAML) {
                  console.warn(`      Skipping nested link [${linkKey}]: Could not retrieve original YAML object.`);
                  return;
                }
                if (linkYAML.has("data_assets_sent")) {
                  const sentSeq = linkYAML.get("data_assets_sent");
                  if (isYAMLCollection(sentSeq)) {
                    updateIdInArray(sentSeq, oldId, newId, `technical_assets[${assetKey}].communication_links[${linkKey}].data_assets_sent`);
                  }
                }
                if (linkYAML.has("data_assets_received")) {
                  const receivedSeq = linkYAML.get("data_assets_received");
                  if (isYAMLCollection(receivedSeq)) {
                    updateIdInArray(receivedSeq, oldId, newId, `technical_assets[${assetKey}].communication_links[${linkKey}].data_assets_received`);
                  }
                }
              });
            }
          }
        });
      } else {
        console.warn("Could not iterate over 'technical_assets': Not a recognized YAML collection or is null.");
      }
    } else {
      console.log("  No 'technical_assets' section found.");
    }
    if (model.has("communication_links")) {
      const topLevelCommLinksYAML = model.get("communication_links");
      if (topLevelCommLinksYAML && typeof topLevelCommLinksYAML.toJSON === "function") {
        const topLevelCommLinksJS = topLevelCommLinksYAML.toJSON();
        console.log(`  Checking Top-Level Communication Links...`);
        Object.keys(topLevelCommLinksJS).forEach((linkKey) => {
          console.log(`    Checking Top-Level Link: [${linkKey}]`);
          const linkYAML = topLevelCommLinksYAML.get(linkKey);
          if (!linkYAML) {
            console.warn(`    Skipping top-level link [${linkKey}]: Could not retrieve original YAML object.`);
            return;
          }
          if (linkYAML.has("data_assets_sent")) {
            const sentSeq = linkYAML.get("data_assets_sent");
            if (isYAMLCollection(sentSeq)) {
              updateIdInArray(sentSeq, oldId, newId, `communication_links[${linkKey}].data_assets_sent`);
            }
          }
          if (linkYAML.has("data_assets_received")) {
            const receivedSeq = linkYAML.get("data_assets_received");
            if (isYAMLCollection(receivedSeq)) {
              updateIdInArray(receivedSeq, oldId, newId, `communication_links[${linkKey}].data_assets_received`);
            }
          }
        });
      } else {
        console.warn("Could not iterate over 'communication_links': Not a recognized YAML collection or is null.");
      }
    } else {
      console.log("  No top-level 'communication_links' section found.");
    }
    if (model.has("risk_tracking")) {
      console.log("  Checking 'risk_tracking' keys...");
    } else {
      console.log("  No 'risk_tracking' section found.");
    }
    console.log(`>>> Reference update finished for ${oldId} -> ${newId}`);
  }
  function renameYamlMapKey(doc, mapPath, oldKey, newKey, YAML2) {
    if (!YAML2 || typeof YAML2.isMap !== "function") {
      console.error("Error: Valid YAML library object must be provided as the fifth argument.");
      return false;
    }
    if (!doc || typeof doc.getIn !== "function" || typeof doc.createNode !== "function") {
      console.error("Error: Invalid YAML Document object provided (first argument). Must have getIn and createNode methods.");
      return false;
    }
    if (!Array.isArray(mapPath)) {
      console.error("Error: mapPath (second argument) must be an array.");
      return false;
    }
    if (typeof oldKey !== "string" || oldKey === "") {
      console.error("Error: oldKey (third argument) must be a non-empty string.");
      return false;
    }
    if (typeof newKey !== "string" || newKey === "") {
      console.error("Error: newKey (fourth argument) must be a non-empty string.");
      return false;
    }
    if (oldKey === newKey) {
      console.warn("Warning: oldKey and newKey are the same. No rename needed.");
      return true;
    }
    const targetMap = doc.getIn(mapPath, true);
    if (!targetMap) {
      console.error(`Error: Could not find a node at path: [${mapPath.join(", ")}]`);
      return false;
    }
    if (!YAML2.isMap(targetMap)) {
      const type = targetMap?.constructor?.name ?? typeof targetMap;
      console.error(`Error: The node at path [${mapPath.join(", ")}] is not a YAMLMap. Found type: ${type}`);
      return false;
    }
    if (targetMap.has(newKey)) {
      console.warn(`Warning: The new key "${newKey}" already exists in the map at path [${mapPath.join(", ")}]. Renaming aborted.`);
      return false;
    }
    let foundAndRenamed = false;
    for (let i2 = 0; i2 < targetMap.items.length; i2++) {
      const pair = targetMap.items[i2];
      if (pair.key && YAML2.isScalar(pair.key) && pair.key.value === oldKey) {
        const newKeyNode = doc.createNode(newKey);
        pair.key = newKeyNode;
        console.log(`Successfully replaced key node "${oldKey}" with new key node "${newKey}" in map at path [${mapPath.join(", ")}].`);
        foundAndRenamed = true;
        break;
      }
    }
    if (!foundAndRenamed) {
      console.warn(`Warning: Key "${oldKey}" was not found in the map at path [${mapPath.join(", ")}].`);
      return false;
    }
    return true;
  }
  var self = this;
  let uniqueID;
  if (UUID == void 0) {
    uniqueID = generateUniquekeyData(self.editorUi.editor.graph);
  } else {
    uniqueID = UUID;
  }
  container.setAttribute("data-info", uniqueID);
  var propertiesSection = createSection("Properties");
  container.appendChild(propertiesSection);
  var typeProperties = {
    key: {
      description: "key",
      type: "button",
      tooltip: "The identifier for the yaml element",
      defaultValue: "<Your title>"
    },
    id: {
      description: "ID",
      type: "button",
      tooltip: "The unique identifier for the element",
      defaultValue: "E.g. Element1"
    },
    description: {
      description: "Description",
      type: "button",
      tooltip: "Provide a brief description of the element",
      defaultValue: "E.g. This element is responsible for..."
    },
    usage: {
      description: "Usage",
      type: "select",
      options: ["business", "devops"],
      tooltip: "Indicates whether the element is used for business or devops purposes",
      defaultValue: "business"
    },
    tags: {
      description: "Tags",
      type: "array",
      uniqueItems: true,
      items: {
        type: "button"
      },
      tooltip: "Provide tags to help categorize the element",
      defaultValue: "E.g. Tag1"
    },
    origin: {
      description: "Origin",
      type: "button",
      tooltip: "Specifies the origin of the element",
      defaultValue: "E.g. Internal Development"
    },
    owner: {
      description: "Owner",
      type: "button",
      tooltip: "Specifies the owner of the element",
      defaultValue: "E.g. Marketing Team"
    },
    quantity: {
      description: "Quantity",
      type: "select",
      options: ["very-few", "few", "many", "very-many"],
      tooltip: "Specifies the quantity of the element",
      defaultValue: "few"
    },
    confidentiality: {
      description: "Confidentiality",
      type: "select",
      options: [
        "public",
        "internal",
        "restricted",
        "confidential",
        "strictly-confidential"
      ],
      tooltip: "Specifies the level of confidentiality of the element",
      defaultValue: "internal"
    },
    integrity: {
      description: "Integrity",
      type: "select",
      options: [
        "archive",
        "operational",
        "important",
        "critical",
        "mission-critical"
      ],
      tooltip: "Specifies the level of integrity of the element",
      defaultValue: "operational"
    },
    availability: {
      description: "Availability",
      type: "select",
      options: [
        "archive",
        "operational",
        "important",
        "critical",
        "mission-critical"
      ],
      tooltip: "Specifies the level of availability of the element",
      defaultValue: "operational"
    },
    justification_cia_rating: {
      description: "Justification of the rating",
      type: "button",
      tooltip: "Justify the confidentiality, integrity, and availability rating",
      defaultValue: "E.g. This rating is due to..."
    },
    tags: {
      description: "Tags",
      type: "array",
      uniqueItems: true,
      items: {
        type: "button"
      },
      tooltip: "Add any tags associated with the component.",
      defaultValue: [],
      section: "Properties"
    }
  };
  var customListener2 = {
    install: function(apply) {
      this.listener = function() {
      };
    },
    destroy: function() {
    }
  };
  var self = this;
  var typePropertiesMap = {};
  for (let property2 in typeProperties) {
    var typeItem = document.createElement("li");
    typeItem.style.display = "flex";
    typeItem.style.alignItems = "baseline";
    typeItem.style.marginBottom = "8px";
    var propertyName = document.createElement("span");
    propertyName.innerHTML = property2;
    propertyName.style.width = "100px";
    propertyName.style.marginRight = "10px";
    var propertyType = typeProperties[property2].type;
    if (propertyType === "select") {
      const propertySelect = property2;
      typeItem.appendChild(propertyName);
      var selectContainer = document.createElement("div");
      selectContainer.style.display = "flex";
      selectContainer.style.alignItems = "center";
      selectContainer.style.marginLeft = "auto";
      var selectDropdown = document.createElement("select");
      selectDropdown.style.width = "100px";
      selectDropdown.title = typeProperties[property2].tooltip;
      selectContainer.appendChild(selectDropdown);
      var options = typeProperties[property2].options;
      for (var i = 0; i < options.length; i++) {
        var option = document.createElement("option");
        option.value = options[i];
        option.text = options[i];
        selectDropdown.appendChild(option);
      }
      var createChangeListener = function(selectDropdown2, property3) {
        var self2 = this.editorUi;
        return function(evt) {
          let textContentData = evt.target.parentNode.parentNode.parentNode.parentNode.parentNode.textContent;
          let dataAssetName = textContentData.substring(0, textContentData.indexOf(":"));
          var newValue = selectDropdown2.value;
          self2.editor.graph.model.threagile.setIn(["data_assets", dataAssetName, property3], newValue);
        };
      }.bind(this);
      mxEvent2.addListener(selectDropdown, "change", createChangeListener(selectDropdown, property2));
      typeItem.appendChild(selectContainer);
    } else if (propertyType === "checkbox") {
      let optionElement = this.createOption(property2, createCustomOption(self, property2), setCustomOption(self, property2), customListener2);
      optionElement.querySelector('input[type="checkbox"]').title = typeProperties[property2].tooltip;
      container.appendChild(optionElement);
    } else if (propertyType === "button") {
      let functionName = "editData" + property2.charAt(0).toUpperCase() + property2.slice(1);
      let button2 = button(property2, bind(this, function(p) {
        return function(evt) {
          let str = evt.target.parentNode.parentNode.parentNode.parentNode.textContent;
          str = str.slice(0, str.indexOf(":"));
          let current2 = self.graph.model.threagile.getIn(["data_assets", str, p]);
          var dataValue;
          if (p === "key") {
            dataValue = str;
          } else {
            if (!current2) {
              self.graph.model.threagile.setIn(["data_assets", str, p], typeProperties[p].defaultValue);
            }
            dataValue = current2 ? self.graph.model.threagile.getIn(["data_assets", str, p]) : void 0;
          }
          var dlg = new TextareaDialog(this.editorUi, p + ":", dataValue, function(newValue) {
            if (newValue != null) {
              if (p === "key") {
                let doc = self.editorUi.editor.graph.model.threagile;
                let dataAssetsPath = ["data_assets"];
                const dataAssetsMap = doc.getIn(dataAssetsPath, true);
                if (doc && typeof doc.getIn === "function") {
                  const success = renameYamlMapKey(doc, dataAssetsPath, uniqueID, newValue, YAML);
                  if (success) {
                    console.log("Rename successful. Updated YAML document:");
                    console.log(doc.toString());
                  } else {
                    console.log("Rename failed. Check warnings/errors above.");
                  }
                } else {
                  console.error("The 'doc' object is not a valid YAML Document.");
                }
                restartWasm();
                let targetElement = evt.target.parentNode.parentNode.parentNode.parentNode;
                const graphvar = self.editorUi.editor.graph;
                graphvar.model.beginUpdate();
                try {
                  const v1 = graphvar.insertVertex(graphvar.getDefaultParent(), null, "", 0, 0, 10, 10, "s");
                  graphvar.removeCells([v1]);
                } finally {
                  graphvar.model.endUpdate();
                }
                graphvar.refresh();
              } else if (p === "id") {
                let id = self.graph.model.threagile.getIn(["data_assets", str, p], newValue).toJSON();
                self.graph.model.threagile.setIn(["data_assets", str, p], newValue);
                updateReferences(self.editorUi.editor.graph.model.threagile, id, newValue);
              } else {
                self.graph.model.threagile.setIn(["data_assets", str, p], newValue);
              }
            }
          }, null, null, 400, 220);
          this.editorUi.showDialog(dlg.container, 420, 300, true, true);
          dlg.init();
          try {
            if (dlg.textarea) {
              let textareaId = `threagile-dialog-${property2}-textarea`;
              dlg.textarea.id = textareaId;
              console.log(`Added ID to textarea: ${textareaId}`);
            } else {
              console.warn(`Could not find dlg.textarea for property '${property2}'.`);
            }
          } catch (e) {
            console.error("Error adding ID to dialog textarea:", e);
          }
          try {
            let buttonContainer = dlg.container.querySelector(".geDialogButtons");
            let buttons = buttonContainer ? buttonContainer.querySelectorAll("button") : dlg.container.querySelectorAll("button");
            if (buttons && buttons.length > 0) {
              const applyText = mxResources2.get("apply") || "Apply";
              const cancelText = mxResources2.get("cancel") || "Cancel";
              let applyFound = false;
              let cancelFound = false;
              buttons.forEach((btn) => {
                if (!applyFound && (btn.textContent.trim() === applyText || btn.textContent.trim() === (mxResources2.get("ok") || "OK"))) {
                  btn.id = `threagile-dialog-${property2}-apply-button`;
                  applyFound = true;
                } else if (!cancelFound && btn.textContent.trim() === cancelText) {
                  btn.id = `threagile-dialog-${property2}-cancel-button`;
                  cancelFound = true;
                }
              });
            } else {
              console.warn("Could not find buttons in TextareaDialog container for property:", property2);
            }
          } catch (e) {
            console.error("Error adding IDs to dialog buttons:", e);
          }
        };
      }(property2)));
      button2.title = typeProperties[property2].tooltip;
      button2.style.width = "200px";
      typeItem.appendChild(button2);
    }
    propertiesSection.appendChild(typeItem);
  }
  let inputElement = document.createElement("input");
  inputElement.value = "";
  inputElement.placeholder = "Enter your tags and press Enter";
  propertiesSection.appendChild(inputElement);
  let tags = self.editorUi.editor.graph.model.threagile.getIn(["tags"]);
  let t_available;
  let threagileData = self.editorUi.editor.graph.model.threagile.getIn(["tags_available"]);
  if (typeof threagileData.toJSON === "function") {
    t_available = threagileData.toJSON();
  } else {
    t_available = Array.from(threagileData);
  }
  let tagsAsset = self.editorUi.editor.graph.model.threagile.getIn(["data_assets", uniqueID, "tags"]);
  inputElement.value = tagsAsset != void 0 ? Array.from(tagsAsset) : [];
  let t = new Tagify(inputElement, {
    whitelist: typeof self.editorUi.editor.graph.model.threagile.getIn(["tags_available"]).toJSON === "function" ? Array.from(self.editorUi.editor.graph.model.threagile.getIn(["tags_available"]).toJSON()) : Array.from(self.editorUi.editor.graph.model.threagile.getIn(["tags_available"])),
    editTags: false,
    dropdown: {
      maxItems: 100,
      classname: "tags-look",
      enabled: 0,
      closeOnSelect: true
    }
  });
  t.on("add", onAddThreagileTag).on("remove", onRemoveThreagileTag);
  function onAddThreagileTag(e) {
    const model = self.editorUi.editor.graph.model.threagile;
    let str;
    if (e.detail.tagify.DOM.input.parentNode.parentNode.parentNode.parentNode == null) {
      str = e.detail.tagify.DOM.input.parentNode.parentNode.parentNode.id;
    } else {
      str = e.detail.tagify.DOM.input.parentNode.parentNode.parentNode.parentNode.textContent;
    }
    str = str.slice(0, str.indexOf(":"));
    let threagileTags;
    let threagileData2 = self.editorUi.editor.graph.model.threagile.getIn(["tags_available"]);
    if (typeof threagileData2.toJSON === "function") {
      threagileTags = threagileData2.toJSON();
    } else {
      threagileTags = Array.from(threagileData2);
    }
    if (!(threagileTags instanceof Set)) {
      if (threagileTags) {
        var threagileTagsSet = /* @__PURE__ */ new Set();
        if (Array.isArray(threagileTags)) {
          for (const tag of threagileTags) {
            threagileTagsSet.add(tag);
          }
        } else {
          threagileTagsSet = /* @__PURE__ */ new Set([threagileTags]);
        }
      } else {
        threagileTagsSet = /* @__PURE__ */ new Set();
      }
    }
    let old = threagileTagsSet.size;
    threagileTagsSet.add(e.detail.data.value);
    if (old != threagileTagsSet.size) {
      restartWasm();
    }
    model.setIn(["tags_available"], threagileTagsSet);
    let dataAssetTags = new Set(model.getIn(["data_assets", str, "tags"]));
    if (!(dataAssetTags instanceof Set)) {
      let tempSet;
      if (dataAssetTags) {
        tempSet = /* @__PURE__ */ new Set();
        if (Array.isArray(dataAssetTags)) {
          for (const tag of dataAssetTags) {
            tempSet.add(tag);
          }
        } else {
          tempSet.add(dataAssetTags);
        }
        dataAssetTags = tempSet;
      } else {
        dataAssetTags = /* @__PURE__ */ new Set();
      }
    }
    dataAssetTags.add(e.detail.data.value);
    model.setIn(["data_assets", str, "tags"], dataAssetTags);
  }
  function onRemoveThreagileTag(e) {
    const model = self.editorUi.editor.graph.model.threagile;
    let threagileTags = model.getIn(["tags_available"]);
    let str = e.detail.tagify.DOM.input.parentNode.parentNode.parentNode.parentNode.textContent;
    str = str.slice(0, str.indexOf(":"));
    let dataAssetTag = model.getIn(["data_assets", str, "tags"]) || [];
    if (!(dataAssetTag instanceof Set)) {
      let tempSet;
      if (dataAssetTag) {
        tempSet = /* @__PURE__ */ new Set();
        if (Array.isArray(dataAssetTag)) {
          for (const tag of dataAssetTag) {
            tempSet.add(tag);
          }
        } else {
          tempSet.add(dataAssetTag);
        }
        dataAssetTag = tempSet;
      } else {
        dataAssetTag = /* @__PURE__ */ new Set();
      }
    }
    dataAssetTag.delete(e.detail.data.value);
    model.setIn(["data_assets", str, dataAssetTag]);
  }
  return container;
};
DiagramFormatPanel.showPageView = true;
DiagramFormatPanel.prototype.showBackgroundImageOption = true;
DiagramFormatPanel.prototype.init = function() {
  function removeIdFromArray(arr, idToRemove, path) {
    if (!arr) {
      return;
    }
    let removed = false;
    if (Array.isArray(arr)) {
      for (let i2 = arr.length - 1; i2 >= 0; i2--) {
        if (arr[i2] === idToRemove) {
          console.log(`      Removing ID at ${path}[${i2}]: "${idToRemove}" (JS Array)`);
          arr.splice(i2, 1);
          removed = true;
        }
      }
    } else if (typeof arr.get === "function" && typeof arr.delete === "function" && Array.isArray(arr.items)) {
      for (let i2 = arr.items.length - 1; i2 >= 0; i2--) {
        const currentNodeOrValue = arr.get(i2);
        let currentValue2;
        if (currentNodeOrValue && typeof currentNodeOrValue === "object" && currentNodeOrValue.hasOwnProperty("value")) {
          currentValue2 = currentNodeOrValue.value;
        } else {
          currentValue2 = currentNodeOrValue;
        }
        if (currentValue2 === idToRemove) {
          console.log(`      Removing ID at ${path}[${i2}]: Value "${idToRemove}" (YAML Seq)`);
          arr.delete(i2);
          removed = true;
        }
      }
    } else if (typeof arr.get === "function" && typeof arr.delete === "function" && typeof arr.size === "number") {
      console.warn(`    Path "${path}": Attempting removal in map-like sequence for "${idToRemove}". Logic assumes sequence behavior.`);
      console.warn(`    Path "${path}": Encountered map-like structure with get/delete/size but no 'items' array. Cannot reliably perform indexed removal. Skipping removal for this specific type.`);
    } else {
      console.warn(`    Skipping removal for path "${path}": Unsupported collection type or structure for removal. Type: ${typeof arr}`, arr);
      return;
    }
  }
  function removeReferences(model, idToRemove) {
    console.log(`>>> Starting reference removal for Data Asset ID: ${idToRemove}`);
    const isProcessableArray = (val) => {
      if (Array.isArray(val)) {
        return true;
      }
      if (val && typeof val.get === "function" && typeof val.delete === "function" && Array.isArray(val.items)) {
        return true;
      }
      return false;
    };
    if (model.has("technical_assets")) {
      const techAssetsYAML = model.get("technical_assets");
      if (techAssetsYAML && typeof techAssetsYAML.toJSON === "function") {
        const techAssetsJS = techAssetsYAML.toJSON();
        Object.keys(techAssetsJS).forEach((assetKey) => {
          console.log(`  Checking Technical Asset: [${assetKey}] for removal of "${idToRemove}"`);
          const assetYAML = techAssetsYAML.get(assetKey);
          if (!assetYAML) {
            console.warn(`    Skipping asset [${assetKey}]: Could not retrieve original YAML object.`);
            return;
          }
          if (assetYAML.has("data_assets_processed")) {
            const processedSeq = assetYAML.get("data_assets_processed");
            if (isProcessableArray(processedSeq)) {
              removeIdFromArray(processedSeq, idToRemove, `technical_assets[${assetKey}].data_assets_processed`);
            } else if (processedSeq) {
              console.warn(`    Skipping removal in technical_assets[${assetKey}].data_assets_processed: Not a processable array/sequence.`);
            }
          }
          if (assetYAML.has("data_assets_stored")) {
            const storedSeq = assetYAML.get("data_assets_stored");
            if (isProcessableArray(storedSeq)) {
              removeIdFromArray(storedSeq, idToRemove, `technical_assets[${assetKey}].data_assets_stored`);
            } else if (storedSeq) {
              console.warn(`    Skipping removal in technical_assets[${assetKey}].data_assets_stored: Not a processable array/sequence.`);
            }
          }
          if (assetYAML.has("communication_links")) {
            const nestedCommLinksYAML = assetYAML.get("communication_links");
            if (nestedCommLinksYAML && typeof nestedCommLinksYAML.toJSON === "function") {
              const nestedCommLinksJS = nestedCommLinksYAML.toJSON();
              console.log(`    Checking Nested Communication Links within [${assetKey}] for removal of "${idToRemove}"...`);
              Object.keys(nestedCommLinksJS).forEach((linkKey) => {
                console.log(`      Checking Nested Link: [${linkKey}]`);
                const linkYAML = nestedCommLinksYAML.get(linkKey);
                if (!linkYAML) {
                  console.warn(`      Skipping nested link [${linkKey}]: Could not retrieve original YAML object.`);
                  return;
                }
                if (linkYAML.has("data_assets_sent")) {
                  const sentSeq = linkYAML.get("data_assets_sent");
                  if (isProcessableArray(sentSeq)) {
                    removeIdFromArray(sentSeq, idToRemove, `technical_assets[${assetKey}].communication_links[${linkKey}].data_assets_sent`);
                  } else if (sentSeq) {
                    console.warn(`      Skipping removal in ...communication_links[${linkKey}].data_assets_sent: Not a processable array/sequence.`);
                  }
                }
                if (linkYAML.has("data_assets_received")) {
                  const receivedSeq = linkYAML.get("data_assets_received");
                  if (isProcessableArray(receivedSeq)) {
                    removeIdFromArray(receivedSeq, idToRemove, `technical_assets[${assetKey}].communication_links[${linkKey}].data_assets_received`);
                  } else if (receivedSeq) {
                    console.warn(`      Skipping removal in ...communication_links[${linkKey}].data_assets_received: Not a processable array/sequence.`);
                  }
                }
              });
            }
          }
        });
      } else {
        console.warn(`Could not iterate over 'technical_assets' for removal: Not a recognized YAML collection or is null.`);
      }
    } else {
      console.log("  No 'technical_assets' section found, skipping removal within.");
    }
    if (model.has("communication_links")) {
      const topLevelCommLinksYAML = model.get("communication_links");
      if (topLevelCommLinksYAML && typeof topLevelCommLinksYAML.toJSON === "function") {
        const topLevelCommLinksJS = topLevelCommLinksYAML.toJSON();
        console.log(`  Checking Top-Level Communication Links for removal of "${idToRemove}"...`);
        Object.keys(topLevelCommLinksJS).forEach((linkKey) => {
          console.log(`    Checking Top-Level Link: [${linkKey}]`);
          const linkYAML = topLevelCommLinksYAML.get(linkKey);
          if (!linkYAML) {
            console.warn(`    Skipping top-level link [${linkKey}]: Could not retrieve original YAML object.`);
            return;
          }
          if (linkYAML.has("data_assets_sent")) {
            const sentSeq = linkYAML.get("data_assets_sent");
            if (isProcessableArray(sentSeq)) {
              removeIdFromArray(sentSeq, idToRemove, `communication_links[${linkKey}].data_assets_sent`);
            } else if (sentSeq) {
              console.warn(`    Skipping removal in communication_links[${linkKey}].data_assets_sent: Not a processable array/sequence.`);
            }
          }
          if (linkYAML.has("data_assets_received")) {
            const receivedSeq = linkYAML.get("data_assets_received");
            if (isProcessableArray(receivedSeq)) {
              removeIdFromArray(receivedSeq, idToRemove, `communication_links[${linkKey}].data_assets_received`);
            } else if (receivedSeq) {
              console.warn(`    Skipping removal in communication_links[${linkKey}].data_assets_received: Not a processable array/sequence.`);
            }
          }
        });
      } else {
        console.warn(`Could not iterate over 'communication_links' for removal: Not a recognized YAML collection or is null.`);
      }
    } else {
      console.log("  No top-level 'communication_links' section found, skipping removal within.");
    }
    if (model.has("risk_tracking")) {
      console.log(`  Checking 'risk_tracking': Removal logic for risk keys containing "${idToRemove}" is NOT IMPLEMENTED.`);
    } else {
      console.log("  No 'risk_tracking' section found.");
    }
    console.log(`>>> Reference removal finished for ID: ${idToRemove}`);
  }
  var ui = this.editorUi;
  var editor = ui.editor;
  var graph = editor.graph;
  var listContainer = document.createElement("div");
  listContainer.style.maxWidth = "400px";
  listContainer.style.margin = "0 auto";
  var list = document.createElement("ul");
  list.style.listStyleType = "none";
  list.style.padding = "0";
  list.id = "threagileDataAssetList";
  var items = [];
  for (var i = 0; i < items.length; i++) {
    var listItem = document.createElement("li");
    listItem.textContent = items[i];
    listItem.style.display = "flex";
    listItem.style.alignItems = "center";
    listItem.style.padding = "8px";
    listItem.style.borderBottom = "1px solid #ccc";
    var xButton = document.createElement("button");
    xButton.innerHTML = '<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJAQMAAADaX5RTAAAABlBMVEV7mr3///+wksspAAAAAnRSTlP/AOW3MEoAAAAdSURBVAgdY9jXwCDDwNDRwHCwgeExmASygSL7GgB12QiqNHZZIwAAAABJRU5ErkJggg==" alt="X">';
    xButton.style.marginLeft = "auto";
    xButton.style.padding = "5px";
    xButton.style.backgroundColor = "transparent";
    xButton.style.border = "none";
    xButton.style.cursor = "pointer";
    listItem.appendChild(xButton);
    list.appendChild(listItem);
  }
  if (typeof graph.model.threagile.getIn(["data_assets"]) !== "undefined" && typeof this.editorUi.editor.graph.model.threagile.getIn(["data_assets"]) !== "undefined") {
    let interpolateColorForRisks = function(minColor, maxColor, minVal, maxVal, val) {
      function interpolate(start, end, step2) {
        return start + (end - start) * step2;
      }
      var step = (val - minVal) / (maxVal - minVal);
      step = Math.max(0, Math.min(1, step));
      var red = interpolate(minColor[0], maxColor[0], step);
      var green = interpolate(minColor[1], maxColor[1], step);
      var blue = interpolate(minColor[2], maxColor[2], step);
      if (step > 0.5) {
        green *= 1 - step * 2;
      }
      return `rgb(${Math.round(red)}, ${Math.round(green)}, ${Math.round(blue)})`;
    }, mapRiskLevel = function(value, category) {
      const mappings = {
        "quantity": {
          "very-few": 1,
          "few": 2,
          "many": 3,
          "very-many": 4
        },
        "confidentiality": {
          "public": 1,
          "internal": 2,
          "restricted": 3,
          "confidential": 4,
          "strictly-confidential": 5
        },
        "integrity": {
          "archive": 1,
          "operational": 2,
          "important": 3,
          "critical": 4,
          "mission-critical": 5
        },
        "availability": {
          "archive": 1,
          "operational": 2,
          "important": 3,
          "critical": 4,
          "mission-critical": 5
        }
      };
      return mappings[category][value.toLowerCase().replace("-", "")] || 0;
    };
    let data_assets_map = graph.model.threagile.getIn(["data_assets"]).toJSON();
    const lowRiskColor = [0, 255, 0];
    const highRiskColor = [255, 0, 0];
    Object.entries(data_assets_map).forEach(([property2, value]) => {
      let data_asset = this.editorUi.editor.graph.model.threagile.getIn(["data_assets", property2]);
      var clonedMenu = this.addDataMenu(this.createPanel(), property2);
      let orginalProperty = property2;
      property2 = property2 + ":";
      clonedMenu.id = property2;
      var listItem2 = document.createElement("li");
      listItem2.style.display = "flex";
      listItem2.style.flexDirection = "column";
      listItem2.style.padding = "8px";
      listItem2.style.borderBottom = "1px solid #ccc";
      listItem2.dataset.visible = "false";
      var parentNode = clonedMenu.childNodes[0];
      let riskScore = 0;
      console.log(value.quantity);
      console.log(value.confidentiality);
      console.log(value.integrity);
      console.log(value.availability);
      if (value.quantity !== void 0)
        riskScore *= mapRiskLevel(value.quantity, "quantity");
      if (value.confidentiality !== void 0)
        riskScore += mapRiskLevel(value.confidentiality, "confidentiality");
      if (value.integrity !== void 0)
        riskScore += mapRiskLevel(value.integrity, "integrity");
      if (value.availability !== void 0)
        riskScore *= mapRiskLevel(value.availability, "availability");
      for (var key in value) {
        if (value.hasOwnProperty(key)) {
          var childNode = value[key];
          for (var i2 = 0; i2 < parentNode.childNodes.length; i2++) {
            var currentChildNode = parentNode.childNodes[i2];
            if (currentChildNode.nodeName === "INPUT") {
              if ("__tagify" in currentChildNode) {
                let tags = graph.model.threagile.getIn(["data_assets", orginalProperty, "tags"]) || [];
              }
            } else {
              if (currentChildNode.nodeType === Node.ELEMENT_NODE && currentChildNode.children.length > 0 && currentChildNode.children[0].textContent === key) {
                if (currentChildNode.children.length > 1 && currentChildNode.childNodes.length > 0) {
                  let nextChildNode = currentChildNode.children[1].children[0];
                  if (nextChildNode.nodeName === "SELECT") {
                    for (let i3 = 0; i3 < nextChildNode.options.length; i3++) {
                      if (nextChildNode.options[i3].value === childNode) {
                        nextChildNode.selectedIndex = i3;
                        break;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      var textContainer = document.createElement("div");
      textContainer.style.display = "flex";
      textContainer.style.alignItems = "center";
      textContainer.style.marginBottom = "8px";
      textContainer.style.color = "black";
      textContainer.style.fontWeight = "bold";
      let arrowIcon = document.createElement("img");
      arrowIcon.src = " data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAAagAAAGoB3Bi5tQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAEUSURBVDiNjdO9SgNBFIbhJ4YkhZ2W2tgmphYEsTJiY2Vjk0YbMYVeiKAo2mjlHVhpDBaCoPGnEjtvQLAWRIjF7sJmM9nk7WbO+b6Zc+ZMwSB1bGMRhXivhwec4z2gARWcoo0VlFKxEhq4xQnKIXEbO8PcU+ziJmtyNqY4oYXjZFGPHbNMo5hj0kEVDkU1Z2niCpNDDFZxAF39DUuzgUfMBmJlPMFLzjVhGW+YC8ReJ0aIR9FjvBJmArEKukXU8IfPTEITm1jHd8CgkRw8L5qwLFPyn/EO1SK+sCBq0nMq4UdcY4B9/OIy2SiLhqmVc2LCHq4F+lYWjWdHNCTpWa9gLb72UVpcMEgNW1jS/53vcYGPdPI/rfEvjAsiqsMAAAAASUVORK5CYII=";
      arrowIcon.style.width = "15px";
      arrowIcon.style.height = "15px";
      arrowIcon.style.marginRight = "5px";
      arrowIcon.style.transform = "rotate(270deg)";
      textContainer.insertBefore(arrowIcon, dataText);
      var dataText = document.createElement("div");
      dataText.textContent = property2;
      var xButton2 = document.createElement("button");
      xButton2.innerHTML = '<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJAQMAAADaX5RTAAAABlBMVEV7mr3///+wksspAAAAAnRSTlP/AOW3MEoAAAAdSURBVAgdY9jXwCDDwNDRwHCwgeExmASygSL7GgB12QiqNHZZIwAAAABJRU5ErkJggg==" alt="X">';
      xButton2.style.marginLeft = "auto";
      xButton2.style.padding = "5px";
      xButton2.style.backgroundColor = "transparent";
      xButton2.style.border = "none";
      xButton2.style.cursor = "pointer";
      xButton2.addEventListener("click", function(event2) {
        event2.stopPropagation();
        const dataAssetKeyToDelete = clonedMenu.id.slice(0, -1);
        const uiListItem = xButton2.parentNode.parentNode;
        const uiList = uiListItem.parentNode;
        const model = graph.model;
        const dataAssetIdToDeleteID = model.threagile.getIn(["data_assets", dataAssetKeyToDelete], true).toJSON().id;
        if (!model || !model.threagile) {
          console.error("Threagile model data not found!");
          Swal.fire({
            title: "Error",
            text: "Could not find Threagile model data to perform deletion.",
            icon: "error"
          });
          return;
        }
        const dependents = [];
        const dataAssets = model.threagile.toJSON().data_assets || {};
        for (const assetId in dataAssets) {
          if (assetId === dataAssetKeyToDelete)
            continue;
          const asset = dataAssets[assetId];
          if (asset && asset["<<"]) {
            let referencedId = "";
            if (typeof asset["<<"] === "string") {
              referencedId = asset["<<"];
            } else if (typeof asset["<<"] === "object" && asset["<<"] !== null && asset["<<"].id) {
              referencedId = asset["<<"].id;
            }
            if (referencedId === dataAssetIdToDeleteID) {
              dependents.push({
                id: assetId,
                type: "data_assets",
                name: asset.description || assetId
              });
            }
          }
        }
        const performSingleDeletion = (itemId, itemType, diagramKey) => {
          console.log(`Attempting to delete ${itemType}: ${itemId} (UI key: ${diagramKey})`);
          let modelDeleted = false;
          let uiDeleted = false;
          const model2 = graph.model;
          try {
            const modelPath = [itemType, itemId];
            if (model2.threagile.hasIn(modelPath)) {
              if (model2.threagile.deleteIn) {
                model2.threagile.deleteIn(modelPath);
                console.log(`  Successfully deleted from model: ${modelPath.join(".")}`);
                modelDeleted = true;
              } else {
                console.error(`  Cannot delete from model: 'deleteIn' method not available.`);
              }
            } else {
              console.warn(`  Skipping model deletion: ${itemId} not found in ${itemType}. It might have been deleted already.`);
              modelDeleted = true;
            }
            if (diagramKey && graph.model.diagramData && graph.model.diagramData[diagramKey]) {
              console.log(`  Deleting ${diagramKey} from diagramData`);
              delete graph.model.diagramData[diagramKey];
            }
            const listContainer2 = document.getElementById("threagileDataAssetList");
            if (!listContainer2) {
              console.error("  Cannot remove UI element: Could not find the list container with id='threagileDataAssetList'.");
            } else {
              let listItemToRemove = null;
              const listItems = listContainer2.getElementsByTagName("li");
              for (let i3 = 0; i3 < listItems.length; i3++) {
                const li = listItems[i3];
                if (li.children.length > 1 && li.children[1] && li.children[1].id === diagramKey) {
                  listItemToRemove = li;
                  break;
                }
              }
              if (listItemToRemove) {
                listContainer2.removeChild(listItemToRemove);
                console.log(`  Successfully removed UI list item (<li>) associated with key: ${diagramKey}`);
                uiDeleted = true;
              } else {
                console.warn(`  Could not find the UI list item (<li>) to remove for key: ${diagramKey}. It might have been removed already or the structure is incorrect.`);
              }
            }
          } catch (error2) {
            console.error(`Error during deletion process for ${itemType} ${itemId}:`, error2);
            Swal.fire("Deletion Error", `Failed to fully delete ${itemId}. Check console for details.`, "error");
          } finally {
            if (modelDeleted && uiDeleted) {
              console.log(`Deletion process completed successfully for ${itemId}.`);
            } else {
              console.warn(`Deletion process for ${itemId} might be incomplete (Model Deleted: ${modelDeleted}, UI Deleted: ${uiDeleted}).`);
            }
          }
        };
        if (dependents.length > 0) {
          const dependentNames = dependents.map((item) => `- ${item.name} (Data Asset)`).join("<br/>");
          const message = `The data asset "<b>${dataAssetKeyToDelete}</b>" is used as an anchor (<code><<</code>) by the following data assets:<br/><br/>${dependentNames}<br/><br/>How do you want to proceed?`;
          Swal.fire({
            title: "Confirm Deletion",
            html: message,
            icon: "warning",
            showCancelButton: true,
            confirmButtonText: "Delete Item + Dependents",
            confirmButtonColor: "#d33",
            cancelButtonText: "Cancel",
            showDenyButton: true,
            denyButtonText: "Delete Item Only(May break graph)",
            denyButtonColor: "#ffae42",
            buttonsStyling: false,
            customClass: {
              confirmButton: "swal-confirm-button-style",
              denyButton: "swal-deny-button-style",
              cancelButton: "swal-cancel-button-style",
              popup: "custom-popup-style"
            },
            didRender: () => {
              if (!document.getElementById("swal-custom-button-styles")) {
                const styleTag = document.createElement("style");
                styleTag.id = "swal-custom-button-styles";
                styleTag.innerHTML = `
                                 .swal-confirm-button-style, .swal-deny-button-style, .swal-cancel-button-style {
                                     color: #fff;
                                     border: none;
                                     border-radius: 5px;
                                     padding: 10px 20px;
                                     font-size: 14px;
                                     margin: 5px;
                                     transition: background-color 0.3s ease;
                                 }
                                 .swal-confirm-button-style { background-color: #d33; } /* Red */
                                 .swal-confirm-button-style:hover { background-color: #c82333; }
                                 .swal-deny-button-style { background-color: #ffae42; } /* Orange */
                                 .swal-deny-button-style:hover { background-color: #f49d2c; }
                                 .swal-cancel-button-style { background-color: #aaa; } /* Grey */
                                 .swal-cancel-button-style:hover { background-color: #999; }
                                 .custom-popup-style {
                                     box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
                                     border-radius: 8px;
                                     background: #f0f0f0; /* Your background */
                                 }
                             `;
                document.head.appendChild(styleTag);
              }
            }
          }).then((result2) => {
            if (result2.isConfirmed) {
              console.log("User chose to DELETE ALL (item and dependents).");
              removeReferences(graph.model.threagile, dataAssetIdToDeleteID);
              dependents.forEach((item) => {
                performSingleDeletion(item.id, item.type, null);
              });
              performSingleDeletion(dataAssetKeyToDelete, "data_assets", clonedMenu.id);
              console.log(`Data asset ${dataAssetKeyToDelete} and its dependents deleted.`);
            } else if (result2.isDenied) {
              console.log("User chose to DELETE ITEM ONLY.");
              removeReferences(graph.model.threagile, dataAssetIdToDeleteID);
              performSingleDeletion(dataAssetKeyToDelete, "data_assets", clonedMenu.id);
              console.log(`Data asset ${dataAssetKeyToDelete} deleted. Dependents were NOT deleted.`);
            } else {
              console.log("User cancelled deletion.");
            }
          });
        } else {
          console.log(`No dependencies found for ${dataAssetKeyToDelete}. Deleting directly.`);
          performSingleDeletion(dataAssetKeyToDelete, "data_assets", clonedMenu.id);
          removeReferences(graph.model.threagile, dataAssetIdToDeleteID);
          console.log(`Data asset ${dataAssetKeyToDelete} deleted.`);
        }
      });
      textContainer.appendChild(dataText);
      textContainer.appendChild(xButton2);
      let initialColor = interpolateColorForRisks(lowRiskColor, highRiskColor, 0, 25, riskScore);
      if (listItem2.dataset.visible === "true") {
        listItem2.style.backgroundColor = "";
        arrowIcon.style.transform = "rotate(270deg)";
        xButton2.style.display = "inline-block";
        clonedMenu.style.display = "block";
      } else {
        listItem2.style.backgroundColor = initialColor;
        listItem2.dataset.initialColor = initialColor;
        arrowIcon.style.transform = "rotate(90deg)";
        xButton2.style.display = "none";
        clonedMenu.style.display = "none";
      }
      listItem2.appendChild(textContainer);
      listItem2.appendChild(clonedMenu);
      function toggleContent() {
        let isVisible = listItem2.dataset.visible === "true";
        listItem2.dataset.visible = !isVisible;
        if (!isVisible) {
          listItem2.style.backgroundColor = "";
          arrowIcon.style.transform = "rotate(270deg)";
          xButton2.style.display = "inline-block";
          clonedMenu.style.display = "block";
        } else {
          listItem2.style.backgroundColor = initialColor;
          listItem2.dataset.initialColor = initialColor;
          arrowIcon.style.transform = "rotate(90deg)";
          xButton2.style.display = "none";
          clonedMenu.style.display = "none";
        }
      }
      arrowIcon.addEventListener("click", toggleContent);
      dataText.addEventListener("click", toggleContent);
      list.appendChild(listItem2);
    });
  }
  var generalHeader = document.createElement("div");
  generalHeader.innerHTML = "Data:";
  generalHeader.style.padding = "10px 0px 6px 0px";
  generalHeader.style.whiteSpace = "nowrap";
  generalHeader.style.overflow = "hidden";
  generalHeader.style.width = "200px";
  generalHeader.style.fontWeight = "bold";
  this.container.appendChild(generalHeader);
  var addButton = button("Add Data Asset", bind(this, function(evt) {
    this.editorUi.actions.get("addDataAssets").funct(list, this.addDataMenu(this.createPanel()));
  }));
  addButton.innerHTML = `
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-database-fill" viewBox="0 0 16 16">
  <path d="M3 2a7 7 0 0 0 10 0v1c0 .542-.229 1.04-.61 1.465C11.105 5.352 9.342 6 8 6c-1.342 0-3.105-.648-4.39-1.535A2.877 2.877 0 0 1 3 3V2zm0 3c0 .542.229 1.04.61 1.465C4.895 7.352 6.658 8 8 8c1.342 0 3.105-.648 4.39-1.535A2.877 2.877 0 0 0 13 5V4c-1.285.887-3.048 1.535-4.39 1.535C7.658 5.535 5.895 4.887 4.61 4A2.877 2.877 0 0 1 3 4v1zm0 2c0 .542.229 1.04.61 1.465C4.895 9.352 6.658 10 8 10c1.342 0 3.105-.648 4.39-1.535A2.877 2.877 0 0 0 13 8V7c-1.285.887-3.048 1.535-4.39 1.535C7.658 8.535 5.895 7.887 4.61 7A2.877 2.877 0 0 1 3 7v1zm0 2c0 .542.229 1.04.61 1.465C4.895 11.352 6.658 12 8 12c1.342 0 3.105-.648 4.39-1.535A2.877 2.877 0 0 0 13 10V9c-1.285.887-3.048 1.535-4.39 1.535C7.658 10.535 5.895 9.887 4.61 9A2.877 2.877 0 0 1 3 9v1zm0 2c0 .542.229 1.04.61 1.465C4.895 13.352 6.658 14 8 14c1.342 0 3.105-.648 4.39-1.535A2.877 2.877 0 0 0 13 12v1a7 7 0 0 1-10 0v-1z"/>
</svg> Add Data Asset`;
  addButton.style.cssText = `
    margin: 0 auto;
    display: block;
    margin-top: 8px;
    padding: 8px 12px;
    background-color: #4CAF50; // More vibrant color
    color: #fff;
    border: none;
    border-radius: 5px; // Rounded corners
    cursor: pointer;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); // Subtle shadow
    transition: background-color 0.3s; // Smooth transition for hover effect
`;
  addButton.setAttribute("aria-label", "Add data assets");
  addButton.onmouseover = function() {
    this.style.backgroundColor = "#45a049";
  };
  addButton.onmouseout = function() {
    this.style.backgroundColor = "#4CAF50";
  };
  listContainer.appendChild(list);
  listContainer.appendChild(addButton);
  this.container.appendChild(listContainer);
  var styleHeader = document.createElement("div");
  styleHeader.innerHTML = "Style:";
  styleHeader.style.padding = "10px 0px 6px 0px";
  styleHeader.style.whiteSpace = "nowrap";
  styleHeader.style.overflow = "hidden";
  styleHeader.style.width = "200px";
  styleHeader.style.fontWeight = "bold";
  this.container.appendChild(styleHeader);
  if (graph.isEnabled()) {
    this.container.appendChild(this.addOptions(this.createPanel()));
    this.container.appendChild(this.addPaperSize(this.createPanel()));
    this.container.appendChild(this.addStyleOps(this.createPanel()));
  }
  let self = this;
  this.graph = graph;
};
DiagramFormatPanel.prototype.addView = function(div) {
  var ui = this.editorUi;
  var editor = ui.editor;
  var graph = editor.graph;
  div.appendChild(this.createTitle(mxResources2.get("view")));
  this.addGridOption(div);
  if (DiagramFormatPanel.showPageView) {
    div.appendChild(this.createOption(mxResources2.get("pageView"), function() {
      return graph.pageVisible;
    }, function(checked) {
      ui.actions.get("pageView").funct();
    }, {
      install: function(apply) {
        this.listener = function() {
          apply(graph.pageVisible);
        };
        ui.addListener("pageViewChanged", this.listener);
      },
      destroy: function() {
        ui.removeListener(this.listener);
      }
    }));
  }
  if (graph.isEnabled()) {
    var bg = this.createColorOption(mxResources2.get("background"), function() {
      return graph.background;
    }, function(color) {
      var change = new ChangePageSetup(ui, color);
      change.ignoreImage = true;
      graph.model.execute(change);
    }, "#ffffff", {
      install: function(apply) {
        this.listener = function() {
          apply(graph.background);
        };
        ui.addListener("backgroundColorChanged", this.listener);
      },
      destroy: function() {
        ui.removeListener(this.listener);
      }
    });
    if (this.showBackgroundImageOption) {
      var btn = button(mxResources2.get("image"), function(evt) {
        ui.showBackgroundImageDialog(null, ui.editor.graph.backgroundImage);
        mxEvent2.consume(evt);
      });
      btn.style.position = "absolute";
      btn.className = "geColorBtn";
      btn.style.marginTop = "-4px";
      btn.style.paddingBottom = document.documentMode == 11 || mxClient.IS_MT ? "0px" : "2px";
      btn.style.height = "22px";
      btn.style.right = mxClient.IS_QUIRKS ? "52px" : "72px";
      btn.style.width = "56px";
      bg.appendChild(btn);
    }
    div.appendChild(bg);
  }
  return div;
};
DiagramFormatPanel.prototype.addOptions = function(div) {
  var ui = this.editorUi;
  var editor = ui.editor;
  var graph = editor.graph;
  div.appendChild(this.createTitle(mxResources2.get("options")));
  if (graph.isEnabled()) {
    div.appendChild(this.createOption(mxResources2.get("connectionArrows"), function() {
      return graph.connectionArrowsEnabled;
    }, function(checked) {
      ui.actions.get("connectionArrows").funct();
    }, {
      install: function(apply) {
        this.listener = function() {
          apply(graph.connectionArrowsEnabled);
        };
        ui.addListener("connectionArrowsChanged", this.listener);
      },
      destroy: function() {
        ui.removeListener(this.listener);
      }
    }));
    div.appendChild(this.createOption(mxResources2.get("connectionPoints"), function() {
      return graph.connectionHandler.isEnabled();
    }, function(checked) {
      ui.actions.get("connectionPoints").funct();
    }, {
      install: function(apply) {
        this.listener = function() {
          apply(graph.connectionHandler.isEnabled());
        };
        ui.addListener("connectionPointsChanged", this.listener);
      },
      destroy: function() {
        ui.removeListener(this.listener);
      }
    }));
    div.appendChild(this.createOption(mxResources2.get("guides"), function() {
      return graph.graphHandler.guidesEnabled;
    }, function(checked) {
      ui.actions.get("guides").funct();
    }, {
      install: function(apply) {
        this.listener = function() {
          apply(graph.graphHandler.guidesEnabled);
        };
        ui.addListener("guidesEnabledChanged", this.listener);
      },
      destroy: function() {
        ui.removeListener(this.listener);
      }
    }));
  }
  let optionFlow = this.createOption("FlowPipe Animation", function() {
    return graph.floweffect;
  }, function(checked) {
    graph.floweffect = !graph.floweffect;
    if (graph.floweffect) {
      cells = graph.getVerticesAndEdges(false, true);
      cells.forEach((cell2) => {
        if (cell2.isEdge() && cell2.source != null && cell2.target != null) {
          let state2 = graph.view.getState(cell2);
          if (state2) {
            setTimeout(() => {
              let pathNodes = state2.shape.node.getElementsByTagName("path");
              if (pathNodes.length >= 2) {
                pathNodes[0].removeAttribute("visibility");
                pathNodes[0].setAttribute("stroke-width", "6");
                pathNodes[0].setAttribute("stroke", "lightGray");
                pathNodes[1].setAttribute("class", "pipeFlowAnimation");
              }
            }, 0);
          }
        }
      });
    } else {
      var cells = graph.getVerticesAndEdges(false, true);
      cells.forEach((cell2) => {
        if (cell2.isEdge() && cell2.source != null && cell2.target != null) {
          let state2 = graph.view.getState(cell2);
          if (state2) {
            let pathNodes = state2.shape.node.getElementsByTagName("path");
            if (pathNodes.length >= 2) {
              pathNodes[0].setAttribute("visibility", "hidden");
              pathNodes[0].removeAttribute("stroke-width");
              pathNodes[0].removeAttribute("stroke");
              pathNodes[1].removeAttribute("class");
            }
          }
        }
      });
    }
  }, {
    install: function(apply) {
    },
    destroy: function() {
    }
  });
  div.appendChild(optionFlow);
  return div;
};
DiagramFormatPanel.prototype.addGridOption = function(container) {
  var fPanel = this;
  var ui = this.editorUi;
  var graph = ui.editor.graph;
  var input = document.createElement("input");
  input.style.position = "absolute";
  input.style.textAlign = "right";
  input.style.width = "38px";
  input.value = this.inUnit(graph.getGridSize()) + " " + this.getUnit();
  var stepper = this.createStepper(input, update, this.getUnitStep(), null, null, null, this.isFloatUnit());
  input.style.display = graph.isGridEnabled() ? "" : "none";
  stepper.style.display = input.style.display;
  mxEvent2.addListener(input, "keydown", function(e) {
    if (e.keyCode == 13) {
      graph.container.focus();
      mxEvent2.consume(e);
    } else if (e.keyCode == 27) {
      input.value = graph.getGridSize();
      graph.container.focus();
      mxEvent2.consume(e);
    }
  });
  function update(evt) {
    var value = fPanel.isFloatUnit() ? parseFloat(input.value) : parseInt(input.value);
    value = fPanel.fromUnit(Math.max(fPanel.inUnit(1), isNaN(value) ? fPanel.inUnit(10) : value));
    if (value != graph.getGridSize()) {
      graph.setGridSize(value);
    }
    input.value = fPanel.inUnit(value) + " " + fPanel.getUnit();
    mxEvent2.consume(evt);
  }
  mxEvent2.addListener(input, "blur", update);
  mxEvent2.addListener(input, "change", update);
  var unitChangeListener = function(sender, evt) {
    input.value = fPanel.inUnit(graph.getGridSize()) + " " + fPanel.getUnit();
    fPanel.format.refresh();
  };
  graph.view.addListener("unitChanged", unitChangeListener);
  this.listeners.push({
    destroy: function() {
      graph.view.removeListener(unitChangeListener);
    }
  });
  if (mxClient.IS_SVG) {
    input.style.marginTop = "-2px";
    input.style.right = "84px";
    stepper.style.marginTop = "-16px";
    stepper.style.right = "72px";
    var panel = this.createColorOption(mxResources2.get("grid"), function() {
      var color = graph.view.gridColor;
      return graph.isGridEnabled() ? color : null;
    }, function(color) {
      var enabled = graph.isGridEnabled();
      if (color == mxConstants.NONE) {
        graph.setGridEnabled(false);
      } else {
        graph.setGridEnabled(true);
        ui.setGridColor(color);
      }
      input.style.display = graph.isGridEnabled() ? "" : "none";
      stepper.style.display = input.style.display;
      if (enabled != graph.isGridEnabled()) {
        ui.fireEvent(new mxEventObject("gridEnabledChanged"));
      }
    }, "#e0e0e0", {
      install: function(apply) {
        this.listener = function() {
          apply(graph.isGridEnabled() ? graph.view.gridColor : null);
        };
        ui.addListener("gridColorChanged", this.listener);
        ui.addListener("gridEnabledChanged", this.listener);
      },
      destroy: function() {
        ui.removeListener(this.listener);
      }
    });
    panel.appendChild(input);
    panel.appendChild(stepper);
    container.appendChild(panel);
  } else {
    input.style.marginTop = "2px";
    input.style.right = "32px";
    stepper.style.marginTop = "2px";
    stepper.style.right = "20px";
    container.appendChild(input);
    container.appendChild(stepper);
    container.appendChild(this.createOption(mxResources2.get("grid"), function() {
      return graph.isGridEnabled();
    }, function(checked) {
      graph.setGridEnabled(checked);
      if (graph.isGridEnabled()) {
        graph.view.gridColor = "#e0e0e0";
      }
      ui.fireEvent(new mxEventObject("gridEnabledChanged"));
    }, {
      install: function(apply) {
        this.listener = function() {
          input.style.display = graph.isGridEnabled() ? "" : "none";
          stepper.style.display = input.style.display;
          apply(graph.isGridEnabled());
        };
        ui.addListener("gridEnabledChanged", this.listener);
      },
      destroy: function() {
        ui.removeListener(this.listener);
      }
    }));
  }
};
DiagramFormatPanel.prototype.addDocumentProperties = function(div) {
  var ui = this.editorUi;
  var editor = ui.editor;
  var graph = editor.graph;
  div.appendChild(this.createTitle(mxResources2.get("options")));
  return div;
};
DiagramFormatPanel.prototype.addPaperSize = function(div) {
  var ui = this.editorUi;
  var editor = ui.editor;
  var graph = editor.graph;
  div.appendChild(this.createTitle(mxResources2.get("paperSize")));
  var accessor = PageSetupDialog.addPageFormatPanel(div, "formatpanel", graph.pageFormat, function(pageFormat) {
    if (graph.pageFormat == null || graph.pageFormat.width != pageFormat.width || graph.pageFormat.height != pageFormat.height) {
      var change = new ChangePageSetup(ui, null, null, pageFormat);
      change.ignoreColor = true;
      change.ignoreImage = true;
      graph.model.execute(change);
    }
  });
  this.addKeyHandler(accessor.widthInput, function() {
    accessor.set(graph.pageFormat);
  });
  this.addKeyHandler(accessor.heightInput, function() {
    accessor.set(graph.pageFormat);
  });
  var listener = function() {
    accessor.set(graph.pageFormat);
  };
  ui.addListener("pageFormatChanged", listener);
  this.listeners.push({
    destroy: function() {
      ui.removeListener(listener);
    }
  });
  graph.getModel().addListener(mxEvent2.CHANGE, listener);
  this.listeners.push({
    destroy: function() {
      graph.getModel().removeListener(listener);
    }
  });
  return div;
};
DiagramFormatPanel.prototype.addStyleOps = function(div) {
  var btn = button(mxResources2.get("editData"), bind(this, function(evt) {
    this.editorUi.actions.get("editData").funct();
  }));
  btn.setAttribute("title", mxResources2.get("editData") + " (" + this.editorUi.actions.get("editData").shortcut + ")");
  btn.style.width = "202px";
  btn.style.marginBottom = "2px";
  div.appendChild(btn);
  br(div);
  btn = button(mxResources2.get("clearDefaultStyle"), bind(this, function(evt) {
    this.editorUi.actions.get("clearDefaultStyle").funct();
  }));
  btn.setAttribute("title", mxResources2.get("clearDefaultStyle") + " (" + this.editorUi.actions.get("clearDefaultStyle").shortcut + ")");
  btn.style.width = "202px";
  div.appendChild(btn);
  return div;
};
DiagramFormatPanel.prototype.destroy = function() {
  BaseFormatPanel.prototype.destroy.apply(this, arguments);
  if (this.gridEnabledListener) {
    this.editorUi.removeListener(this.gridEnabledListener);
    this.gridEnabledListener = null;
  }
};

// js/AssetFormatPanel.js
var AssetFormatPanel = function(format, editorUi, container) {
  BaseFormatPanel.call(this, format, editorUi, container);
  this.init();
};
extend(AssetFormatPanel, BaseFormatPanel);
AssetFormatPanel.prototype.defaultStrokeColor = "black";
AssetFormatPanel.prototype.init = function() {
  var ui = this.editorUi;
  var editor = ui.editor;
  var graph = editor.graph;
  var ss = this.format.getSelectionState();
  this.container.appendChild(this.addThreagileMenu(this.createPanel()));
};
AssetFormatPanel.isTechnicalAssetOutOfScope = function(assetCell, threagileModel) {
  if (assetCell && assetCell.isVertex() && assetCell.technicalAsset && assetCell.technicalAsset.key) {
    const assetKey = assetCell.technicalAsset.key;
    const oosDataValue = threagileModel.getIn(["technical_assets", assetKey, "out_of_scope"]);
    return oosDataValue === "true";
  }
  return false;
};
AssetFormatPanel.updateCellScopeStyle = function(changedAssetCell, isChangedAssetNowOutOfScope, graphInstance, threagileModel) {
  const model = graphInstance.getModel();
  model.beginUpdate();
  try {
    const assetOriginalStylesKey = "originalStylesBeforeOutOfScope";
    if (isChangedAssetNowOutOfScope) {
      if (!changedAssetCell[assetOriginalStylesKey]) {
        const currentStyle = graphInstance.getCellStyle(changedAssetCell);
        changedAssetCell[assetOriginalStylesKey] = {
          opacity: currentStyle[mxConstants.STYLE_OPACITY],
          strokeColor: currentStyle[mxConstants.STYLE_STROKECOLOR],
          fillColor: currentStyle[mxConstants.STYLE_FILLCOLOR],
          fontColor: currentStyle[mxConstants.STYLE_FONTCOLOR]
        };
      }
      graphInstance.setCellStyles(mxConstants.STYLE_OPACITY, 50, [changedAssetCell]);
      graphInstance.setCellStyles(mxConstants.STYLE_STROKECOLOR, "#aaaaaa", [changedAssetCell]);
      graphInstance.setCellStyles(mxConstants.STYLE_FILLCOLOR, "#cccccc", [changedAssetCell]);
      graphInstance.setCellStyles(mxConstants.STYLE_FONTCOLOR, "#999999", [changedAssetCell]);
    } else {
      if (changedAssetCell[assetOriginalStylesKey]) {
        graphInstance.setCellStyles(mxConstants.STYLE_OPACITY, changedAssetCell[assetOriginalStylesKey].opacity, [changedAssetCell]);
        graphInstance.setCellStyles(mxConstants.STYLE_STROKECOLOR, changedAssetCell[assetOriginalStylesKey].strokeColor, [changedAssetCell]);
        graphInstance.setCellStyles(mxConstants.STYLE_FILLCOLOR, changedAssetCell[assetOriginalStylesKey].fillColor, [changedAssetCell]);
        graphInstance.setCellStyles(mxConstants.STYLE_FONTCOLOR, changedAssetCell[assetOriginalStylesKey].fontColor, [changedAssetCell]);
        delete changedAssetCell[assetOriginalStylesKey];
      } else {
        graphInstance.setCellStyles(mxConstants.STYLE_OPACITY, null, [changedAssetCell]);
        graphInstance.setCellStyles(mxConstants.STYLE_STROKECOLOR, null, [changedAssetCell]);
        graphInstance.setCellStyles(mxConstants.STYLE_FILLCOLOR, null, [changedAssetCell]);
        graphInstance.setCellStyles(mxConstants.STYLE_FONTCOLOR, null, [changedAssetCell]);
      }
    }
    graphInstance.refresh(changedAssetCell);
    const edges = graphInstance.getEdges(changedAssetCell, null, true, true, true);
    const edgeOriginalStylesKey = "originalEdgeStylesBeforeOutOfScope";
    for (const edge of edges) {
      const sourceAsset2 = model.getTerminal(edge, true);
      const targetAsset = model.getTerminal(edge, false);
      let sourceIsOOS = sourceAsset2 === changedAssetCell ? isChangedAssetNowOutOfScope : AssetFormatPanel.isTechnicalAssetOutOfScope(sourceAsset2, threagileModel);
      let targetIsOOS = targetAsset === changedAssetCell ? isChangedAssetNowOutOfScope : AssetFormatPanel.isTechnicalAssetOutOfScope(targetAsset, threagileModel);
      const edgeShouldBeGray = sourceIsOOS || targetIsOOS;
      if (edgeShouldBeGray) {
        if (!edge[edgeOriginalStylesKey]) {
          const currentEdgeStyle = graphInstance.getCellStyle(edge);
          edge[edgeOriginalStylesKey] = {
            strokeColor: currentEdgeStyle[mxConstants.STYLE_STROKECOLOR],
            fontColor: currentEdgeStyle[mxConstants.STYLE_FONTCOLOR],
            opacity: currentEdgeStyle[mxConstants.STYLE_OPACITY]
          };
        }
        graphInstance.setCellStyles(mxConstants.STYLE_STROKECOLOR, "#bbbbbb", [edge]);
        graphInstance.setCellStyles(mxConstants.STYLE_FONTCOLOR, "#aaaaaa", [edge]);
        graphInstance.setCellStyles(mxConstants.STYLE_OPACITY, 60, [edge]);
      } else {
        if (edge[edgeOriginalStylesKey]) {
          graphInstance.setCellStyles(mxConstants.STYLE_STROKECOLOR, edge[edgeOriginalStylesKey].strokeColor, [edge]);
          graphInstance.setCellStyles(mxConstants.STYLE_FONTCOLOR, edge[edgeOriginalStylesKey].fontColor, [edge]);
          graphInstance.setCellStyles(mxConstants.STYLE_OPACITY, edge[edgeOriginalStylesKey].opacity, [edge]);
          delete edge[edgeOriginalStylesKey];
        } else {
          graphInstance.setCellStyles(mxConstants.STYLE_STROKECOLOR, null, [edge]);
          graphInstance.setCellStyles(mxConstants.STYLE_FONTCOLOR, null, [edge]);
          graphInstance.setCellStyles(mxConstants.STYLE_OPACITY, null, [edge]);
        }
      }
      graphInstance.refresh(edge);
    }
  } finally {
    model.endUpdate();
  }
};
AssetFormatPanel.prototype.addThreagileMenu = function(container) {
  let self = this;
  let main = document.createElement("div");
  main.id = "threagile-asset-main-container";
  var typeProperties = {
    key: {
      description: "key",
      type: "button",
      section: "General",
      tooltip: " ",
      defaultValue: "<Your Title>"
    },
    id: {
      description: "Id",
      type: "button",
      section: "General",
      tooltip: "All id attribute values must be unique ",
      defaultValue: "<Your ID>"
    },
    description: {
      description: "Description",
      type: "button",
      section: "General",
      tooltip: "Provide a brief description of the technology asset. ",
      defaultValue: "Tech Asset"
    },
    type: {
      description: "Type",
      defaultValue: 0,
      type: "select",
      options: [
        {
          group: "Category 1",
          options: ["external-entity", "process", "datastore"],
          defaultValue: "external-entity"
        }
      ],
      section: "Properties",
      tooltip: "Select the 'Type' for your threat model component. 'external-entity' represents an outside actor or system, 'process' indicates an operational component, and 'datastore' refers to data storage within the system."
    },
    technology: {
      description: "Technologies",
      defaultValue: 0,
      type: "select",
      defaultValue: "unknown-technology",
      options: [
        {
          group: "Unknown Technology",
          options: ["unknown-technology"]
        },
        {
          group: "Client System",
          options: ["client-system", "desktop", "mobile-app", "devops-client"]
        },
        {
          group: "Web-related",
          options: [
            "browser",
            "web-server",
            "web-application",
            "reverse-proxy",
            "load-balancer"
          ]
        },
        {
          group: "Development-related",
          options: [
            "code-inspection-platform",
            "build-pipeline",
            "artifact-registry",
            "sourcecode-repository"
          ]
        },
        {
          group: "Infrastructure-related",
          options: [
            "file-server",
            "local-file-system",
            "database",
            "ldap-server",
            "container-platform",
            "mainframe",
            "block-storage"
          ]
        },
        {
          group: "Web Services",
          options: ["web-service-rest", "web-service-soap"]
        },
        {
          group: "Content Management",
          options: ["cms"]
        },
        {
          group: "Enterprise related",
          options: ["erp"]
        },
        {
          group: "Security-related",
          options: [
            "identity-provider",
            "identity-store-ldap",
            "identity-store-database",
            "vault",
            "hsm",
            "waf",
            "ids",
            "ips"
          ]
        },
        {
          group: "Tools and Utilities",
          options: ["tool", "cli"]
        },
        {
          group: "Message and Processing",
          options: [
            "message-queue",
            "stream-processing",
            "batch-processing",
            "event-listener"
          ]
        },
        {
          group: "Networking:",
          options: ["gateway", "service-mesh"]
        },
        {
          group: "Date-related",
          options: ["data-lake"]
        },
        {
          group: "Reporting and Analytics",
          options: ["report-engine", "ai"]
        },
        {
          group: "Monitoring",
          options: ["monitoring"]
        },
        {
          group: "Search-related",
          options: ["search-index", "search-engine"]
        },
        {
          group: "Other",
          options: [
            "application-server",
            "ejb",
            "service-registry",
            "task",
            "function",
            "iot-device",
            "data-lake",
            "mail-server",
            "scheduler",
            "library"
          ]
        }
      ],
      section: "Properties",
      tooltip: "The 'Technologies' field allows you to classify your components based on the underlying technologies "
    },
    size: {
      description: "Size",
      type: "select",
      defaultValue: "system",
      options: [
        {
          group: "Category 1",
          options: ["system", "service", "application", "component"]
        }
      ],
      section: "Properties",
      tooltip: "The 'Size' option classifies the component based on its scope in your system hierarchy - 'system' for a whole system, 'service' for an individual service, 'application' for a specific application, and 'component' for smaller, constituent parts."
    },
    machine: {
      description: "Machine",
      type: "select",
      defaultValue: 0,
      options: [
        {
          group: "Category 1",
          options: ["physical", "virtual", "container", "serverless"]
        }
      ],
      section: "Properties",
      tooltip: "The 'Machine' option indicates the infrastructure type of your component - 'physical' for traditional hardware, 'virtual' for virtualized environments, 'container' for containerized applications, and 'serverless' for serverless architectures."
    },
    encryption: {
      description: "Encryption",
      type: "select",
      defaultValue: 0,
      options: [
        {
          group: "Category 1",
          options: [
            "none",
            "data-with-symmetric-shared-key",
            "data-with-asymmetric-shared-key",
            "data-with-enduser-individual-key"
          ]
        }
      ],
      section: "Properties",
      tooltip: "The 'Encryption' option specifies the type of encryption used for your data - 'none' for no encryption, 'data-with-symmetric-shared-key' for symmetric encryption, 'data-with-asymmetric-shared-key' for asymmetric encryption, and 'data-with-enduser-individual-key' for encryption with unique keys per end user."
    },
    owner: {
      description: "Owner",
      type: "button",
      section: "Properties",
      defaultValue: "<Captain Awesome>",
      tooltip: "The 'Owner' field designates the individual or the entity that has administrative authority or control over the component."
    },
    internet: {
      defaultValue: "false",
      description: "Internet",
      type: "checkbox",
      section: "Properties",
      tooltip: "The 'Internet' field indicates whether the component is connected to the internet or not."
    },
    confidentiality: {
      section: "CIA",
      description: "Confidentility",
      type: "select",
      options: [
        {
          group: "Category 1",
          options: [
            "public",
            "internal",
            "restricted",
            "confidential",
            "strictly-confidential"
          ]
        }
      ],
      defaultValue: 0,
      tooltip: "Confidentiality: refers to the practice of keeping sensitive information private and secure from unauthorized access. This ensures that only authorized individuals can view the sensitive data."
    },
    integrity: {
      section: "CIA",
      description: "Integritity",
      type: "select",
      options: [
        {
          group: "Category 1",
          options: [
            "archive",
            "operational",
            "important",
            "critical",
            "mission-critical"
          ]
        }
      ],
      defaultValue: 0,
      tooltip: "Integrity: refers to the assurance that the information is trustworthy and accurate. It ensures that the data has not been improperly modified, whether intentionally or accidentally, and remains consistent and accurate in its intended lifecycle."
    },
    availability: {
      section: "CIA",
      description: "Availiablity",
      type: "select",
      options: [
        {
          group: "Category 1",
          options: [
            "archive",
            "operational",
            "important",
            "critical",
            "mission-critical"
          ]
        }
      ],
      defaultValue: 0,
      tooltip: "Availability: refers to the guarantee that information and resources are accessible to authorized individuals when needed. This ensures that systems, applications, and data are always up and running, reducing downtime and providing reliable access to necessary information."
    },
    usage: {
      section: "Utilization",
      description: "Usage",
      type: "select",
      options: [
        {
          group: "Category 1",
          options: ["business", "devops"]
        }
      ],
      defaultValue: 0,
      tooltip: "Select the main usage category of this resource."
    },
    used_as_client_by_human: {
      defaultValue: "false",
      description: "Used as client by human",
      type: "checkbox",
      section: "Utilization",
      tooltip: "Check this if the resource is directly used by a human client."
    },
    multi_tenant: {
      defaultValue: "false",
      description: "Multi tenant",
      type: "checkbox",
      section: "Utilization",
      tooltip: "Check this if the resource is designed to serve multiple users in a multi-tenant environment."
    },
    redundant: {
      defaultValue: "false",
      description: "redundant",
      type: "checkbox",
      section: "Utilization",
      tooltip: "Check this if the resource has redundancy features to prevent failure or data loss."
    },
    custom_developed_parts: {
      defaultValue: "false",
      description: "Custom Developed parts",
      type: "checkbox",
      section: "Utilization",
      tooltip: "Check this if the resource includes parts that were custom developed."
    },
    out_of_scope: {
      defaultValue: "false",
      description: "Out of Scope",
      type: "checkbox",
      section: "Utilization",
      tooltip: "Check this if the resource is out of the scope of your threat model analysis."
    },
    justification_out_of_scope: {
      description: "Justification out of Scope",
      type: "button",
      section: "Utilization",
      defaultValue: "The 'XYZ' component is considered out of scope for the current threat model analysis due to its limited interaction with critical system functions. Additionally, it has recently undergone a comprehensive security audit and vulnerabilities identified have been addressed, reducing its overall risk level.",
      tooltip: "Provide justification if the resource is marked as out of scope."
    },
    tags: {
      description: "Tags",
      type: "array",
      section: "Properties",
      tooltip: "Add tags to categorize this technical asset. New tags will be added to the global list.",
      defaultValue: []
    }
  };
  let customListener2 = {
    install: function(apply) {
      this.listener = function() {
      };
    },
    destroy: function() {
    }
  };
  let sections = {};
  for (let property2 in typeProperties) {
    let sectionName = typeProperties[property2].section;
    if (!sections[sectionName]) {
      sections[sectionName] = createSection(sectionName);
      let sectionIdName = sectionName.toLowerCase().replace(/\s+/g, "-").replace(/[^a-z0-9-]/g, "");
      sections[sectionName].id = `threagile-asset-section-${sectionIdName}`;
    }
    let typeItem = document.createElement("li");
    typeItem.style.display = "flex";
    typeItem.style.alignItems = "baseline";
    typeItem.style.marginBottom = "8px";
    typeItem.id = `threagile-asset-item-${property2}`;
    let propertyName = document.createElement("span");
    propertyName.innerHTML = property2;
    propertyName.style.width = "100px";
    propertyName.style.marginRight = "10px";
    propertyName.id = `threagile-asset-item-span-${property2}`;
    let propertyType = typeProperties[property2].type;
    if (propertyType === "select") {
      const propertySelect = property2;
      typeItem.appendChild(propertyName);
      let selectContainer = document.createElement("div");
      selectContainer.style.display = "flex";
      selectContainer.style.alignItems = "center";
      selectContainer.style.marginLeft = "auto";
      let selectDropdown = document.createElement("select");
      selectDropdown.id = `threagile-asset-select-${property2}`;
      selectDropdown.style.width = "100px";
      selectDropdown.title = typeProperties[property2].tooltip;
      selectContainer.appendChild(selectDropdown);
      let optionGroups = typeProperties[property2].options;
      for (var i = 0; i < optionGroups.length; i++) {
        let optgroup = document.createElement("optgroup");
        optgroup.label = optionGroups[i].group;
        let options = optionGroups[i].options;
        for (let j = 0; j < options.length; j++) {
          let option = document.createElement("option");
          option.value = options[j];
          option.text = options[j];
          optgroup.appendChild(option);
        }
        selectDropdown.appendChild(optgroup);
      }
      if (self.editorUi.editor.graph.getSelectionCell().technicalAsset !== void 0) {
        let assetId2 = self.editorUi.editor.graph.getSelectionCell().technicalAsset.key;
        let assetInAst = self.editorUi.editor.graph.model.threagile.getIn(["technical_assets", assetId2]);
        if (assetInAst && self.editorUi.editor.graph.model.threagile.getIn(["technical_assets", assetId2, propertySelect])) {
          selectDropdown.value = self.editorUi.editor.graph.model.threagile.getIn(["technical_assets", assetId2, propertySelect]);
        }
      }
      let createChangeListener = function(selectDropdown2, propertySelect2) {
        return function(evt) {
          var vals = selectDropdown2.value;
          if (vals != null) {
            var assetId2 = self.editorUi.editor.graph.getSelectionCell().technicalAsset;
            if (assetId2) {
              let assetPath = ["technical_assets", assetId2.key, propertySelect2];
              self.editorUi.editor.graph.model.threagile.setIn(assetPath, selectDropdown2.value);
            }
          }
          mxEvent2.consume(evt);
        };
      };
      mxEvent2.addListener(selectDropdown, "change", createChangeListener(selectDropdown, propertySelect));
      typeItem.appendChild(selectContainer);
      sections[sectionName].appendChild(typeItem);
    } else if (propertyType === "checkbox") {
      const currentPropertyKey = property2;
      let optionElement = this.createOption(typeProperties[property2].description, createCustomOption2(self, property2), function(newValue) {
        setCustomOption2(self, currentPropertyKey)(newValue);
        if (currentPropertyKey === "out_of_scope") {
          const selectedCell = self.editorUi.editor.graph.getSelectionCell();
          if (selectedCell && selectedCell.technicalAsset) {
            AssetFormatPanel.updateCellScopeStyle(selectedCell, newValue, self.editorUi.editor.graph, self.editorUi.editor.graph.model.threagile);
          }
        }
      }, customListener2);
      let checkboxInput = optionElement.querySelector('input[type="checkbox"]');
      if (checkboxInput) {
        checkboxInput.id = `threagile-asset-checkbox-${property2}`;
        checkboxInput.title = typeProperties[property2].tooltip;
        let labelSpan = optionElement.querySelector("span");
        if (labelSpan) {
          labelSpan.setAttribute("for", checkboxInput.id);
        }
      }
      sections[sectionName].appendChild(optionElement);
    } else if (propertyType === "button") {
      let button2 = button(property2, bind(this, function(evt) {
        let assetId2 = self.editorUi.editor.graph.getSelectionCell().technicalAsset;
        let assetInAst = self.editorUi.editor.graph.model.threagile.getIn(["technical_assets", assetId2.key]);
        let assetInAstValue = self.editorUi.editor.graph.model.threagile.getIn(["technical_assets", assetId2.key, property2]);
        let dataValue = assetInAst && assetInAstValue ? assetInAstValue : typeProperties[property2].defaultValue;
        if (property2 == "key") {
          dataValue = self.editorUi.editor.graph.getSelectionCell().technicalAsset.key;
        }
        var dlg = new TextareaDialog2(this.editorUi, property2 + ":", dataValue, function(newValue) {
          if (newValue != null) {
            if (assetId2) {
              var adjustedValue = newValue.replace(/</g, "&lt;").replace(/>/g, "&gt;");
              let model = self.editorUi.editor.graph.model;
              model.beginUpdate();
              let cell2 = self.editorUi.editor.graph.getSelectionCell();
              try {
                if (property2 === "id") {
                  var validIdSyntax = /^[a-zA-Z0-9\-]+$/;
                  if (!validIdSyntax.test(newValue)) {
                    alert("Invalid ID format. Only alphanumeric characters and dashes are allowed.");
                    return;
                  }
                } else if (property2 == "key") {
                  restartWasm();
                  let oldassetPath = ["technical_assets", assetId2.key];
                  let cell3 = self.editorUi.editor.graph.getSelectionCell();
                  let edges = self.editorUi.editor.graph.getEdges(cell3, null, false, true, true);
                  let object = JSON.parse(JSON.stringify(self.editorUi.editor.graph.model.threagile.getIn(oldassetPath)));
                  self.editorUi.editor.graph.model.threagile.deleteIn(oldassetPath);
                  cell3.technicalAsset.key = adjustedValue;
                  let newassetPath = ["technical_assets", assetId2.key];
                  self.editorUi.editor.graph.model.threagile.setIn(newassetPath, object);
                  cell3.value = adjustedValue;
                  let restoreIntegrity = self.editorUi.editor.graph.model.threagile.toString();
                  self.editorUi.editor.graph.model.threagile = YAML.parseDocument(restoreIntegrity);
                  edges.forEach(function(edge) {
                    let newassetPathCom = ["technical_assets", assetId2.key, "communication_links", edge.communicationAssetKey];
                    edge.communicationAsset = self.editorUi.editor.graph.model.threagile.getIn(newassetPathCom);
                  });
                } else {
                  let assetPath = ["technical_assets", assetId2.key, property2];
                  self.editorUi.editor.graph.model.threagile.setIn(assetPath, adjustedValue);
                }
                self.editorUi.editor.graph.refresh(cell2);
                self.editorUi.editor.graph.refresh();
              } finally {
                model.endUpdate();
              }
            }
          }
        }, null, null, 400, 220);
        this.editorUi.showDialog(dlg.container, 420, 300, true, true);
        dlg.init();
        try {
          if (dlg.textarea) {
            let textareaId = `threagile-dialog-${property2}-textarea`;
            dlg.textarea.id = textareaId;
            console.log(`Added ID to textarea: ${textareaId}`);
          } else {
            console.warn(`Could not find dlg.textarea for property '${property2}'.`);
          }
        } catch (e) {
          console.error("Error adding ID to dialog textarea:", e);
        }
        try {
          let buttonContainer = dlg.container.querySelector(".geDialogButtons");
          let buttons = buttonContainer ? buttonContainer.querySelectorAll("button") : dlg.container.querySelectorAll("button");
          if (buttons && buttons.length > 0) {
            const applyText = mxResources.get("apply") || "Apply";
            const cancelText = mxResources.get("cancel") || "Cancel";
            let applyFound = false;
            let cancelFound = false;
            buttons.forEach((btn) => {
              if (!applyFound && (btn.textContent.trim() === applyText || btn.textContent.trim() === (mxResources.get("ok") || "OK"))) {
                btn.id = `threagile-dialog-${property2}-apply-button`;
                applyFound = true;
              } else if (!cancelFound && btn.textContent.trim() === cancelText) {
                btn.id = `threagile-dialog-${property2}-cancel-button`;
                cancelFound = true;
              }
            });
          } else {
            console.warn("Could not find buttons in TextareaDialog container for property:", property2);
          }
        } catch (e) {
          console.error("Error adding IDs to dialog buttons:", e);
        }
        if (property2 == "id") {
          dlg.textarea.readOnly = true;
          dlg.textarea.style.backgroundColor = "#f3f3f3";
          dlg.textarea.style.color = "#686868";
          dlg.textarea.style.border = "1px solid #ccc";
        }
      }));
      button2.id = `threagile-asset-button-${property2}`;
      button2.title = typeProperties[property2].tooltip;
      button2.style.width = "200px";
      typeItem.appendChild(button2);
      sections[sectionName].appendChild(typeItem);
    } else if (property2 === "tags" && propertyType === "array") {
      let onAddAssetTag = function(e) {
        const model = self.editorUi.editor.graph.model.threagile;
        const newTagValue = e.detail.data.value;
        let tagsAvailableNode = model.getIn(["tags_available"]);
        let tagsAvailableSet = new Set(tagsAvailableNode && typeof tagsAvailableNode.toJSON === "function" ? tagsAvailableNode.toJSON() : Array.isArray(tagsAvailableNode) ? tagsAvailableNode : []);
        if (!tagsAvailableSet.has(newTagValue)) {
          tagsAvailableSet.add(newTagValue);
          model.setIn(["tags_available"], Array.from(tagsAvailableSet));
          restartWasm();
        }
        let assetTagsNode = model.getIn(["technical_assets", assetKey, "tags"]);
        let assetTagsSet = new Set(assetTagsNode && typeof assetTagsNode.toJSON === "function" ? assetTagsNode.toJSON() : Array.isArray(assetTagsNode) ? assetTagsNode : []);
        assetTagsSet.add(newTagValue);
        model.setIn(["technical_assets", assetKey, "tags"], Array.from(assetTagsSet));
      }, onRemoveAssetTag = function(e) {
        const model = self.editorUi.editor.graph.model.threagile;
        const removedTagValue = e.detail.data.value;
        let assetTagsNode = model.getIn(["technical_assets", assetKey, "tags"]);
        let assetTagsSet = new Set(assetTagsNode && typeof assetTagsNode.toJSON === "function" ? assetTagsNode.toJSON() : Array.isArray(assetTagsNode) ? assetTagsNode : []);
        if (assetTagsSet.delete(removedTagValue)) {
          model.setIn(["technical_assets", assetKey, "tags"], Array.from(assetTagsSet));
        }
      };
      typeItem.appendChild(propertyName);
      let tagInputElement = document.createElement("input");
      tagInputElement.placeholder = "Add tags...";
      typeItem.appendChild(tagInputElement);
      let currentSelectedCell = self.editorUi.editor.graph.getSelectionCell();
      let assetKey = currentSelectedCell.technicalAsset?.key;
      if (!assetKey) {
        console.warn("No technical asset selected, cannot initialize tags input for 'tags'.");
        let placeholder = document.createElement("span");
        placeholder.textContent = " (No asset selected)";
        placeholder.style.fontStyle = "italic";
        placeholder.style.color = "#888";
        tagInputElement.style.display = "none";
        typeItem.appendChild(placeholder);
        sections[sectionName].appendChild(typeItem);
        continue;
      }
      tagInputElement.id = `threagile-asset-tags-input-${assetKey}`;
      tagInputElement.style.flexGrow = "1";
      let currentAssetTagsNode = self.editorUi.editor.graph.model.threagile.getIn(["technical_assets", assetKey, "tags"]);
      let initialTagValues = [];
      if (currentAssetTagsNode) {
        initialTagValues = typeof currentAssetTagsNode.toJSON === "function" ? currentAssetTagsNode.toJSON() : Array.from(currentAssetTagsNode);
      }
      tagInputElement.value = initialTagValues.join(",");
      let availableTagsData = self.editorUi.editor.graph.model.threagile.getIn(["tags_available"]);
      let availableTagsWhitelist = [];
      if (availableTagsData) {
        availableTagsWhitelist = typeof availableTagsData.toJSON === "function" ? availableTagsData.toJSON() : Array.from(availableTagsData);
      }
      let assetTagify = new Tagify(tagInputElement, {
        whitelist: availableTagsWhitelist,
        enforceWhitelist: false,
        dropdown: {
          maxItems: 100,
          classname: "tags-look",
          enabled: 0,
          closeOnSelect: true
        }
      });
      assetTagify.on("add", onAddAssetTag).on("remove", onRemoveAssetTag);
      sections[sectionName].appendChild(typeItem);
    }
  }
  {
  }
  let selects = sections.CIA.querySelectorAll("select");
  selects.forEach(function(select) {
    switch (select.value) {
      case "public":
      case "archive":
        select.style.backgroundColor = "#CCFFCC";
        break;
      case "internal":
      case "operational":
        select.style.backgroundColor = "#99FF99";
        break;
      case "restricted":
      case "important":
        select.style.backgroundColor = "#FFCCCC";
        break;
      case "confidential":
      case "critical":
        select.style.backgroundColor = "#FF9999";
        break;
      case "strictly-confidential":
      case "mission-critical":
        select.style.backgroundColor = "#FF6666";
        break;
      default:
        select.style.backgroundColor = "";
    }
    select.addEventListener("change", function() {
      switch (this.value) {
        case "public":
        case "archive":
          this.style.backgroundColor = "#CCFFCC";
          break;
        case "internal":
        case "operational":
          this.style.backgroundColor = "#99FF99";
          break;
        case "restricted":
        case "important":
          this.style.backgroundColor = "#FFCCCC";
          break;
        case "confidential":
        case "critical":
          this.style.backgroundColor = "#FF9999";
          break;
        case "strictly-confidential":
        case "mission-critical":
          this.style.backgroundColor = "#FF6666";
          break;
        default:
          this.style.backgroundColor = "";
      }
    });
    let options = select.querySelectorAll("option");
    options.forEach(function(option) {
      switch (option.value) {
        case "public":
        case "archive":
          option.style.backgroundColor = "#CCFFCC";
          break;
        case "internal":
        case "operational":
          option.style.backgroundColor = "#99FF99";
          break;
        case "restricted":
        case "important":
          option.style.backgroundColor = "#FFCCCC";
          break;
        case "confidential":
        case "critical":
          option.style.backgroundColor = "#FF9999";
          break;
        case "strictly-confidential":
        case "mission-critical":
          option.style.backgroundColor = "#FF6666";
          break;
      }
    });
  });
  for (let sectionName in sections) {
    main.appendChild(sections[sectionName]);
  }
  {
    let cells = self.editorUi.editor.graph.getSelectionCells();
    let cell2 = cells && cells.length > 0 ? cells[0] : null;
    if (!cell2.getValue()) {
      let model = self.editorUi.editor.graph.model;
      model.beginUpdate();
      try {
        let newStyle = cell2.getStyle() + "verticalAlign=top";
        cell2.setStyle(newStyle);
        model.setValue(cell2, typeProperties["id"].defaultValue);
        self.editorUi.editor.graph.refresh(cell2);
        self.editorUi.editor.graph.refresh();
      } finally {
        model.endUpdate();
      }
    }
  }
  let idsData = [];
  let diagramData = self.editorUi.editor.graph.model.threagile.getIn(["data_assets"]);
  if (diagramData) {
    diagramData = self.editorUi.editor.graph.model.threagile.getIn(["data_assets"]).toJSON();
    Object.keys(diagramData).forEach(function(key) {
      idsData.push(key);
    });
  }
  let assetId = self.editorUi.editor.graph.getSelectionCell().technicalAsset;
  console.log(assetId);
  let inputElement = document.createElement("input");
  inputElement.placeholder = "Data Processed";
  let sentSection = createSection("Data Processed:");
  sentSection.appendChild(document.createElement("br"));
  if (assetId) {
    let arr = self.editorUi.editor.graph.model.threagile.getIn(["technical_assets", assetId.key, "data_assets_processed"]);
    if (arr) {
      if (typeof arr.toJSON === "function") {
        arr = arr.toJSON();
      }
      let matchingKeys = Object.keys(diagramData).filter((key) => arr.includes(diagramData[key].id)).map((key) => key);
      inputElement.value = matchingKeys;
    }
  }
  sentSection.appendChild(inputElement);
  let tagify = new Tagify(inputElement, {
    whitelist: idsData,
    editTags: false,
    enforceWhitelist: true,
    dropdown: {
      maxItems: 100,
      classname: "tags-look",
      enabled: 0,
      closeOnSelect: true
    }
  });
  tagify.on("add", onAddTagPro).on("remove", onRemoveTagPro);
  main.appendChild(sentSection);
  let inputElement2 = document.createElement("input");
  let receivedSecion = createSection("Data Stored:");
  receivedSecion.id = "threagile-asset-section-data-stored";
  receivedSecion.appendChild(document.createElement("br"));
  if (assetId) {
    let arr = self.editorUi.editor.graph.model.threagile.getIn(["technical_assets", assetId.key, "data_assets_stored"]);
    if (arr) {
      if (typeof arr.toJSON === "function") {
        arr = arr.toJSON();
      }
      let matchingKeys = Object.keys(diagramData).filter((key) => arr.includes(diagramData[key].id)).map((key) => key);
      inputElement2.value = matchingKeys;
    }
  }
  receivedSecion.appendChild(inputElement2);
  let tagify2 = new Tagify(inputElement2, {
    whitelist: idsData,
    enforceWhitelist: true,
    editTags: false,
    dropdown: {
      maxItems: 100,
      classname: "tags-look",
      enabled: 0,
      closeOnSelect: true
    }
  });
  tagify2.on("add", onAddTagStored).on("focus", onTagifyFocusBlur).on("remove", onRemoveTagStored);
  function onAddTagPro(e) {
    let proAssetID = self.editorUi.editor.graph.getSelectionCell().technicalAsset;
    ;
    const model = self.editorUi.editor.graph.model.threagile;
    let dataId = model.getIn(["data_assets", e.detail.data.value, "id"]);
    let dataAssetsProcessed = model.getIn(["technical_assets", proAssetID.key, "data_assets_processed"]) || [];
    if (typeof dataAssetsProcessed.toJSON === "function") {
      dataAssetsProcessed = dataAssetsProcessed.toJSON();
    }
    if (!Array.isArray(dataAssetsProcessed)) {
      dataAssetsProcessed = dataAssetsProcessed ? [dataAssetsProcessed] : [];
    }
    dataAssetsProcessed.push(dataId);
    model.setIn(["technical_assets", proAssetID.key, "data_assets_processed"], dataAssetsProcessed);
  }
  function onRemoveTagPro(e) {
    let proassetKey = self.editorUi.editor.graph.getSelectionCell().technicalAsset;
    ;
    const model = self.editorUi.editor.graph.model.threagile;
    let dataId = model.getIn(["data_assets", e.detail.data.value, "id"]);
    let dataAssetsProcessed = model.getIn(["technical_assets", proassetKey.key, "data_assets_processed"]) || [];
    if (typeof dataAssetsProcessed.toJSON === "function") {
      dataAssetsProcessed = dataAssetsProcessed.toJSON();
    }
    if (!Array.isArray(dataAssetsProcessed)) {
      dataAssetsProcessed = dataAssetsProcessed ? [dataAssetsProcessed] : [];
    }
    const index = dataAssetsProcessed.indexOf(dataId);
    if (index > -1) {
      dataAssetsProcessed.splice(index, 1);
    }
    model.setIn(["technical_assets", proassetKey.key, "data_assets_processed"], dataAssetsProcessed);
  }
  function onRemoveTagStored(e) {
    let id = self.editorUi.editor.graph.getSelectionCell().technicalAsset;
    ;
    const model = self.editorUi.editor.graph.model.threagile;
    let dataId = model.getIn(["data_assets", e.detail.data.value, "id"]);
    let dataAssetsStored = model.getIn(["technical_assets", id.key, "data_assets_stored"]) || [];
    if (typeof dataAssetsStored.toJSON === "function") {
      dataAssetsStored = dataAssetsStored.toJSON();
    }
    if (!Array.isArray(dataAssetsStored)) {
      dataAssetsStored = dataAssetsStored ? [dataAssetsStored] : [];
    }
    const index = dataAssetsStored.indexOf(dataId);
    if (index > -1) {
      dataAssetsStored.splice(index, 1);
    }
    model.setIn(["technical_assets", id.key, "data_assets_stored"], dataAssetsStored);
  }
  function onAddTagStored(e) {
    let id = self.editorUi.editor.graph.getSelectionCell().technicalAsset;
    ;
    const model = self.editorUi.editor.graph.model.threagile;
    let dataId = model.getIn(["data_assets", e.detail.data.value, "id"]);
    let dataAssetsStored = model.getIn(["technical_assets", id.key, "data_assets_stored"]) || [];
    if (typeof dataAssetsStored.toJSON === "function") {
      dataAssetsStored = dataAssetsStored.toJSON();
    }
    if (!Array.isArray(dataAssetsStored)) {
      dataAssetsStored = dataAssetsStored ? [dataAssetsStored] : [];
    }
    dataAssetsStored.push(dataId);
    model.setIn(["technical_assets", id.key, "data_assets_stored"], dataAssetsStored);
  }
  function onTagifyFocusBlur(e) {
    console.log(e.type, "event fired");
  }
  main.appendChild(receivedSecion);
  container.appendChild(main);
  return container;
};
AssetFormatPanel.prototype.addStroke = function(container) {
  var ui = this.editorUi;
  var graph = ui.editor.graph;
  var ss = this.format.getSelectionState();
  container.style.paddingTop = "4px";
  container.style.paddingBottom = "4px";
  container.style.whiteSpace = "normal";
  var colorPanel = document.createElement("div");
  colorPanel.style.fontWeight = "bold";
  if (!ss.stroke) {
    colorPanel.style.display = "none";
  }
  var styleSelect = document.createElement("select");
  styleSelect.style.position = "absolute";
  styleSelect.style.marginTop = "-2px";
  styleSelect.style.right = "72px";
  styleSelect.style.width = "80px";
  var styles = ["sharp", "rounded", "curved"];
  for (var i = 0; i < styles.length; i++) {
    var styleOption = document.createElement("option");
    styleOption.setAttribute("value", styles[i]);
    write(styleOption, mxResources.get(styles[i]));
    styleSelect.appendChild(styleOption);
  }
  mxEvent2.addListener(styleSelect, "change", function(evt) {
    graph.getModel().beginUpdate();
    try {
      var keys = [mxConstants.STYLE_ROUNDED, mxConstants.STYLE_CURVED];
      var values = ["0", null];
      if (styleSelect.value == "rounded") {
        values = ["1", null];
      } else if (styleSelect.value == "curved") {
        values = [null, "1"];
      }
      for (var i2 = 0; i2 < keys.length; i2++) {
        graph.setCellStyles(keys[i2], values[i2], graph.getSelectionCells());
      }
      ui.fireEvent(new mxEventObject("styleChanged", "keys", keys, "values", values, "cells", graph.getSelectionCells()));
    } finally {
      graph.getModel().endUpdate();
    }
    mxEvent2.consume(evt);
  });
  mxEvent2.addListener(styleSelect, "click", function(evt) {
    mxEvent2.consume(evt);
  });
  var strokeKey = ss.style.shape == "image" ? mxConstants.STYLE_IMAGE_BORDER : mxConstants.STYLE_STROKECOLOR;
  var label = ss.style.shape == "image" ? mxResources.get("border") : mxResources.get("line");
  var defs = ss.vertices.length >= 1 ? graph.stylesheet.getDefaultVertexStyle() : graph.stylesheet.getDefaultEdgeStyle();
  var lineColor = this.createCellColorOption(label, strokeKey, defs[strokeKey] != null ? defs[strokeKey] : "#000000", null, bind(this, function(color) {
    graph.updateCellStyles(strokeKey, color, graph.getSelectionCells());
  }));
  lineColor.appendChild(styleSelect);
  colorPanel.appendChild(lineColor);
  var stylePanel = colorPanel.cloneNode(false);
  stylePanel.style.fontWeight = "normal";
  stylePanel.style.whiteSpace = "nowrap";
  stylePanel.style.position = "relative";
  stylePanel.style.paddingLeft = "16px";
  stylePanel.style.marginBottom = "2px";
  stylePanel.style.marginTop = "2px";
  stylePanel.className = "geToolbarContainer";
  var addItem = bind(this, function(menu, width, cssName, keys, values) {
    var item = this.editorUi.menus.styleChange(menu, "", keys, values, "geIcon", null);
    var pat = document.createElement("div");
    pat.style.width = width + "px";
    pat.style.height = "1px";
    pat.style.borderBottom = "1px " + cssName + " " + this.defaultStrokeColor;
    pat.style.paddingTop = "6px";
    item.firstChild.firstChild.style.padding = "0px 4px 0px 4px";
    item.firstChild.firstChild.style.width = width + "px";
    item.firstChild.firstChild.appendChild(pat);
    return item;
  });
  var pattern = this.editorUi.toolbar.addMenuFunctionInContainer(stylePanel, "geSprite-orthogonal", mxResources.get("pattern"), false, bind(this, function(menu) {
    addItem(menu, 75, "solid", [mxConstants.STYLE_DASHED, mxConstants.STYLE_DASH_PATTERN], [null, null]).setAttribute("title", mxResources.get("solid"));
    addItem(menu, 75, "dashed", [mxConstants.STYLE_DASHED, mxConstants.STYLE_DASH_PATTERN], ["1", null]).setAttribute("title", mxResources.get("dashed"));
    addItem(menu, 75, "dotted", [mxConstants.STYLE_DASHED, mxConstants.STYLE_DASH_PATTERN], ["1", "1 1"]).setAttribute("title", mxResources.get("dotted") + " (1)");
    addItem(menu, 75, "dotted", [mxConstants.STYLE_DASHED, mxConstants.STYLE_DASH_PATTERN], ["1", "1 2"]).setAttribute("title", mxResources.get("dotted") + " (2)");
    addItem(menu, 75, "dotted", [mxConstants.STYLE_DASHED, mxConstants.STYLE_DASH_PATTERN], ["1", "1 4"]).setAttribute("title", mxResources.get("dotted") + " (3)");
  }));
  var altStylePanel = stylePanel.cloneNode(false);
  var edgeShape = this.editorUi.toolbar.addMenuFunctionInContainer(altStylePanel, "geSprite-connection", mxResources.get("connection"), false, bind(this, function(menu) {
    this.editorUi.menus.styleChange(menu, "", [
      mxConstants.STYLE_SHAPE,
      mxConstants.STYLE_STARTSIZE,
      mxConstants.STYLE_ENDSIZE,
      "width"
    ], [null, null, null, null], "geIcon geSprite geSprite-connection", null, true).setAttribute("title", mxResources.get("line"));
    this.editorUi.menus.styleChange(menu, "", [
      mxConstants.STYLE_SHAPE,
      mxConstants.STYLE_STARTSIZE,
      mxConstants.STYLE_ENDSIZE,
      "width"
    ], ["link", null, null, null], "geIcon geSprite geSprite-linkedge", null, true).setAttribute("title", mxResources.get("link"));
    this.editorUi.menus.styleChange(menu, "", [
      mxConstants.STYLE_SHAPE,
      mxConstants.STYLE_STARTSIZE,
      mxConstants.STYLE_ENDSIZE,
      "width"
    ], ["flexArrow", null, null, null], "geIcon geSprite geSprite-arrow", null, true).setAttribute("title", mxResources.get("arrow"));
    this.editorUi.menus.styleChange(menu, "", [
      mxConstants.STYLE_SHAPE,
      mxConstants.STYLE_STARTSIZE,
      mxConstants.STYLE_ENDSIZE,
      "width"
    ], ["arrow", null, null, null], "geIcon geSprite geSprite-simplearrow", null, true).setAttribute("title", mxResources.get("simpleArrow"));
  }));
  var altPattern = this.editorUi.toolbar.addMenuFunctionInContainer(altStylePanel, "geSprite-orthogonal", mxResources.get("pattern"), false, bind(this, function(menu) {
    addItem(menu, 33, "solid", [mxConstants.STYLE_DASHED, mxConstants.STYLE_DASH_PATTERN], [null, null]).setAttribute("title", mxResources.get("solid"));
    addItem(menu, 33, "dashed", [mxConstants.STYLE_DASHED, mxConstants.STYLE_DASH_PATTERN], ["1", null]).setAttribute("title", mxResources.get("dashed"));
    addItem(menu, 33, "dotted", [mxConstants.STYLE_DASHED, mxConstants.STYLE_DASH_PATTERN], ["1", "1 1"]).setAttribute("title", mxResources.get("dotted") + " (1)");
    addItem(menu, 33, "dotted", [mxConstants.STYLE_DASHED, mxConstants.STYLE_DASH_PATTERN], ["1", "1 2"]).setAttribute("title", mxResources.get("dotted") + " (2)");
    addItem(menu, 33, "dotted", [mxConstants.STYLE_DASHED, mxConstants.STYLE_DASH_PATTERN], ["1", "1 4"]).setAttribute("title", mxResources.get("dotted") + " (3)");
  }));
  var stylePanel2 = stylePanel.cloneNode(false);
  var input = document.createElement("input");
  input.style.textAlign = "right";
  input.style.marginTop = "2px";
  input.style.width = "41px";
  input.setAttribute("title", mxResources.get("linewidth"));
  stylePanel.appendChild(input);
  var altInput = input.cloneNode(true);
  altStylePanel.appendChild(altInput);
  function update(evt) {
    var value = parseInt(input.value);
    value = Math.min(999, Math.max(1, isNaN(value) ? 1 : value));
    if (value != getValue(ss.style, mxConstants.STYLE_STROKEWIDTH, 1)) {
      graph.setCellStyles(mxConstants.STYLE_STROKEWIDTH, value, graph.getSelectionCells());
      ui.fireEvent(new mxEventObject("styleChanged", "keys", [mxConstants.STYLE_STROKEWIDTH], "values", [value], "cells", graph.getSelectionCells()));
    }
    input.value = value + " pt";
    mxEvent2.consume(evt);
  }
  function altUpdate(evt) {
    var value = parseInt(altInput.value);
    value = Math.min(999, Math.max(1, isNaN(value) ? 1 : value));
    if (value != getValue(ss.style, mxConstants.STYLE_STROKEWIDTH, 1)) {
      graph.setCellStyles(mxConstants.STYLE_STROKEWIDTH, value, graph.getSelectionCells());
      ui.fireEvent(new mxEventObject("styleChanged", "keys", [mxConstants.STYLE_STROKEWIDTH], "values", [value], "cells", graph.getSelectionCells()));
    }
    altInput.value = value + " pt";
    mxEvent2.consume(evt);
  }
  var stepper = this.createStepper(input, update, 1, 9);
  stepper.style.display = input.style.display;
  stepper.style.marginTop = "2px";
  stylePanel.appendChild(stepper);
  var altStepper = this.createStepper(altInput, altUpdate, 1, 9);
  altStepper.style.display = altInput.style.display;
  altStepper.style.marginTop = "2px";
  altStylePanel.appendChild(altStepper);
  if (!mxClient.IS_QUIRKS) {
    input.style.position = "absolute";
    input.style.height = "15px";
    input.style.left = "141px";
    stepper.style.left = "190px";
    altInput.style.position = "absolute";
    altInput.style.left = "141px";
    altInput.style.height = "15px";
    altStepper.style.left = "190px";
  } else {
    input.style.height = "17px";
    altInput.style.height = "17px";
  }
  mxEvent2.addListener(input, "blur", update);
  mxEvent2.addListener(input, "change", update);
  mxEvent2.addListener(altInput, "blur", altUpdate);
  mxEvent2.addListener(altInput, "change", altUpdate);
  if (mxClient.IS_QUIRKS) {
    br(stylePanel2);
    br(stylePanel2);
  }
  var edgeStyle = this.editorUi.toolbar.addMenuFunctionInContainer(stylePanel2, "geSprite-orthogonal", mxResources.get("waypoints"), false, bind(this, function(menu) {
    if (ss.style.shape != "arrow") {
      this.editorUi.menus.edgeStyleChange(menu, "", [
        mxConstants.STYLE_EDGE,
        mxConstants.STYLE_CURVED,
        mxConstants.STYLE_NOEDGESTYLE
      ], [null, null, null], "geIcon geSprite geSprite-straight", null, true).setAttribute("title", mxResources.get("straight"));
      this.editorUi.menus.edgeStyleChange(menu, "", [
        mxConstants.STYLE_EDGE,
        mxConstants.STYLE_CURVED,
        mxConstants.STYLE_NOEDGESTYLE
      ], ["orthogonalEdgeStyle", null, null], "geIcon geSprite geSprite-orthogonal", null, true).setAttribute("title", mxResources.get("orthogonal"));
      this.editorUi.menus.edgeStyleChange(menu, "", [
        mxConstants.STYLE_EDGE,
        mxConstants.STYLE_ELBOW,
        mxConstants.STYLE_CURVED,
        mxConstants.STYLE_NOEDGESTYLE
      ], ["elbowEdgeStyle", null, null, null], "geIcon geSprite geSprite-horizontalelbow", null, true).setAttribute("title", mxResources.get("simple"));
      this.editorUi.menus.edgeStyleChange(menu, "", [
        mxConstants.STYLE_EDGE,
        mxConstants.STYLE_ELBOW,
        mxConstants.STYLE_CURVED,
        mxConstants.STYLE_NOEDGESTYLE
      ], ["elbowEdgeStyle", "vertical", null, null], "geIcon geSprite geSprite-verticalelbow", null, true).setAttribute("title", mxResources.get("simple"));
      this.editorUi.menus.edgeStyleChange(menu, "", [
        mxConstants.STYLE_EDGE,
        mxConstants.STYLE_ELBOW,
        mxConstants.STYLE_CURVED,
        mxConstants.STYLE_NOEDGESTYLE
      ], ["isometricEdgeStyle", null, null, null], "geIcon geSprite geSprite-horizontalisometric", null, true).setAttribute("title", mxResources.get("isometric"));
      this.editorUi.menus.edgeStyleChange(menu, "", [
        mxConstants.STYLE_EDGE,
        mxConstants.STYLE_ELBOW,
        mxConstants.STYLE_CURVED,
        mxConstants.STYLE_NOEDGESTYLE
      ], ["isometricEdgeStyle", "vertical", null, null], "geIcon geSprite geSprite-verticalisometric", null, true).setAttribute("title", mxResources.get("isometric"));
      if (ss.style.shape == "connector") {
        this.editorUi.menus.edgeStyleChange(menu, "", [
          mxConstants.STYLE_EDGE,
          mxConstants.STYLE_CURVED,
          mxConstants.STYLE_NOEDGESTYLE
        ], ["orthogonalEdgeStyle", "1", null], "geIcon geSprite geSprite-curved", null, true).setAttribute("title", mxResources.get("curved"));
      }
      this.editorUi.menus.edgeStyleChange(menu, "", [
        mxConstants.STYLE_EDGE,
        mxConstants.STYLE_CURVED,
        mxConstants.STYLE_NOEDGESTYLE
      ], ["entityRelationEdgeStyle", null, null], "geIcon geSprite geSprite-entity", null, true).setAttribute("title", mxResources.get("entityRelation"));
    }
  }));
  var lineStart = this.editorUi.toolbar.addMenuFunctionInContainer(stylePanel2, "geSprite-startclassic", mxResources.get("linestart"), false, bind(this, function(menu) {
    if (ss.style.shape == "connector" || ss.style.shape == "flexArrow" || ss.style.shape == "filledEdge") {
      var item = this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_STARTARROW, "startFill"], [mxConstants.NONE, 0], "geIcon", null, false);
      item.setAttribute("title", mxResources.get("none"));
      item.firstChild.firstChild.innerHTML = '<font style="font-size:10px;">' + htmlEntities(mxResources.get("none")) + "</font>";
      if (ss.style.shape == "connector" || ss.style.shape == "filledEdge") {
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_STARTARROW, "startFill"], [mxConstants.ARROW_CLASSIC, 1], "geIcon geSprite geSprite-startclassic", null, false).setAttribute("title", mxResources.get("classic"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_STARTARROW, "startFill"], [mxConstants.ARROW_CLASSIC_THIN, 1], "geIcon geSprite geSprite-startclassicthin", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_STARTARROW, "startFill"], [mxConstants.ARROW_OPEN, 0], "geIcon geSprite geSprite-startopen", null, false).setAttribute("title", mxResources.get("openArrow"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_STARTARROW, "startFill"], [mxConstants.ARROW_OPEN_THIN, 0], "geIcon geSprite geSprite-startopenthin", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_STARTARROW, "startFill"], ["openAsync", 0], "geIcon geSprite geSprite-startopenasync", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_STARTARROW, "startFill"], [mxConstants.ARROW_BLOCK, 1], "geIcon geSprite geSprite-startblock", null, false).setAttribute("title", mxResources.get("block"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_STARTARROW, "startFill"], [mxConstants.ARROW_BLOCK_THIN, 1], "geIcon geSprite geSprite-startblockthin", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_STARTARROW, "startFill"], ["async", 1], "geIcon geSprite geSprite-startasync", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_STARTARROW, "startFill"], [mxConstants.ARROW_OVAL, 1], "geIcon geSprite geSprite-startoval", null, false).setAttribute("title", mxResources.get("oval"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_STARTARROW, "startFill"], [mxConstants.ARROW_DIAMOND, 1], "geIcon geSprite geSprite-startdiamond", null, false).setAttribute("title", mxResources.get("diamond"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_STARTARROW, "startFill"], [mxConstants.ARROW_DIAMOND_THIN, 1], "geIcon geSprite geSprite-startthindiamond", null, false).setAttribute("title", mxResources.get("diamondThin"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_STARTARROW, "startFill"], [mxConstants.ARROW_CLASSIC, 0], "geIcon geSprite geSprite-startclassictrans", null, false).setAttribute("title", mxResources.get("classic"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_STARTARROW, "startFill"], [mxConstants.ARROW_CLASSIC_THIN, 0], "geIcon geSprite geSprite-startclassicthintrans", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_STARTARROW, "startFill"], [mxConstants.ARROW_BLOCK, 0], "geIcon geSprite geSprite-startblocktrans", null, false).setAttribute("title", mxResources.get("block"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_STARTARROW, "startFill"], [mxConstants.ARROW_BLOCK_THIN, 0], "geIcon geSprite geSprite-startblockthintrans", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_STARTARROW, "startFill"], ["async", 0], "geIcon geSprite geSprite-startasynctrans", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_STARTARROW, "startFill"], [mxConstants.ARROW_OVAL, 0], "geIcon geSprite geSprite-startovaltrans", null, false).setAttribute("title", mxResources.get("oval"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_STARTARROW, "startFill"], [mxConstants.ARROW_DIAMOND, 0], "geIcon geSprite geSprite-startdiamondtrans", null, false).setAttribute("title", mxResources.get("diamond"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_STARTARROW, "startFill"], [mxConstants.ARROW_DIAMOND_THIN, 0], "geIcon geSprite geSprite-startthindiamondtrans", null, false).setAttribute("title", mxResources.get("diamondThin"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_STARTARROW, "startFill"], ["box", 0], "geIcon geSprite geSvgSprite geSprite-box", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_STARTARROW, "startFill"], ["halfCircle", 0], "geIcon geSprite geSvgSprite geSprite-halfCircle", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_STARTARROW, "startFill"], ["dash", 0], "geIcon geSprite geSprite-startdash", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_STARTARROW, "startFill"], ["cross", 0], "geIcon geSprite geSprite-startcross", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_STARTARROW, "startFill"], ["circlePlus", 0], "geIcon geSprite geSprite-startcircleplus", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_STARTARROW, "startFill"], ["circle", 1], "geIcon geSprite geSprite-startcircle", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_STARTARROW, "startFill"], ["ERone", 0], "geIcon geSprite geSprite-starterone", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_STARTARROW, "startFill"], ["ERmandOne", 0], "geIcon geSprite geSprite-starteronetoone", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_STARTARROW, "startFill"], ["ERmany", 0], "geIcon geSprite geSprite-startermany", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_STARTARROW, "startFill"], ["ERoneToMany", 0], "geIcon geSprite geSprite-starteronetomany", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_STARTARROW, "startFill"], ["ERzeroToOne", 1], "geIcon geSprite geSprite-starteroneopt", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_STARTARROW, "startFill"], ["ERzeroToMany", 1], "geIcon geSprite geSprite-startermanyopt", null, false);
      } else {
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_STARTARROW], [mxConstants.ARROW_BLOCK], "geIcon geSprite geSprite-startblocktrans", null, false).setAttribute("title", mxResources.get("block"));
      }
    }
  }));
  var lineEnd = this.editorUi.toolbar.addMenuFunctionInContainer(stylePanel2, "geSprite-endclassic", mxResources.get("lineend"), false, bind(this, function(menu) {
    if (ss.style.shape == "connector" || ss.style.shape == "flexArrow" || ss.style.shape == "filledEdge") {
      var item = this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_ENDARROW, "endFill"], [mxConstants.NONE, 0], "geIcon", null, false);
      item.setAttribute("title", mxResources.get("none"));
      item.firstChild.firstChild.innerHTML = '<font style="font-size:10px;">' + htmlEntities(mxResources.get("none")) + "</font>";
      if (ss.style.shape == "connector" || ss.style.shape == "filledEdge") {
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_ENDARROW, "endFill"], [mxConstants.ARROW_CLASSIC, 1], "geIcon geSprite geSprite-endclassic", null, false).setAttribute("title", mxResources.get("classic"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_ENDARROW, "endFill"], [mxConstants.ARROW_CLASSIC_THIN, 1], "geIcon geSprite geSprite-endclassicthin", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_ENDARROW, "endFill"], [mxConstants.ARROW_OPEN, 0], "geIcon geSprite geSprite-endopen", null, false).setAttribute("title", mxResources.get("openArrow"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_ENDARROW, "endFill"], [mxConstants.ARROW_OPEN_THIN, 0], "geIcon geSprite geSprite-endopenthin", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_ENDARROW, "endFill"], ["openAsync", 0], "geIcon geSprite geSprite-endopenasync", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_ENDARROW, "endFill"], [mxConstants.ARROW_BLOCK, 1], "geIcon geSprite geSprite-endblock", null, false).setAttribute("title", mxResources.get("block"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_ENDARROW, "endFill"], [mxConstants.ARROW_BLOCK_THIN, 1], "geIcon geSprite geSprite-endblockthin", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_ENDARROW, "endFill"], ["async", 1], "geIcon geSprite geSprite-endasync", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_ENDARROW, "endFill"], [mxConstants.ARROW_OVAL, 1], "geIcon geSprite geSprite-endoval", null, false).setAttribute("title", mxResources.get("oval"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_ENDARROW, "endFill"], [mxConstants.ARROW_DIAMOND, 1], "geIcon geSprite geSprite-enddiamond", null, false).setAttribute("title", mxResources.get("diamond"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_ENDARROW, "endFill"], [mxConstants.ARROW_DIAMOND_THIN, 1], "geIcon geSprite geSprite-endthindiamond", null, false).setAttribute("title", mxResources.get("diamondThin"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_ENDARROW, "endFill"], [mxConstants.ARROW_CLASSIC, 0], "geIcon geSprite geSprite-endclassictrans", null, false).setAttribute("title", mxResources.get("classic"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_ENDARROW, "endFill"], [mxConstants.ARROW_CLASSIC_THIN, 0], "geIcon geSprite geSprite-endclassicthintrans", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_ENDARROW, "endFill"], [mxConstants.ARROW_BLOCK, 0], "geIcon geSprite geSprite-endblocktrans", null, false).setAttribute("title", mxResources.get("block"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_ENDARROW, "endFill"], [mxConstants.ARROW_BLOCK_THIN, 0], "geIcon geSprite geSprite-endblockthintrans", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_ENDARROW, "endFill"], ["async", 0], "geIcon geSprite geSprite-endasynctrans", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_ENDARROW, "endFill"], [mxConstants.ARROW_OVAL, 0], "geIcon geSprite geSprite-endovaltrans", null, false).setAttribute("title", mxResources.get("oval"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_ENDARROW, "endFill"], [mxConstants.ARROW_DIAMOND, 0], "geIcon geSprite geSprite-enddiamondtrans", null, false).setAttribute("title", mxResources.get("diamond"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_ENDARROW, "endFill"], [mxConstants.ARROW_DIAMOND_THIN, 0], "geIcon geSprite geSprite-endthindiamondtrans", null, false).setAttribute("title", mxResources.get("diamondThin"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_ENDARROW, "endFill"], ["box", 0], "geIcon geSprite geSvgSprite geFlipSprite geSprite-box", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_ENDARROW, "endFill"], ["halfCircle", 0], "geIcon geSprite geSvgSprite geFlipSprite geSprite-halfCircle", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_ENDARROW, "endFill"], ["dash", 0], "geIcon geSprite geSprite-enddash", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_ENDARROW, "endFill"], ["cross", 0], "geIcon geSprite geSprite-endcross", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_ENDARROW, "endFill"], ["circlePlus", 0], "geIcon geSprite geSprite-endcircleplus", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_ENDARROW, "endFill"], ["circle", 1], "geIcon geSprite geSprite-endcircle", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_ENDARROW, "endFill"], ["ERone", 0], "geIcon geSprite geSprite-enderone", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_ENDARROW, "endFill"], ["ERmandOne", 0], "geIcon geSprite geSprite-enderonetoone", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_ENDARROW, "endFill"], ["ERmany", 0], "geIcon geSprite geSprite-endermany", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_ENDARROW, "endFill"], ["ERoneToMany", 0], "geIcon geSprite geSprite-enderonetomany", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_ENDARROW, "endFill"], ["ERzeroToOne", 1], "geIcon geSprite geSprite-enderoneopt", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_ENDARROW, "endFill"], ["ERzeroToMany", 1], "geIcon geSprite geSprite-endermanyopt", null, false);
      } else {
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants.STYLE_ENDARROW], [mxConstants.ARROW_BLOCK], "geIcon geSprite geSprite-endblocktrans", null, false).setAttribute("title", mxResources.get("block"));
      }
    }
  }));
  this.addArrow(edgeShape, 8);
  this.addArrow(edgeStyle);
  this.addArrow(lineStart);
  this.addArrow(lineEnd);
  var symbol = this.addArrow(pattern, 9);
  symbol.className = "geIcon";
  symbol.style.width = "auto";
  var altSymbol = this.addArrow(altPattern, 9);
  altSymbol.className = "geIcon";
  altSymbol.style.width = "22px";
  var solid = document.createElement("div");
  solid.style.width = "85px";
  solid.style.height = "1px";
  solid.style.borderBottom = "1px solid " + this.defaultStrokeColor;
  solid.style.marginBottom = "9px";
  symbol.appendChild(solid);
  var altSolid = document.createElement("div");
  altSolid.style.width = "23px";
  altSolid.style.height = "1px";
  altSolid.style.borderBottom = "1px solid " + this.defaultStrokeColor;
  altSolid.style.marginBottom = "9px";
  altSymbol.appendChild(altSolid);
  pattern.style.height = "15px";
  altPattern.style.height = "15px";
  edgeShape.style.height = "15px";
  edgeStyle.style.height = "17px";
  lineStart.style.marginLeft = "3px";
  lineStart.style.height = "17px";
  lineEnd.style.marginLeft = "3px";
  lineEnd.style.height = "17px";
  container.appendChild(colorPanel);
  container.appendChild(altStylePanel);
  container.appendChild(stylePanel);
  var arrowPanel = stylePanel.cloneNode(false);
  arrowPanel.style.paddingBottom = "6px";
  arrowPanel.style.paddingTop = "4px";
  arrowPanel.style.fontWeight = "normal";
  var span = document.createElement("div");
  span.style.position = "absolute";
  span.style.marginLeft = "3px";
  span.style.marginBottom = "12px";
  span.style.marginTop = "2px";
  span.style.fontWeight = "normal";
  span.style.width = "76px";
  write(span, mxResources.get("lineend"));
  arrowPanel.appendChild(span);
  var endSpacingUpdate, endSizeUpdate;
  var endSpacing = this.addUnitInput(arrowPanel, "pt", 74, 33, function() {
    endSpacingUpdate.apply(this, arguments);
  });
  var endSize = this.addUnitInput(arrowPanel, "pt", 20, 33, function() {
    endSizeUpdate.apply(this, arguments);
  });
  br(arrowPanel);
  var spacer = document.createElement("div");
  spacer.style.height = "8px";
  arrowPanel.appendChild(spacer);
  span = span.cloneNode(false);
  write(span, mxResources.get("linestart"));
  arrowPanel.appendChild(span);
  var startSpacingUpdate, startSizeUpdate;
  var startSpacing = this.addUnitInput(arrowPanel, "pt", 74, 33, function() {
    startSpacingUpdate.apply(this, arguments);
  });
  var startSize = this.addUnitInput(arrowPanel, "pt", 20, 33, function() {
    startSizeUpdate.apply(this, arguments);
  });
  br(arrowPanel);
  this.addLabel(arrowPanel, mxResources.get("spacing"), 74, 50);
  this.addLabel(arrowPanel, mxResources.get("size"), 20, 50);
  br(arrowPanel);
  var perimeterPanel = colorPanel.cloneNode(false);
  perimeterPanel.style.fontWeight = "normal";
  perimeterPanel.style.position = "relative";
  perimeterPanel.style.paddingLeft = "16px";
  perimeterPanel.style.marginBottom = "2px";
  perimeterPanel.style.marginTop = "6px";
  perimeterPanel.style.borderWidth = "0px";
  perimeterPanel.style.paddingBottom = "18px";
  var span = document.createElement("div");
  span.style.position = "absolute";
  span.style.marginLeft = "3px";
  span.style.marginBottom = "12px";
  span.style.marginTop = "1px";
  span.style.fontWeight = "normal";
  span.style.width = "120px";
  write(span, mxResources.get("perimeter"));
  perimeterPanel.appendChild(span);
  var perimeterUpdate;
  var perimeterSpacing = this.addUnitInput(perimeterPanel, "pt", 20, 41, function() {
    perimeterUpdate.apply(this, arguments);
  });
  if (ss.edges.length == graph.getSelectionCount()) {
    container.appendChild(stylePanel2);
    if (mxClient.IS_QUIRKS) {
      br(container);
      br(container);
    }
    container.appendChild(arrowPanel);
  } else if (ss.vertices.length == graph.getSelectionCount()) {
    if (mxClient.IS_QUIRKS) {
      br(container);
    }
    container.appendChild(perimeterPanel);
  }
  var listener = bind(this, function(sender, evt, force) {
    ss = this.format.getSelectionState();
    var color = getValue(ss.style, strokeKey, null);
    if (force || document.activeElement != input) {
      var tmp = parseInt(getValue(ss.style, mxConstants.STYLE_STROKEWIDTH, 1));
      input.value = isNaN(tmp) ? "" : tmp + " pt";
    }
    if (force || document.activeElement != altInput) {
      var tmp = parseInt(getValue(ss.style, mxConstants.STYLE_STROKEWIDTH, 1));
      altInput.value = isNaN(tmp) ? "" : tmp + " pt";
    }
    styleSelect.style.visibility = ss.style.shape == "connector" || ss.style.shape == "filledEdge" ? "" : "hidden";
    if (getValue(ss.style, mxConstants.STYLE_CURVED, null) == "1") {
      styleSelect.value = "curved";
    } else if (getValue(ss.style, mxConstants.STYLE_ROUNDED, null) == "1") {
      styleSelect.value = "rounded";
    }
    if (getValue(ss.style, mxConstants.STYLE_DASHED, null) == "1") {
      if (getValue(ss.style, mxConstants.STYLE_DASH_PATTERN, null) == null) {
        solid.style.borderBottom = "1px dashed " + this.defaultStrokeColor;
      } else {
        solid.style.borderBottom = "1px dotted " + this.defaultStrokeColor;
      }
    } else {
      solid.style.borderBottom = "1px solid " + this.defaultStrokeColor;
    }
    altSolid.style.borderBottom = solid.style.borderBottom;
    var edgeStyleDiv = edgeStyle.getElementsByTagName("div")[0];
    if (edgeStyleDiv != null) {
      var es = getValue(ss.style, mxConstants.STYLE_EDGE, null);
      if (getValue(ss.style, mxConstants.STYLE_NOEDGESTYLE, null) == "1") {
        es = null;
      }
      if (es == "orthogonalEdgeStyle" && getValue(ss.style, mxConstants.STYLE_CURVED, null) == "1") {
        edgeStyleDiv.className = "geSprite geSprite-curved";
      } else if (es == "straight" || es == "none" || es == null) {
        edgeStyleDiv.className = "geSprite geSprite-straight";
      } else if (es == "entityRelationEdgeStyle") {
        edgeStyleDiv.className = "geSprite geSprite-entity";
      } else if (es == "elbowEdgeStyle") {
        edgeStyleDiv.className = "geSprite " + (getValue(ss.style, mxConstants.STYLE_ELBOW, null) == "vertical" ? "geSprite-verticalelbow" : "geSprite-horizontalelbow");
      } else if (es == "isometricEdgeStyle") {
        edgeStyleDiv.className = "geSprite " + (getValue(ss.style, mxConstants.STYLE_ELBOW, null) == "vertical" ? "geSprite-verticalisometric" : "geSprite-horizontalisometric");
      } else {
        edgeStyleDiv.className = "geSprite geSprite-orthogonal";
      }
    }
    var edgeShapeDiv = edgeShape.getElementsByTagName("div")[0];
    if (edgeShapeDiv != null) {
      if (ss.style.shape == "link") {
        edgeShapeDiv.className = "geSprite geSprite-linkedge";
      } else if (ss.style.shape == "flexArrow") {
        edgeShapeDiv.className = "geSprite geSprite-arrow";
      } else if (ss.style.shape == "arrow") {
        edgeShapeDiv.className = "geSprite geSprite-simplearrow";
      } else {
        edgeShapeDiv.className = "geSprite geSprite-connection";
      }
    }
    if (ss.edges.length == graph.getSelectionCount()) {
      altStylePanel.style.display = "";
      stylePanel.style.display = "none";
    } else {
      altStylePanel.style.display = "none";
      stylePanel.style.display = "";
    }
    function updateArrow(marker, fill, elt, prefix) {
      var markerDiv = elt.getElementsByTagName("div")[0];
      if (markerDiv != null) {
        markerDiv.className = ui.getCssClassForMarker(prefix, ss.style.shape, marker, fill);
        if (markerDiv.className == "geSprite geSprite-noarrow") {
          markerDiv.innerHTML = htmlEntities(mxResources.get("none"));
          markerDiv.style.backgroundImage = "none";
          markerDiv.style.verticalAlign = "top";
          markerDiv.style.marginTop = "5px";
          markerDiv.style.fontSize = "10px";
          markerDiv.style.filter = "none";
          markerDiv.style.color = this.defaultStrokeColor;
          markerDiv.nextSibling.style.marginTop = "0px";
        }
      }
      return markerDiv;
    }
    var sourceDiv = updateArrow(getValue(ss.style, mxConstants.STYLE_STARTARROW, null), getValue(ss.style, "startFill", "1"), lineStart, "start");
    var targetDiv = updateArrow(getValue(ss.style, mxConstants.STYLE_ENDARROW, null), getValue(ss.style, "endFill", "1"), lineEnd, "end");
    if (sourceDiv != null && targetDiv != null) {
      if (ss.style.shape == "arrow") {
        sourceDiv.className = "geSprite geSprite-noarrow";
        targetDiv.className = "geSprite geSprite-endblocktrans";
      } else if (ss.style.shape == "link") {
        sourceDiv.className = "geSprite geSprite-noarrow";
        targetDiv.className = "geSprite geSprite-noarrow";
      }
    }
    setOpacity(edgeStyle, ss.style.shape == "arrow" ? 30 : 100);
    if (ss.style.shape != "connector" && ss.style.shape != "flexArrow" && ss.style.shape != "filledEdge") {
      setOpacity(lineStart, 30);
      setOpacity(lineEnd, 30);
    } else {
      setOpacity(lineStart, 100);
      setOpacity(lineEnd, 100);
    }
    if (force || document.activeElement != startSize) {
      var tmp = parseInt(getValue(ss.style, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_MARKERSIZE));
      startSize.value = isNaN(tmp) ? "" : tmp + " pt";
    }
    if (force || document.activeElement != startSpacing) {
      var tmp = parseInt(getValue(ss.style, mxConstants.STYLE_SOURCE_PERIMETER_SPACING, 0));
      startSpacing.value = isNaN(tmp) ? "" : tmp + " pt";
    }
    if (force || document.activeElement != endSize) {
      var tmp = parseInt(getValue(ss.style, mxConstants.STYLE_ENDSIZE, mxConstants.DEFAULT_MARKERSIZE));
      endSize.value = isNaN(tmp) ? "" : tmp + " pt";
    }
    if (force || document.activeElement != startSpacing) {
      var tmp = parseInt(getValue(ss.style, mxConstants.STYLE_TARGET_PERIMETER_SPACING, 0));
      endSpacing.value = isNaN(tmp) ? "" : tmp + " pt";
    }
    if (force || document.activeElement != perimeterSpacing) {
      var tmp = parseInt(getValue(ss.style, mxConstants.STYLE_PERIMETER_SPACING, 0));
      perimeterSpacing.value = isNaN(tmp) ? "" : tmp + " pt";
    }
  });
  startSizeUpdate = this.installInputHandler(startSize, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_MARKERSIZE, 0, 999, " pt");
  startSpacingUpdate = this.installInputHandler(startSpacing, mxConstants.STYLE_SOURCE_PERIMETER_SPACING, 0, -999, 999, " pt");
  endSizeUpdate = this.installInputHandler(endSize, mxConstants.STYLE_ENDSIZE, mxConstants.DEFAULT_MARKERSIZE, 0, 999, " pt");
  endSpacingUpdate = this.installInputHandler(endSpacing, mxConstants.STYLE_TARGET_PERIMETER_SPACING, 0, -999, 999, " pt");
  perimeterUpdate = this.installInputHandler(perimeterSpacing, mxConstants.STYLE_PERIMETER_SPACING, 0, 0, 999, " pt");
  this.addKeyHandler(input, listener);
  this.addKeyHandler(startSize, listener);
  this.addKeyHandler(startSpacing, listener);
  this.addKeyHandler(endSize, listener);
  this.addKeyHandler(endSpacing, listener);
  this.addKeyHandler(perimeterSpacing, listener);
  graph.getModel().addListener(mxEvent2.CHANGE, listener);
  this.listeners.push({
    destroy: function() {
      graph.getModel().removeListener(listener);
    }
  });
  listener();
  return container;
};
AssetFormatPanel.prototype.addLineJumps = function(container) {
  var ss = this.format.getSelectionState();
  if (Graph.lineJumpsEnabled && ss.edges.length > 0 && ss.vertices.length == 0 && ss.lineJumps) {
    container.style.padding = "8px 0px 24px 18px";
    var ui = this.editorUi;
    var editor = ui.editor;
    var graph = editor.graph;
    var span = document.createElement("div");
    span.style.position = "absolute";
    span.style.fontWeight = "bold";
    span.style.width = "80px";
    write(span, mxResources.get("lineJumps"));
    container.appendChild(span);
    var styleSelect = document.createElement("select");
    styleSelect.style.position = "absolute";
    styleSelect.style.marginTop = "-2px";
    styleSelect.style.right = "76px";
    styleSelect.style.width = "62px";
    var styles = ["none", "arc", "gap", "sharp"];
    for (var i = 0; i < styles.length; i++) {
      var styleOption = document.createElement("option");
      styleOption.setAttribute("value", styles[i]);
      write(styleOption, mxResources.get(styles[i]));
      styleSelect.appendChild(styleOption);
    }
    mxEvent2.addListener(styleSelect, "change", function(evt) {
      graph.getModel().beginUpdate();
      try {
        graph.setCellStyles("jumpStyle", styleSelect.value, graph.getSelectionCells());
        ui.fireEvent(new mxEventObject("styleChanged", "keys", ["jumpStyle"], "values", [styleSelect.value], "cells", graph.getSelectionCells()));
      } finally {
        graph.getModel().endUpdate();
      }
      mxEvent2.consume(evt);
    });
    mxEvent2.addListener(styleSelect, "click", function(evt) {
      mxEvent2.consume(evt);
    });
    container.appendChild(styleSelect);
    var jumpSizeUpdate;
    var jumpSize = this.addUnitInput(container, "pt", 22, 33, function() {
      jumpSizeUpdate.apply(this, arguments);
    });
    jumpSizeUpdate = this.installInputHandler(jumpSize, "jumpSize", Graph.defaultJumpSize, 0, 999, " pt");
    var listener = bind(this, function(sender, evt, force) {
      ss = this.format.getSelectionState();
      styleSelect.value = getValue(ss.style, "jumpStyle", "none");
      if (force || document.activeElement != jumpSize) {
        var tmp = parseInt(getValue(ss.style, "jumpSize", Graph.defaultJumpSize));
        jumpSize.value = isNaN(tmp) ? "" : tmp + " pt";
      }
    });
    this.addKeyHandler(jumpSize, listener);
    graph.getModel().addListener(mxEvent2.CHANGE, listener);
    this.listeners.push({
      destroy: function() {
        graph.getModel().removeListener(listener);
      }
    });
    listener();
  } else {
    container.style.display = "none";
  }
  return container;
};
AssetFormatPanel.prototype.addEffects = function(div) {
  var ui = this.editorUi;
  var editor = ui.editor;
  var graph = editor.graph;
  var ss = this.format.getSelectionState();
  div.style.paddingTop = "0px";
  div.style.paddingBottom = "2px";
  var table = document.createElement("table");
  if (mxClient.IS_QUIRKS) {
    table.style.fontSize = "1em";
  }
  table.style.width = "100%";
  table.style.fontWeight = "bold";
  table.style.paddingRight = "20px";
  var tbody = document.createElement("tbody");
  var row = document.createElement("tr");
  row.style.padding = "0px";
  var left = document.createElement("td");
  left.style.padding = "0px";
  left.style.width = "50%";
  left.setAttribute("valign", "top");
  var right = left.cloneNode(true);
  right.style.paddingLeft = "8px";
  row.appendChild(left);
  row.appendChild(right);
  tbody.appendChild(row);
  table.appendChild(tbody);
  div.appendChild(table);
  var current2 = left;
  var count = 0;
  var addOption2 = bind(this, function(label, key, defaultValue) {
    var opt = this.createCellOption(label, key, defaultValue);
    opt.style.width = "100%";
    current2.appendChild(opt);
    current2 = current2 == left ? right : left;
    count++;
  });
  var listener = bind(this, function(sender, evt, force) {
    ss = this.format.getSelectionState();
    left.innerHTML = "";
    right.innerHTML = "";
    current2 = left;
    if (ss.rounded) {
      addOption2(mxResources.get("rounded"), mxConstants.STYLE_ROUNDED, 0);
    }
    if (ss.style.shape == "swimlane") {
      addOption2(mxResources.get("divider"), "swimlaneLine", 1);
    }
    if (!ss.containsImage) {
      addOption2(mxResources.get("shadow"), mxConstants.STYLE_SHADOW, 0);
    }
    if (ss.glass) {
      addOption2(mxResources.get("glass"), mxConstants.STYLE_GLASS, 0);
    }
    addOption2(mxResources.get("sketch"), "sketch", 0);
  });
  graph.getModel().addListener(mxEvent2.CHANGE, listener);
  this.listeners.push({
    destroy: function() {
      graph.getModel().removeListener(listener);
    }
  });
  listener();
  return div;
};
AssetFormatPanel.prototype.addStyleOps = function(div) {
  div.style.paddingTop = "10px";
  div.style.paddingBottom = "10px";
  var btn = button(mxResources.get("setAsDefaultStyle"), bind(this, function(evt) {
    this.editorUi.actions.get("setAsDefaultStyle").funct();
  }));
  btn.setAttribute("title", mxResources.get("setAsDefaultStyle") + " (" + this.editorUi.actions.get("setAsDefaultStyle").shortcut + ")");
  btn.style.width = "202px";
  div.appendChild(btn);
  return div;
};
AssetFormatPanel.prototype.addFill = function(container) {
  var ui = this.editorUi;
  var graph = ui.editor.graph;
  var ss = this.format.getSelectionState();
  container.style.paddingTop = "6px";
  container.style.paddingBottom = "6px";
  var gradientSelect = document.createElement("select");
  gradientSelect.style.position = "absolute";
  gradientSelect.style.marginTop = "-2px";
  gradientSelect.style.right = mxClient.IS_QUIRKS ? "52px" : "72px";
  gradientSelect.style.width = "70px";
  var fillStyleSelect = gradientSelect.cloneNode(false);
  mxEvent2.addListener(gradientSelect, "click", function(evt) {
    mxEvent2.consume(evt);
  });
  mxEvent2.addListener(fillStyleSelect, "click", function(evt) {
    mxEvent2.consume(evt);
  });
  var defs = ss.vertices.length >= 1 ? graph.stylesheet.getDefaultVertexStyle() : graph.stylesheet.getDefaultEdgeStyle();
  var gradientPanel = this.createCellColorOption(mxResources.get("gradient"), mxConstants.STYLE_GRADIENTCOLOR, defs[mxConstants.STYLE_GRADIENTCOLOR] != null ? defs[mxConstants.STYLE_GRADIENTCOLOR] : "#ffffff", function(color) {
    if (color == null || color == mxConstants.NONE) {
      gradientSelect.style.display = "none";
    } else {
      gradientSelect.style.display = "";
    }
  }, function(color) {
    graph.updateCellStyles(mxConstants.STYLE_GRADIENTCOLOR, color, graph.getSelectionCells());
  });
  var fillKey = ss.style.shape == "image" ? mxConstants.STYLE_IMAGE_BACKGROUND : mxConstants.STYLE_FILLCOLOR;
  var label = ss.style.shape == "image" ? mxResources.get("background") : mxResources.get("fill");
  var defs = ss.vertices.length >= 1 ? graph.stylesheet.getDefaultVertexStyle() : graph.stylesheet.getDefaultEdgeStyle();
  var fillPanel = this.createCellColorOption(label, fillKey, defs[fillKey] != null ? defs[fillKey] : "#ffffff", null, bind(this, function(color) {
    graph.updateCellStyles(fillKey, color, graph.getSelectionCells());
  }));
  fillPanel.style.fontWeight = "bold";
  var tmpColor = getValue(ss.style, fillKey, null);
  gradientPanel.style.display = tmpColor != null && tmpColor != mxConstants.NONE && ss.fill && ss.style.shape != "image" ? "" : "none";
  var directions = [
    mxConstants.DIRECTION_NORTH,
    mxConstants.DIRECTION_EAST,
    mxConstants.DIRECTION_SOUTH,
    mxConstants.DIRECTION_WEST
  ];
  for (var i = 0; i < directions.length; i++) {
    var gradientOption = document.createElement("option");
    gradientOption.setAttribute("value", directions[i]);
    write(gradientOption, mxResources.get(directions[i]));
    gradientSelect.appendChild(gradientOption);
  }
  gradientPanel.appendChild(gradientSelect);
  for (var i = 0; i < Editor.roughFillStyles.length; i++) {
    var fillStyleOption = document.createElement("option");
    fillStyleOption.setAttribute("value", Editor.roughFillStyles[i].val);
    write(fillStyleOption, Editor.roughFillStyles[i].dispName);
    fillStyleSelect.appendChild(fillStyleOption);
  }
  fillPanel.appendChild(fillStyleSelect);
  var listener = bind(this, function() {
    ss = this.format.getSelectionState();
    var value = getValue(ss.style, mxConstants.STYLE_GRADIENT_DIRECTION, mxConstants.DIRECTION_SOUTH);
    var fillStyle = getValue(ss.style, "fillStyle", "auto");
    if (value == "") {
      value = mxConstants.DIRECTION_SOUTH;
    }
    gradientSelect.value = value;
    fillStyleSelect.value = fillStyle;
    container.style.display = ss.fill ? "" : "none";
    var fillColor = getValue(ss.style, mxConstants.STYLE_FILLCOLOR, null);
    if (!ss.fill || ss.containsImage || fillColor == null || fillColor == mxConstants.NONE || ss.style.shape == "filledEdge") {
      fillStyleSelect.style.display = "none";
      gradientPanel.style.display = "none";
    } else {
      fillStyleSelect.style.display = ss.style.sketch == "1" ? "" : "none";
      gradientPanel.style.display = ss.style.sketch != "1" || fillStyle == "solid" || fillStyle == "auto" ? "" : "none";
    }
  });
  graph.getModel().addListener(mxEvent2.CHANGE, listener);
  this.listeners.push({
    destroy: function() {
      graph.getModel().removeListener(listener);
    }
  });
  listener();
  mxEvent2.addListener(gradientSelect, "change", function(evt) {
    graph.setCellStyles(mxConstants.STYLE_GRADIENT_DIRECTION, gradientSelect.value, graph.getSelectionCells());
    mxEvent2.consume(evt);
  });
  mxEvent2.addListener(fillStyleSelect, "change", function(evt) {
    graph.setCellStyles("fillStyle", fillStyleSelect.value, graph.getSelectionCells());
    mxEvent2.consume(evt);
  });
  container.appendChild(fillPanel);
  container.appendChild(gradientPanel);
  var custom = this.getCustomColors();
  for (var i = 0; i < custom.length; i++) {
    container.appendChild(this.createCellColorOption(custom[i].title, custom[i].key, custom[i].defaultValue));
  }
  return container;
};
AssetFormatPanel.prototype.getCustomColors = function() {
  var ss = this.format.getSelectionState();
  var result2 = [];
  if (ss.style.shape == "swimlane" || ss.style.shape == "table") {
    result2.push({
      title: mxResources.get("laneColor"),
      key: "swimlaneFillColor",
      defaultValue: "#ffffff"
    });
  }
  return result2;
};

// js/CommunicationFormatPanel.js
var CommunicationFormatPanel = function(format, editorUi, container) {
  BaseFormatPanel.call(this, format, editorUi, container);
  this.init();
};
function symbolicGibberish(length = 8) {
  const chars = "\u03B1\u03B2\u03B3\u03B4\u03B5\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C3\u03C4\u03C5\u03C6\u03C7\u03C8\u03C9\u0393\u0394\u0398\u039B\u039E\u03A0\u03A3\u03A6\u03A8\u03A90123456789/* \u09AD\u099F\u09CD\u099F\u09BE\u099A\u09BE\u09B0\u09CD\u09AF\u2735\u26BF";
  let result2 = "";
  for (let i = 0; i < length; i++) {
    result2 += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result2;
}
extend(CommunicationFormatPanel, BaseFormatPanel);
CommunicationFormatPanel.prototype.init = function() {
  var ui = this.editorUi;
  var panel = this.createPanel();
  this.exampleDataContainer = document.createElement("div");
  this.exampleDataContainer.id = "communication-panel-example-data-container";
  this.exampleDataContainer.style.position = "relative";
  this.exampleDataContainer.style.width = "100%";
  this.exampleDataContainer.style.height = "70px";
  this.exampleDataContainer.style.display = "flex";
  this.exampleDataContainer.style.flexDirection = "column";
  this.exampleDataContainer.style.alignItems = "center";
  this.exampleDataContainer.style.justifyContent = "center";
  this.exampleDataContainer.style.overflow = "hidden";
  this.exampleDataContainer.style.borderRadius = "4px";
  this.exampleDataContainer.style.marginTop = "5px";
  this.exampleDataContainer.style.marginBottom = "15px";
  this.exampleDataContainer.style.boxSizing = "border-box";
  this.exampleDataContainer.style.pointerEvents = "auto";
  this.exampleDataContainer.style.setProperty("--bg-angle", "45deg");
  this.exampleDataContainer.style.setProperty("--color1", "#0d0d1a");
  this.exampleDataContainer.style.setProperty("--color2", "#1a1a2e");
  this.exampleDataContainer.style.setProperty("--color3", "#0d0d1a");
  this.exampleDataContainer.style.setProperty("--border-color", "rgba(0, 150, 255, 0.6)");
  this.exampleDataContainer.style.setProperty("--shadow-color", "rgba(0, 150, 255, 0.3)");
  this.exampleDataContainer.style.background = `linear-gradient(var(--bg-angle), var(--color1), var(--color2), var(--color3))`;
  this.exampleDataContainer.style.backgroundSize = "400% 400%";
  this.exampleDataContainer.style.border = "1px solid var(--border-color)";
  this.exampleDataContainer.style.boxShadow = `0 0 12px 2px var(--shadow-color), inset 0 0 15px rgba(0,0,0,0.6)`;
  this.exampleDataContainer.style.animation = "gradientShift 10s ease infinite alternate, borderPulse 2.5s infinite alternate";
  this.exampleDataContainer.style.padding = "4px 0";
  this.exampleDataElement = document.createElement("div");
  this.exampleDataElement.id = "communication-panel-example-data";
  this.exampleDataElement.style.fontFamily = '"Nova Mono", "Share Tech Mono", monospace';
  this.exampleDataElement.style.fontSize = "10px";
  this.exampleDataElement.style.lineHeight = "1.2";
  this.exampleDataElement.style.padding = "2px 8px";
  this.exampleDataElement.style.textAlign = "center";
  this.exampleDataElement.style.color = "rgba(200, 220, 255, 0.95)";
  this.exampleDataElement.style.textShadow = "0 0 5px rgba(100, 180, 255, 0.6)";
  this.exampleDataElement.style.letterSpacing = "0.3px";
  this.exampleDataElement.style.whiteSpace = "pre-line";
  this.exampleDataElement.style.overflow = "hidden";
  this.exampleDataElement.style.textOverflow = "ellipsis";
  this.exampleDataElement.style.width = "calc(100% - 10px)";
  this.exampleDataSubtitleElement = document.createElement("div");
  this.exampleDataSubtitleElement.id = "communication-panel-example-data-subtitle";
  this.exampleDataSubtitleElement.style.fontFamily = '"Share Tech Mono", "Courier New", monospace';
  this.exampleDataSubtitleElement.style.fontSize = "9px";
  this.exampleDataSubtitleElement.style.lineHeight = "1.2";
  this.exampleDataSubtitleElement.style.padding = "1px 8px";
  this.exampleDataSubtitleElement.style.textAlign = "center";
  this.exampleDataSubtitleElement.style.color = "rgba(160, 180, 210, 0.85)";
  this.exampleDataSubtitleElement.style.whiteSpace = "nowrap";
  this.exampleDataSubtitleElement.style.overflow = "hidden";
  this.exampleDataSubtitleElement.style.textOverflow = "ellipsis";
  this.exampleDataSubtitleElement.style.width = "calc(100% - 10px)";
  this.exampleDataSubtitleElement.style.fontStyle = "italic";
  this.exampleDataSubtitleElement.style.marginTop = "2px";
  this.exampleDataContainer.appendChild(this.exampleDataElement);
  this.exampleDataContainer.appendChild(this.exampleDataSubtitleElement);
  if (this.container.firstChild) {
    this.container.insertBefore(this.exampleDataContainer, this.container.firstChild);
  } else {
    this.container.appendChild(this.exampleDataContainer);
  }
  var dynamicMenu = this.addCommunicationMenuDynamic(panel);
  this.container.appendChild(dynamicMenu);
  this.updateExampleDataDisplay();
  if (!document.getElementById("commPanelAnimations")) {
    const styleSheet = document.createElement("style");
    styleSheet.id = "commPanelAnimations";
    styleSheet.type = "text/css";
    styleSheet.innerText = `
      @keyframes gradientShift { /* ... */ }
      @keyframes borderPulse { /* ... */ }
      @keyframes textGlow { /* ... */ }
    `;
    document.head.appendChild(styleSheet);
  }
};
CommunicationFormatPanel.prototype.addCommunicationMenuDynamic = function(container) {
  let self = this;
  var typeProperties = {
    key: {
      description: "key",
      type: "button",
      tooltip: "The identifier for the yaml element",
      defaultValue: "<Your title>",
      section: "General"
    },
    target: {
      description: "target",
      type: "button",
      section: "General",
      tooltip: "",
      defaultValue: "<Your ID>"
    },
    description: {
      description: "Description",
      type: "button",
      tooltip: "Provide a brief description of the component.",
      defaultValue: "<Your Description>",
      section: "General"
    },
    protocol: {
      description: "Protocol",
      type: "select",
      options: [
        {
          group: "Web Protocols",
          options: [
            "http",
            "https",
            "ws",
            "wss",
            "reverse-proxy-web-protocol",
            "reverse-proxy-web-protocol-encrypted"
          ]
        },
        {
          group: "Database Protocols",
          options: [
            "jdbc",
            "jdbc-encrypted",
            "odbc",
            "odbc-encrypted",
            "sql-access-protocol",
            "sql-access-protocol-encrypted",
            "nosql-access-protocol",
            "nosql-access-protocol-encrypted"
          ]
        },
        {
          group: "General Protocols",
          options: [
            "unknown-protocol",
            "mqtt",
            "binary",
            "binary-encrypted",
            "text",
            "text-encrypted",
            "ssh",
            "ssh-tunnel"
          ]
        },
        {
          group: "Mail Protocols",
          options: [
            "smtp",
            "smtp-encrypted",
            "pop3",
            "pop3-encrypted",
            "imap",
            "imap-encrypted"
          ]
        },
        {
          group: "File Transfer Protocols",
          options: [
            "ftp",
            "ftps",
            "sftp",
            "scp",
            "nfs",
            "smb",
            "smb-encrypted",
            "local-file-access"
          ]
        },
        {
          group: "Various Protocols",
          options: [
            "ldap",
            "ldaps",
            "jms",
            "nrpe",
            "xmpp",
            "iiop",
            "iiop-encrypted",
            "jrmp",
            "jrmp-encrypted",
            "in-process-library-call",
            "container-spawning"
          ]
        }
      ],
      section: "Properties",
      defaultValue: 0
    },
    authentication: {
      description: "Authentication",
      type: "select",
      options: [
        {
          group: "Authentication Types",
          options: [
            "none",
            "credentials",
            "session-id",
            "token",
            "client-certificate",
            "two-factor",
            "externalized"
          ],
          defaultValue: "none"
        }
      ],
      tooltip: "Select the authentication method for the component.",
      section: "Properties",
      defaultValue: 0
    },
    authorization: {
      description: "Authorization",
      type: "select",
      options: [
        {
          group: "Authorization Types",
          options: ["none", "technical-user", "enduser-identity-propagation"],
          defaultValue: "none"
        }
      ],
      tooltip: "Select the authorization level for the component.",
      section: "Properties",
      defaultValue: 0
    },
    usage: {
      description: "Usage",
      type: "select",
      options: [
        {
          group: "Usage Type",
          options: ["business", "devops"],
          defaultValue: "business"
        }
      ],
      tooltip: "Select the usage type of the component.",
      section: "Properties",
      defaultValue: 0
    },
    tags: {
      description: "Tags",
      type: "array",
      uniqueItems: true,
      items: {
        type: "button"
      },
      tooltip: "Add any tags associated with the component.",
      defaultValue: [],
      section: "Properties"
    },
    vpn: {
      description: "VPN",
      type: "checkbox",
      tooltip: "Check if the component is accessed over VPN.",
      defaultValue: false,
      section: "Properties"
    },
    ip_filtered: {
      description: "IP filtered",
      type: "checkbox",
      tooltip: "Check if the component is IP filtered.",
      defaultValue: false,
      section: "Properties"
    },
    readonly: {
      description: "Readonly",
      type: "checkbox",
      tooltip: "Check if the component is readonly.",
      defaultValue: false,
      section: "Properties"
    }
  };
  this.typePropertiesForAnimation = typeProperties;
  {
    let cell3 = self.editorUi.editor.graph.getSelectionCell();
    cell3.source = self.editorUi.editor.graph.model.getTerminal(cell3, true);
    cell3.target = self.editorUi.editor.graph.model.getTerminal(cell3, false);
    let idtarget = self.editorUi.editor.graph.model.threagile.getIn(["technical_assets", cell3.target.technicalAsset.key, "id"]);
    if (!cell3.communicationAsset) {
      {
        let comId = generateUniqueCommkeyData(self.editorUi.editor.graph);
        const communicationLinkProperties = {
          target: idtarget,
          description: "your description",
          protocol: "http",
          authentication: "none",
          authorization: "none",
          tags: [],
          vpn: false,
          ip_filtered: false,
          readonly: false,
          usage: "business",
          data_assets_sent: [],
          data_assets_received: []
        };
        const path = ["technical_assets", cell3.source.technicalAsset.key, "communication_links", comId];
        Object.keys(communicationLinkProperties).forEach((property2) => {
          self.editorUi.editor.graph.model.threagile.setIn([...path, property2], communicationLinkProperties[property2]);
        });
        cell3.communicationAsset = self.editorUi.editor.graph.model.threagile.getIn(["technical_assets", cell3.source.technicalAsset.key, "communication_links", comId]);
        cell3.communicationAssetKey = comId;
      }
    }
  }
  var customListener2 = {
    install: function(apply) {
      this.listener = function() {
      };
    },
    destroy: function() {
    }
  };
  let sections = {};
  for (let property2 in typeProperties) {
    let sectionName = typeProperties[property2].section;
    if (!sections[sectionName]) {
      sections[sectionName] = createSection(sectionName);
    }
    let typeItem = document.createElement("li");
    typeItem.style.display = "flex";
    typeItem.style.alignItems = "baseline";
    typeItem.style.marginBottom = "8px";
    let propertyName = document.createElement("span");
    propertyName.innerHTML = property2;
    propertyName.style.width = "100px";
    propertyName.style.marginRight = "10px";
    let propertyType = typeProperties[property2].type;
    if (propertyType === "select") {
      const propertySelect = property2;
      typeItem.appendChild(propertyName);
      let selectContainer = document.createElement("div");
      selectContainer.style.display = "flex";
      selectContainer.style.alignItems = "center";
      selectContainer.style.marginLeft = "auto";
      let selectDropdown = document.createElement("select");
      selectDropdown.style.width = "100px";
      selectDropdown.title = typeProperties[property2].tooltip;
      selectContainer.appendChild(selectDropdown);
      let optionGroups = typeProperties[property2].options;
      for (var i = 0; i < optionGroups.length; i++) {
        let optgroup = document.createElement("optgroup");
        optgroup.label = optionGroups[i].group;
        let options = optionGroups[i].options;
        for (let j = 0; j < options.length; j++) {
          let option = document.createElement("option");
          option.value = options[j];
          option.text = options[j];
          optgroup.appendChild(option);
        }
        selectDropdown.appendChild(optgroup);
      }
      let cell3 = self.editorUi.editor.graph.getSelectionCell();
      let commAsset2;
      if (typeof cell3.communicationAsset.toJSON === "function") {
        commAsset2 = cell3.communicationAsset.toJSON();
      } else {
        commAsset2 = cell3.communicationAsset;
      }
      if (commAsset2[propertySelect]) {
        selectDropdown.value = commAsset2[propertySelect];
      }
      let createChangeListener = function(selectDropdown2, propertySelect2) {
        return function(evt) {
          var vals = selectDropdown2.value;
          let currentCell = self.editorUi.editor.graph.getSelectionCell();
          if (vals != null && currentCell && currentCell.communicationAsset) {
            self.editorUi.editor.graph.model.threagile.setIn(["technical_assets", currentCell.source.technicalAsset.key, "communication_links", currentCell.communicationAssetKey, propertySelect2], selectDropdown2.value);
            self.updateExampleDataDisplay();
          }
          mxEvent2.consume(evt);
        };
      };
      mxEvent2.addListener(selectDropdown, "change", createChangeListener(selectDropdown, propertySelect));
      typeItem.appendChild(selectContainer);
      sections[sectionName].appendChild(typeItem);
    } else if (propertyType === "checkbox") {
      let createCustomOptionCommunicationLink = function(self2, parameter) {
        return function() {
          var cells2 = self2.editorUi.editor.graph.getSelectionCells();
          if (cells2 != null && cells2.length > 0) {
            let cell3 = self2.editorUi.editor.graph.getSelectionCell();
            return self2.editorUi.editor.graph.model.threagile.getIn(["technical_assets", cell3.source.technicalAsset.key, "communication_links", cell3.communicationAssetKey, parameter]);
          }
        };
      }, setCustomOptionCommunicationLink = function(self2, parameter) {
        return function(checked) {
          var cells2 = self2.editorUi.editor.graph.getSelectionCells();
          if (cells2 != null && cells2.length > 0) {
            let cell3 = self2.editorUi.editor.graph.getSelectionCell();
            self2.editorUi.editor.graph.model.threagile.setIn(["technical_assets", cell3.source.technicalAsset.key, "communication_links", cell3.communicationAssetKey, parameter], checked);
            self2.updateExampleDataDisplay();
          }
        };
      };
      let optionElement = this.createOption(property2, createCustomOptionCommunicationLink(self, property2), setCustomOptionCommunicationLink(self, property2), customListener2);
      optionElement.querySelector('input[type="checkbox"]').title = typeProperties[property2].tooltip;
      sections[sectionName].appendChild(optionElement);
    } else if (propertyType === "button") {
      let button2 = button(property2, bind(this, function(evt) {
        let cell3 = self.editorUi.editor.graph.getSelectionCell();
        let commAsset2 = self.editorUi.editor.graph.model.threagile.getIn(["technical_assets", cell3.source.technicalAsset.key, "communication_links", cell3.communicationAssetKey]);
        if (typeof cell3.communicationAsset.toJSON === "function") {
          commAsset2 = self.editorUi.editor.graph.model.threagile.getIn(["technical_assets", cell3.source.technicalAsset.key, "communication_links", cell3.communicationAssetKey]).toJSON();
        }
        let dataValue = cell3 && commAsset2[property2] ? commAsset2[property2] : typeProperties[property2].defaultValue;
        if (property2 == "key") {
          dataValue = cell3.communicationAssetKey;
        }
        var dlg = new TextareaDialog(this.editorUi, property2 + ":", dataValue, function(newValue) {
          if (newValue != null) {
            if (cell3) {
              if (property2 === "Id") {
                var adjustedValue = newValue.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                let model = self.editorUi.editor.graph.model;
                model.beginUpdate();
                try {
                  model.setValue(cell3, adjustedValue);
                  self.editorUi.editor.graph.refresh(cell3);
                  self.editorUi.editor.graph.refresh();
                } finally {
                  model.endUpdate();
                }
              }
              if (property2 == "key") {
                restartWasm();
                let oldassetPath = ["technical_assets", cell3.source.technicalAsset.key, "communication_links", cell3.communicationAssetKey];
                let object = JSON.parse(JSON.stringify(self.editorUi.editor.graph.model.threagile.getIn(oldassetPath)));
                self.editorUi.editor.graph.model.threagile.deleteIn(oldassetPath);
                cell3.communicationAssetKey = newValue;
                let newassetPath = ["technical_assets", cell3.source.technicalAsset.key, "communication_links", cell3.communicationAssetKey];
                self.editorUi.editor.graph.model.threagile.setIn(newassetPath, object);
                cell3.communicationAsset = self.editorUi.editor.graph.model.threagile.getIn(newassetPath);
                let restoreIntegrity = self.editorUi.editor.graph.model.threagile.toString();
                self.editorUi.editor.graph.model.threagile = YAML.parseDocument(restoreIntegrity);
              } else {
                self.editorUi.editor.graph.model.threagile.setIn(["technical_assets", cell3.source.technicalAsset.key, "communication_links", cell3.communicationAssetKey, property2], newValue);
              }
            }
          }
        }, null, null, 400, 220);
        this.editorUi.showDialog(dlg.container, 420, 300, true, true);
        dlg.init();
        try {
          if (dlg.textarea) {
            let textareaId = `threagile-dialog-${property2}-textarea`;
            dlg.textarea.id = textareaId;
            console.log(`Added ID to textarea: ${textareaId}`);
          } else {
            console.warn(`Could not find dlg.textarea for property '${property2}'.`);
          }
        } catch (e) {
          console.error("Error adding ID to dialog textarea:", e);
        }
        try {
          let buttonContainer = dlg.container.querySelector(".geDialogButtons");
          let buttons = buttonContainer ? buttonContainer.querySelectorAll("button") : dlg.container.querySelectorAll("button");
          if (buttons && buttons.length > 0) {
            const applyText = mxResources.get("apply") || "Apply";
            const cancelText = mxResources.get("cancel") || "Cancel";
            let applyFound = false;
            let cancelFound = false;
            buttons.forEach((btn) => {
              if (!applyFound && (btn.textContent.trim() === applyText || btn.textContent.trim() === (mxResources.get("ok") || "OK"))) {
                btn.id = `threagile-dialog-${property2}-apply-button`;
                applyFound = true;
              } else if (!cancelFound && btn.textContent.trim() === cancelText) {
                btn.id = `threagile-dialog-${property2}-cancel-button`;
                cancelFound = true;
              }
            });
          } else {
            console.warn("Could not find buttons in TextareaDialog container for property:", property2);
          }
        } catch (e) {
          console.error("Error adding IDs to dialog buttons:", e);
        }
        if (property2 == "target") {
          dlg.textarea.readOnly = true;
          dlg.textarea.style.backgroundColor = "#f3f3f3";
          dlg.textarea.style.color = "#686868";
          dlg.textarea.style.border = "1px solid #ccc";
        }
      }));
      button2.title = typeProperties[property2].tooltip;
      button2.style.width = "200px";
      typeItem.appendChild(button2);
      sections[sectionName].appendChild(typeItem);
    }
  }
  for (let sectionName in sections) {
    container.appendChild(sections[sectionName]);
  }
  let tmpData = self.editorUi.editor.graph.model.threagile.getIn(["data_assets"]);
  var diagramData = tmpData === void 0 ? [] : tmpData;
  if (typeof diagramData.toJSON === "function") {
    diagramData = diagramData.toJSON();
  }
  let idsData = [];
  Object.keys(diagramData).forEach(function(property2) {
    idsData.push(property2);
  });
  let inputElement = document.createElement("input");
  inputElement.id = "data_send_tagify";
  inputElement.placeholder = "Data sent";
  let cells = self.editorUi.editor.graph.getSelectionCells();
  let cell2 = cells && cells.length > 0 ? cells[0] : null;
  let sentSection = createSection("Data Sent:");
  sentSection.appendChild(document.createElement("br"));
  let commAsset = cell2.communicationAsset;
  if (typeof cell2.communicationAsset.toJSON === "function") {
    commAsset = cell2.communicationAsset.toJSON();
  }
  if (cell2 && commAsset.data_assets_sent) {
    let matches = [];
    inputElement.value = commAsset.data_assets_sent;
    for (let key in diagramData) {
      if (diagramData.hasOwnProperty(key)) {
        let item = diagramData[key];
        for (let id of commAsset.data_assets_sent) {
          if (item.id === id) {
            matches.push(key);
            break;
          }
        }
      }
    }
    inputElement.value = matches;
  }
  sentSection.appendChild(inputElement);
  let tinput = document.querySelector('input[name="input-custom-dropdown"]');
  let tagify1 = new Tagify(inputElement, {
    whitelist: idsData,
    dropdown: {
      maxItems: 100,
      classname: "tags-look",
      enabled: 0,
      closeOnSelect: false
    }
  });
  function addComSent(e) {
    let currentCell = self.editorUi.editor.graph.getSelectionCell();
    if (!currentCell || !currentCell.communicationAsset)
      return;
    let currentCommAsset = typeof currentCell.communicationAsset.toJSON === "function" ? currentCell.communicationAsset.toJSON() : currentCell.communicationAsset;
    let dataKey = e.detail.data.value;
    let dataId = diagramData[dataKey]?.id;
    if (dataId && currentCommAsset.data_assets_sent && !currentCommAsset.data_assets_sent.includes(dataId)) {
      currentCommAsset.data_assets_sent.push(dataId);
      self.editorUi.editor.graph.model.threagile.setIn(["technical_assets", currentCell.source.technicalAsset.key, "communication_links", currentCell.communicationAssetKey, "data_assets_sent"], currentCommAsset.data_assets_sent);
      self.updateExampleDataDisplay();
    }
  }
  function removeComSent(e) {
    let currentCell = self.editorUi.editor.graph.getSelectionCell();
    if (!currentCell || !currentCell.communicationAsset)
      return;
    let currentCommAsset = typeof currentCell.communicationAsset.toJSON === "function" ? currentCell.communicationAsset.toJSON() : currentCell.communicationAsset;
    let dataKey = e.detail.data.value;
    let dataId = diagramData[dataKey]?.id;
    if (dataId && currentCommAsset.data_assets_sent) {
      currentCommAsset.data_assets_sent = currentCommAsset.data_assets_sent.filter((asset) => asset !== dataId);
      self.editorUi.editor.graph.model.threagile.setIn(["technical_assets", currentCell.source.technicalAsset.key, "communication_links", currentCell.communicationAssetKey, "data_assets_sent"], currentCommAsset.data_assets_sent);
      self.updateExampleDataDisplay();
    }
  }
  tagify1.on("add", addComSent).on("remove", removeComSent);
  container.appendChild(sentSection);
  let inputElement2 = document.createElement("input");
  inputElement.id = "receivedtagifyid";
  inputElement2.placeholder = "Data received";
  let receivedSecion = createSection("Data Received:");
  receivedSecion.appendChild(document.createElement("br"));
  if (cell2 && commAsset.data_assets_received) {
    let matches = [];
    for (let key in diagramData) {
      if (diagramData.hasOwnProperty(key)) {
        let item = diagramData[key];
        for (let id of commAsset.data_assets_received) {
          if (item.id === id) {
            matches.push(key);
            break;
          }
        }
      }
    }
    inputElement2.value = matches;
  }
  receivedSecion.appendChild(inputElement2);
  let tinput2 = document.querySelector('input[name="input-custom-dropdown"]');
  let tagify2 = new Tagify(inputElement2, {
    whitelist: idsData,
    dropdown: {
      maxItems: 20,
      classname: "tags-look",
      enabled: 0,
      closeOnSelect: false
    }
  });
  function addComReceived(e) {
    let currentCell = self.editorUi.editor.graph.getSelectionCell();
    if (!currentCell || !currentCell.communicationAsset)
      return;
    let currentCommAsset = typeof currentCell.communicationAsset.toJSON === "function" ? currentCell.communicationAsset.toJSON() : currentCell.communicationAsset;
    let dataKey = e.detail.data.value;
    let dataId = diagramData[dataKey]?.id;
    if (dataId && currentCommAsset.data_assets_received && !currentCommAsset.data_assets_received.includes(dataId)) {
      currentCommAsset.data_assets_received.push(dataId);
      self.editorUi.editor.graph.model.threagile.setIn(["technical_assets", currentCell.source.technicalAsset.key, "communication_links", currentCell.communicationAssetKey, "data_assets_received"], currentCommAsset.data_assets_received);
      self.updateExampleDataDisplay();
    }
  }
  function removeComReceived(e) {
    let currentCell = self.editorUi.editor.graph.getSelectionCell();
    if (!currentCell || !currentCell.communicationAsset)
      return;
    let currentCommAsset = typeof currentCell.communicationAsset.toJSON === "function" ? currentCell.communicationAsset.toJSON() : currentCell.communicationAsset;
    let dataKey = e.detail.data.value;
    let dataId = diagramData[dataKey]?.id;
    if (dataId && currentCommAsset.data_assets_received) {
      currentCommAsset.data_assets_received = currentCommAsset.data_assets_received.filter((asset) => asset !== dataId);
      self.editorUi.editor.graph.model.threagile.setIn(["technical_assets", currentCell.source.technicalAsset.key, "communication_links", currentCell.communicationAssetKey, "data_assets_received"], currentCommAsset.data_assets_received);
      self.updateExampleDataDisplay();
    }
  }
  tagify2.DOM.scope.addEventListener("click", () => {
    tagify2.DOM.input.focus();
  });
  tagify2.on("add", addComReceived).on("remove", removeComReceived);
  container.appendChild(receivedSecion);
  return container;
};
CommunicationFormatPanel.prototype.generateExampleData = function(protocol, commAssetData) {
  const Protocol = {
    UnknownProtocol: "unknown-protocol",
    HTTP: "http",
    HTTPS: "https",
    WS: "ws",
    WSS: "wss",
    ReverseProxyWebProtocol: "reverse-proxy-web-protocol",
    ReverseProxyWebProtocolEncrypted: "reverse-proxy-web-protocol-encrypted",
    MQTT: "mqtt",
    JDBC: "jdbc",
    JDBCEncrypted: "jdbc-encrypted",
    ODBC: "odbc",
    ODBCEncrypted: "odbc-encrypted",
    SQLAccessProtocol: "sql-access-protocol",
    SQLAccessProtocolEncrypted: "sql-access-protocol-encrypted",
    NoSQLAccessProtocol: "nosql-access-protocol",
    NoSQLAccessProtocolEncrypted: "nosql-access-protocol-encrypted",
    BINARY: "binary",
    BINARYEncrypted: "binary-encrypted",
    TEXT: "text",
    TEXTEncrypted: "text-encrypted",
    SSH: "ssh",
    SSHTunnel: "ssh-tunnel",
    SMTP: "smtp",
    SMTPEncrypted: "smtp-encrypted",
    POP3: "pop3",
    POP3Encrypted: "pop3-encrypted",
    IMAP: "imap",
    IMAPEncrypted: "imap-encrypted",
    FTP: "ftp",
    FTPS: "ftps",
    SFTP: "sftp",
    SCP: "scp",
    LDAP: "ldap",
    LDAPS: "ldaps",
    JMS: "jms",
    NFS: "nfs",
    SMB: "smb",
    SMBEncrypted: "smb-encrypted",
    LocalFileAccess: "local-file-access",
    NRPE: "nrpe",
    XMPP: "xmpp",
    IIOP: "iiop",
    IIOPEncrypted: "iiop-encrypted",
    JRMP: "jrmp",
    JRMPEncrypted: "jrmp-encrypted",
    InProcessLibraryCall: "in-process-library-call",
    ContainerSpawning: "container-spawning"
  };
  const isEncrypted = protocol.endsWith("-encrypted") || [Protocol.HTTPS, Protocol.WSS, Protocol.ReverseProxyWebProtocolEncrypted, Protocol.SSHTunnel, Protocol.FTPS, Protocol.SFTP, Protocol.SCP, Protocol.LDAPS, Protocol.SMTPEncrypted, Protocol.POP3Encrypted, Protocol.IMAPEncrypted].includes(protocol);
  const auth = commAssetData?.authentication || "none";
  const usage = commAssetData?.usage || "devops";
  const sentData = commAssetData?.data_assets_sent || [];
  const receivedData = commAssetData?.data_assets_received || [];
  const allDataAssets = [.../* @__PURE__ */ new Set([...sentData, ...receivedData])];
  let maxConfidentiality = "confidential";
  let maxIntegrity = "important";
  let maxAvailability = "important";
  allDataAssets.forEach((assetKey) => {
    const dataAssetNode = this.editorUi.editor.graph.model.threagile.getIn(["data_assets", assetKey]);
    if (dataAssetNode) {
      const dataAsset = typeof dataAssetNode.toJSON === "function" ? dataAssetNode.toJSON() : dataAssetNode;
      if (dataAsset.confidentiality === "strictly_confidential")
        maxConfidentiality = "strictly_confidential";
      else if (dataAsset.confidentiality === "restricted" && maxConfidentiality !== "strictly_confidential")
        maxConfidentiality = "restricted";
      if (dataAsset.integrity === "mission_critical")
        maxIntegrity = "mission_critical";
      else if (dataAsset.integrity === "critical" && maxIntegrity !== "mission_critical")
        maxIntegrity = "critical";
      if (dataAsset.availability === "mission_critical")
        maxAvailability = "mission_critical";
      else if (dataAsset.availability === "critical" && maxAvailability !== "mission_critical")
        maxAvailability = "critical";
    }
  });
  const highConfidentiality = maxConfidentiality === "strictly_confidential" || maxConfidentiality === "restricted";
  const highIntegrity = maxIntegrity === "mission_critical" || maxIntegrity === "critical";
  const highAvailability = maxAvailability === "mission_critical" || maxAvailability === "critical";
  let oneLiner = `[${protocol.toUpperCase()}] `;
  let subtitle = "";
  let container = this.exampleDataContainer;
  let element = this.exampleDataElement;
  let subtitleElement = this.exampleDataSubtitleElement;
  container.style.setProperty("--bg-angle", "45deg");
  container.style.setProperty("--color1", "#0d0d1a");
  container.style.setProperty("--color2", "#1a1a2e");
  container.style.setProperty("--color3", "#0d0d1a");
  container.style.setProperty("--border-color", "rgba(0, 150, 255, 0.6)");
  container.style.setProperty("--shadow-color", "rgba(0, 150, 255, 0.3)");
  container.style.setProperty("--border-highlight", "rgba(50, 200, 255, 0.8)");
  container.style.setProperty("--shadow-highlight", "rgba(50, 200, 255, 0.5)");
  element.style.color = "rgba(200, 220, 255, 0.95)";
  element.style.setProperty("--text-glow-start", "rgba(100, 180, 255, 0.7)");
  element.style.setProperty("--text-glow-end", "rgba(150,200,255,0.9)");
  element.style.animation = "textGlow 3s infinite alternate";
  subtitleElement.style.color = "rgba(160, 180, 210, 0.85)";
  if (isEncrypted) {
    oneLiner += `\u{1F6E1}\uFE0F Secure Channel
Data: ${symbolicGibberish(10)}`;
    container.style.setProperty("--color1", "#002211");
    container.style.setProperty("--color2", "#003a1e");
    container.style.setProperty("--color3", "#001f0c");
    container.style.setProperty("--border-color", "rgba(0, 200, 100, 0.6)");
    container.style.setProperty("--shadow-color", "rgba(0, 200, 100, 0.4)");
    container.style.setProperty("--border-highlight", "rgba(80, 255, 150, 0.8)");
    container.style.setProperty("--shadow-highlight", "rgba(80, 255, 150, 0.6)");
    element.style.color = "rgba(180, 255, 200, 0.95)";
    element.style.setProperty("--text-glow-start", "rgba(80,220,150,0.6)");
    element.style.setProperty("--text-glow-end", "rgba(120,255,180,0.8)");
    subtitleElement.style.color = "rgba(140, 210, 160, 0.9)";
    if (highConfidentiality)
      subtitle = "Encrypted PII, Financial Records";
    else if (highIntegrity)
      subtitle = "Encrypted Transaction Logs, System State";
    else
      subtitle = "Encrypted General Data";
  } else {
    oneLiner += `\u{1F4AC} Clear Text Channel
`;
    if (auth !== "none" || highConfidentiality || protocol === Protocol.FTP || protocol === Protocol.HTTP && auth === "credentials") {
      oneLiner += `\u26A0\uFE0F Sensitive? Auth: ${auth}`;
      container.style.setProperty("--bg-angle", "135deg");
      container.style.setProperty("--color1", "#330000");
      container.style.setProperty("--color2", "#550000");
      container.style.setProperty("--color3", "#220000");
      container.style.setProperty("--border-color", "rgba(255, 50, 50, 0.7)");
      container.style.setProperty("--shadow-color", "rgba(255, 50, 50, 0.5)");
      container.style.setProperty("--border-highlight", "rgba(255, 100, 100, 0.9)");
      container.style.setProperty("--shadow-highlight", "rgba(255, 100, 100, 0.7)");
      element.style.color = "rgba(255, 180, 180, 0.95)";
      element.style.setProperty("--text-glow-start", "rgba(255,100,100,0.7)");
      element.style.setProperty("--text-glow-end", "rgba(255,150,150,0.9)");
      subtitleElement.style.color = "rgba(220, 150, 150, 0.9)";
      if (protocol === Protocol.HTTP && auth === "credentials") {
        oneLiner = `[HTTP] \u{1F525} EXPOSED CREDS!
(admin:P@$$wOrd) :: CRITICAL`;
        subtitle = "Admin password sent in clear text!";
      } else if (protocol === Protocol.FTP) {
        oneLiner = `[FTP] \u26A0\uFE0F PASSWORDS IN CLEAR
(user:P@$$wOrd) :: INSECURE`;
        subtitle = "FTP credentials and data unencrypted.";
      } else if (highConfidentiality) {
        subtitle = "Unencrypted SSN, Admin Passwords";
      } else {
        subtitle = "Unencrypted Session IDs, User Details";
      }
    } else {
      oneLiner += `Data: ${symbolicGibberish(12)}`;
      container.style.setProperty("--bg-angle", "90deg");
      container.style.setProperty("--color1", "#332200");
      container.style.setProperty("--color2", "#553300");
      container.style.setProperty("--color3", "#221100");
      container.style.setProperty("--border-color", "rgba(255, 150, 0, 0.6)");
      container.style.setProperty("--shadow-color", "rgba(255, 150, 0, 0.4)");
      container.style.setProperty("--border-highlight", "rgba(255, 180, 50, 0.8)");
      container.style.setProperty("--shadow-highlight", "rgba(255, 180, 50, 0.6)");
      element.style.color = "rgba(255, 220, 150, 0.95)";
      element.style.setProperty("--text-glow-start", "rgba(255,180,100,0.6)");
      element.style.setProperty("--text-glow-end", "rgba(255,200,120,0.8)");
      subtitleElement.style.color = "rgba(210, 180, 120, 0.9)";
      subtitle = "Unencrypted Product IDs, Public Logs";
    }
  }
  if (!subtitle || subtitle === "Encrypted General Data" || subtitle === "Unencrypted Product IDs, Public Logs") {
    if (highIntegrity && usage === "business") {
      subtitle = `${isEncrypted ? "Encrypted" : ""} Patient Vitals, Financial Transactions`;
    } else if (highAvailability && usage === "business") {
      subtitle = `${isEncrypted ? "Encrypted" : ""} SCADA Commands, Emergency Alerts`;
    } else if (highConfidentiality) {
      subtitle = `${isEncrypted ? "Encrypted" : ""} Sensitive Config, API Keys`;
    }
  }
  if (usage === "business" && !isEncrypted && (auth !== "none" || highConfidentiality || highIntegrity)) {
    oneLiner += ` \u{1F3E5} CRITICAL!`;
    container.style.animationDuration = "1.5s, 5s";
  } else if (usage === "business" && isEncrypted) {
    oneLiner += ` \u{1F3E5}`;
    container.style.animationDuration = "2s, 8s";
  } else {
    container.style.animationDuration = "2.5s, 10s";
  }
  switch (protocol) {
    case Protocol.HTTP:
      if (auth !== "credentials" && highConfidentiality)
        subtitle = "Unencrypted PII over HTTP";
      else if (auth !== "credentials")
        subtitle = "General web traffic, API calls";
      break;
    case Protocol.SSH:
    case Protocol.SFTP:
    case Protocol.SCP:
    case Protocol.SSHTunnel:
      subtitle = `Encrypted commands & file transfers (system config, backups)`;
      if (protocol === Protocol.SSHTunnel)
        subtitle = `Encrypted tunnel for other protocols (DB access)`;
      break;
    case Protocol.MQTT:
      if (usage === "business") {
        subtitle = `${isEncrypted ? "Encrypted" : ""} IoT Sensor Data (Vitals, Industrial Controls)`;
      } else {
        subtitle = `${isEncrypted ? "Encrypted" : ""} Smart Home Device Status`;
      }
      break;
    case Protocol.JDBC:
    case Protocol.ODBC:
    case Protocol.SQLAccessProtocol:
      oneLiner = `[${protocol.toUpperCase()}] \u{1F5C3}\uFE0F DB Query
`;
      if (highConfidentiality) {
        oneLiner += `\u26A0\uFE0F Sensitive Data Access!`;
        subtitle = `Clear text SQL queries for PII, financial data. Encrypt connection!`;
      } else {
        oneLiner += `Generic SQL`;
        subtitle = `Clear text SQL for product info. Consider encryption if internal.`;
      }
      break;
    case Protocol.JDBCEncrypted:
    case Protocol.ODBCEncrypted:
    case Protocol.SQLAccessProtocolEncrypted:
      if (highConfidentiality)
        subtitle = `Encrypted SQL queries for PII, financial data.`;
      else
        subtitle = `Encrypted SQL for general database access.`;
      break;
    case Protocol.NoSQLAccessProtocol:
      oneLiner = `[NoSQL] \u{1F4C4} Document Store
`;
      if (highConfidentiality) {
        oneLiner += `\u26A0\uFE0F Unencrypted Sensitive Docs!`;
        subtitle = `Clear text NoSQL queries for user profiles, logs. Encrypt!`;
      } else {
        oneLiner += `Generic Ops`;
        subtitle = `Clear text NoSQL for catalog data.`;
      }
      break;
    case Protocol.NoSQLAccessProtocolEncrypted:
      subtitle = `Encrypted NoSQL queries for sensitive documents.`;
      break;
    case Protocol.LDAP:
      oneLiner = `[LDAP] \u{1F464} Directory Query
\u26A0\uFE0F Clear Text Auth Possible!`;
      subtitle = `Unencrypted user lookups, group memberships. Use LDAPS.`;
      if (auth !== "none")
        subtitle += " Potential credential exposure.";
      break;
    case Protocol.LDAPS:
      subtitle = `Encrypted user authentication, directory synchronization.`;
      break;
    case Protocol.SMTP:
      oneLiner = `[SMTP] \u2709\uFE0F Email Transfer
`;
      if (highConfidentiality || auth !== "none") {
        oneLiner += `\u26A0\uFE0F Unencrypted Content/Auth!`;
        subtitle = `Clear text emails (PII, reports), potentially passwords. Use SMTPS/STARTTLS.`;
      } else {
        oneLiner += `Standard Mail`;
        subtitle = `General unencrypted email. Risk of interception.`;
      }
      break;
    case Protocol.SMTPEncrypted:
      subtitle = `Encrypted email content and authentication.`;
      break;
    case Protocol.FTPS:
      subtitle = "Encrypted file transfers (data, backups)";
      break;
    case Protocol.TEXT:
      oneLiner = `[TXT] \u{1F4DC} Plain Text Stream
`;
      if (highConfidentiality) {
        oneLiner += `\u26A0\uFE0F Unencrypted Sensitive Info!`;
        subtitle = `Clear text API keys, config, raw PII. Encrypt this stream!`;
      } else if (highIntegrity) {
        oneLiner += `Data Integrity Critical!`;
        subtitle = `Unencrypted logs, status updates. Risk of tampering.`;
      } else {
        oneLiner += `Generic Data`;
        subtitle = `Public information, non-critical logs.`;
      }
      break;
    case Protocol.TEXTEncrypted:
      if (highConfidentiality)
        subtitle = `Encrypted secrets, sensitive logs.`;
      else
        subtitle = `Encrypted general text data.`;
      break;
    case Protocol.BINARY:
      oneLiner = `[BIN] \u2699\uFE0F Binary Data Stream
`;
      if (highConfidentiality) {
        oneLiner += `\u26A0\uFE0F Unencrypted Proprietary/Sensitive!`;
        subtitle = `Raw unencrypted firmware, medical images. Encrypt!`;
      } else if (highIntegrity) {
        oneLiner += `Integrity Paramount!`;
        subtitle = `Unencrypted executables, data files. Risk of modification.`;
      } else {
        oneLiner += `Generic Content`;
        subtitle = `Images, non-critical compiled code.`;
      }
      break;
    case Protocol.BINARYEncrypted:
      if (highConfidentiality)
        subtitle = `Encrypted firmware, proprietary data.`;
      else
        subtitle = `Encrypted general binary content.`;
      break;
    case Protocol.SMB:
      oneLiner = `[SMB] \u{1F4C1} File Share Access
`;
      if (highConfidentiality) {
        oneLiner += `\u26A0\uFE0F Sensitive Files Unencrypted?`;
        subtitle = `Access to shares with PII, financial docs. Ensure SMB3+Encryption.`;
      } else {
        subtitle = `General file sharing. Older SMB versions vulnerable.`;
      }
      break;
    case Protocol.SMBEncrypted:
      subtitle = `Encrypted access to sensitive file shares (SMB3+).`;
      break;
    case Protocol.NFS:
      oneLiner = `[NFS] \u{1F4BE} Network File System
`;
      if (highConfidentiality) {
        oneLiner += `\u26A0\uFE0F Sensitive Data Exposure Risk!`;
        subtitle = `Unrestricted access to sensitive data volumes. Use Kerberos/IPSec.`;
      } else {
        subtitle = `Shared application data. Network segmentation crucial.`;
      }
      break;
    case Protocol.UnknownProtocol:
      oneLiner = `[???] Unknown Protocol
Data: ${symbolicGibberish(10)}`;
      subtitle = `Data format and security characteristics undefined. Investigate.`;
      break;
    default:
      if (!subtitle) {
        if (isEncrypted)
          subtitle = `Encrypted communication, protocol-specific content.`;
        else
          subtitle = `Unencrypted data, specific format unknown.`;
      }
      if (!oneLiner.includes("\n") && (isEncrypted || !isEncrypted && !highConfidentiality && auth === "none")) {
        oneLiner += `
Data: ${symbolicGibberish(8)}`;
      }
  }
  return { oneLiner, subtitle };
};
CommunicationFormatPanel.prototype.updateExampleDataDisplay = function() {
  if (!this.exampleDataContainer || !this.exampleDataElement || !this.exampleDataSubtitleElement) {
    console.warn("CommunicationFormatPanel: Example data display elements not ready.");
    if (this.container)
      this.container.style.opacity = "0.5";
    return;
  }
  if (this.container)
    this.container.style.opacity = "1";
  const cell2 = this.editorUi.editor.graph.getSelectionCell();
  if (!cell2 || !cell2.isEdge() || !cell2.source || !cell2.target || !cell2.source.technicalAsset || !cell2.communicationAssetKey) {
    this.exampleDataElement.textContent = "// No communication link selected.";
    this.exampleDataSubtitleElement.textContent = "// Select an edge to see details.";
    this.exampleDataElement.style.color = "rgba(150, 150, 150, 0.8)";
    this.exampleDataSubtitleElement.style.color = "rgba(120, 120, 120, 0.7)";
    this.exampleDataContainer.style.setProperty("--color1", "#1a1a2e");
    this.exampleDataContainer.style.setProperty("--color2", "#2c2c3e");
    this.exampleDataContainer.style.setProperty("--color3", "#1a1a2e");
    this.exampleDataContainer.style.setProperty("--border-color", "rgba(100, 100, 100, 0.5)");
    this.exampleDataContainer.style.setProperty("--shadow-color", "rgba(80, 80, 80, 0.3)");
    this.exampleDataContainer.style.animation = "gradientShift 15s ease infinite alternate, borderPulse 3s infinite alternate";
    this.exampleDataElement.style.animation = "none";
    this.applyExampleDataAnimation(false);
    return;
  }
  let commAssetData;
  try {
    const sourceAssetKey = cell2.source.technicalAsset.key;
    const commKey = cell2.communicationAssetKey;
    const commAssetNode = this.editorUi.editor.graph.model.threagile.getIn(["technical_assets", sourceAssetKey, "communication_links", commKey]);
    if (!commAssetNode) {
      this.exampleDataElement.textContent = `// Link data missing: ${commKey}`;
      this.exampleDataSubtitleElement.textContent = `// Asset: ${sourceAssetKey}`;
      this.exampleDataElement.style.color = "rgba(200, 100, 100, 0.9)";
      this.exampleDataSubtitleElement.style.color = "rgba(180, 80, 80, 0.8)";
      this.applyExampleDataAnimation(false);
      return;
    }
    commAssetData = typeof commAssetNode.toJSON === "function" ? commAssetNode.toJSON() : { ...commAssetNode };
  } catch (e) {
    console.error("CommunicationFormatPanel: Error accessing communication asset data:", e);
    this.exampleDataElement.textContent = "// Error retrieving data.";
    this.exampleDataSubtitleElement.textContent = `// ${e.message.substring(0, 30)}...`;
    this.exampleDataElement.style.color = "rgba(255, 100, 100, 0.9)";
    this.exampleDataSubtitleElement.style.color = "rgba(220, 80, 80, 0.8)";
    this.applyExampleDataAnimation(false);
    return;
  }
  const protocol = commAssetData?.protocol || "unknown-protocol";
  let exampleOutput = { oneLiner: "", subtitle: "" };
  try {
    exampleOutput = this.generateExampleData(protocol, commAssetData);
    this.exampleDataElement.textContent = exampleOutput.oneLiner;
    this.exampleDataSubtitleElement.textContent = exampleOutput.subtitle;
  } catch (e) {
    console.error("CommunicationFormatPanel: Error generating example data:", e);
    this.exampleDataElement.textContent = `// Error for: ${protocol}.`;
    this.exampleDataSubtitleElement.textContent = `// ${e.message.substring(0, 40)}...`;
    this.exampleDataContainer.style.background = "rgba(50,0,0,0.8)";
    this.exampleDataContainer.style.border = "1px solid red";
    this.exampleDataContainer.style.boxShadow = "0 0 10px red";
    this.exampleDataContainer.style.animation = "none";
    this.exampleDataElement.style.color = "white";
    this.exampleDataElement.style.textShadow = "none";
    this.exampleDataElement.style.animation = "none";
    this.exampleDataSubtitleElement.style.color = "rgba(255, 150, 150, 0.9)";
  }
  this.applyExampleDataAnimation(true);
};
CommunicationFormatPanel.prototype.applyExampleDataAnimation = function(isSuccess) {
  if (!this.exampleDataElement)
    return;
  if (this.exampleDataContainer) {
    this.exampleDataContainer.scrollTop = 0;
  }
  this.exampleDataElement.style.opacity = "0";
  requestAnimationFrame(() => {
    this.exampleDataElement.style.transition = "opacity 0.3s ease-in-out";
    this.exampleDataElement.style.opacity = "1";
  });
  setTimeout(() => {
    if (this.exampleDataElement) {
      this.exampleDataElement.style.transition = "";
    }
  }, 350);
};
CommunicationFormatPanel.prototype.refresh = function() {
  var cell2 = this.editorUi.editor.graph.getSelectionCell();
  var currentContainerIsEmptyOrPlaceholder = !this.container.firstChild || this.container.firstChild.tagName === "DIV" && this.container.firstChild.textContent.includes("Select a communication link");
  if (cell2 != null && cell2.isEdge() && cell2.source && cell2.target && cell2.source.technicalAsset && cell2.communicationAssetKey !== void 0) {
    if (currentContainerIsEmptyOrPlaceholder || !this.lastSelectedCellId || this.lastSelectedCellId !== cell2.id) {
      while (this.container.firstChild) {
        this.container.removeChild(this.container.firstChild);
      }
      this.init();
    } else {
      this.updateExampleDataDisplay();
    }
    this.lastSelectedCellId = cell2.id;
  } else {
    if (!currentContainerIsEmptyOrPlaceholder || this.lastSelectedCellId) {
      while (this.container.firstChild) {
        this.container.removeChild(this.container.firstChild);
      }
      var msgDiv = document.createElement("div");
      msgDiv.style.padding = "20px";
      msgDiv.style.textAlign = "center";
      msgDiv.innerHTML = mxResources.get("selectCommLinkToEdit") || "Select a communication link to edit its properties.";
      this.container.appendChild(msgDiv);
      if (this.exampleDataContainer) {
        this.exampleDataContainer.innerHTML = "";
      }
    }
    this.lastSelectedCellId = null;
  }
};
CommunicationFormatPanel.prototype.flashPanel = function(duration = 300, color = "rgba(0, 100, 255, 0.15)") {
  if (!this.container)
    return;
  const originalBg = this.container.style.backgroundColor;
  this.container.style.transition = `background-color ${duration / 2e3}s ease-out`;
  this.container.style.backgroundColor = color;
  setTimeout(() => {
    this.container.style.backgroundColor = originalBg;
    setTimeout(() => {
      if (this.container) {
        this.container.style.transition = "";
      }
    }, duration / 2);
  }, duration / 2);
};

// js/StyleFormatPanel.js
var StyleFormatPanel2 = function(format, editorUi, container) {
  BaseFormatPanel.call(this, format, editorUi, container);
  this.init();
};
extend(StyleFormatPanel2, BaseFormatPanel);
StyleFormatPanel2.prototype.defaultStrokeColor = "black";
StyleFormatPanel2.prototype.init = function() {
  var ui = this.editorUi;
  var editor = ui.editor;
  var graph = editor.graph;
  var ss = this.format.getSelectionState();
  if (!ss.containsLabel) {
    if (ss.containsImage && ss.vertices.length == 1 && ss.style.shape == "image" && ss.style.image != null && ss.style.image.substring(0, 19) == "data:image/svg+xml;") {
      this.container.appendChild(this.addSvgStyles(this.createPanel()));
    }
    if (!ss.containsImage || ss.style.shape == "image") {
      this.container.appendChild(this.addFill(this.createPanel()));
    }
    this.container.appendChild(this.addStroke(this.createPanel()));
    this.container.appendChild(this.addLineJumps(this.createPanel()));
    var opacityPanel = this.createRelativeOption(mxResources2.get("opacity"), mxConstants2.STYLE_OPACITY, 41);
    opacityPanel.style.paddingTop = "8px";
    opacityPanel.style.paddingBottom = "8px";
    this.container.appendChild(opacityPanel);
    this.container.appendChild(this.addEffects(this.createPanel()));
  }
  var opsPanel = this.addEditOps(this.createPanel());
  if (opsPanel.firstChild != null) {
    br(opsPanel);
  }
  this.container.appendChild(this.addStyleOps(opsPanel));
};
StyleFormatPanel2.prototype.getCssRules = function(css) {
  var doc = document.implementation.createHTMLDocument("");
  var styleElement = document.createElement("style");
  setTextContent(styleElement, css);
  doc.body.appendChild(styleElement);
  return styleElement.sheet.cssRules;
};
StyleFormatPanel2.prototype.addSvgStyles = function(container) {
  var ui = this.editorUi;
  var graph = ui.editor.graph;
  var ss = this.format.getSelectionState();
  container.style.paddingTop = "6px";
  container.style.paddingBottom = "6px";
  container.style.fontWeight = "bold";
  container.style.display = "none";
  try {
    var exp = ss.style.editableCssRules;
    if (exp != null) {
      var regex = new RegExp(exp);
      var data = ss.style.image.substring(ss.style.image.indexOf(",") + 1);
      var xml2 = window.atob ? atob(data) : Base64.decode(data, true);
      var svg = parseXml(xml2);
      if (svg != null) {
        var styles = svg.getElementsByTagName("style");
        for (var i = 0; i < styles.length; i++) {
          var rules = this.getCssRules(getTextContent(styles[i]));
          for (var j = 0; j < rules.length; j++) {
            this.addSvgRule(container, rules[j], svg, styles[i], rules, j, regex);
          }
        }
      }
    }
  } catch (e) {
  }
  return container;
};
StyleFormatPanel2.prototype.addSvgRule = function(container, rule, svg, styleElem, rules, ruleIndex, regex) {
  var ui = this.editorUi;
  var graph = ui.editor.graph;
  if (regex.test(rule.selectorText)) {
    let rgb2hex = function(rgb) {
      rgb = rgb.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
      return rgb && rgb.length === 4 ? "#" + ("0" + parseInt(rgb[1], 10).toString(16)).slice(-2) + ("0" + parseInt(rgb[2], 10).toString(16)).slice(-2) + ("0" + parseInt(rgb[3], 10).toString(16)).slice(-2) : "";
    };
    var addStyleRule = bind(this, function(rule2, key, label) {
      var value = trim(rule2.style[key]);
      if (value != "" && value.substring(0, 4) != "url(") {
        var option = this.createColorOption(label + " " + rule2.selectorText, function() {
          return rgb2hex(value);
        }, function(color) {
          rules[ruleIndex].style[key] = color;
          var cssTxt = "";
          for (var i = 0; i < rules.length; i++) {
            cssTxt += rules[i].cssText + " ";
          }
          styleElem.textContent = cssTxt;
          var xml2 = getXml(svg.documentElement);
          graph.setCellStyles(mxConstants2.STYLE_IMAGE, "data:image/svg+xml," + (window.btoa ? btoa(xml2) : Base64.encode(xml2, true)), graph.getSelectionCells());
        }, "#ffffff", {
          install: function(apply) {
          },
          destroy: function() {
          }
        });
        container.appendChild(option);
        container.style.display = "";
      }
    });
    addStyleRule(rule, "fill", mxResources2.get("fill"));
    addStyleRule(rule, "stroke", mxResources2.get("line"));
    addStyleRule(rule, "stop-color", mxResources2.get("gradient"));
  }
};
StyleFormatPanel2.prototype.addEditOps = function(div) {
  var ss = this.format.getSelectionState();
  var btn = null;
  if (this.editorUi.editor.graph.getSelectionCount() == 1) {
    btn = button(mxResources2.get("editStyle"), bind(this, function(evt) {
      this.editorUi.actions.get("editStyle").funct();
    }));
    btn.setAttribute("title", mxResources2.get("editStyle") + " (" + this.editorUi.actions.get("editStyle").shortcut + ")");
    btn.style.width = "202px";
    btn.style.marginBottom = "2px";
    div.appendChild(btn);
  }
  if (ss.image) {
    var btn2 = button(mxResources2.get("editImage"), bind(this, function(evt) {
      this.editorUi.actions.get("image").funct();
    }));
    btn2.setAttribute("title", mxResources2.get("editImage"));
    btn2.style.marginBottom = "2px";
    if (btn == null) {
      btn2.style.width = "202px";
    } else {
      btn.style.width = "100px";
      btn2.style.width = "100px";
      btn2.style.marginLeft = "2px";
    }
    div.appendChild(btn2);
  }
  return div;
};
StyleFormatPanel2.prototype.addFill = function(container) {
  var ui = this.editorUi;
  var graph = ui.editor.graph;
  var ss = this.format.getSelectionState();
  container.style.paddingTop = "6px";
  container.style.paddingBottom = "6px";
  var gradientSelect = document.createElement("select");
  gradientSelect.style.position = "absolute";
  gradientSelect.style.marginTop = "-2px";
  gradientSelect.style.right = mxClient_default.IS_QUIRKS ? "52px" : "72px";
  gradientSelect.style.width = "70px";
  var fillStyleSelect = gradientSelect.cloneNode(false);
  mxEvent2.addListener(gradientSelect, "click", function(evt) {
    mxEvent2.consume(evt);
  });
  mxEvent2.addListener(fillStyleSelect, "click", function(evt) {
    mxEvent2.consume(evt);
  });
  var defs = ss.vertices.length >= 1 ? graph.stylesheet.getDefaultVertexStyle() : graph.stylesheet.getDefaultEdgeStyle();
  var gradientPanel = this.createCellColorOption(mxResources2.get("gradient"), mxConstants2.STYLE_GRADIENTCOLOR, defs[mxConstants2.STYLE_GRADIENTCOLOR] != null ? defs[mxConstants2.STYLE_GRADIENTCOLOR] : "#ffffff", function(color) {
    if (color == null || color == mxConstants2.NONE) {
      gradientSelect.style.display = "none";
    } else {
      gradientSelect.style.display = "";
    }
  }, function(color) {
    graph.updateCellStyles(mxConstants2.STYLE_GRADIENTCOLOR, color, graph.getSelectionCells());
  });
  var fillKey = ss.style.shape == "image" ? mxConstants2.STYLE_IMAGE_BACKGROUND : mxConstants2.STYLE_FILLCOLOR;
  var label = ss.style.shape == "image" ? mxResources2.get("background") : mxResources2.get("fill");
  var defs = ss.vertices.length >= 1 ? graph.stylesheet.getDefaultVertexStyle() : graph.stylesheet.getDefaultEdgeStyle();
  var fillPanel = this.createCellColorOption(label, fillKey, defs[fillKey] != null ? defs[fillKey] : "#ffffff", null, bind(this, function(color) {
    graph.updateCellStyles(fillKey, color, graph.getSelectionCells());
  }));
  fillPanel.style.fontWeight = "bold";
  var tmpColor = getValue(ss.style, fillKey, null);
  gradientPanel.style.display = tmpColor != null && tmpColor != mxConstants2.NONE && ss.fill && ss.style.shape != "image" ? "" : "none";
  var directions = [
    mxConstants2.DIRECTION_NORTH,
    mxConstants2.DIRECTION_EAST,
    mxConstants2.DIRECTION_SOUTH,
    mxConstants2.DIRECTION_WEST
  ];
  for (var i = 0; i < directions.length; i++) {
    var gradientOption = document.createElement("option");
    gradientOption.setAttribute("value", directions[i]);
    write(gradientOption, mxResources2.get(directions[i]));
    gradientSelect.appendChild(gradientOption);
  }
  gradientPanel.appendChild(gradientSelect);
  for (var i = 0; i < Editor2.roughFillStyles.length; i++) {
    var fillStyleOption = document.createElement("option");
    fillStyleOption.setAttribute("value", Editor2.roughFillStyles[i].val);
    write(fillStyleOption, Editor2.roughFillStyles[i].dispName);
    fillStyleSelect.appendChild(fillStyleOption);
  }
  fillPanel.appendChild(fillStyleSelect);
  var listener = bind(this, function() {
    ss = this.format.getSelectionState();
    var value = getValue(ss.style, mxConstants2.STYLE_GRADIENT_DIRECTION, mxConstants2.DIRECTION_SOUTH);
    var fillStyle = getValue(ss.style, "fillStyle", "auto");
    if (value == "") {
      value = mxConstants2.DIRECTION_SOUTH;
    }
    gradientSelect.value = value;
    fillStyleSelect.value = fillStyle;
    container.style.display = ss.fill ? "" : "none";
    var fillColor = getValue(ss.style, mxConstants2.STYLE_FILLCOLOR, null);
    if (!ss.fill || ss.containsImage || fillColor == null || fillColor == mxConstants2.NONE || ss.style.shape == "filledEdge") {
      fillStyleSelect.style.display = "none";
      gradientPanel.style.display = "none";
    } else {
      fillStyleSelect.style.display = ss.style.sketch == "1" ? "" : "none";
      gradientPanel.style.display = ss.style.sketch != "1" || fillStyle == "solid" || fillStyle == "auto" ? "" : "none";
    }
  });
  graph.getModel().addListener(mxEvent2.CHANGE, listener);
  this.listeners.push({
    destroy: function() {
      graph.getModel().removeListener(listener);
    }
  });
  listener();
  mxEvent2.addListener(gradientSelect, "change", function(evt) {
    graph.setCellStyles(mxConstants2.STYLE_GRADIENT_DIRECTION, gradientSelect.value, graph.getSelectionCells());
    mxEvent2.consume(evt);
  });
  mxEvent2.addListener(fillStyleSelect, "change", function(evt) {
    graph.setCellStyles("fillStyle", fillStyleSelect.value, graph.getSelectionCells());
    mxEvent2.consume(evt);
  });
  container.appendChild(fillPanel);
  container.appendChild(gradientPanel);
  var custom = this.getCustomColors();
  for (var i = 0; i < custom.length; i++) {
    container.appendChild(this.createCellColorOption(custom[i].title, custom[i].key, custom[i].defaultValue));
  }
  return container;
};
StyleFormatPanel2.prototype.getCustomColors = function() {
  var ss = this.format.getSelectionState();
  var result2 = [];
  if (ss.style.shape == "swimlane" || ss.style.shape == "table") {
    result2.push({
      title: mxResources2.get("laneColor"),
      key: "swimlaneFillColor",
      defaultValue: "#ffffff"
    });
  }
  return result2;
};
StyleFormatPanel2.prototype.addStroke = function(container) {
  var ui = this.editorUi;
  var graph = ui.editor.graph;
  var ss = this.format.getSelectionState();
  container.style.paddingTop = "4px";
  container.style.paddingBottom = "4px";
  container.style.whiteSpace = "normal";
  var colorPanel = document.createElement("div");
  colorPanel.style.fontWeight = "bold";
  if (!ss.stroke) {
    colorPanel.style.display = "none";
  }
  var styleSelect = document.createElement("select");
  styleSelect.style.position = "absolute";
  styleSelect.style.marginTop = "-2px";
  styleSelect.style.right = "72px";
  styleSelect.style.width = "80px";
  var styles = ["sharp", "rounded", "curved"];
  for (var i = 0; i < styles.length; i++) {
    var styleOption = document.createElement("option");
    styleOption.setAttribute("value", styles[i]);
    write(styleOption, mxResources2.get(styles[i]));
    styleSelect.appendChild(styleOption);
  }
  mxEvent2.addListener(styleSelect, "change", function(evt) {
    graph.getModel().beginUpdate();
    try {
      var keys = [mxConstants2.STYLE_ROUNDED, mxConstants2.STYLE_CURVED];
      var values = ["0", null];
      if (styleSelect.value == "rounded") {
        values = ["1", null];
      } else if (styleSelect.value == "curved") {
        values = [null, "1"];
      }
      for (var i2 = 0; i2 < keys.length; i2++) {
        graph.setCellStyles(keys[i2], values[i2], graph.getSelectionCells());
      }
      ui.fireEvent(new mxEventObject("styleChanged", "keys", keys, "values", values, "cells", graph.getSelectionCells()));
    } finally {
      graph.getModel().endUpdate();
    }
    mxEvent2.consume(evt);
  });
  mxEvent2.addListener(styleSelect, "click", function(evt) {
    mxEvent2.consume(evt);
  });
  var strokeKey = ss.style.shape == "image" ? mxConstants2.STYLE_IMAGE_BORDER : mxConstants2.STYLE_STROKECOLOR;
  var label = ss.style.shape == "image" ? mxResources2.get("border") : mxResources2.get("line");
  var defs = ss.vertices.length >= 1 ? graph.stylesheet.getDefaultVertexStyle() : graph.stylesheet.getDefaultEdgeStyle();
  var lineColor = this.createCellColorOption(label, strokeKey, defs[strokeKey] != null ? defs[strokeKey] : "#000000", null, bind(this, function(color) {
    graph.updateCellStyles(strokeKey, color, graph.getSelectionCells());
  }));
  lineColor.appendChild(styleSelect);
  colorPanel.appendChild(lineColor);
  var stylePanel = colorPanel.cloneNode(false);
  stylePanel.style.fontWeight = "normal";
  stylePanel.style.whiteSpace = "nowrap";
  stylePanel.style.position = "relative";
  stylePanel.style.paddingLeft = "16px";
  stylePanel.style.marginBottom = "2px";
  stylePanel.style.marginTop = "2px";
  stylePanel.className = "geToolbarContainer";
  var addItem = bind(this, function(menu, width, cssName, keys, values) {
    var item = this.editorUi.menus.styleChange(menu, "", keys, values, "geIcon", null);
    var pat = document.createElement("div");
    pat.style.width = width + "px";
    pat.style.height = "1px";
    pat.style.borderBottom = "1px " + cssName + " " + this.defaultStrokeColor;
    pat.style.paddingTop = "6px";
    item.firstChild.firstChild.style.padding = "0px 4px 0px 4px";
    item.firstChild.firstChild.style.width = width + "px";
    item.firstChild.firstChild.appendChild(pat);
    return item;
  });
  var pattern = this.editorUi.toolbar.addMenuFunctionInContainer(stylePanel, "geSprite-orthogonal", mxResources2.get("pattern"), false, bind(this, function(menu) {
    addItem(menu, 75, "solid", [mxConstants2.STYLE_DASHED, mxConstants2.STYLE_DASH_PATTERN], [null, null]).setAttribute("title", mxResources2.get("solid"));
    addItem(menu, 75, "dashed", [mxConstants2.STYLE_DASHED, mxConstants2.STYLE_DASH_PATTERN], ["1", null]).setAttribute("title", mxResources2.get("dashed"));
    addItem(menu, 75, "dotted", [mxConstants2.STYLE_DASHED, mxConstants2.STYLE_DASH_PATTERN], ["1", "1 1"]).setAttribute("title", mxResources2.get("dotted") + " (1)");
    addItem(menu, 75, "dotted", [mxConstants2.STYLE_DASHED, mxConstants2.STYLE_DASH_PATTERN], ["1", "1 2"]).setAttribute("title", mxResources2.get("dotted") + " (2)");
    addItem(menu, 75, "dotted", [mxConstants2.STYLE_DASHED, mxConstants2.STYLE_DASH_PATTERN], ["1", "1 4"]).setAttribute("title", mxResources2.get("dotted") + " (3)");
  }));
  var altStylePanel = stylePanel.cloneNode(false);
  var edgeShape = this.editorUi.toolbar.addMenuFunctionInContainer(altStylePanel, "geSprite-connection", mxResources2.get("connection"), false, bind(this, function(menu) {
    this.editorUi.menus.styleChange(menu, "", [
      mxConstants2.STYLE_SHAPE,
      mxConstants2.STYLE_STARTSIZE,
      mxConstants2.STYLE_ENDSIZE,
      "width"
    ], [null, null, null, null], "geIcon geSprite geSprite-connection", null, true).setAttribute("title", mxResources2.get("line"));
    this.editorUi.menus.styleChange(menu, "", [
      mxConstants2.STYLE_SHAPE,
      mxConstants2.STYLE_STARTSIZE,
      mxConstants2.STYLE_ENDSIZE,
      "width"
    ], ["link", null, null, null], "geIcon geSprite geSprite-linkedge", null, true).setAttribute("title", mxResources2.get("link"));
    this.editorUi.menus.styleChange(menu, "", [
      mxConstants2.STYLE_SHAPE,
      mxConstants2.STYLE_STARTSIZE,
      mxConstants2.STYLE_ENDSIZE,
      "width"
    ], ["flexArrow", null, null, null], "geIcon geSprite geSprite-arrow", null, true).setAttribute("title", mxResources2.get("arrow"));
    this.editorUi.menus.styleChange(menu, "", [
      mxConstants2.STYLE_SHAPE,
      mxConstants2.STYLE_STARTSIZE,
      mxConstants2.STYLE_ENDSIZE,
      "width"
    ], ["arrow", null, null, null], "geIcon geSprite geSprite-simplearrow", null, true).setAttribute("title", mxResources2.get("simpleArrow"));
  }));
  var altPattern = this.editorUi.toolbar.addMenuFunctionInContainer(altStylePanel, "geSprite-orthogonal", mxResources2.get("pattern"), false, bind(this, function(menu) {
    addItem(menu, 33, "solid", [mxConstants2.STYLE_DASHED, mxConstants2.STYLE_DASH_PATTERN], [null, null]).setAttribute("title", mxResources2.get("solid"));
    addItem(menu, 33, "dashed", [mxConstants2.STYLE_DASHED, mxConstants2.STYLE_DASH_PATTERN], ["1", null]).setAttribute("title", mxResources2.get("dashed"));
    addItem(menu, 33, "dotted", [mxConstants2.STYLE_DASHED, mxConstants2.STYLE_DASH_PATTERN], ["1", "1 1"]).setAttribute("title", mxResources2.get("dotted") + " (1)");
    addItem(menu, 33, "dotted", [mxConstants2.STYLE_DASHED, mxConstants2.STYLE_DASH_PATTERN], ["1", "1 2"]).setAttribute("title", mxResources2.get("dotted") + " (2)");
    addItem(menu, 33, "dotted", [mxConstants2.STYLE_DASHED, mxConstants2.STYLE_DASH_PATTERN], ["1", "1 4"]).setAttribute("title", mxResources2.get("dotted") + " (3)");
  }));
  var stylePanel2 = stylePanel.cloneNode(false);
  var input = document.createElement("input");
  input.style.textAlign = "right";
  input.style.marginTop = "2px";
  input.style.width = "41px";
  input.setAttribute("title", mxResources2.get("linewidth"));
  stylePanel.appendChild(input);
  var altInput = input.cloneNode(true);
  altStylePanel.appendChild(altInput);
  function update(evt) {
    var value = parseInt(input.value);
    value = Math.min(999, Math.max(1, isNaN(value) ? 1 : value));
    if (value != getValue(ss.style, mxConstants2.STYLE_STROKEWIDTH, 1)) {
      graph.setCellStyles(mxConstants2.STYLE_STROKEWIDTH, value, graph.getSelectionCells());
      ui.fireEvent(new mxEventObject("styleChanged", "keys", [mxConstants2.STYLE_STROKEWIDTH], "values", [value], "cells", graph.getSelectionCells()));
    }
    input.value = value + " pt";
    mxEvent2.consume(evt);
  }
  function altUpdate(evt) {
    var value = parseInt(altInput.value);
    value = Math.min(999, Math.max(1, isNaN(value) ? 1 : value));
    if (value != getValue(ss.style, mxConstants2.STYLE_STROKEWIDTH, 1)) {
      graph.setCellStyles(mxConstants2.STYLE_STROKEWIDTH, value, graph.getSelectionCells());
      ui.fireEvent(new mxEventObject("styleChanged", "keys", [mxConstants2.STYLE_STROKEWIDTH], "values", [value], "cells", graph.getSelectionCells()));
    }
    altInput.value = value + " pt";
    mxEvent2.consume(evt);
  }
  var stepper = this.createStepper(input, update, 1, 9);
  stepper.style.display = input.style.display;
  stepper.style.marginTop = "2px";
  stylePanel.appendChild(stepper);
  var altStepper = this.createStepper(altInput, altUpdate, 1, 9);
  altStepper.style.display = altInput.style.display;
  altStepper.style.marginTop = "2px";
  altStylePanel.appendChild(altStepper);
  if (!mxClient_default.IS_QUIRKS) {
    input.style.position = "absolute";
    input.style.height = "15px";
    input.style.left = "141px";
    stepper.style.left = "190px";
    altInput.style.position = "absolute";
    altInput.style.left = "141px";
    altInput.style.height = "15px";
    altStepper.style.left = "190px";
  } else {
    input.style.height = "17px";
    altInput.style.height = "17px";
  }
  mxEvent2.addListener(input, "blur", update);
  mxEvent2.addListener(input, "change", update);
  mxEvent2.addListener(altInput, "blur", altUpdate);
  mxEvent2.addListener(altInput, "change", altUpdate);
  if (mxClient_default.IS_QUIRKS) {
    br(stylePanel2);
    br(stylePanel2);
  }
  var edgeStyle = this.editorUi.toolbar.addMenuFunctionInContainer(stylePanel2, "geSprite-orthogonal", mxResources2.get("waypoints"), false, bind(this, function(menu) {
    if (ss.style.shape != "arrow") {
      this.editorUi.menus.edgeStyleChange(menu, "", [
        mxConstants2.STYLE_EDGE,
        mxConstants2.STYLE_CURVED,
        mxConstants2.STYLE_NOEDGESTYLE
      ], [null, null, null], "geIcon geSprite geSprite-straight", null, true).setAttribute("title", mxResources2.get("straight"));
      this.editorUi.menus.edgeStyleChange(menu, "", [
        mxConstants2.STYLE_EDGE,
        mxConstants2.STYLE_CURVED,
        mxConstants2.STYLE_NOEDGESTYLE
      ], ["orthogonalEdgeStyle", null, null], "geIcon geSprite geSprite-orthogonal", null, true).setAttribute("title", mxResources2.get("orthogonal"));
      this.editorUi.menus.edgeStyleChange(menu, "", [
        mxConstants2.STYLE_EDGE,
        mxConstants2.STYLE_ELBOW,
        mxConstants2.STYLE_CURVED,
        mxConstants2.STYLE_NOEDGESTYLE
      ], ["elbowEdgeStyle", null, null, null], "geIcon geSprite geSprite-horizontalelbow", null, true).setAttribute("title", mxResources2.get("simple"));
      this.editorUi.menus.edgeStyleChange(menu, "", [
        mxConstants2.STYLE_EDGE,
        mxConstants2.STYLE_ELBOW,
        mxConstants2.STYLE_CURVED,
        mxConstants2.STYLE_NOEDGESTYLE
      ], ["elbowEdgeStyle", "vertical", null, null], "geIcon geSprite geSprite-verticalelbow", null, true).setAttribute("title", mxResources2.get("simple"));
      this.editorUi.menus.edgeStyleChange(menu, "", [
        mxConstants2.STYLE_EDGE,
        mxConstants2.STYLE_ELBOW,
        mxConstants2.STYLE_CURVED,
        mxConstants2.STYLE_NOEDGESTYLE
      ], ["isometricEdgeStyle", null, null, null], "geIcon geSprite geSprite-horizontalisometric", null, true).setAttribute("title", mxResources2.get("isometric"));
      this.editorUi.menus.edgeStyleChange(menu, "", [
        mxConstants2.STYLE_EDGE,
        mxConstants2.STYLE_ELBOW,
        mxConstants2.STYLE_CURVED,
        mxConstants2.STYLE_NOEDGESTYLE
      ], ["isometricEdgeStyle", "vertical", null, null], "geIcon geSprite geSprite-verticalisometric", null, true).setAttribute("title", mxResources2.get("isometric"));
      if (ss.style.shape == "connector") {
        this.editorUi.menus.edgeStyleChange(menu, "", [
          mxConstants2.STYLE_EDGE,
          mxConstants2.STYLE_CURVED,
          mxConstants2.STYLE_NOEDGESTYLE
        ], ["orthogonalEdgeStyle", "1", null], "geIcon geSprite geSprite-curved", null, true).setAttribute("title", mxResources2.get("curved"));
      }
      this.editorUi.menus.edgeStyleChange(menu, "", [
        mxConstants2.STYLE_EDGE,
        mxConstants2.STYLE_CURVED,
        mxConstants2.STYLE_NOEDGESTYLE
      ], ["entityRelationEdgeStyle", null, null], "geIcon geSprite geSprite-entity", null, true).setAttribute("title", mxResources2.get("entityRelation"));
    }
  }));
  var lineStart = this.editorUi.toolbar.addMenuFunctionInContainer(stylePanel2, "geSprite-startclassic", mxResources2.get("linestart"), false, bind(this, function(menu) {
    if (ss.style.shape == "connector" || ss.style.shape == "flexArrow" || ss.style.shape == "filledEdge") {
      var item = this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_STARTARROW, "startFill"], [mxConstants2.NONE, 0], "geIcon", null, false);
      item.setAttribute("title", mxResources2.get("none"));
      item.firstChild.firstChild.innerHTML = '<font style="font-size:10px;">' + htmlEntities(mxResources2.get("none")) + "</font>";
      if (ss.style.shape == "connector" || ss.style.shape == "filledEdge") {
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_STARTARROW, "startFill"], [mxConstants2.ARROW_CLASSIC, 1], "geIcon geSprite geSprite-startclassic", null, false).setAttribute("title", mxResources2.get("classic"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_STARTARROW, "startFill"], [mxConstants2.ARROW_CLASSIC_THIN, 1], "geIcon geSprite geSprite-startclassicthin", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_STARTARROW, "startFill"], [mxConstants2.ARROW_OPEN, 0], "geIcon geSprite geSprite-startopen", null, false).setAttribute("title", mxResources2.get("openArrow"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_STARTARROW, "startFill"], [mxConstants2.ARROW_OPEN_THIN, 0], "geIcon geSprite geSprite-startopenthin", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_STARTARROW, "startFill"], ["openAsync", 0], "geIcon geSprite geSprite-startopenasync", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_STARTARROW, "startFill"], [mxConstants2.ARROW_BLOCK, 1], "geIcon geSprite geSprite-startblock", null, false).setAttribute("title", mxResources2.get("block"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_STARTARROW, "startFill"], [mxConstants2.ARROW_BLOCK_THIN, 1], "geIcon geSprite geSprite-startblockthin", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_STARTARROW, "startFill"], ["async", 1], "geIcon geSprite geSprite-startasync", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_STARTARROW, "startFill"], [mxConstants2.ARROW_OVAL, 1], "geIcon geSprite geSprite-startoval", null, false).setAttribute("title", mxResources2.get("oval"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_STARTARROW, "startFill"], [mxConstants2.ARROW_DIAMOND, 1], "geIcon geSprite geSprite-startdiamond", null, false).setAttribute("title", mxResources2.get("diamond"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_STARTARROW, "startFill"], [mxConstants2.ARROW_DIAMOND_THIN, 1], "geIcon geSprite geSprite-startthindiamond", null, false).setAttribute("title", mxResources2.get("diamondThin"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_STARTARROW, "startFill"], [mxConstants2.ARROW_CLASSIC, 0], "geIcon geSprite geSprite-startclassictrans", null, false).setAttribute("title", mxResources2.get("classic"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_STARTARROW, "startFill"], [mxConstants2.ARROW_CLASSIC_THIN, 0], "geIcon geSprite geSprite-startclassicthintrans", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_STARTARROW, "startFill"], [mxConstants2.ARROW_BLOCK, 0], "geIcon geSprite geSprite-startblocktrans", null, false).setAttribute("title", mxResources2.get("block"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_STARTARROW, "startFill"], [mxConstants2.ARROW_BLOCK_THIN, 0], "geIcon geSprite geSprite-startblockthintrans", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_STARTARROW, "startFill"], ["async", 0], "geIcon geSprite geSprite-startasynctrans", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_STARTARROW, "startFill"], [mxConstants2.ARROW_OVAL, 0], "geIcon geSprite geSprite-startovaltrans", null, false).setAttribute("title", mxResources2.get("oval"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_STARTARROW, "startFill"], [mxConstants2.ARROW_DIAMOND, 0], "geIcon geSprite geSprite-startdiamondtrans", null, false).setAttribute("title", mxResources2.get("diamond"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_STARTARROW, "startFill"], [mxConstants2.ARROW_DIAMOND_THIN, 0], "geIcon geSprite geSprite-startthindiamondtrans", null, false).setAttribute("title", mxResources2.get("diamondThin"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_STARTARROW, "startFill"], ["box", 0], "geIcon geSprite geSvgSprite geSprite-box", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_STARTARROW, "startFill"], ["halfCircle", 0], "geIcon geSprite geSvgSprite geSprite-halfCircle", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_STARTARROW, "startFill"], ["dash", 0], "geIcon geSprite geSprite-startdash", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_STARTARROW, "startFill"], ["cross", 0], "geIcon geSprite geSprite-startcross", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_STARTARROW, "startFill"], ["circlePlus", 0], "geIcon geSprite geSprite-startcircleplus", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_STARTARROW, "startFill"], ["circle", 1], "geIcon geSprite geSprite-startcircle", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_STARTARROW, "startFill"], ["ERone", 0], "geIcon geSprite geSprite-starterone", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_STARTARROW, "startFill"], ["ERmandOne", 0], "geIcon geSprite geSprite-starteronetoone", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_STARTARROW, "startFill"], ["ERmany", 0], "geIcon geSprite geSprite-startermany", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_STARTARROW, "startFill"], ["ERoneToMany", 0], "geIcon geSprite geSprite-starteronetomany", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_STARTARROW, "startFill"], ["ERzeroToOne", 1], "geIcon geSprite geSprite-starteroneopt", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_STARTARROW, "startFill"], ["ERzeroToMany", 1], "geIcon geSprite geSprite-startermanyopt", null, false);
      } else {
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_STARTARROW], [mxConstants2.ARROW_BLOCK], "geIcon geSprite geSprite-startblocktrans", null, false).setAttribute("title", mxResources2.get("block"));
      }
    }
  }));
  var lineEnd = this.editorUi.toolbar.addMenuFunctionInContainer(stylePanel2, "geSprite-endclassic", mxResources2.get("lineend"), false, bind(this, function(menu) {
    if (ss.style.shape == "connector" || ss.style.shape == "flexArrow" || ss.style.shape == "filledEdge") {
      var item = this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_ENDARROW, "endFill"], [mxConstants2.NONE, 0], "geIcon", null, false);
      item.setAttribute("title", mxResources2.get("none"));
      item.firstChild.firstChild.innerHTML = '<font style="font-size:10px;">' + htmlEntities(mxResources2.get("none")) + "</font>";
      if (ss.style.shape == "connector" || ss.style.shape == "filledEdge") {
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_ENDARROW, "endFill"], [mxConstants2.ARROW_CLASSIC, 1], "geIcon geSprite geSprite-endclassic", null, false).setAttribute("title", mxResources2.get("classic"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_ENDARROW, "endFill"], [mxConstants2.ARROW_CLASSIC_THIN, 1], "geIcon geSprite geSprite-endclassicthin", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_ENDARROW, "endFill"], [mxConstants2.ARROW_OPEN, 0], "geIcon geSprite geSprite-endopen", null, false).setAttribute("title", mxResources2.get("openArrow"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_ENDARROW, "endFill"], [mxConstants2.ARROW_OPEN_THIN, 0], "geIcon geSprite geSprite-endopenthin", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_ENDARROW, "endFill"], ["openAsync", 0], "geIcon geSprite geSprite-endopenasync", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_ENDARROW, "endFill"], [mxConstants2.ARROW_BLOCK, 1], "geIcon geSprite geSprite-endblock", null, false).setAttribute("title", mxResources2.get("block"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_ENDARROW, "endFill"], [mxConstants2.ARROW_BLOCK_THIN, 1], "geIcon geSprite geSprite-endblockthin", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_ENDARROW, "endFill"], ["async", 1], "geIcon geSprite geSprite-endasync", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_ENDARROW, "endFill"], [mxConstants2.ARROW_OVAL, 1], "geIcon geSprite geSprite-endoval", null, false).setAttribute("title", mxResources2.get("oval"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_ENDARROW, "endFill"], [mxConstants2.ARROW_DIAMOND, 1], "geIcon geSprite geSprite-enddiamond", null, false).setAttribute("title", mxResources2.get("diamond"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_ENDARROW, "endFill"], [mxConstants2.ARROW_DIAMOND_THIN, 1], "geIcon geSprite geSprite-endthindiamond", null, false).setAttribute("title", mxResources2.get("diamondThin"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_ENDARROW, "endFill"], [mxConstants2.ARROW_CLASSIC, 0], "geIcon geSprite geSprite-endclassictrans", null, false).setAttribute("title", mxResources2.get("classic"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_ENDARROW, "endFill"], [mxConstants2.ARROW_CLASSIC_THIN, 0], "geIcon geSprite geSprite-endclassicthintrans", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_ENDARROW, "endFill"], [mxConstants2.ARROW_BLOCK, 0], "geIcon geSprite geSprite-endblocktrans", null, false).setAttribute("title", mxResources2.get("block"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_ENDARROW, "endFill"], [mxConstants2.ARROW_BLOCK_THIN, 0], "geIcon geSprite geSprite-endblockthintrans", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_ENDARROW, "endFill"], ["async", 0], "geIcon geSprite geSprite-endasynctrans", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_ENDARROW, "endFill"], [mxConstants2.ARROW_OVAL, 0], "geIcon geSprite geSprite-endovaltrans", null, false).setAttribute("title", mxResources2.get("oval"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_ENDARROW, "endFill"], [mxConstants2.ARROW_DIAMOND, 0], "geIcon geSprite geSprite-enddiamondtrans", null, false).setAttribute("title", mxResources2.get("diamond"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_ENDARROW, "endFill"], [mxConstants2.ARROW_DIAMOND_THIN, 0], "geIcon geSprite geSprite-endthindiamondtrans", null, false).setAttribute("title", mxResources2.get("diamondThin"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_ENDARROW, "endFill"], ["box", 0], "geIcon geSprite geSvgSprite geFlipSprite geSprite-box", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_ENDARROW, "endFill"], ["halfCircle", 0], "geIcon geSprite geSvgSprite geFlipSprite geSprite-halfCircle", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_ENDARROW, "endFill"], ["dash", 0], "geIcon geSprite geSprite-enddash", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_ENDARROW, "endFill"], ["cross", 0], "geIcon geSprite geSprite-endcross", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_ENDARROW, "endFill"], ["circlePlus", 0], "geIcon geSprite geSprite-endcircleplus", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_ENDARROW, "endFill"], ["circle", 1], "geIcon geSprite geSprite-endcircle", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_ENDARROW, "endFill"], ["ERone", 0], "geIcon geSprite geSprite-enderone", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_ENDARROW, "endFill"], ["ERmandOne", 0], "geIcon geSprite geSprite-enderonetoone", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_ENDARROW, "endFill"], ["ERmany", 0], "geIcon geSprite geSprite-endermany", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_ENDARROW, "endFill"], ["ERoneToMany", 0], "geIcon geSprite geSprite-enderonetomany", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_ENDARROW, "endFill"], ["ERzeroToOne", 1], "geIcon geSprite geSprite-enderoneopt", null, false);
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_ENDARROW, "endFill"], ["ERzeroToMany", 1], "geIcon geSprite geSprite-endermanyopt", null, false);
      } else {
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_ENDARROW], [mxConstants2.ARROW_BLOCK], "geIcon geSprite geSprite-endblocktrans", null, false).setAttribute("title", mxResources2.get("block"));
      }
    }
  }));
  this.addArrow(edgeShape, 8);
  this.addArrow(edgeStyle);
  this.addArrow(lineStart);
  this.addArrow(lineEnd);
  var symbol = this.addArrow(pattern, 9);
  symbol.className = "geIcon";
  symbol.style.width = "auto";
  var altSymbol = this.addArrow(altPattern, 9);
  altSymbol.className = "geIcon";
  altSymbol.style.width = "22px";
  var solid = document.createElement("div");
  solid.style.width = "85px";
  solid.style.height = "1px";
  solid.style.borderBottom = "1px solid " + this.defaultStrokeColor;
  solid.style.marginBottom = "9px";
  symbol.appendChild(solid);
  var altSolid = document.createElement("div");
  altSolid.style.width = "23px";
  altSolid.style.height = "1px";
  altSolid.style.borderBottom = "1px solid " + this.defaultStrokeColor;
  altSolid.style.marginBottom = "9px";
  altSymbol.appendChild(altSolid);
  pattern.style.height = "15px";
  altPattern.style.height = "15px";
  edgeShape.style.height = "15px";
  edgeStyle.style.height = "17px";
  lineStart.style.marginLeft = "3px";
  lineStart.style.height = "17px";
  lineEnd.style.marginLeft = "3px";
  lineEnd.style.height = "17px";
  container.appendChild(colorPanel);
  container.appendChild(altStylePanel);
  container.appendChild(stylePanel);
  var arrowPanel = stylePanel.cloneNode(false);
  arrowPanel.style.paddingBottom = "6px";
  arrowPanel.style.paddingTop = "4px";
  arrowPanel.style.fontWeight = "normal";
  var span = document.createElement("div");
  span.style.position = "absolute";
  span.style.marginLeft = "3px";
  span.style.marginBottom = "12px";
  span.style.marginTop = "2px";
  span.style.fontWeight = "normal";
  span.style.width = "76px";
  write(span, mxResources2.get("lineend"));
  arrowPanel.appendChild(span);
  var endSpacingUpdate, endSizeUpdate;
  var endSpacing = this.addUnitInput(arrowPanel, "pt", 74, 33, function() {
    endSpacingUpdate.apply(this, arguments);
  });
  var endSize = this.addUnitInput(arrowPanel, "pt", 20, 33, function() {
    endSizeUpdate.apply(this, arguments);
  });
  br(arrowPanel);
  var spacer = document.createElement("div");
  spacer.style.height = "8px";
  arrowPanel.appendChild(spacer);
  span = span.cloneNode(false);
  write(span, mxResources2.get("linestart"));
  arrowPanel.appendChild(span);
  var startSpacingUpdate, startSizeUpdate;
  var startSpacing = this.addUnitInput(arrowPanel, "pt", 74, 33, function() {
    startSpacingUpdate.apply(this, arguments);
  });
  var startSize = this.addUnitInput(arrowPanel, "pt", 20, 33, function() {
    startSizeUpdate.apply(this, arguments);
  });
  br(arrowPanel);
  this.addLabel(arrowPanel, mxResources2.get("spacing"), 74, 50);
  this.addLabel(arrowPanel, mxResources2.get("size"), 20, 50);
  br(arrowPanel);
  var perimeterPanel = colorPanel.cloneNode(false);
  perimeterPanel.style.fontWeight = "normal";
  perimeterPanel.style.position = "relative";
  perimeterPanel.style.paddingLeft = "16px";
  perimeterPanel.style.marginBottom = "2px";
  perimeterPanel.style.marginTop = "6px";
  perimeterPanel.style.borderWidth = "0px";
  perimeterPanel.style.paddingBottom = "18px";
  var span = document.createElement("div");
  span.style.position = "absolute";
  span.style.marginLeft = "3px";
  span.style.marginBottom = "12px";
  span.style.marginTop = "1px";
  span.style.fontWeight = "normal";
  span.style.width = "120px";
  write(span, mxResources2.get("perimeter"));
  perimeterPanel.appendChild(span);
  var perimeterUpdate;
  var perimeterSpacing = this.addUnitInput(perimeterPanel, "pt", 20, 41, function() {
    perimeterUpdate.apply(this, arguments);
  });
  if (ss.edges.length == graph.getSelectionCount()) {
    container.appendChild(stylePanel2);
    if (mxClient_default.IS_QUIRKS) {
      br(container);
      br(container);
    }
    container.appendChild(arrowPanel);
  } else if (ss.vertices.length == graph.getSelectionCount()) {
    if (mxClient_default.IS_QUIRKS) {
      br(container);
    }
    container.appendChild(perimeterPanel);
  }
  var listener = bind(this, function(sender, evt, force) {
    ss = this.format.getSelectionState();
    var color = getValue(ss.style, strokeKey, null);
    if (force || document.activeElement != input) {
      var tmp = parseInt(getValue(ss.style, mxConstants2.STYLE_STROKEWIDTH, 1));
      input.value = isNaN(tmp) ? "" : tmp + " pt";
    }
    if (force || document.activeElement != altInput) {
      var tmp = parseInt(getValue(ss.style, mxConstants2.STYLE_STROKEWIDTH, 1));
      altInput.value = isNaN(tmp) ? "" : tmp + " pt";
    }
    styleSelect.style.visibility = ss.style.shape == "connector" || ss.style.shape == "filledEdge" ? "" : "hidden";
    if (getValue(ss.style, mxConstants2.STYLE_CURVED, null) == "1") {
      styleSelect.value = "curved";
    } else if (getValue(ss.style, mxConstants2.STYLE_ROUNDED, null) == "1") {
      styleSelect.value = "rounded";
    }
    if (getValue(ss.style, mxConstants2.STYLE_DASHED, null) == "1") {
      if (getValue(ss.style, mxConstants2.STYLE_DASH_PATTERN, null) == null) {
        solid.style.borderBottom = "1px dashed " + this.defaultStrokeColor;
      } else {
        solid.style.borderBottom = "1px dotted " + this.defaultStrokeColor;
      }
    } else {
      solid.style.borderBottom = "1px solid " + this.defaultStrokeColor;
    }
    altSolid.style.borderBottom = solid.style.borderBottom;
    var edgeStyleDiv = edgeStyle.getElementsByTagName("div")[0];
    if (edgeStyleDiv != null) {
      var es = getValue(ss.style, mxConstants2.STYLE_EDGE, null);
      if (getValue(ss.style, mxConstants2.STYLE_NOEDGESTYLE, null) == "1") {
        es = null;
      }
      if (es == "orthogonalEdgeStyle" && getValue(ss.style, mxConstants2.STYLE_CURVED, null) == "1") {
        edgeStyleDiv.className = "geSprite geSprite-curved";
      } else if (es == "straight" || es == "none" || es == null) {
        edgeStyleDiv.className = "geSprite geSprite-straight";
      } else if (es == "entityRelationEdgeStyle") {
        edgeStyleDiv.className = "geSprite geSprite-entity";
      } else if (es == "elbowEdgeStyle") {
        edgeStyleDiv.className = "geSprite " + (getValue(ss.style, mxConstants2.STYLE_ELBOW, null) == "vertical" ? "geSprite-verticalelbow" : "geSprite-horizontalelbow");
      } else if (es == "isometricEdgeStyle") {
        edgeStyleDiv.className = "geSprite " + (getValue(ss.style, mxConstants2.STYLE_ELBOW, null) == "vertical" ? "geSprite-verticalisometric" : "geSprite-horizontalisometric");
      } else {
        edgeStyleDiv.className = "geSprite geSprite-orthogonal";
      }
    }
    var edgeShapeDiv = edgeShape.getElementsByTagName("div")[0];
    if (edgeShapeDiv != null) {
      if (ss.style.shape == "link") {
        edgeShapeDiv.className = "geSprite geSprite-linkedge";
      } else if (ss.style.shape == "flexArrow") {
        edgeShapeDiv.className = "geSprite geSprite-arrow";
      } else if (ss.style.shape == "arrow") {
        edgeShapeDiv.className = "geSprite geSprite-simplearrow";
      } else {
        edgeShapeDiv.className = "geSprite geSprite-connection";
      }
    }
    if (ss.edges.length == graph.getSelectionCount()) {
      altStylePanel.style.display = "";
      stylePanel.style.display = "none";
    } else {
      altStylePanel.style.display = "none";
      stylePanel.style.display = "";
    }
    let self = this;
    function updateArrow(marker, fill, elt, prefix) {
      var markerDiv = elt.getElementsByTagName("div")[0];
      if (markerDiv != null) {
        markerDiv.className = ui.getCssClassForMarker(prefix, ss.style.shape, marker, fill);
        if (markerDiv.className == "geSprite geSprite-noarrow") {
          markerDiv.innerHTML = htmlEntities(mxResources2.get("none"));
          markerDiv.style.backgroundImage = "none";
          markerDiv.style.verticalAlign = "top";
          markerDiv.style.marginTop = "5px";
          markerDiv.style.fontSize = "10px";
          markerDiv.style.filter = "none";
          markerDiv.style.color = self.defaultStrokeColor;
          markerDiv.nextSibling.style.marginTop = "0px";
        }
      }
      return markerDiv;
    }
    var sourceDiv = updateArrow(getValue(ss.style, mxConstants2.STYLE_STARTARROW, null), getValue(ss.style, "startFill", "1"), lineStart, "start");
    var targetDiv = updateArrow(getValue(ss.style, mxConstants2.STYLE_ENDARROW, null), getValue(ss.style, "endFill", "1"), lineEnd, "end");
    if (sourceDiv != null && targetDiv != null) {
      if (ss.style.shape == "arrow") {
        sourceDiv.className = "geSprite geSprite-noarrow";
        targetDiv.className = "geSprite geSprite-endblocktrans";
      } else if (ss.style.shape == "link") {
        sourceDiv.className = "geSprite geSprite-noarrow";
        targetDiv.className = "geSprite geSprite-noarrow";
      }
    }
    setOpacity(edgeStyle, ss.style.shape == "arrow" ? 30 : 100);
    if (ss.style.shape != "connector" && ss.style.shape != "flexArrow" && ss.style.shape != "filledEdge") {
      setOpacity(lineStart, 30);
      setOpacity(lineEnd, 30);
    } else {
      setOpacity(lineStart, 100);
      setOpacity(lineEnd, 100);
    }
    if (force || document.activeElement != startSize) {
      var tmp = parseInt(getValue(ss.style, mxConstants2.STYLE_STARTSIZE, mxConstants2.DEFAULT_MARKERSIZE));
      startSize.value = isNaN(tmp) ? "" : tmp + " pt";
    }
    if (force || document.activeElement != startSpacing) {
      var tmp = parseInt(getValue(ss.style, mxConstants2.STYLE_SOURCE_PERIMETER_SPACING, 0));
      startSpacing.value = isNaN(tmp) ? "" : tmp + " pt";
    }
    if (force || document.activeElement != endSize) {
      var tmp = parseInt(getValue(ss.style, mxConstants2.STYLE_ENDSIZE, mxConstants2.DEFAULT_MARKERSIZE));
      endSize.value = isNaN(tmp) ? "" : tmp + " pt";
    }
    if (force || document.activeElement != startSpacing) {
      var tmp = parseInt(getValue(ss.style, mxConstants2.STYLE_TARGET_PERIMETER_SPACING, 0));
      endSpacing.value = isNaN(tmp) ? "" : tmp + " pt";
    }
    if (force || document.activeElement != perimeterSpacing) {
      var tmp = parseInt(getValue(ss.style, mxConstants2.STYLE_PERIMETER_SPACING, 0));
      perimeterSpacing.value = isNaN(tmp) ? "" : tmp + " pt";
    }
  });
  startSizeUpdate = this.installInputHandler(startSize, mxConstants2.STYLE_STARTSIZE, mxConstants2.DEFAULT_MARKERSIZE, 0, 999, " pt");
  startSpacingUpdate = this.installInputHandler(startSpacing, mxConstants2.STYLE_SOURCE_PERIMETER_SPACING, 0, -999, 999, " pt");
  endSizeUpdate = this.installInputHandler(endSize, mxConstants2.STYLE_ENDSIZE, mxConstants2.DEFAULT_MARKERSIZE, 0, 999, " pt");
  endSpacingUpdate = this.installInputHandler(endSpacing, mxConstants2.STYLE_TARGET_PERIMETER_SPACING, 0, -999, 999, " pt");
  perimeterUpdate = this.installInputHandler(perimeterSpacing, mxConstants2.STYLE_PERIMETER_SPACING, 0, 0, 999, " pt");
  this.addKeyHandler(input, listener);
  this.addKeyHandler(startSize, listener);
  this.addKeyHandler(startSpacing, listener);
  this.addKeyHandler(endSize, listener);
  this.addKeyHandler(endSpacing, listener);
  this.addKeyHandler(perimeterSpacing, listener);
  graph.getModel().addListener(mxEvent2.CHANGE, listener);
  this.listeners.push({
    destroy: function() {
      graph.getModel().removeListener(listener);
    }
  });
  listener();
  return container;
};
StyleFormatPanel2.prototype.addLineJumps = function(container) {
  var ss = this.format.getSelectionState();
  if (Graph2.lineJumpsEnabled && ss.edges.length > 0 && ss.vertices.length == 0 && ss.lineJumps) {
    container.style.padding = "8px 0px 24px 18px";
    var ui = this.editorUi;
    var editor = ui.editor;
    var graph = editor.graph;
    var span = document.createElement("div");
    span.style.position = "absolute";
    span.style.fontWeight = "bold";
    span.style.width = "80px";
    write(span, mxResources2.get("lineJumps"));
    container.appendChild(span);
    var styleSelect = document.createElement("select");
    styleSelect.style.position = "absolute";
    styleSelect.style.marginTop = "-2px";
    styleSelect.style.right = "76px";
    styleSelect.style.width = "62px";
    var styles = ["none", "arc", "gap", "sharp"];
    for (var i = 0; i < styles.length; i++) {
      var styleOption = document.createElement("option");
      styleOption.setAttribute("value", styles[i]);
      write(styleOption, mxResources2.get(styles[i]));
      styleSelect.appendChild(styleOption);
    }
    mxEvent2.addListener(styleSelect, "change", function(evt) {
      graph.getModel().beginUpdate();
      try {
        graph.setCellStyles("jumpStyle", styleSelect.value, graph.getSelectionCells());
        ui.fireEvent(new mxEventObject("styleChanged", "keys", ["jumpStyle"], "values", [styleSelect.value], "cells", graph.getSelectionCells()));
      } finally {
        graph.getModel().endUpdate();
      }
      mxEvent2.consume(evt);
    });
    mxEvent2.addListener(styleSelect, "click", function(evt) {
      mxEvent2.consume(evt);
    });
    container.appendChild(styleSelect);
    var jumpSizeUpdate;
    var jumpSize = this.addUnitInput(container, "pt", 22, 33, function() {
      jumpSizeUpdate.apply(this, arguments);
    });
    jumpSizeUpdate = this.installInputHandler(jumpSize, "jumpSize", Graph2.defaultJumpSize, 0, 999, " pt");
    var listener = bind(this, function(sender, evt, force) {
      ss = this.format.getSelectionState();
      styleSelect.value = getValue(ss.style, "jumpStyle", "none");
      if (force || document.activeElement != jumpSize) {
        var tmp = parseInt(getValue(ss.style, "jumpSize", Graph2.defaultJumpSize));
        jumpSize.value = isNaN(tmp) ? "" : tmp + " pt";
      }
    });
    this.addKeyHandler(jumpSize, listener);
    graph.getModel().addListener(mxEvent2.CHANGE, listener);
    this.listeners.push({
      destroy: function() {
        graph.getModel().removeListener(listener);
      }
    });
    listener();
  } else {
    container.style.display = "none";
  }
  return container;
};
StyleFormatPanel2.prototype.addEffects = function(div) {
  var ui = this.editorUi;
  var editor = ui.editor;
  var graph = editor.graph;
  var ss = this.format.getSelectionState();
  div.style.paddingTop = "0px";
  div.style.paddingBottom = "2px";
  var table = document.createElement("table");
  if (mxClient_default.IS_QUIRKS) {
    table.style.fontSize = "1em";
  }
  table.style.width = "100%";
  table.style.fontWeight = "bold";
  table.style.paddingRight = "20px";
  var tbody = document.createElement("tbody");
  var row = document.createElement("tr");
  row.style.padding = "0px";
  var left = document.createElement("td");
  left.style.padding = "0px";
  left.style.width = "50%";
  left.setAttribute("valign", "top");
  var right = left.cloneNode(true);
  right.style.paddingLeft = "8px";
  row.appendChild(left);
  row.appendChild(right);
  tbody.appendChild(row);
  table.appendChild(tbody);
  div.appendChild(table);
  var current2 = left;
  var count = 0;
  var addOption2 = bind(this, function(label, key, defaultValue) {
    var opt = this.createCellOption(label, key, defaultValue);
    opt.style.width = "100%";
    current2.appendChild(opt);
    current2 = current2 == left ? right : left;
    count++;
  });
  var listener = bind(this, function(sender, evt, force) {
    ss = this.format.getSelectionState();
    left.innerHTML = "";
    right.innerHTML = "";
    current2 = left;
    if (ss.rounded) {
      addOption2(mxResources2.get("rounded"), mxConstants2.STYLE_ROUNDED, 0);
    }
    if (ss.style.shape == "swimlane") {
      addOption2(mxResources2.get("divider"), "swimlaneLine", 1);
    }
    if (!ss.containsImage) {
      addOption2(mxResources2.get("shadow"), mxConstants2.STYLE_SHADOW, 0);
    }
    if (ss.glass) {
      addOption2(mxResources2.get("glass"), mxConstants2.STYLE_GLASS, 0);
    }
    addOption2(mxResources2.get("sketch"), "sketch", 0);
  });
  graph.getModel().addListener(mxEvent2.CHANGE, listener);
  this.listeners.push({
    destroy: function() {
      graph.getModel().removeListener(listener);
    }
  });
  listener();
  return div;
};
StyleFormatPanel2.prototype.addStyleOps = function(div) {
  div.style.paddingTop = "10px";
  div.style.paddingBottom = "10px";
  var btn = button(mxResources2.get("setAsDefaultStyle"), bind(this, function(evt) {
    this.editorUi.actions.get("setAsDefaultStyle").funct();
  }));
  btn.setAttribute("title", mxResources2.get("setAsDefaultStyle") + " (" + this.editorUi.actions.get("setAsDefaultStyle").shortcut + ")");
  btn.style.width = "202px";
  div.appendChild(btn);
  return div;
};

// js/DiagramStylePanel.js
var DiagramStylePanel = function(format, editorUi, container) {
  BaseFormatPanel.call(this, format, editorUi, container);
  this.init();
};
extend(DiagramStylePanel, BaseFormatPanel);
DiagramStylePanel.prototype.init = function() {
  var ui = this.editorUi;
  var editor = ui.editor;
  var graph = editor.graph;
  this.container.appendChild(this.addView(this.createPanel()));
};
DiagramStylePanel.prototype.addView = function(div) {
  var ui = this.editorUi;
  var editor = ui.editor;
  var graph = editor.graph;
  var model = graph.getModel();
  div.style.whiteSpace = "normal";
  var sketch = graph.currentVertexStyle["sketch"] == "1" && graph.currentEdgeStyle["sketch"] == "1";
  var rounded = graph.currentVertexStyle["rounded"] == "1";
  var curved = graph.currentEdgeStyle["curved"] == "1";
  var opts = document.createElement("div");
  opts.style.paddingBottom = "12px";
  opts.style.marginRight = "16px";
  div.style.paddingTop = "8px";
  var table = document.createElement("table");
  if (mxClient.IS_QUIRKS) {
    table.style.fontSize = "1em";
  }
  table.style.width = "100%";
  table.style.fontWeight = "bold";
  var tbody = document.createElement("tbody");
  var row = document.createElement("tr");
  row.style.padding = "0px";
  var left = document.createElement("td");
  left.style.padding = "0px";
  left.style.width = "50%";
  left.setAttribute("valign", "middle");
  var right = left.cloneNode(true);
  right.style.paddingLeft = "8px";
  row.appendChild(left);
  row.appendChild(right);
  tbody.appendChild(row);
  table.appendChild(tbody);
  left.appendChild(this.createOption(mxResources.get("sketch"), function() {
    return sketch;
  }, function(checked) {
    sketch = checked;
    if (checked) {
      graph.currentEdgeStyle["sketch"] = "1";
      graph.currentVertexStyle["sketch"] = "1";
    } else {
      delete graph.currentEdgeStyle["sketch"];
      delete graph.currentVertexStyle["sketch"];
    }
    graph.updateCellStyles("sketch", checked ? "1" : null, graph.getVerticesAndEdges());
  }, null, function(div2) {
    div2.style.width = "auto";
  }));
  right.appendChild(this.createOption(mxResources.get("rounded"), function() {
    return rounded;
  }, function(checked) {
    rounded = checked;
    if (checked) {
      graph.currentVertexStyle["rounded"] = "1";
    } else {
      delete graph.currentVertexStyle["rounded"];
    }
    graph.updateCellStyles("rounded", checked ? "1" : null, graph.getVerticesAndEdges(true, true));
  }, null, function(div2) {
    div2.style.width = "auto";
  }));
  left = left.cloneNode(false);
  right = right.cloneNode(false);
  row = row.cloneNode(false);
  row.appendChild(left);
  row.appendChild(right);
  tbody.appendChild(row);
  left.appendChild(this.createOption(mxResources.get("curved"), function() {
    return curved;
  }, function(checked) {
    curved = checked;
    if (checked) {
      graph.currentEdgeStyle["curved"] = "1";
    } else {
      delete graph.currentEdgeStyle["curved"];
    }
    graph.updateCellStyles("curved", checked ? "1" : null, graph.getVerticesAndEdges(false, true));
  }, null, function(div2) {
    div2.style.width = "auto";
  }));
  opts.appendChild(table);
  div.appendChild(opts);
  var defaultStyles = [
    "fillColor",
    "strokeColor",
    "fontColor",
    "gradientColor"
  ];
  var updateCells = bind(this, function(styles, graphStyle) {
    var cells = graph.getVerticesAndEdges();
    model.beginUpdate();
    try {
      for (var i2 = 0; i2 < cells.length; i2++) {
        var style = graph.getCellStyle(cells[i2]);
        if (style["labelBackgroundColor"] != null) {
          graph.updateCellStyles("labelBackgroundColor", graphStyle != null ? graphStyle.background : null, [cells[i2]]);
        }
        var edge = model.isEdge(cells[i2]);
        var newStyle = model.getStyle(cells[i2]);
        var current2 = edge ? graph.currentEdgeStyle : graph.currentVertexStyle;
        for (var j = 0; j < styles.length; j++) {
          if (style[styles[j]] != null && style[styles[j]] != mxConstants.NONE || styles[j] != mxConstants.STYLE_FILLCOLOR && styles[j] != mxConstants.STYLE_STROKECOLOR) {
            newStyle = setStyle(newStyle, styles[j], current2[styles[j]]);
          }
        }
        model.setStyle(cells[i2], newStyle);
      }
    } finally {
      model.endUpdate();
    }
  });
  var removeStyles = bind(this, function(style, styles, defaultStyle) {
    if (style != null) {
      for (var j = 0; j < styles.length; j++) {
        if (style[styles[j]] != null && style[styles[j]] != mxConstants.NONE || styles[j] != mxConstants.STYLE_FILLCOLOR && styles[j] != mxConstants.STYLE_STROKECOLOR) {
          style[styles[j]] = defaultStyle[styles[j]];
        }
      }
    }
  });
  var applyStyle = bind(this, function(style, result2, cell2, graphStyle, theGraph) {
    if (style != null) {
      if (cell2 != null) {
        if (result2["labelBackgroundColor"] != null) {
          var bg = graphStyle != null ? graphStyle.background : null;
          theGraph = theGraph != null ? theGraph : graph;
          if (bg == null) {
            bg = theGraph.background;
          }
          if (bg == null) {
            bg = theGraph.defaultPageBackgroundColor;
          }
          result2["labelBackgroundColor"] = bg;
        }
      }
      for (var key in style) {
        if (cell2 == null || result2[key] != null && result2[key] != mxConstants.NONE || key != mxConstants.STYLE_FILLCOLOR && key != mxConstants.STYLE_STROKECOLOR) {
          result2[key] = style[key];
        }
      }
    }
  });
  var btn = button(mxResources.get("reset"), bind(this, function(evt) {
    var all = graph.getVerticesAndEdges(true, true);
    if (all.length > 0) {
      model.beginUpdate();
      try {
        graph.updateCellStyles("sketch", null, all);
        graph.updateCellStyles("rounded", null, all);
        graph.updateCellStyles("curved", null, graph.getVerticesAndEdges(false, true));
      } finally {
        model.endUpdate();
      }
    }
    graph.defaultVertexStyle = clone(ui.initialDefaultVertexStyle);
    graph.defaultEdgeStyle = clone(ui.initialDefaultEdgeStyle);
    ui.clearDefaultStyle();
  }));
  btn.setAttribute("title", mxResources.get("reset"));
  btn.style.textOverflow = "ellipsis";
  btn.style.maxWidth = "90px";
  right.appendChild(btn);
  var createPreview = bind(this, function(commonStyle, vertexStyle, edgeStyle, graphStyle, container) {
    var div2 = document.createElement("div");
    div2.style.cssText = "position:absolute;display:inline-block;width:100%;height:100%;overflow:hidden;pointer-events:none;";
    container.appendChild(div2);
    var graph2 = new Graph(div2, null, null, graph.getStylesheet());
    graph2.resetViewOnRootChange = false;
    graph2.foldingEnabled = false;
    graph2.gridEnabled = false;
    graph2.autoScroll = false;
    graph2.setTooltips(false);
    graph2.setConnectable(false);
    graph2.setPanning(false);
    graph2.setEnabled(false);
    graph2.getCellStyle = function(cell2) {
      var result2 = clone(Graph.prototype.getCellStyle.apply(this, arguments));
      var defaultStyle = graph.stylesheet.getDefaultVertexStyle();
      var appliedStyle = vertexStyle;
      if (model.isEdge(cell2)) {
        defaultStyle = graph.stylesheet.getDefaultEdgeStyle();
        appliedStyle = edgeStyle;
      }
      removeStyles(result2, defaultStyles, defaultStyle);
      applyStyle(commonStyle, result2, cell2, graphStyle, graph2);
      applyStyle(appliedStyle, result2, cell2, graphStyle, graph2);
      return result2;
    };
    graph2.model.beginUpdate();
    try {
      var v1 = graph2.insertVertex(graph2.getDefaultParent(), null, "Shape", 14, 8, 70, 40, "strokeWidth=2;");
      var e1 = graph2.insertEdge(graph2.getDefaultParent(), null, "Connector", v1, v1, "edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;endSize=5;strokeWidth=2;");
      e1.geometry.points = [new mxPoint(32, 70)];
      e1.geometry.offset = new mxPoint(0, 8);
    } finally {
      graph2.model.endUpdate();
    }
  });
  var entries = document.createElement("div");
  entries.style.position = "relative";
  div.appendChild(entries);
  if (this.format.cachedStyleEntries == null) {
    this.format.cachedStyleEntries = [];
  }
  var addEntry = bind(this, function(commonStyle, vertexStyle, edgeStyle, graphStyle, index) {
    var panel = this.format.cachedStyleEntries[index];
    if (panel == null) {
      panel = document.createElement("div");
      panel.style.cssText = "display:inline-block;position:relative;width:96px;height:90px;cursor:pointer;border:1px solid gray;margin:2px;overflow:hidden;";
      if (graphStyle != null && graphStyle.background != null) {
        panel.style.backgroundColor = graphStyle.background;
      }
      createPreview(commonStyle, vertexStyle, edgeStyle, graphStyle, panel);
      mxEvent.addGestureListeners(panel, bind(this, function(evt) {
        panel.style.opacity = 0.5;
      }), null, bind(this, function(evt) {
        panel.style.opacity = 1;
        graph.defaultVertexStyle = clone(ui.initialDefaultVertexStyle);
        graph.defaultEdgeStyle = clone(ui.initialDefaultEdgeStyle);
        applyStyle(commonStyle, graph.defaultVertexStyle);
        applyStyle(commonStyle, graph.defaultEdgeStyle);
        applyStyle(vertexStyle, graph.defaultVertexStyle);
        applyStyle(edgeStyle, graph.defaultEdgeStyle);
        ui.clearDefaultStyle();
        if (sketch) {
          graph.currentEdgeStyle["sketch"] = "1";
          graph.currentVertexStyle["sketch"] = "1";
        } else {
          graph.currentEdgeStyle["sketch"] = "0";
          graph.currentVertexStyle["sketch"] = "0";
        }
        if (rounded) {
          graph.currentVertexStyle["rounded"] = "1";
          graph.currentEdgeStyle["rounded"] = "1";
        } else {
          graph.currentVertexStyle["rounded"] = "0";
          graph.currentEdgeStyle["rounded"] = "1";
        }
        if (curved) {
          graph.currentEdgeStyle["curved"] = "1";
        } else {
          graph.currentEdgeStyle["curved"] = "0";
        }
        model.beginUpdate();
        try {
          updateCells(defaultStyles, graphStyle);
          var change = new ChangePageSetup(ui, graphStyle != null ? graphStyle.background : null);
          change.ignoreImage = true;
          model.execute(change);
          model.execute(new ChangeGridColor(ui, graphStyle != null && graphStyle.gridColor != null ? graphStyle.gridColor : graph.view.defaultGridColor));
        } finally {
          model.endUpdate();
        }
      }));
      mxEvent.addListener(panel, "mouseenter", bind(this, function(evt) {
        var prev = graph.getCellStyle;
        var prevBg = graph.background;
        var prevGrid = graph.view.gridColor;
        graph.background = graphStyle != null ? graphStyle.background : null;
        graph.view.gridColor = graphStyle != null && graphStyle.gridColor != null ? graphStyle.gridColor : graph.view.defaultGridColor;
        graph.getCellStyle = function(cell2) {
          var result2 = clone(prev.apply(this, arguments));
          var defaultStyle = graph.stylesheet.getDefaultVertexStyle();
          var appliedStyle = vertexStyle;
          if (model.isEdge(cell2)) {
            defaultStyle = graph.stylesheet.getDefaultEdgeStyle();
            appliedStyle = edgeStyle;
          }
          removeStyles(result2, defaultStyles, defaultStyle);
          applyStyle(commonStyle, result2, cell2, graphStyle);
          applyStyle(appliedStyle, result2, cell2, graphStyle);
          return result2;
        };
        graph.refresh();
        graph.getCellStyle = prev;
        graph.background = prevBg;
        graph.view.gridColor = prevGrid;
      }));
      mxEvent.addListener(panel, "mouseleave", bind(this, function(evt) {
        graph.refresh();
      }));
      this.format.cachedStyleEntries[index] = panel;
    }
    entries.appendChild(panel);
  });
  var maxEntries = 10;
  var pageCount = Math.ceil(Editor.styles.length / maxEntries);
  this.format.currentStylePage = this.format.currentStylePage != null ? this.format.currentStylePage : 0;
  var dots = [];
  var addEntries = bind(this, function() {
    if (dots.length > 0) {
      dots[this.format.currentStylePage].style.background = "#84d7ff";
    }
    for (var i2 = this.format.currentStylePage * maxEntries; i2 < Math.min((this.format.currentStylePage + 1) * maxEntries, Editor.styles.length); i2++) {
      var s = Editor.styles[i2];
      addEntry(s.commonStyle, s.vertexStyle, s.edgeStyle, s.graph, i2);
    }
  });
  var selectPage = bind(this, function(index) {
    if (index >= 0 && index < pageCount) {
      dots[this.format.currentStylePage].style.background = "transparent";
      entries.innerHTML = "";
      this.format.currentStylePage = index;
      addEntries();
    }
  });
  if (pageCount > 1) {
    var switcher = document.createElement("div");
    switcher.style.whiteSpace = "nowrap";
    switcher.style.position = "relative";
    switcher.style.textAlign = "center";
    switcher.style.paddingTop = "4px";
    switcher.style.width = "210px";
    div.style.paddingBottom = "8px";
    for (var i = 0; i < pageCount; i++) {
      var dot = document.createElement("div");
      dot.style.display = "inline-block";
      dot.style.width = "6px";
      dot.style.height = "6px";
      dot.style.marginLeft = "4px";
      dot.style.marginRight = "3px";
      dot.style.borderRadius = "3px";
      dot.style.cursor = "pointer";
      dot.style.background = "transparent";
      dot.style.border = "1px solid #b5b6b7";
      bind(this, function(index, elt) {
        mxEvent.addListener(dot, "click", bind(this, function() {
          selectPage(index);
        }));
      })(i, dot);
      switcher.appendChild(dot);
      dots.push(dot);
    }
    div.appendChild(switcher);
    addEntries();
    if (pageCount < 15) {
      let addHoverState = function(elt) {
        mxEvent.addListener(elt, "mouseenter", function() {
          elt.style.opacity = "1";
        });
        mxEvent.addListener(elt, "mouseleave", function() {
          elt.style.opacity = "0.5";
        });
      };
      var left = document.createElement("div");
      left.style.cssText = "position:absolute;left:0px;top:4px;bottom:0px;width:20px;margin:0px;opacity:0.5;background-repeat:no-repeat;background-position:center center;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAQBAMAAADQT4M0AAAAIVBMVEUAAAB2dnZ4eHh3d3d1dXVxcXF2dnZ2dnZ2dnZxcXF2dnYmb3w1AAAACnRSTlMAfCTkhhvb7cQSPH2JPgAAADRJREFUCNdjwACMAmBKaiGYs2oJmLPKAZ3DabU8AMRTXpUKopislqFyVzCAuUZgikkBZjoAcMYLnp53P/UAAAAASUVORK5CYII=);";
      mxEvent.addListener(left, "click", bind(this, function() {
        selectPage(mod(this.format.currentStylePage - 1, pageCount));
      }));
      var right = document.createElement("div");
      right.style.cssText = "position:absolute;right:2px;top:4px;bottom:0px;width:20px;margin:0px;opacity:0.5;background-repeat:no-repeat;background-position:center center;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAQBAMAAADQT4M0AAAAIVBMVEUAAAB2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnYBuwCcAAAACnRSTlMAfCTkhhvb7cQSPH2JPgAAADZJREFUCNdjQAOMAmBKaiGY8loF5rKswsZlrVo8AUiFrTICcbIWK8A5DF1gDoMymMPApIAwHwCS0Qx/U7qCBQAAAABJRU5ErkJggg==);";
      switcher.appendChild(left);
      switcher.appendChild(right);
      mxEvent.addListener(right, "click", bind(this, function() {
        selectPage(mod(this.format.currentStylePage + 1, pageCount));
      }));
      addHoverState(left);
      addHoverState(right);
    }
  } else {
    addEntries();
  }
  return div;
};

// js/Menus.js
function Menus(editorUi) {
  this.editorUi = editorUi;
  this.menus = new Object();
  this.init();
  if (!mxClient_default.IS_SVG) {
    new Image().src = this.checkmarkImage;
  }
}
Menus.prototype.defaultFont = "Helvetica";
Menus.prototype.defaultFontSize = "12";
Menus.prototype.defaultMenuItems = ["file", "edit", "view", "arrange", "extras", "help"];
Menus.prototype.defaultFonts = [
  "Helvetica",
  "Verdana",
  "Times New Roman",
  "Garamond",
  "Comic Sans MS",
  "Courier New",
  "Georgia",
  "Lucida Console",
  "Tahoma"
];
Menus.prototype.init = function() {
  var graph = this.editorUi.editor.graph;
  var isGraphEnabled = bind(graph, graph.isEnabled);
  this.customFonts = [];
  this.customFontSizes = [];
  this.put("fontFamily", new Menu(bind(this, function(menu, parent2) {
    var addItem = bind(this, function(fontname) {
      var tr = this.styleChange(menu, fontname, [mxConstants2.STYLE_FONTFAMILY], [fontname], null, parent2, function() {
        document.execCommand("fontname", false, fontname);
      }, function() {
        graph.updateLabelElements(graph.getSelectionCells(), function(elt) {
          elt.removeAttribute("face");
          elt.style.fontFamily = null;
          if (elt.nodeName == "PRE") {
            graph.replaceElement(elt, "div");
          }
        });
      });
      tr.firstChild.nextSibling.style.fontFamily = fontname;
    });
    for (var i = 0; i < this.defaultFonts.length; i++) {
      addItem(this.defaultFonts[i]);
    }
    menu.addSeparator(parent2);
    if (this.customFonts.length > 0) {
      for (var i = 0; i < this.customFonts.length; i++) {
        addItem(this.customFonts[i]);
      }
      menu.addSeparator(parent2);
      menu.addItem(mxResources2.get("reset"), null, bind(this, function() {
        this.customFonts = [];
        this.editorUi.fireEvent(new mxEventObject2("customFontsChanged"));
      }), parent2);
      menu.addSeparator(parent2);
    }
    this.promptChange(menu, mxResources2.get("custom") + "...", "", mxConstants2.DEFAULT_FONTFAMILY, mxConstants2.STYLE_FONTFAMILY, parent2, true, bind(this, function(newValue) {
      if (indexOf(this.customFonts, newValue) < 0) {
        this.customFonts.push(newValue);
        this.editorUi.fireEvent(new mxEventObject2("customFontsChanged"));
      }
    }));
  })));
  this.put("formatBlock", new Menu(bind(this, function(menu, parent2) {
    function addItem(label, tag) {
      return menu.addItem(label, null, bind(this, function() {
        if (graph.cellEditor.textarea != null) {
          graph.cellEditor.textarea.focus();
          document.execCommand("formatBlock", false, "<" + tag + ">");
        }
      }), parent2);
    }
    ;
    addItem(mxResources2.get("normal"), "p");
    addItem("", "h1").firstChild.nextSibling.innerHTML = '<h1 style="margin:0px;">' + mxResources2.get("heading") + " 1</h1>";
    addItem("", "h2").firstChild.nextSibling.innerHTML = '<h2 style="margin:0px;">' + mxResources2.get("heading") + " 2</h2>";
    addItem("", "h3").firstChild.nextSibling.innerHTML = '<h3 style="margin:0px;">' + mxResources2.get("heading") + " 3</h3>";
    addItem("", "h4").firstChild.nextSibling.innerHTML = '<h4 style="margin:0px;">' + mxResources2.get("heading") + " 4</h4>";
    addItem("", "h5").firstChild.nextSibling.innerHTML = '<h5 style="margin:0px;">' + mxResources2.get("heading") + " 5</h5>";
    addItem("", "h6").firstChild.nextSibling.innerHTML = '<h6 style="margin:0px;">' + mxResources2.get("heading") + " 6</h6>";
    addItem("", "pre").firstChild.nextSibling.innerHTML = '<pre style="margin:0px;">' + mxResources2.get("formatted") + "</pre>";
    addItem("", "blockquote").firstChild.nextSibling.innerHTML = '<blockquote style="margin-top:0px;margin-bottom:0px;">' + mxResources2.get("blockquote") + "</blockquote>";
  })));
  this.put("fontSize", new Menu(bind(this, function(menu, parent2) {
    var sizes = [6, 8, 9, 10, 11, 12, 14, 18, 24, 36, 48, 72];
    var addItem = bind(this, function(fontsize) {
      this.styleChange(menu, fontsize, [mxConstants2.STYLE_FONTSIZE], [fontsize], null, parent2, function() {
        if (graph.cellEditor.textarea != null) {
          document.execCommand("fontSize", false, "3");
          var elts = graph.cellEditor.textarea.getElementsByTagName("font");
          for (var i2 = 0; i2 < elts.length; i2++) {
            if (elts[i2].getAttribute("size") == "3") {
              elts[i2].removeAttribute("size");
              elts[i2].style.fontSize = fontsize + "px";
              break;
            }
          }
        }
      });
    });
    for (var i = 0; i < sizes.length; i++) {
      addItem(sizes[i]);
    }
    menu.addSeparator(parent2);
    if (this.customFontSizes.length > 0) {
      for (var i = 0; i < this.customFontSizes.length; i++) {
        addItem(this.customFontSizes[i]);
      }
      menu.addSeparator(parent2);
      menu.addItem(mxResources2.get("reset"), null, bind(this, function() {
        this.customFontSizes = [];
      }), parent2);
      menu.addSeparator(parent2);
    }
    this.promptChange(menu, mxResources2.get("custom") + "...", "(pt)", "12", mxConstants2.STYLE_FONTSIZE, parent2, true, bind(this, function(newValue) {
      this.customFontSizes.push(newValue);
    }));
  })));
  this.put("direction", new Menu(bind(this, function(menu, parent2) {
    menu.addItem(mxResources2.get("flipH"), null, function() {
      graph.toggleCellStyles(mxConstants2.STYLE_FLIPH, false);
    }, parent2);
    menu.addItem(mxResources2.get("flipV"), null, function() {
      graph.toggleCellStyles(mxConstants2.STYLE_FLIPV, false);
    }, parent2);
    this.addMenuItems(menu, ["-", "rotation"], parent2);
  })));
  this.put("align", new Menu(bind(this, function(menu, parent2) {
    menu.addItem(mxResources2.get("leftAlign"), null, function() {
      graph.alignCells(mxConstants2.ALIGN_LEFT);
    }, parent2);
    menu.addItem(mxResources2.get("center"), null, function() {
      graph.alignCells(mxConstants2.ALIGN_CENTER);
    }, parent2);
    menu.addItem(mxResources2.get("rightAlign"), null, function() {
      graph.alignCells(mxConstants2.ALIGN_RIGHT);
    }, parent2);
    menu.addSeparator(parent2);
    menu.addItem(mxResources2.get("topAlign"), null, function() {
      graph.alignCells(mxConstants2.ALIGN_TOP);
    }, parent2);
    menu.addItem(mxResources2.get("middle"), null, function() {
      graph.alignCells(mxConstants2.ALIGN_MIDDLE);
    }, parent2);
    menu.addItem(mxResources2.get("bottomAlign"), null, function() {
      graph.alignCells(mxConstants2.ALIGN_BOTTOM);
    }, parent2);
  })));
  this.put("distribute", new Menu(bind(this, function(menu, parent2) {
    menu.addItem(mxResources2.get("horizontal"), null, function() {
      graph.distributeCells(true);
    }, parent2);
    menu.addItem(mxResources2.get("vertical"), null, function() {
      graph.distributeCells(false);
    }, parent2);
  })));
  this.put("layout", new Menu(bind(this, function(menu, parent2) {
    var promptSpacing = bind(this, function(defaultValue, fn) {
      var dlg = new FilenameDialog(this.editorUi, defaultValue, mxResources2.get("apply"), function(newValue) {
        fn(parseFloat(newValue));
      }, mxResources2.get("spacing"));
      this.editorUi.showDialog(dlg.container, 300, 80, true, true);
      dlg.init();
    });
    menu.addItem(mxResources2.get("horizontalFlow"), null, bind(this, function() {
      var layout = new mxHierarchicalLayout(graph, mxConstants2.DIRECTION_WEST);
      this.editorUi.executeLayout(function() {
        var selectionCells = graph.getSelectionCells();
        layout.execute(graph.getDefaultParent(), selectionCells.length == 0 ? null : selectionCells);
      }, true);
    }), parent2);
    menu.addItem(mxResources2.get("verticalFlow"), null, bind(this, function() {
      var layout = new mxHierarchicalLayout(graph, mxConstants2.DIRECTION_NORTH);
      this.editorUi.executeLayout(function() {
        var selectionCells = graph.getSelectionCells();
        layout.execute(graph.getDefaultParent(), selectionCells.length == 0 ? null : selectionCells);
      }, true);
    }), parent2);
    menu.addSeparator(parent2);
    menu.addItem(mxResources2.get("horizontalTree"), null, bind(this, function() {
      var tmp = graph.getSelectionCell();
      var roots = null;
      if (tmp == null || graph.getModel().getChildCount(tmp) == 0) {
        if (graph.getModel().getEdgeCount(tmp) == 0) {
          roots = graph.findTreeRoots(graph.getDefaultParent());
        }
      } else {
        roots = graph.findTreeRoots(tmp);
      }
      if (roots != null && roots.length > 0) {
        tmp = roots[0];
      }
      if (tmp != null) {
        var layout = new mxCompactTreeLayout(graph, true);
        layout.edgeRouting = false;
        layout.levelDistance = 30;
        promptSpacing(layout.levelDistance, bind(this, function(newValue) {
          layout.levelDistance = newValue;
          this.editorUi.executeLayout(function() {
            layout.execute(graph.getDefaultParent(), tmp);
          }, true);
        }));
      }
    }), parent2);
    menu.addItem(mxResources2.get("verticalTree"), null, bind(this, function() {
      var tmp = graph.getSelectionCell();
      var roots = null;
      if (tmp == null || graph.getModel().getChildCount(tmp) == 0) {
        if (graph.getModel().getEdgeCount(tmp) == 0) {
          roots = graph.findTreeRoots(graph.getDefaultParent());
        }
      } else {
        roots = graph.findTreeRoots(tmp);
      }
      if (roots != null && roots.length > 0) {
        tmp = roots[0];
      }
      if (tmp != null) {
        var layout = new mxCompactTreeLayout(graph, false);
        layout.edgeRouting = false;
        layout.levelDistance = 30;
        promptSpacing(layout.levelDistance, bind(this, function(newValue) {
          layout.levelDistance = newValue;
          this.editorUi.executeLayout(function() {
            layout.execute(graph.getDefaultParent(), tmp);
          }, true);
        }));
      }
    }), parent2);
    menu.addItem(mxResources2.get("radialTree"), null, bind(this, function() {
      var tmp = graph.getSelectionCell();
      var roots = null;
      if (tmp == null || graph.getModel().getChildCount(tmp) == 0) {
        if (graph.getModel().getEdgeCount(tmp) == 0) {
          roots = graph.findTreeRoots(graph.getDefaultParent());
        }
      } else {
        roots = graph.findTreeRoots(tmp);
      }
      if (roots != null && roots.length > 0) {
        tmp = roots[0];
      }
      if (tmp != null) {
        var layout = new mxRadialTreeLayout(graph, false);
        layout.levelDistance = 80;
        layout.autoRadius = true;
        promptSpacing(layout.levelDistance, bind(this, function(newValue) {
          layout.levelDistance = newValue;
          this.editorUi.executeLayout(function() {
            layout.execute(graph.getDefaultParent(), tmp);
            if (!graph.isSelectionEmpty()) {
              tmp = graph.getModel().getParent(tmp);
              if (graph.getModel().isVertex(tmp)) {
                graph.updateGroupBounds([tmp], graph.gridSize * 2, true);
              }
            }
          }, true);
        }));
      }
    }), parent2);
    menu.addSeparator(parent2);
    menu.addItem(mxResources2.get("organic"), null, bind(this, function() {
      var layout = new mxFastOrganicLayout(graph);
      promptSpacing(layout.forceConstant, bind(this, function(newValue) {
        layout.forceConstant = newValue;
        this.editorUi.executeLayout(function() {
          var tmp = graph.getSelectionCell();
          if (tmp == null || graph.getModel().getChildCount(tmp) == 0) {
            tmp = graph.getDefaultParent();
          }
          layout.execute(tmp);
          if (graph.getModel().isVertex(tmp)) {
            graph.updateGroupBounds([tmp], graph.gridSize * 2, true);
          }
        }, true);
      }));
    }), parent2);
    menu.addItem(mxResources2.get("circle"), null, bind(this, function() {
      var layout = new mxCircleLayout(graph);
      this.editorUi.executeLayout(function() {
        var tmp = graph.getSelectionCell();
        if (tmp == null || graph.getModel().getChildCount(tmp) == 0) {
          tmp = graph.getDefaultParent();
        }
        layout.execute(tmp);
        if (graph.getModel().isVertex(tmp)) {
          graph.updateGroupBounds([tmp], graph.gridSize * 2, true);
        }
      }, true);
    }), parent2);
  })));
  this.put("navigation", new Menu(bind(this, function(menu, parent2) {
    this.addMenuItems(menu, ["home", "-", "exitGroup", "enterGroup", "-", "expand", "collapse", "-", "collapsible"], parent2);
  })));
  this.put("arrange", new Menu(bind(this, function(menu, parent2) {
    this.addMenuItems(menu, ["toFront", "toBack", "-"], parent2);
    this.addSubmenu("direction", menu, parent2);
    this.addMenuItems(menu, ["turn", "-"], parent2);
    this.addSubmenu("align", menu, parent2);
    this.addSubmenu("distribute", menu, parent2);
    menu.addSeparator(parent2);
    this.addSubmenu("navigation", menu, parent2);
    this.addSubmenu("insert", menu, parent2);
    this.addSubmenu("layout", menu, parent2);
    this.addMenuItems(menu, ["-", "group", "ungroup", "removeFromGroup", "-", "clearWaypoints", "autosize"], parent2);
  }))).isEnabled = isGraphEnabled;
  this.put("insert", new Menu(bind(this, function(menu, parent2) {
    this.addMenuItems(menu, ["insertLink", "insertImage"], parent2);
  })));
  this.put("view", new Menu(bind(this, function(menu, parent2) {
    this.addMenuItems(menu, (this.editorUi.format != null ? ["formatPanel"] : []).concat([
      "outline",
      "layers",
      "-",
      "pageView",
      "pageScale",
      "-",
      "scrollbars",
      "tooltips",
      "-",
      "grid",
      "guides",
      "-",
      "connectionArrows",
      "connectionPoints",
      "-",
      "resetView",
      "zoomIn",
      "zoomOut"
    ], parent2));
  })));
  this.put("viewPanels", new Menu(bind(this, function(menu, parent2) {
    if (this.editorUi.format != null) {
      this.addMenuItems(menu, ["formatPanel"], parent2);
    }
    this.addMenuItems(menu, ["outline", "layers"], parent2);
  })));
  this.put("viewZoom", new Menu(bind(this, function(menu, parent2) {
    this.addMenuItems(menu, ["resetView", "-"], parent2);
    var scales = [0.25, 0.5, 0.75, 1, 1.25, 1.5, 2, 3, 4];
    for (var i = 0; i < scales.length; i++) {
      (function(scale) {
        menu.addItem(scale * 100 + "%", null, function() {
          graph.zoomTo(scale);
        }, parent2);
      })(scales[i]);
    }
    this.addMenuItems(menu, ["-", "fitWindow", "fitPageWidth", "fitPage", "fitTwoPages", "-", "customZoom"], parent2);
  })));
  this.put("file", new Menu(bind(this, function(menu, parent2) {
    this.addMenuItems(menu, ["new", "open", "-", "save", "saveAs", "-", "import", "export", "-", "pageSetup", "print"], parent2);
  })));
  this.put("edit", new Menu(bind(this, function(menu, parent2) {
    this.addMenuItems(menu, [
      "undo",
      "redo",
      "-",
      "cut",
      "copy",
      "paste",
      "delete",
      "-",
      "duplicate",
      "-",
      "editData",
      "editTooltip",
      "-",
      "editStyle",
      "-",
      "edit",
      "-",
      "editLink",
      "openLink",
      "-",
      "selectVertices",
      "selectEdges",
      "selectAll",
      "selectNone",
      "-",
      "lockUnlock"
    ]);
  })));
  this.put("extras", new Menu(bind(this, function(menu, parent2) {
    this.addMenuItems(menu, ["copyConnect", "collapseExpand", "-", "editDiagram"]);
  })));
  this.put("help", new Menu(bind(this, function(menu, parent2) {
    this.addMenuItems(menu, ["help", "-", "about"]);
  })));
};
Menus.prototype.put = function(name, menu) {
  this.menus[name] = menu;
  return menu;
};
Menus.prototype.get = function(name) {
  return this.menus[name];
};
Menus.prototype.addSubmenu = function(name, menu, parent2, label) {
  var entry = this.get(name);
  if (entry != null) {
    var enabled = entry.isEnabled();
    if (menu.showDisabled || enabled) {
      var submenu = menu.addItem(label || mxResources2.get(name), null, null, parent2, null, enabled);
      this.addMenu(name, menu, submenu);
    }
  }
};
Menus.prototype.addMenu = function(name, popupMenu, parent2) {
  var menu = this.get(name);
  if (menu != null && (popupMenu.showDisabled || menu.isEnabled())) {
    this.get(name).execute(popupMenu, parent2);
  }
};
Menus.prototype.addInsertTableCellItem = function(menu, parent2) {
  var graph = this.editorUi.editor.graph;
  this.addInsertTableItem(menu, bind(this, function(evt, rows, cols) {
    var table = mxEvent2.isControlDown(evt) || mxEvent2.isMetaDown(evt) ? graph.createCrossFunctionalSwimlane(rows, cols) : graph.createTable(rows, cols, null, null, mxEvent2.isShiftDown(evt) ? "Table" : null);
    var pt = mxEvent2.isAltDown(evt) ? graph.getFreeInsertPoint() : graph.getCenterInsertPoint(graph.getBoundingBoxFromGeometry([table], true));
    var select = graph.importCells([table], pt.x, pt.y);
    if (select != null && select.length > 0) {
      graph.scrollCellToVisible(select[0]);
      graph.setSelectionCells(select);
    }
  }), parent2);
};
Menus.prototype.addInsertTableItem = function(menu, insertFn, parent2) {
  insertFn = insertFn != null ? insertFn : bind(this, function(evt, rows, cols) {
    var graph2 = this.editorUi.editor.graph;
    var td2 = graph2.getParentByName(mxEvent2.getSource(evt), "TD");
    if (td2 != null && graph2.cellEditor.textarea != null) {
      var row22 = graph2.getParentByName(td2, "TR");
      var tmp = graph2.cellEditor.textarea.getElementsByTagName("table");
      var oldTables = [];
      for (var i = 0; i < tmp.length; i++) {
        oldTables.push(tmp[i]);
      }
      graph2.container.focus();
      graph2.pasteHtmlAtCaret(createTable(rows, cols));
      var newTables = graph2.cellEditor.textarea.getElementsByTagName("table");
      if (newTables.length == oldTables.length + 1) {
        for (var i = newTables.length - 1; i >= 0; i--) {
          if (i == 0 || newTables[i] != oldTables[i - 1]) {
            graph2.selectNode(newTables[i].rows[0].cells[0]);
            break;
          }
        }
      }
    }
  });
  var graph = this.editorUi.editor.graph;
  var row2 = null;
  var td = null;
  function createTable(rows, cols) {
    var html = ["<table>"];
    for (var i = 0; i < rows; i++) {
      html.push("<tr>");
      for (var j = 0; j < cols; j++) {
        html.push("<td><br></td>");
      }
      html.push("</tr>");
    }
    html.push("</table>");
    return html.join("");
  }
  ;
  var elt2 = menu.addItem("", null, null, parent2, null, null, null, true);
  var quirksCellHtml = '<img src="' + mxClient_default.imageBasePath + '/transparent.gif" width="16" height="16"/>';
  function createPicker(rows, cols) {
    var table2 = document.createElement("table");
    table2.setAttribute("border", "1");
    table2.style.borderCollapse = "collapse";
    table2.style.borderStyle = "solid";
    if (!mxClient_default.IS_QUIRKS) {
      table2.setAttribute("cellPadding", "8");
    }
    for (var i = 0; i < rows; i++) {
      var row = table2.insertRow(i);
      for (var j = 0; j < cols; j++) {
        var cell2 = row.insertCell(-1);
        if (mxClient_default.IS_QUIRKS) {
          cell2.innerHTML = quirksCellHtml;
        }
      }
    }
    return table2;
  }
  ;
  function extendPicker(picker2, rows, cols) {
    for (var i = picker2.rows.length; i < rows; i++) {
      var row = picker2.insertRow(i);
      for (var j = 0; j < picker2.rows[0].cells.length; j++) {
        var cell2 = row.insertCell(-1);
        if (mxClient_default.IS_QUIRKS) {
          cell2.innerHTML = quirksCellHtml;
        }
      }
    }
    for (var i = 0; i < picker2.rows.length; i++) {
      var row = picker2.rows[i];
      for (var j = row.cells.length; j < cols; j++) {
        var cell2 = row.insertCell(-1);
        if (mxClient_default.IS_QUIRKS) {
          cell2.innerHTML = quirksCellHtml;
        }
      }
    }
  }
  ;
  elt2.firstChild.innerHTML = "";
  var picker = createPicker(5, 5);
  elt2.firstChild.appendChild(picker);
  var label = document.createElement("div");
  label.style.padding = "4px";
  label.style.fontSize = Menus.prototype.defaultFontSize + "px";
  label.innerHTML = "1x1";
  elt2.firstChild.appendChild(label);
  function mouseover(e) {
    td = graph.getParentByName(mxEvent2.getSource(e), "TD");
    var selected = false;
    if (td != null) {
      row2 = graph.getParentByName(td, "TR");
      var ext = mxEvent2.isMouseEvent(e) ? 2 : 4;
      extendPicker(picker, Math.min(20, row2.sectionRowIndex + ext), Math.min(20, td.cellIndex + ext));
      label.innerHTML = td.cellIndex + 1 + "x" + (row2.sectionRowIndex + 1);
      for (var i = 0; i < picker.rows.length; i++) {
        var r = picker.rows[i];
        for (var j = 0; j < r.cells.length; j++) {
          var cell2 = r.cells[j];
          if (i == row2.sectionRowIndex && j == td.cellIndex) {
            selected = cell2.style.backgroundColor == "blue";
          }
          if (i <= row2.sectionRowIndex && j <= td.cellIndex) {
            cell2.style.backgroundColor = "blue";
          } else {
            cell2.style.backgroundColor = "transparent";
          }
        }
      }
    }
    mxEvent2.consume(e);
    return selected;
  }
  ;
  mxEvent2.addGestureListeners(picker, null, null, bind(this, function(e) {
    var selected = mouseover(e);
    if (td != null && row2 != null && selected) {
      insertFn(e, row2.sectionRowIndex + 1, td.cellIndex + 1);
      window.setTimeout(bind(this, function() {
        this.editorUi.hideCurrentMenu();
      }), 0);
    }
  }));
  mxEvent2.addListener(picker, "mouseover", mouseover);
};
Menus.prototype.edgeStyleChange = function(menu, label, keys, values, sprite, parent2, reset2) {
  return menu.addItem(label, null, bind(this, function() {
    var graph = this.editorUi.editor.graph;
    graph.stopEditing(false);
    graph.getModel().beginUpdate();
    try {
      var cells = graph.getSelectionCells();
      var edges = [];
      for (var i = 0; i < cells.length; i++) {
        var cell2 = cells[i];
        if (graph.getModel().isEdge(cell2)) {
          if (reset2) {
            var geo = graph.getCellGeometry(cell2);
            if (geo != null) {
              geo = geo.clone();
              geo.points = null;
              graph.getModel().setGeometry(cell2, geo);
            }
          }
          for (var j = 0; j < keys.length; j++) {
            graph.setCellStyles(keys[j], values[j], [cell2]);
          }
          edges.push(cell2);
        }
      }
      this.editorUi.fireEvent(new mxEventObject2("styleChanged", "keys", keys, "values", values, "cells", edges));
    } finally {
      graph.getModel().endUpdate();
    }
  }), parent2, sprite);
};
Menus.prototype.styleChange = function(menu, label, keys, values, sprite, parent2, fn, post2) {
  var apply = this.createStyleChangeFunction(keys, values);
  return menu.addItem(label, null, bind(this, function() {
    var graph = this.editorUi.editor.graph;
    if (fn != null && graph.cellEditor.isContentEditing()) {
      fn();
    } else {
      apply(post2);
    }
  }), parent2, sprite);
};
Menus.prototype.createStyleChangeFunction = function(keys, values) {
  return bind(this, function(post2) {
    var graph = this.editorUi.editor.graph;
    graph.stopEditing(false);
    graph.getModel().beginUpdate();
    try {
      var cells = graph.getSelectionCells();
      for (var i = 0; i < keys.length; i++) {
        graph.setCellStyles(keys[i], values[i], cells);
        if (keys[i] == mxConstants2.STYLE_ALIGN) {
          graph.updateLabelElements(cells, function(elt) {
            elt.removeAttribute("align");
            elt.style.textAlign = null;
          });
        }
        if (keys[i] == mxConstants2.STYLE_FONTFAMILY) {
          for (var j = 0; j < cells.length; j++) {
            if (graph.model.getChildCount(cells[j]) == 0) {
              graph.autoSizeCell(cells[j], false);
            }
          }
        }
      }
      if (post2 != null) {
        post2();
      }
      this.editorUi.fireEvent(new mxEventObject2("styleChanged", "keys", keys, "values", values, "cells", cells));
    } finally {
      graph.getModel().endUpdate();
    }
  });
};
Menus.prototype.promptChange = function(menu, label, hint, defaultValue, key, parent2, enabled, fn, sprite) {
  return menu.addItem(label, null, bind(this, function() {
    var graph = this.editorUi.editor.graph;
    var value = defaultValue;
    var state2 = graph.getView().getState(graph.getSelectionCell());
    if (state2 != null) {
      value = state2.style[key] || value;
    }
    var dlg = new FilenameDialog(this.editorUi, value, mxResources2.get("apply"), bind(this, function(newValue) {
      if (newValue != null && newValue.length > 0) {
        graph.getModel().beginUpdate();
        try {
          graph.stopEditing(false);
          graph.setCellStyles(key, newValue);
        } finally {
          graph.getModel().endUpdate();
        }
        if (fn != null) {
          fn(newValue);
        }
      }
    }), mxResources2.get("enterValue") + (hint.length > 0 ? " " + hint : ""));
    this.editorUi.showDialog(dlg.container, 300, 80, true, true);
    dlg.init();
  }), parent2, sprite, enabled);
};
Menus.prototype.pickColor = function(key, cmd, defaultValue) {
  var graph = this.editorUi.editor.graph;
  var h2 = 226 + (Math.ceil(ColorDialog.prototype.presetColors.length / 12) + Math.ceil(ColorDialog.prototype.defaultColors.length / 12)) * 17;
  if (cmd != null && graph.cellEditor.isContentEditing()) {
    var selState = graph.cellEditor.saveSelection();
    var dlg = new ColorDialog(this.editorUi, defaultValue || "000000", bind(this, function(color2) {
      graph.cellEditor.restoreSelection(selState);
      document.execCommand(cmd, false, color2 != mxConstants2.NONE ? color2 : "transparent");
    }), function() {
      graph.cellEditor.restoreSelection(selState);
    });
    this.editorUi.showDialog(dlg.container, 230, h2, true, true);
    dlg.init();
  } else {
    if (this.colorDialog == null) {
      this.colorDialog = new ColorDialog(this.editorUi);
    }
    this.colorDialog.currentColorKey = key;
    var state2 = graph.getView().getState(graph.getSelectionCell());
    var color = "none";
    if (state2 != null) {
      color = state2.style[key] || color;
    }
    if (color == "none") {
      color = "ffffff";
      this.colorDialog.picker.fromString("ffffff");
      this.colorDialog.colorInput.value = "none";
    } else {
      this.colorDialog.picker.fromString(color);
    }
    this.editorUi.showDialog(this.colorDialog.container, 230, h2, true, true);
    this.colorDialog.init();
  }
};
Menus.prototype.toggleStyle = function(key, defaultValue) {
  var graph = this.editorUi.editor.graph;
  var value = graph.toggleCellStyles(key, defaultValue);
  this.editorUi.fireEvent(new mxEventObject2("styleChanged", "keys", [key], "values", [value], "cells", graph.getSelectionCells()));
};
Menus.prototype.addMenuItem = function(menu, key, parent2, trigger, sprite, label) {
  var action = this.editorUi.actions.get(key);
  if (action != null && (menu.showDisabled || action.isEnabled()) && action.visible) {
    var item = menu.addItem(label || action.label, null, function() {
      action.funct(trigger);
    }, parent2, sprite, action.isEnabled());
    if (action.toggleAction && action.isSelected()) {
      menu.addCheckmark(item, Editor2.checkmarkImage);
    }
    this.addShortcut(item, action);
    return item;
  }
  return null;
};
Menus.prototype.addShortcut = function(item, action) {
  if (action.shortcut != null) {
    var td = item.firstChild.nextSibling.nextSibling;
    var span = document.createElement("span");
    span.style.color = "gray";
    write(span, action.shortcut);
    td.appendChild(span);
  }
};
Menus.prototype.addMenuItems = function(menu, keys, parent2, trigger, sprites) {
  for (var i = 0; i < keys.length; i++) {
    if (keys[i] == "-") {
      menu.addSeparator(parent2);
    } else {
      this.addMenuItem(menu, keys[i], parent2, trigger, sprites != null ? sprites[i] : null);
    }
  }
};
Menus.prototype.createPopupMenu = function(menu, cell2, evt) {
  menu.smartSeparators = true;
  this.addPopupMenuHistoryItems(menu, cell2, evt);
  this.addPopupMenuEditItems(menu, cell2, evt);
  this.addPopupMenuStyleItems(menu, cell2, evt);
  this.addPopupMenuArrangeItems(menu, cell2, evt);
  this.addPopupMenuCellItems(menu, cell2, evt);
  this.addPopupMenuSelectionItems(menu, cell2, evt);
};
Menus.prototype.addPopupMenuHistoryItems = function(menu, cell2, evt) {
  if (this.editorUi.editor.graph.isSelectionEmpty()) {
    this.addMenuItems(menu, ["undo", "redo"], null, evt);
  }
};
Menus.prototype.addPopupMenuEditItems = function(menu, cell2, evt) {
  if (this.editorUi.editor.graph.isSelectionEmpty()) {
    this.addMenuItems(menu, ["pasteHere"], null, evt);
  } else {
    this.addMenuItems(menu, ["delete", "-", "cut", "copy", "-", "duplicate"], null, evt);
  }
};
Menus.prototype.addPopupMenuStyleItems = function(menu, cell2, evt) {
  if (this.editorUi.editor.graph.getSelectionCount() == 1) {
    this.addMenuItems(menu, ["-", "setAsDefaultStyle"], null, evt);
  } else if (this.editorUi.editor.graph.isSelectionEmpty()) {
    this.addMenuItems(menu, ["-", "clearDefaultStyle"], null, evt);
  }
};
Menus.prototype.addPopupMenuArrangeItems = function(menu, cell2, evt) {
  var graph = this.editorUi.editor.graph;
  if (!graph.isSelectionEmpty()) {
    this.addMenuItems(menu, ["-", "toFront", "toBack"], null, evt);
  }
  if (graph.getSelectionCount() > 1) {
    this.addMenuItems(menu, ["-", "group"], null, evt);
  } else if (graph.getSelectionCount() == 1 && !graph.getModel().isEdge(cell2) && !graph.isSwimlane(cell2) && graph.getModel().getChildCount(cell2) > 0) {
    this.addMenuItems(menu, ["-", "ungroup"], null, evt);
  }
};
Menus.prototype.addPopupMenuCellItems = function(menu, cell2, evt) {
  var graph = this.editorUi.editor.graph;
  cell2 = graph.getSelectionCell();
  var state2 = graph.view.getState(cell2);
  menu.addSeparator();
  if (state2 != null) {
    var hasWaypoints = false;
    if (graph.getModel().isEdge(cell2) && getValue(state2.style, mxConstants2.STYLE_EDGE, null) != "entityRelationEdgeStyle" && getValue(state2.style, mxConstants2.STYLE_SHAPE, null) != "arrow") {
      var handler = graph.selectionCellsHandler.getHandler(cell2);
      var isWaypoint = false;
      if (handler instanceof mxEdgeHandler && handler.bends != null && handler.bends.length > 2) {
        var index = handler.getHandleForEvent(graph.updateMouseEvent(new mxMouseEvent(evt)));
        var rmWaypointAction = this.editorUi.actions.get("removeWaypoint");
        rmWaypointAction.handler = handler;
        rmWaypointAction.index = index;
        isWaypoint = index > 0 && index < handler.bends.length - 1;
      }
      menu.addSeparator();
      this.addMenuItem(menu, "turn", null, evt, null, mxResources2.get("reverse"));
      this.addMenuItems(menu, [isWaypoint ? "removeWaypoint" : "addWaypoint"], null, evt);
      var geo = graph.getModel().getGeometry(cell2);
      hasWaypoints = geo != null && geo.points != null && geo.points.length > 0;
    }
    if (graph.getSelectionCount() == 1 && (hasWaypoints || graph.getModel().isVertex(cell2) && graph.getModel().getEdgeCount(cell2) > 0)) {
      this.addMenuItems(menu, ["-", "clearWaypoints"], null, evt);
    }
    if (graph.getSelectionCount() == 1) {
      this.addMenuItems(menu, ["-", "editStyle", "editData", "editLink"], null, evt);
      if (graph.getModel().isVertex(cell2) && getValue(state2.style, mxConstants2.STYLE_IMAGE, null) != null) {
        menu.addSeparator();
        this.addMenuItem(menu, "image", null, evt).firstChild.nextSibling.innerHTML = mxResources2.get("editImage") + "...";
      }
    }
  }
};
Menus.prototype.addPopupMenuSelectionItems = function(menu, cell2, evt) {
  if (this.editorUi.editor.graph.isSelectionEmpty()) {
    this.addMenuItems(menu, ["-", "selectVertices", "selectEdges", "selectAll"], null, evt);
  }
};
Menus.prototype.createMenubar = function(container) {
  var menubar = new Menubar(this.editorUi, container);
  var menus = this.defaultMenuItems;
  for (var i = 0; i < menus.length; i++) {
    bind(this, function(menu) {
      var elt = menubar.addMenu(mxResources2.get(menus[i]), bind(this, function() {
        menu.funct.apply(this, arguments);
      }));
      this.menuCreated(menu, elt);
    })(this.get(menus[i]));
  }
  return menubar;
};
Menus.prototype.menuCreated = function(menu, elt, className) {
  if (elt != null) {
    className = className != null ? className : "geItem";
    menu.addListener("stateChanged", function() {
      elt.enabled = menu.enabled;
      if (!menu.enabled) {
        elt.className = className + " mxDisabled";
        if (document.documentMode == 8) {
          elt.style.color = "#c3c3c3";
        }
      } else {
        elt.className = className;
        if (document.documentMode == 8) {
          elt.style.color = "";
        }
      }
    });
  }
};
function Menubar(editorUi, container) {
  this.editorUi = editorUi;
  this.container = container;
}
Menubar.prototype.hideMenu = function() {
  this.editorUi.hideCurrentMenu();
};
Menubar.prototype.addMenu = function(label, funct, before) {
  var elt = document.createElement("a");
  elt.className = "geItem";
  write(elt, label);
  this.addMenuHandler(elt, funct);
  if (before != null) {
    this.container.insertBefore(elt, before);
  } else {
    this.container.appendChild(elt);
  }
  return elt;
};
Menubar.prototype.addMenuHandler = function(elt, funct) {
  if (funct != null) {
    var show3 = true;
    var clickHandler = bind(this, function(evt) {
      if (show3 && elt.enabled == null || elt.enabled) {
        this.editorUi.editor.graph.popupMenuHandler.hideMenu();
        var menu = new mxPopupMenu(funct);
        menu.div.className += " geMenubarMenu";
        menu.smartSeparators = true;
        menu.showDisabled = true;
        menu.autoExpand = true;
        menu.hideMenu = bind(this, function() {
          mxPopupMenu.prototype.hideMenu.apply(menu, arguments);
          this.editorUi.resetCurrentMenu();
          menu.destroy();
        });
        var offset = getOffset(elt);
        menu.popup(offset.x, offset.y + elt.offsetHeight, null, evt);
        this.editorUi.setCurrentMenu(menu, elt);
      }
      mxEvent2.consume(evt);
    });
    mxEvent2.addListener(elt, "mousemove", bind(this, function(evt) {
      if (this.editorUi.currentMenu != null && this.editorUi.currentMenuElt != elt) {
        this.editorUi.hideCurrentMenu();
        clickHandler(evt);
      }
    }));
    mxEvent2.addListener(elt, mxClient_default.IS_POINTER ? "pointerdown" : "mousedown", bind(this, function(evt) {
      show3 = this.currentElt != elt;
      evt.preventDefault();
    }));
    mxEvent2.addListener(elt, "click", bind(this, function(evt) {
      clickHandler(evt);
      show3 = true;
    }));
  }
};
Menubar.prototype.destroy = function() {
};
function Menu(funct, enabled) {
  mxEventSource.call(this);
  this.funct = funct;
  this.enabled = enabled != null ? enabled : true;
}
extend(Menu, mxEventSource);
Menu.prototype.isEnabled = function() {
  return this.enabled;
};
Menu.prototype.setEnabled = function(value) {
  if (this.enabled != value) {
    this.enabled = value;
    this.fireEvent(new mxEventObject2("stateChanged"));
  }
};
Menu.prototype.execute = function(menu, parent2) {
  this.funct(menu, parent2);
};

// js/TextFormatPanel.js
var TextFormatPanel = function(format, editorUi, container) {
  BaseFormatPanel.call(this, format, editorUi, container);
  this.init();
};
extend(TextFormatPanel, BaseFormatPanel);
TextFormatPanel.prototype.init = function() {
  this.container.style.borderBottom = "none";
  this.addFont(this.container);
};
TextFormatPanel.prototype.addFont = function(container) {
  var ui = this.editorUi;
  var editor = ui.editor;
  var graph = editor.graph;
  var ss = this.format.getSelectionState();
  var title = this.createTitle(mxResources2.get("font"));
  title.style.paddingLeft = "18px";
  title.style.paddingTop = "10px";
  title.style.paddingBottom = "6px";
  container.appendChild(title);
  var stylePanel = this.createPanel();
  stylePanel.style.paddingTop = "2px";
  stylePanel.style.paddingBottom = "2px";
  stylePanel.style.position = "relative";
  stylePanel.style.marginLeft = "-2px";
  stylePanel.style.borderWidth = "0px";
  stylePanel.className = "geToolbarContainer";
  if (mxClient_default.IS_QUIRKS) {
    stylePanel.style.display = "block";
  }
  if (graph.cellEditor.isContentEditing()) {
    var cssPanel = stylePanel.cloneNode();
    var cssMenu = this.editorUi.toolbar.addMenu(mxResources2.get("style"), mxResources2.get("style"), true, "formatBlock", cssPanel, null, true);
    cssMenu.style.color = "rgb(112, 112, 112)";
    cssMenu.style.whiteSpace = "nowrap";
    cssMenu.style.overflow = "hidden";
    cssMenu.style.margin = "0px";
    this.addArrow(cssMenu);
    cssMenu.style.width = "192px";
    cssMenu.style.height = "15px";
    var arrow = cssMenu.getElementsByTagName("div")[0];
    arrow.style.cssFloat = "right";
    container.appendChild(cssPanel);
  }
  container.appendChild(stylePanel);
  var colorPanel = this.createPanel();
  colorPanel.style.marginTop = "8px";
  colorPanel.style.borderTop = "1px solid #c0c0c0";
  colorPanel.style.paddingTop = "6px";
  colorPanel.style.paddingBottom = "6px";
  var fontMenu = this.editorUi.toolbar.addMenu("Helvetica", mxResources2.get("fontFamily"), true, "fontFamily", stylePanel, null, true);
  fontMenu.style.color = "rgb(112, 112, 112)";
  fontMenu.style.whiteSpace = "nowrap";
  fontMenu.style.overflow = "hidden";
  fontMenu.style.margin = "0px";
  this.addArrow(fontMenu);
  fontMenu.style.width = "192px";
  fontMenu.style.height = "15px";
  var stylePanel2 = stylePanel.cloneNode(false);
  stylePanel2.style.marginLeft = "-3px";
  var fontStyleItems = this.editorUi.toolbar.addItems(["bold", "italic", "underline"], stylePanel2, true);
  fontStyleItems[0].setAttribute("title", mxResources2.get("bold") + " (" + this.editorUi.actions.get("bold").shortcut + ")");
  fontStyleItems[1].setAttribute("title", mxResources2.get("italic") + " (" + this.editorUi.actions.get("italic").shortcut + ")");
  fontStyleItems[2].setAttribute("title", mxResources2.get("underline") + " (" + this.editorUi.actions.get("underline").shortcut + ")");
  var verticalItem = this.editorUi.toolbar.addItems(["vertical"], stylePanel2, true)[0];
  if (mxClient_default.IS_QUIRKS) {
    br(container);
  }
  container.appendChild(stylePanel2);
  this.styleButtons(fontStyleItems);
  this.styleButtons([verticalItem]);
  var stylePanel3 = stylePanel.cloneNode(false);
  stylePanel3.style.marginLeft = "-3px";
  stylePanel3.style.paddingBottom = "0px";
  var callFn = function(fn) {
    return function() {
      return fn();
    };
  };
  var left = this.editorUi.toolbar.addButton("geSprite-left", mxResources2.get("left"), graph.cellEditor.isContentEditing() ? function(evt) {
    graph.cellEditor.alignText(mxConstants2.ALIGN_LEFT, evt);
  } : callFn(this.editorUi.menus.createStyleChangeFunction([mxConstants2.STYLE_ALIGN], [mxConstants2.ALIGN_LEFT])), stylePanel3);
  var center = this.editorUi.toolbar.addButton("geSprite-center", mxResources2.get("center"), graph.cellEditor.isContentEditing() ? function(evt) {
    graph.cellEditor.alignText(mxConstants2.ALIGN_CENTER, evt);
  } : callFn(this.editorUi.menus.createStyleChangeFunction([mxConstants2.STYLE_ALIGN], [mxConstants2.ALIGN_CENTER])), stylePanel3);
  var right = this.editorUi.toolbar.addButton("geSprite-right", mxResources2.get("right"), graph.cellEditor.isContentEditing() ? function(evt) {
    graph.cellEditor.alignText(mxConstants2.ALIGN_RIGHT, evt);
  } : callFn(this.editorUi.menus.createStyleChangeFunction([mxConstants2.STYLE_ALIGN], [mxConstants2.ALIGN_RIGHT])), stylePanel3);
  this.styleButtons([left, center, right]);
  if (graph.cellEditor.isContentEditing()) {
    var strike = this.editorUi.toolbar.addButton("geSprite-removeformat", mxResources2.get("strikethrough"), function() {
      document.execCommand("strikeThrough", false, null);
    }, stylePanel2);
    this.styleButtons([strike]);
    strike.firstChild.style.background = "url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PGRlZnM+PHBhdGggaWQ9ImEiIGQ9Ik0wIDBoMjR2MjRIMFYweiIvPjwvZGVmcz48Y2xpcFBhdGggaWQ9ImIiPjx1c2UgeGxpbms6aHJlZj0iI2EiIG92ZXJmbG93PSJ2aXNpYmxlIi8+PC9jbGlwUGF0aD48cGF0aCBjbGlwLXBhdGg9InVybCgjYikiIGZpbGw9IiMwMTAxMDEiIGQ9Ik03LjI0IDguNzVjLS4yNi0uNDgtLjM5LTEuMDMtLjM5LTEuNjcgMC0uNjEuMTMtMS4xNi40LTEuNjcuMjYtLjUuNjMtLjkzIDEuMTEtMS4yOS40OC0uMzUgMS4wNS0uNjMgMS43LS44My42Ni0uMTkgMS4zOS0uMjkgMi4xOC0uMjkuODEgMCAxLjU0LjExIDIuMjEuMzQuNjYuMjIgMS4yMy41NCAxLjY5Ljk0LjQ3LjQuODMuODggMS4wOCAxLjQzLjI1LjU1LjM4IDEuMTUuMzggMS44MWgtMy4wMWMwLS4zMS0uMDUtLjU5LS4xNS0uODUtLjA5LS4yNy0uMjQtLjQ5LS40NC0uNjgtLjItLjE5LS40NS0uMzMtLjc1LS40NC0uMy0uMS0uNjYtLjE2LTEuMDYtLjE2LS4zOSAwLS43NC4wNC0xLjAzLjEzLS4yOS4wOS0uNTMuMjEtLjcyLjM2LS4xOS4xNi0uMzQuMzQtLjQ0LjU1LS4xLjIxLS4xNS40My0uMTUuNjYgMCAuNDguMjUuODguNzQgMS4yMS4zOC4yNS43Ny40OCAxLjQxLjdINy4zOWMtLjA1LS4wOC0uMTEtLjE3LS4xNS0uMjV6TTIxIDEydi0ySDN2Mmg5LjYyYy4xOC4wNy40LjE0LjU1LjIuMzcuMTcuNjYuMzQuODcuNTEuMjEuMTcuMzUuMzYuNDMuNTcuMDcuMi4xMS40My4xMS42OSAwIC4yMy0uMDUuNDUtLjE0LjY2LS4wOS4yLS4yMy4zOC0uNDIuNTMtLjE5LjE1LS40Mi4yNi0uNzEuMzUtLjI5LjA4LS42My4xMy0xLjAxLjEzLS40MyAwLS44My0uMDQtMS4xOC0uMTNzLS42Ni0uMjMtLjkxLS40MmMtLjI1LS4xOS0uNDUtLjQ0LS41OS0uNzUtLjE0LS4zMS0uMjUtLjc2LS4yNS0xLjIxSDYuNGMwIC41NS4wOCAxLjEzLjI0IDEuNTguMTYuNDUuMzcuODUuNjUgMS4yMS4yOC4zNS42LjY2Ljk4LjkyLjM3LjI2Ljc4LjQ4IDEuMjIuNjUuNDQuMTcuOS4zIDEuMzguMzkuNDguMDguOTYuMTMgMS40NC4xMy44IDAgMS41My0uMDkgMi4xOC0uMjhzMS4yMS0uNDUgMS42Ny0uNzljLjQ2LS4zNC44Mi0uNzcgMS4wNy0xLjI3cy4zOC0xLjA3LjM4LTEuNzFjMC0uNi0uMS0xLjE0LS4zMS0xLjYxLS4wNS0uMTEtLjExLS4yMy0uMTctLjMzSDIxeiIvPjwvc3ZnPg==)";
    strike.firstChild.style.backgroundPosition = "2px 2px";
    strike.firstChild.style.backgroundSize = "18px 18px";
    this.styleButtons([strike]);
  }
  var top = this.editorUi.toolbar.addButton("geSprite-top", mxResources2.get("top"), callFn(this.editorUi.menus.createStyleChangeFunction([mxConstants2.STYLE_VERTICAL_ALIGN], [mxConstants2.ALIGN_TOP])), stylePanel3);
  var middle = this.editorUi.toolbar.addButton("geSprite-middle", mxResources2.get("middle"), callFn(this.editorUi.menus.createStyleChangeFunction([mxConstants2.STYLE_VERTICAL_ALIGN], [mxConstants2.ALIGN_MIDDLE])), stylePanel3);
  var bottom = this.editorUi.toolbar.addButton("geSprite-bottom", mxResources2.get("bottom"), callFn(this.editorUi.menus.createStyleChangeFunction([mxConstants2.STYLE_VERTICAL_ALIGN], [mxConstants2.ALIGN_BOTTOM])), stylePanel3);
  this.styleButtons([top, middle, bottom]);
  if (mxClient_default.IS_QUIRKS) {
    br(container);
  }
  container.appendChild(stylePanel3);
  var sub, sup, full, tableWrapper, currentTable, tableCell, tableRow;
  if (graph.cellEditor.isContentEditing()) {
    top.style.display = "none";
    middle.style.display = "none";
    bottom.style.display = "none";
    verticalItem.style.display = "none";
    full = this.editorUi.toolbar.addButton("geSprite-justifyfull", mxResources2.get("block"), function() {
      if (full.style.opacity == 1) {
        document.execCommand("justifyfull", false, null);
      }
    }, stylePanel3);
    full.style.marginRight = "9px";
    full.style.opacity = 1;
    this.styleButtons([
      full,
      sub = this.editorUi.toolbar.addButton("geSprite-subscript", mxResources2.get("subscript") + " (" + Editor2.ctrlKey + "+,)", function() {
        document.execCommand("subscript", false, null);
      }, stylePanel3),
      sup = this.editorUi.toolbar.addButton("geSprite-superscript", mxResources2.get("superscript") + " (" + Editor2.ctrlKey + "+.)", function() {
        document.execCommand("superscript", false, null);
      }, stylePanel3)
    ]);
    sub.style.marginLeft = "9px";
    var tmp = stylePanel3.cloneNode(false);
    tmp.style.paddingTop = "4px";
    var btns = [
      this.editorUi.toolbar.addButton("geSprite-orderedlist", mxResources2.get("numberedList"), function() {
        document.execCommand("insertorderedlist", false, null);
      }, tmp),
      this.editorUi.toolbar.addButton("geSprite-unorderedlist", mxResources2.get("bulletedList"), function() {
        document.execCommand("insertunorderedlist", false, null);
      }, tmp),
      this.editorUi.toolbar.addButton("geSprite-outdent", mxResources2.get("decreaseIndent"), function() {
        document.execCommand("outdent", false, null);
      }, tmp),
      this.editorUi.toolbar.addButton("geSprite-indent", mxResources2.get("increaseIndent"), function() {
        document.execCommand("indent", false, null);
      }, tmp),
      this.editorUi.toolbar.addButton("geSprite-removeformat", mxResources2.get("removeFormat"), function() {
        document.execCommand("removeformat", false, null);
      }, tmp),
      this.editorUi.toolbar.addButton("geSprite-code", mxResources2.get("html"), function() {
        graph.cellEditor.toggleViewMode();
      }, tmp)
    ];
    this.styleButtons(btns);
    btns[btns.length - 2].style.marginLeft = "9px";
    if (mxClient_default.IS_QUIRKS) {
      br(container);
      tmp.style.height = "40";
    }
    container.appendChild(tmp);
  } else {
    fontStyleItems[2].style.marginRight = "9px";
    right.style.marginRight = "9px";
  }
  var stylePanel4 = stylePanel.cloneNode(false);
  stylePanel4.style.marginLeft = "0px";
  stylePanel4.style.paddingTop = "8px";
  stylePanel4.style.paddingBottom = "4px";
  stylePanel4.style.fontWeight = "normal";
  write(stylePanel4, mxResources2.get("position"));
  var positionSelect = document.createElement("select");
  positionSelect.style.position = "absolute";
  positionSelect.style.right = "20px";
  positionSelect.style.width = "97px";
  positionSelect.style.marginTop = "-2px";
  var directions = [
    "topLeft",
    "top",
    "topRight",
    "left",
    "center",
    "right",
    "bottomLeft",
    "bottom",
    "bottomRight"
  ];
  var lset = {
    topLeft: [
      mxConstants2.ALIGN_LEFT,
      mxConstants2.ALIGN_TOP,
      mxConstants2.ALIGN_RIGHT,
      mxConstants2.ALIGN_BOTTOM
    ],
    top: [
      mxConstants2.ALIGN_CENTER,
      mxConstants2.ALIGN_TOP,
      mxConstants2.ALIGN_CENTER,
      mxConstants2.ALIGN_BOTTOM
    ],
    topRight: [
      mxConstants2.ALIGN_RIGHT,
      mxConstants2.ALIGN_TOP,
      mxConstants2.ALIGN_LEFT,
      mxConstants2.ALIGN_BOTTOM
    ],
    left: [
      mxConstants2.ALIGN_LEFT,
      mxConstants2.ALIGN_MIDDLE,
      mxConstants2.ALIGN_RIGHT,
      mxConstants2.ALIGN_MIDDLE
    ],
    center: [
      mxConstants2.ALIGN_CENTER,
      mxConstants2.ALIGN_MIDDLE,
      mxConstants2.ALIGN_CENTER,
      mxConstants2.ALIGN_MIDDLE
    ],
    right: [
      mxConstants2.ALIGN_RIGHT,
      mxConstants2.ALIGN_MIDDLE,
      mxConstants2.ALIGN_LEFT,
      mxConstants2.ALIGN_MIDDLE
    ],
    bottomLeft: [
      mxConstants2.ALIGN_LEFT,
      mxConstants2.ALIGN_BOTTOM,
      mxConstants2.ALIGN_RIGHT,
      mxConstants2.ALIGN_TOP
    ],
    bottom: [
      mxConstants2.ALIGN_CENTER,
      mxConstants2.ALIGN_BOTTOM,
      mxConstants2.ALIGN_CENTER,
      mxConstants2.ALIGN_TOP
    ],
    bottomRight: [
      mxConstants2.ALIGN_RIGHT,
      mxConstants2.ALIGN_BOTTOM,
      mxConstants2.ALIGN_LEFT,
      mxConstants2.ALIGN_TOP
    ]
  };
  for (var i = 0; i < directions.length; i++) {
    var positionOption = document.createElement("option");
    positionOption.setAttribute("value", directions[i]);
    write(positionOption, mxResources2.get(directions[i]));
    positionSelect.appendChild(positionOption);
  }
  stylePanel4.appendChild(positionSelect);
  var stylePanel5 = stylePanel.cloneNode(false);
  stylePanel5.style.marginLeft = "0px";
  stylePanel5.style.paddingTop = "4px";
  stylePanel5.style.paddingBottom = "4px";
  stylePanel5.style.fontWeight = "normal";
  write(stylePanel5, mxResources2.get("writingDirection"));
  var dirSelect = document.createElement("select");
  dirSelect.style.position = "absolute";
  dirSelect.style.right = "20px";
  dirSelect.style.width = "97px";
  dirSelect.style.marginTop = "-2px";
  var dirs = ["automatic", "leftToRight", "rightToLeft"];
  var dirSet = {
    automatic: null,
    leftToRight: mxConstants2.TEXT_DIRECTION_LTR,
    rightToLeft: mxConstants2.TEXT_DIRECTION_RTL
  };
  for (var i = 0; i < dirs.length; i++) {
    var dirOption = document.createElement("option");
    dirOption.setAttribute("value", dirs[i]);
    write(dirOption, mxResources2.get(dirs[i]));
    dirSelect.appendChild(dirOption);
  }
  stylePanel5.appendChild(dirSelect);
  if (!graph.isEditing()) {
    container.appendChild(stylePanel4);
    mxEvent2.addListener(positionSelect, "change", function(evt) {
      graph.getModel().beginUpdate();
      try {
        var vals = lset[positionSelect.value];
        if (vals != null) {
          graph.setCellStyles(mxConstants2.STYLE_LABEL_POSITION, vals[0], graph.getSelectionCells());
          graph.setCellStyles(mxConstants2.STYLE_VERTICAL_LABEL_POSITION, vals[1], graph.getSelectionCells());
          graph.setCellStyles(mxConstants2.STYLE_ALIGN, vals[2], graph.getSelectionCells());
          graph.setCellStyles(mxConstants2.STYLE_VERTICAL_ALIGN, vals[3], graph.getSelectionCells());
        }
      } finally {
        graph.getModel().endUpdate();
      }
      mxEvent2.consume(evt);
    });
    container.appendChild(stylePanel5);
    mxEvent2.addListener(dirSelect, "change", function(evt) {
      graph.setCellStyles(mxConstants2.STYLE_TEXT_DIRECTION, dirSet[dirSelect.value], graph.getSelectionCells());
      mxEvent2.consume(evt);
    });
  }
  var input = document.createElement("input");
  input.style.textAlign = "right";
  input.style.marginTop = "4px";
  if (!mxClient_default.IS_QUIRKS) {
    input.style.position = "absolute";
    input.style.right = "32px";
  }
  input.style.width = "40px";
  input.style.height = mxClient_default.IS_QUIRKS ? "21px" : "17px";
  stylePanel2.appendChild(input);
  var pendingFontSize = null;
  var inputUpdate = this.installInputHandler(input, mxConstants2.STYLE_FONTSIZE, Menus.prototype.defaultFontSize, 1, 999, " pt", function(fontSize) {
    if (window.getSelection && !mxClient_default.IS_IE && !mxClient_default.IS_IE11) {
      let updateSize = function(elt, ignoreContains) {
        if (graph.cellEditor.textarea != null && elt != graph.cellEditor.textarea && graph.cellEditor.textarea.contains(elt) && (ignoreContains || selection.containsNode(elt, true))) {
          if (elt.nodeName == "FONT") {
            elt.removeAttribute("size");
            elt.style.fontSize = fontSize + "px";
          } else {
            var css = getCurrentStyle(elt);
            if (css.fontSize != fontSize + "px") {
              if (getCurrentStyle(elt.parentNode).fontSize != fontSize + "px") {
                elt.style.fontSize = fontSize + "px";
              } else {
                elt.style.fontSize = "";
              }
            }
          }
        }
      };
      var selection = window.getSelection();
      var container2 = selection.rangeCount > 0 ? selection.getRangeAt(0).commonAncestorContainer : graph.cellEditor.textarea;
      if (container2 == graph.cellEditor.textarea || container2.nodeType != mxConstants2.NODETYPE_ELEMENT) {
        document.execCommand("fontSize", false, "1");
      }
      if (container2 != graph.cellEditor.textarea) {
        container2 = container2.parentNode;
      }
      if (container2 != null && container2.nodeType == mxConstants2.NODETYPE_ELEMENT) {
        var elts = container2.getElementsByTagName("*");
        updateSize(container2);
        for (var i2 = 0; i2 < elts.length; i2++) {
          updateSize(elts[i2]);
        }
      }
      input.value = fontSize + " pt";
    } else if (window.getSelection || document.selection) {
      let isOrContains = function(container3, node) {
        while (node != null) {
          if (node === container3) {
            return true;
          }
          node = node.parentNode;
        }
        return false;
      };
      var par = null;
      if (document.selection) {
        par = document.selection.createRange().parentElement();
      } else {
        var selection = window.getSelection();
        if (selection.rangeCount > 0) {
          par = selection.getRangeAt(0).commonAncestorContainer;
        }
      }
      if (par != null && isOrContains(graph.cellEditor.textarea, par)) {
        pendingFontSize = fontSize;
        document.execCommand("fontSize", false, "4");
        var elts = graph.cellEditor.textarea.getElementsByTagName("font");
        for (var i2 = 0; i2 < elts.length; i2++) {
          if (elts[i2].getAttribute("size") == "4") {
            elts[i2].removeAttribute("size");
            elts[i2].style.fontSize = pendingFontSize + "px";
            window.setTimeout(function() {
              input.value = pendingFontSize + " pt";
              pendingFontSize = null;
            }, 0);
            break;
          }
        }
      }
    }
  }, true);
  var stepper = this.createStepper(input, inputUpdate, 1, 10, true, Menus.prototype.defaultFontSize);
  stepper.style.display = input.style.display;
  stepper.style.marginTop = "4px";
  if (!mxClient_default.IS_QUIRKS) {
    stepper.style.right = "20px";
  }
  stylePanel2.appendChild(stepper);
  var arrow = fontMenu.getElementsByTagName("div")[0];
  arrow.style.cssFloat = "right";
  var bgColorApply = null;
  var currentBgColor = "#ffffff";
  var fontColorApply = null;
  var currentFontColor = "#000000";
  var bgPanel = graph.cellEditor.isContentEditing() ? this.createColorOption(mxResources2.get("backgroundColor"), function() {
    return currentBgColor;
  }, function(color) {
    document.execCommand("backcolor", false, color != mxConstants2.NONE ? color : "transparent");
  }, "#ffffff", {
    install: function(apply) {
      bgColorApply = apply;
    },
    destroy: function() {
      bgColorApply = null;
    }
  }, null, true) : this.createCellColorOption(mxResources2.get("backgroundColor"), mxConstants2.STYLE_LABEL_BACKGROUNDCOLOR, "#ffffff", null, function(color) {
    graph.updateLabelElements(graph.getSelectionCells(), function(elt) {
      elt.style.backgroundColor = null;
    });
  });
  bgPanel.style.fontWeight = "bold";
  var borderPanel = this.createCellColorOption(mxResources2.get("borderColor"), mxConstants2.STYLE_LABEL_BORDERCOLOR, "#000000");
  borderPanel.style.fontWeight = "bold";
  var defs = ss.vertices.length >= 1 ? graph.stylesheet.getDefaultVertexStyle() : graph.stylesheet.getDefaultEdgeStyle();
  var panel = graph.cellEditor.isContentEditing() ? this.createColorOption(mxResources2.get("fontColor"), function() {
    return currentFontColor;
  }, function(color) {
    if (mxClient_default.IS_FF) {
      var tmp2 = graph.cellEditor.textarea.getElementsByTagName("font");
      var oldFonts = [];
      for (var i2 = 0; i2 < tmp2.length; i2++) {
        oldFonts.push({
          node: tmp2[i2],
          color: tmp2[i2].getAttribute("color")
        });
      }
      document.execCommand("forecolor", false, color != mxConstants2.NONE ? color : "transparent");
      var newFonts = graph.cellEditor.textarea.getElementsByTagName("font");
      for (var i2 = 0; i2 < newFonts.length; i2++) {
        if (i2 >= oldFonts.length || newFonts[i2] != oldFonts[i2].node || newFonts[i2] == oldFonts[i2].node && newFonts[i2].getAttribute("color") != oldFonts[i2].color) {
          var child = newFonts[i2].firstChild;
          if (child != null && child.nodeName == "A" && child.nextSibling == null && child.firstChild != null) {
            var parent2 = newFonts[i2].parentNode;
            parent2.insertBefore(child, newFonts[i2]);
            var tmp2 = child.firstChild;
            while (tmp2 != null) {
              var next = tmp2.nextSibling;
              newFonts[i2].appendChild(tmp2);
              tmp2 = next;
            }
            child.appendChild(newFonts[i2]);
          }
          break;
        }
      }
    } else {
      document.execCommand("forecolor", false, color != mxConstants2.NONE ? color : "transparent");
    }
  }, defs[mxConstants2.STYLE_FONTCOLOR] != null ? defs[mxConstants2.STYLE_FONTCOLOR] : "#000000", {
    install: function(apply) {
      fontColorApply = apply;
    },
    destroy: function() {
      fontColorApply = null;
    }
  }, null, true) : this.createCellColorOption(mxResources2.get("fontColor"), mxConstants2.STYLE_FONTCOLOR, defs[mxConstants2.STYLE_FONTCOLOR] != null ? defs[mxConstants2.STYLE_FONTCOLOR] : "#000000", function(color) {
    if (color == mxConstants2.NONE) {
      bgPanel.style.display = "none";
    } else {
      bgPanel.style.display = "";
    }
    borderPanel.style.display = bgPanel.style.display;
  }, function(color) {
    if (color == mxConstants2.NONE) {
      graph.setCellStyles(mxConstants2.STYLE_NOLABEL, "1", graph.getSelectionCells());
    } else {
      graph.setCellStyles(mxConstants2.STYLE_NOLABEL, null, graph.getSelectionCells());
    }
    graph.updateCellStyles(mxConstants2.STYLE_FONTCOLOR, color, graph.getSelectionCells());
    graph.updateLabelElements(graph.getSelectionCells(), function(elt) {
      elt.removeAttribute("color");
      elt.style.color = null;
    });
  });
  panel.style.fontWeight = "bold";
  colorPanel.appendChild(panel);
  colorPanel.appendChild(bgPanel);
  if (!graph.cellEditor.isContentEditing()) {
    colorPanel.appendChild(borderPanel);
  }
  container.appendChild(colorPanel);
  var extraPanel = this.createPanel();
  extraPanel.style.paddingTop = "2px";
  extraPanel.style.paddingBottom = "4px";
  var wwOpt = this.createCellOption(mxResources2.get("wordWrap"), mxConstants2.STYLE_WHITE_SPACE, null, "wrap", "null", null, null, true);
  wwOpt.style.fontWeight = "bold";
  if (!ss.containsLabel && !ss.autoSize && ss.edges.length == 0) {
    extraPanel.appendChild(wwOpt);
  }
  var htmlOpt = this.createCellOption(mxResources2.get("formattedText"), "html", "0", null, null, null, ui.actions.get("formattedText"));
  htmlOpt.style.fontWeight = "bold";
  extraPanel.appendChild(htmlOpt);
  var spacingPanel = this.createPanel();
  spacingPanel.style.paddingTop = "10px";
  spacingPanel.style.paddingBottom = "28px";
  spacingPanel.style.fontWeight = "normal";
  var span = document.createElement("div");
  span.style.position = "absolute";
  span.style.width = "70px";
  span.style.marginTop = "0px";
  span.style.fontWeight = "bold";
  write(span, mxResources2.get("spacing"));
  spacingPanel.appendChild(span);
  var topUpdate, globalUpdate, leftUpdate, bottomUpdate, rightUpdate;
  var topSpacing = this.addUnitInput(spacingPanel, "pt", 91, 44, function() {
    topUpdate.apply(this, arguments);
  });
  var globalSpacing = this.addUnitInput(spacingPanel, "pt", 20, 44, function() {
    globalUpdate.apply(this, arguments);
  });
  br(spacingPanel);
  this.addLabel(spacingPanel, mxResources2.get("top"), 91);
  this.addLabel(spacingPanel, mxResources2.get("global"), 20);
  br(spacingPanel);
  br(spacingPanel);
  var leftSpacing = this.addUnitInput(spacingPanel, "pt", 162, 44, function() {
    leftUpdate.apply(this, arguments);
  });
  var bottomSpacing = this.addUnitInput(spacingPanel, "pt", 91, 44, function() {
    bottomUpdate.apply(this, arguments);
  });
  var rightSpacing = this.addUnitInput(spacingPanel, "pt", 20, 44, function() {
    rightUpdate.apply(this, arguments);
  });
  br(spacingPanel);
  this.addLabel(spacingPanel, mxResources2.get("left"), 162);
  this.addLabel(spacingPanel, mxResources2.get("bottom"), 91);
  this.addLabel(spacingPanel, mxResources2.get("right"), 20);
  if (!graph.cellEditor.isContentEditing()) {
    container.appendChild(extraPanel);
    container.appendChild(this.createRelativeOption(mxResources2.get("opacity"), mxConstants2.STYLE_TEXT_OPACITY));
    container.appendChild(spacingPanel);
  } else {
    var selState = null;
    var lineHeightInput = null;
    container.appendChild(this.createRelativeOption(mxResources2.get("lineheight"), null, null, function(input2) {
      var value = input2.value == "" ? 120 : parseInt(input2.value);
      value = Math.max(0, isNaN(value) ? 120 : value);
      if (selState != null) {
        graph.cellEditor.restoreSelection(selState);
        selState = null;
      }
      var selectedElement = graph.getSelectedElement();
      var node = selectedElement;
      while (node != null && node.nodeType != mxConstants2.NODETYPE_ELEMENT) {
        node = node.parentNode;
      }
      if (node != null && node == graph.cellEditor.textarea && graph.cellEditor.textarea.firstChild != null) {
        if (graph.cellEditor.textarea.firstChild.nodeName != "P") {
          graph.cellEditor.textarea.innerHTML = "<p>" + graph.cellEditor.textarea.innerHTML + "</p>";
        }
        node = graph.cellEditor.textarea.firstChild;
      }
      if (node != null && graph.cellEditor.textarea != null && node != graph.cellEditor.textarea && graph.cellEditor.textarea.contains(node)) {
        node.style.lineHeight = value + "%";
      }
      input2.value = value + " %";
    }, function(input2) {
      lineHeightInput = input2;
      mxEvent2.addListener(input2, "mousedown", function() {
        if (document.activeElement == graph.cellEditor.textarea) {
          selState = graph.cellEditor.saveSelection();
        }
      });
      mxEvent2.addListener(input2, "touchstart", function() {
        if (document.activeElement == graph.cellEditor.textarea) {
          selState = graph.cellEditor.saveSelection();
        }
      });
      input2.value = "120 %";
    }));
    var insertPanel = stylePanel.cloneNode(false);
    insertPanel.style.paddingLeft = "0px";
    var insertBtns = this.editorUi.toolbar.addItems(["link", "image"], insertPanel, true);
    var btns = [
      this.editorUi.toolbar.addButton("geSprite-horizontalrule", mxResources2.get("insertHorizontalRule"), function() {
        document.execCommand("inserthorizontalrule", false);
      }, insertPanel),
      this.editorUi.toolbar.addMenuFunctionInContainer(insertPanel, "geSprite-table", mxResources2.get("table"), false, bind(this, function(menu) {
        this.editorUi.menus.addInsertTableItem(menu);
      }))
    ];
    this.styleButtons(insertBtns);
    this.styleButtons(btns);
    var wrapper2 = this.createPanel();
    wrapper2.style.paddingTop = "10px";
    wrapper2.style.paddingBottom = "10px";
    wrapper2.appendChild(this.createTitle(mxResources2.get("insert")));
    wrapper2.appendChild(insertPanel);
    container.appendChild(wrapper2);
    if (mxClient_default.IS_QUIRKS) {
      wrapper2.style.height = "70";
    }
    var tablePanel = stylePanel.cloneNode(false);
    tablePanel.style.paddingLeft = "0px";
    var btns = [
      this.editorUi.toolbar.addButton("geSprite-insertcolumnbefore", mxResources2.get("insertColumnBefore"), bind(this, function() {
        try {
          if (currentTable != null) {
            graph.insertColumn(currentTable, tableCell != null ? tableCell.cellIndex : 0);
          }
        } catch (e) {
          this.editorUi.handleError(e);
        }
      }), tablePanel),
      this.editorUi.toolbar.addButton("geSprite-insertcolumnafter", mxResources2.get("insertColumnAfter"), bind(this, function() {
        try {
          if (currentTable != null) {
            graph.insertColumn(currentTable, tableCell != null ? tableCell.cellIndex + 1 : -1);
          }
        } catch (e) {
          this.editorUi.handleError(e);
        }
      }), tablePanel),
      this.editorUi.toolbar.addButton("geSprite-deletecolumn", mxResources2.get("deleteColumn"), bind(this, function() {
        try {
          if (currentTable != null && tableCell != null) {
            graph.deleteColumn(currentTable, tableCell.cellIndex);
          }
        } catch (e) {
          this.editorUi.handleError(e);
        }
      }), tablePanel),
      this.editorUi.toolbar.addButton("geSprite-insertrowbefore", mxResources2.get("insertRowBefore"), bind(this, function() {
        try {
          if (currentTable != null && tableRow != null) {
            graph.insertRow(currentTable, tableRow.sectionRowIndex);
          }
        } catch (e) {
          this.editorUi.handleError(e);
        }
      }), tablePanel),
      this.editorUi.toolbar.addButton("geSprite-insertrowafter", mxResources2.get("insertRowAfter"), bind(this, function() {
        try {
          if (currentTable != null && tableRow != null) {
            graph.insertRow(currentTable, tableRow.sectionRowIndex + 1);
          }
        } catch (e) {
          this.editorUi.handleError(e);
        }
      }), tablePanel),
      this.editorUi.toolbar.addButton("geSprite-deleterow", mxResources2.get("deleteRow"), bind(this, function() {
        try {
          if (currentTable != null && tableRow != null) {
            graph.deleteRow(currentTable, tableRow.sectionRowIndex);
          }
        } catch (e) {
          this.editorUi.handleError(e);
        }
      }), tablePanel)
    ];
    this.styleButtons(btns);
    btns[2].style.marginRight = "9px";
    var wrapper3 = this.createPanel();
    wrapper3.style.paddingTop = "10px";
    wrapper3.style.paddingBottom = "10px";
    wrapper3.appendChild(this.createTitle(mxResources2.get("table")));
    wrapper3.appendChild(tablePanel);
    if (mxClient_default.IS_QUIRKS) {
      br(container);
      wrapper3.style.height = "70";
    }
    var tablePanel2 = stylePanel.cloneNode(false);
    tablePanel2.style.paddingLeft = "0px";
    var btns = [
      this.editorUi.toolbar.addButton("geSprite-strokecolor", mxResources2.get("borderColor"), bind(this, function(evt) {
        if (currentTable != null) {
          var color = currentTable.style.borderColor.replace(/\brgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/g, function($0, $1, $2, $3) {
            return "#" + ("0" + Number($1).toString(16)).substr(-2) + ("0" + Number($2).toString(16)).substr(-2) + ("0" + Number($3).toString(16)).substr(-2);
          });
          this.editorUi.pickColor(color, function(newColor) {
            var targetElt = tableCell != null && (evt == null || !mxEvent2.isShiftDown(evt)) ? tableCell : currentTable;
            graph.processElements(targetElt, function(elt) {
              elt.style.border = null;
            });
            if (newColor == null || newColor == mxConstants2.NONE) {
              targetElt.removeAttribute("border");
              targetElt.style.border = "";
              targetElt.style.borderCollapse = "";
            } else {
              targetElt.setAttribute("border", "1");
              targetElt.style.border = "1px solid " + newColor;
              targetElt.style.borderCollapse = "collapse";
            }
          });
        }
      }), tablePanel2),
      this.editorUi.toolbar.addButton("geSprite-fillcolor", mxResources2.get("backgroundColor"), bind(this, function(evt) {
        if (currentTable != null) {
          var color = currentTable.style.backgroundColor.replace(/\brgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/g, function($0, $1, $2, $3) {
            return "#" + ("0" + Number($1).toString(16)).substr(-2) + ("0" + Number($2).toString(16)).substr(-2) + ("0" + Number($3).toString(16)).substr(-2);
          });
          this.editorUi.pickColor(color, function(newColor) {
            var targetElt = tableCell != null && (evt == null || !mxEvent2.isShiftDown(evt)) ? tableCell : currentTable;
            graph.processElements(targetElt, function(elt) {
              elt.style.backgroundColor = null;
            });
            if (newColor == null || newColor == mxConstants2.NONE) {
              targetElt.style.backgroundColor = "";
            } else {
              targetElt.style.backgroundColor = newColor;
            }
          });
        }
      }), tablePanel2),
      this.editorUi.toolbar.addButton("geSprite-fit", mxResources2.get("spacing"), function() {
        if (currentTable != null) {
          var value = currentTable.getAttribute("cellPadding") || 0;
          var dlg = new FilenameDialog(ui, value, mxResources2.get("apply"), bind(this, function(newValue) {
            if (newValue != null && newValue.length > 0) {
              currentTable.setAttribute("cellPadding", newValue);
            } else {
              currentTable.removeAttribute("cellPadding");
            }
          }), mxResources2.get("spacing"));
          ui.showDialog(dlg.container, 300, 80, true, true);
          dlg.init();
          try {
            if (dlg.textarea) {
              let textareaId = `threagile-dialog-${property}-textarea`;
              dlg.textarea.id = textareaId;
              console.log(`Added ID to textarea: ${textareaId}`);
            } else {
              console.warn(`Could not find dlg.textarea for property '${property}'.`);
            }
          } catch (e) {
            console.error("Error adding ID to dialog textarea:", e);
          }
          try {
            let buttonContainer = dlg.container.querySelector(".geDialogButtons");
            let buttons = buttonContainer ? buttonContainer.querySelectorAll("button") : dlg.container.querySelectorAll("button");
            if (buttons && buttons.length > 0) {
              const applyText = mxResources2.get("apply") || "Apply";
              const cancelText = mxResources2.get("cancel") || "Cancel";
              let applyFound = false;
              let cancelFound = false;
              buttons.forEach((btn) => {
                if (!applyFound && (btn.textContent.trim() === applyText || btn.textContent.trim() === (mxResources2.get("ok") || "OK"))) {
                  btn.id = `threagile-dialog-${property}-apply-button`;
                  applyFound = true;
                } else if (!cancelFound && btn.textContent.trim() === cancelText) {
                  btn.id = `threagile-dialog-${property}-cancel-button`;
                  cancelFound = true;
                }
              });
            } else {
              console.warn("Could not find buttons in TextareaDialog container for property:", property);
            }
          } catch (e) {
            console.error("Error adding IDs to dialog buttons:", e);
          }
        }
      }, tablePanel2),
      this.editorUi.toolbar.addButton("geSprite-left", mxResources2.get("left"), function() {
        if (currentTable != null) {
          currentTable.setAttribute("align", "left");
        }
      }, tablePanel2),
      this.editorUi.toolbar.addButton("geSprite-center", mxResources2.get("center"), function() {
        if (currentTable != null) {
          currentTable.setAttribute("align", "center");
        }
      }, tablePanel2),
      this.editorUi.toolbar.addButton("geSprite-right", mxResources2.get("right"), function() {
        if (currentTable != null) {
          currentTable.setAttribute("align", "right");
        }
      }, tablePanel2)
    ];
    this.styleButtons(btns);
    btns[2].style.marginRight = "9px";
    if (mxClient_default.IS_QUIRKS) {
      br(wrapper3);
      br(wrapper3);
    }
    wrapper3.appendChild(tablePanel2);
    container.appendChild(wrapper3);
    tableWrapper = wrapper3;
  }
  function setSelected(elt, selected) {
    if (mxClient_default.IS_IE && (mxClient_default.IS_QUIRKS || document.documentMode < 10)) {
      elt.style.filter = selected ? "progid:DXImageTransform.Microsoft.Gradient(StartColorStr='#c5ecff', EndColorStr='#87d4fb', GradientType=0)" : "";
    } else {
      elt.style.backgroundImage = selected ? "linear-gradient(#c5ecff 0px,#87d4fb 100%)" : "";
    }
  }
  var listener = bind(this, function(sender, evt, force) {
    ss = this.format.getSelectionState();
    var fontStyle = getValue(ss.style, mxConstants2.STYLE_FONTSTYLE, 0);
    setSelected(fontStyleItems[0], (fontStyle & mxConstants2.FONT_BOLD) == mxConstants2.FONT_BOLD);
    setSelected(fontStyleItems[1], (fontStyle & mxConstants2.FONT_ITALIC) == mxConstants2.FONT_ITALIC);
    setSelected(fontStyleItems[2], (fontStyle & mxConstants2.FONT_UNDERLINE) == mxConstants2.FONT_UNDERLINE);
    fontMenu.firstChild.nodeValue = getValue(ss.style, mxConstants2.STYLE_FONTFAMILY, Menus.prototype.defaultFont);
    setSelected(verticalItem, getValue(ss.style, mxConstants2.STYLE_HORIZONTAL, "1") == "0");
    if (force || document.activeElement != input) {
      var tmp2 = parseFloat(getValue(ss.style, mxConstants2.STYLE_FONTSIZE, Menus.prototype.defaultFontSize));
      input.value = isNaN(tmp2) ? "" : tmp2 + " pt";
    }
    var align = getValue(ss.style, mxConstants2.STYLE_ALIGN, mxConstants2.ALIGN_CENTER);
    setSelected(left, align == mxConstants2.ALIGN_LEFT);
    setSelected(center, align == mxConstants2.ALIGN_CENTER);
    setSelected(right, align == mxConstants2.ALIGN_RIGHT);
    var valign = getValue(ss.style, mxConstants2.STYLE_VERTICAL_ALIGN, mxConstants2.ALIGN_MIDDLE);
    setSelected(top, valign == mxConstants2.ALIGN_TOP);
    setSelected(middle, valign == mxConstants2.ALIGN_MIDDLE);
    setSelected(bottom, valign == mxConstants2.ALIGN_BOTTOM);
    var pos = getValue(ss.style, mxConstants2.STYLE_LABEL_POSITION, mxConstants2.ALIGN_CENTER);
    var vpos = getValue(ss.style, mxConstants2.STYLE_VERTICAL_LABEL_POSITION, mxConstants2.ALIGN_MIDDLE);
    if (pos == mxConstants2.ALIGN_LEFT && vpos == mxConstants2.ALIGN_TOP) {
      positionSelect.value = "topLeft";
    } else if (pos == mxConstants2.ALIGN_CENTER && vpos == mxConstants2.ALIGN_TOP) {
      positionSelect.value = "top";
    } else if (pos == mxConstants2.ALIGN_RIGHT && vpos == mxConstants2.ALIGN_TOP) {
      positionSelect.value = "topRight";
    } else if (pos == mxConstants2.ALIGN_LEFT && vpos == mxConstants2.ALIGN_BOTTOM) {
      positionSelect.value = "bottomLeft";
    } else if (pos == mxConstants2.ALIGN_CENTER && vpos == mxConstants2.ALIGN_BOTTOM) {
      positionSelect.value = "bottom";
    } else if (pos == mxConstants2.ALIGN_RIGHT && vpos == mxConstants2.ALIGN_BOTTOM) {
      positionSelect.value = "bottomRight";
    } else if (pos == mxConstants2.ALIGN_LEFT) {
      positionSelect.value = "left";
    } else if (pos == mxConstants2.ALIGN_RIGHT) {
      positionSelect.value = "right";
    } else {
      positionSelect.value = "center";
    }
    var dir = getValue(ss.style, mxConstants2.STYLE_TEXT_DIRECTION, mxConstants2.DEFAULT_TEXT_DIRECTION);
    if (dir == mxConstants2.TEXT_DIRECTION_RTL) {
      dirSelect.value = "rightToLeft";
    } else if (dir == mxConstants2.TEXT_DIRECTION_LTR) {
      dirSelect.value = "leftToRight";
    } else if (dir == mxConstants2.TEXT_DIRECTION_AUTO) {
      dirSelect.value = "automatic";
    }
    if (force || document.activeElement != globalSpacing) {
      var tmp2 = parseFloat(getValue(ss.style, mxConstants2.STYLE_SPACING, 2));
      globalSpacing.value = isNaN(tmp2) ? "" : tmp2 + " pt";
    }
    if (force || document.activeElement != topSpacing) {
      var tmp2 = parseFloat(getValue(ss.style, mxConstants2.STYLE_SPACING_TOP, 0));
      topSpacing.value = isNaN(tmp2) ? "" : tmp2 + " pt";
    }
    if (force || document.activeElement != rightSpacing) {
      var tmp2 = parseFloat(getValue(ss.style, mxConstants2.STYLE_SPACING_RIGHT, 0));
      rightSpacing.value = isNaN(tmp2) ? "" : tmp2 + " pt";
    }
    if (force || document.activeElement != bottomSpacing) {
      var tmp2 = parseFloat(getValue(ss.style, mxConstants2.STYLE_SPACING_BOTTOM, 0));
      bottomSpacing.value = isNaN(tmp2) ? "" : tmp2 + " pt";
    }
    if (force || document.activeElement != leftSpacing) {
      var tmp2 = parseFloat(getValue(ss.style, mxConstants2.STYLE_SPACING_LEFT, 0));
      leftSpacing.value = isNaN(tmp2) ? "" : tmp2 + " pt";
    }
  });
  globalUpdate = this.installInputHandler(globalSpacing, mxConstants2.STYLE_SPACING, 2, -999, 999, " pt");
  topUpdate = this.installInputHandler(topSpacing, mxConstants2.STYLE_SPACING_TOP, 0, -999, 999, " pt");
  rightUpdate = this.installInputHandler(rightSpacing, mxConstants2.STYLE_SPACING_RIGHT, 0, -999, 999, " pt");
  bottomUpdate = this.installInputHandler(bottomSpacing, mxConstants2.STYLE_SPACING_BOTTOM, 0, -999, 999, " pt");
  leftUpdate = this.installInputHandler(leftSpacing, mxConstants2.STYLE_SPACING_LEFT, 0, -999, 999, " pt");
  this.addKeyHandler(input, listener);
  this.addKeyHandler(globalSpacing, listener);
  this.addKeyHandler(topSpacing, listener);
  this.addKeyHandler(rightSpacing, listener);
  this.addKeyHandler(bottomSpacing, listener);
  this.addKeyHandler(leftSpacing, listener);
  graph.getModel().addListener(mxEvent2.CHANGE, listener);
  this.listeners.push({
    destroy: function() {
      graph.getModel().removeListener(listener);
    }
  });
  listener();
  if (graph.cellEditor.isContentEditing()) {
    var updating = false;
    var updateCssHandler = function() {
      if (!updating) {
        updating = true;
        window.setTimeout(function() {
          var node = graph.getSelectedEditingElement();
          if (node != null) {
            let getRelativeLineHeight = function(fontSize2, css2, elt) {
              if (elt.style != null && css2 != null) {
                var lineHeight2 = css2.lineHeight;
                if (elt.style.lineHeight != null && elt.style.lineHeight.substring(elt.style.lineHeight.length - 1) == "%") {
                  return parseInt(elt.style.lineHeight) / 100;
                } else {
                  return lineHeight2.substring(lineHeight2.length - 2) == "px" ? parseFloat(lineHeight2) / fontSize2 : parseInt(lineHeight2);
                }
              } else {
                return "";
              }
            }, getAbsoluteFontSize = function(css2) {
              var fontSize2 = css2 != null ? css2.fontSize : null;
              if (fontSize2 != null && fontSize2.substring(fontSize2.length - 2) == "px") {
                return parseFloat(fontSize2);
              } else {
                return mxConstants2.DEFAULT_FONTSIZE;
              }
            }, hasParentOrOnlyChild = function(name) {
              if (graph.getParentByName(node, name, graph.cellEditor.textarea) != null) {
                return true;
              } else {
                var child = node;
                while (child != null && child.childNodes.length == 1) {
                  child = child.childNodes[0];
                  if (child.nodeName == name) {
                    return true;
                  }
                }
              }
              return false;
            }, isEqualOrPrefixed = function(str, value) {
              if (str != null && value != null) {
                if (str == value) {
                  return true;
                } else if (str.length > value.length + 1) {
                  return str.substring(str.length - value.length - 1, str.length) == "-" + value;
                }
              }
              return false;
            };
            var css = getCurrentStyle(node);
            var fontSize = getAbsoluteFontSize(css);
            var lineHeight = getRelativeLineHeight(fontSize, css, node);
            var elts = node.getElementsByTagName("*");
            if (elts.length > 0 && window.getSelection && !mxClient_default.IS_IE && !mxClient_default.IS_IE11) {
              var selection = window.getSelection();
              for (var i2 = 0; i2 < elts.length; i2++) {
                if (selection.containsNode(elts[i2], true)) {
                  temp = getCurrentStyle(elts[i2]);
                  fontSize = Math.max(getAbsoluteFontSize(temp), fontSize);
                  var lh = getRelativeLineHeight(fontSize, temp, elts[i2]);
                  if (lh != lineHeight || isNaN(lh)) {
                    lineHeight = "";
                  }
                }
              }
            }
            if (css != null) {
              setSelected(fontStyleItems[0], css.fontWeight == "bold" || css.fontWeight > 400 || hasParentOrOnlyChild("B") || hasParentOrOnlyChild("STRONG"));
              setSelected(fontStyleItems[1], css.fontStyle == "italic" || hasParentOrOnlyChild("I") || hasParentOrOnlyChild("EM"));
              setSelected(fontStyleItems[2], hasParentOrOnlyChild("U"));
              setSelected(sup, hasParentOrOnlyChild("SUP"));
              setSelected(sub, hasParentOrOnlyChild("SUB"));
              if (!graph.cellEditor.isTableSelected()) {
                var align = graph.cellEditor.align || getValue(ss.style, mxConstants2.STYLE_ALIGN, mxConstants2.ALIGN_CENTER);
                if (isEqualOrPrefixed(css.textAlign, "justify")) {
                  setSelected(full, isEqualOrPrefixed(css.textAlign, "justify"));
                  setSelected(left, false);
                  setSelected(center, false);
                  setSelected(right, false);
                } else {
                  setSelected(full, false);
                  setSelected(left, align == mxConstants2.ALIGN_LEFT);
                  setSelected(center, align == mxConstants2.ALIGN_CENTER);
                  setSelected(right, align == mxConstants2.ALIGN_RIGHT);
                }
              } else {
                setSelected(full, isEqualOrPrefixed(css.textAlign, "justify"));
                setSelected(left, isEqualOrPrefixed(css.textAlign, "left"));
                setSelected(center, isEqualOrPrefixed(css.textAlign, "center"));
                setSelected(right, isEqualOrPrefixed(css.textAlign, "right"));
              }
              currentTable = graph.getParentByName(node, "TABLE", graph.cellEditor.textarea);
              tableRow = currentTable == null ? null : graph.getParentByName(node, "TR", currentTable);
              tableCell = currentTable == null ? null : graph.getParentByNames(node, ["TD", "TH"], currentTable);
              tableWrapper.style.display = currentTable != null ? "" : "none";
              if (document.activeElement != input) {
                if (node.nodeName == "FONT" && node.getAttribute("size") == "4" && pendingFontSize != null) {
                  node.removeAttribute("size");
                  node.style.fontSize = pendingFontSize + " pt";
                  pendingFontSize = null;
                } else {
                  input.value = isNaN(fontSize) ? "" : fontSize + " pt";
                }
                var lh = parseFloat(lineHeight);
                if (!isNaN(lh)) {
                  lineHeightInput.value = Math.round(lh * 100) + " %";
                } else {
                  lineHeightInput.value = "100 %";
                }
              }
              var color = css.color.replace(/\brgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/g, function($0, $1, $2, $3) {
                return "#" + ("0" + Number($1).toString(16)).substr(-2) + ("0" + Number($2).toString(16)).substr(-2) + ("0" + Number($3).toString(16)).substr(-2);
              });
              var color2 = css.backgroundColor.replace(/\brgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/g, function($0, $1, $2, $3) {
                return "#" + ("0" + Number($1).toString(16)).substr(-2) + ("0" + Number($2).toString(16)).substr(-2) + ("0" + Number($3).toString(16)).substr(-2);
              });
              if (fontColorApply != null) {
                if (color.charAt(0) == "#") {
                  currentFontColor = color;
                } else {
                  currentFontColor = "#000000";
                }
                fontColorApply(currentFontColor, true);
              }
              if (bgColorApply != null) {
                if (color2.charAt(0) == "#") {
                  currentBgColor = color2;
                } else {
                  currentBgColor = null;
                }
                bgColorApply(currentBgColor, true);
              }
              if (fontMenu.firstChild != null) {
                fontMenu.firstChild.nodeValue = Graph.stripQuotes(css.fontFamily);
              }
            }
          }
          updating = false;
        }, 0);
      }
    };
    if (mxClient_default.IS_FF || mxClient_default.IS_EDGE || mxClient_default.IS_IE || mxClient_default.IS_IE11) {
      mxEvent2.addListener(graph.cellEditor.textarea, "DOMSubtreeModified", updateCssHandler);
    }
    mxEvent2.addListener(graph.cellEditor.textarea, "input", updateCssHandler);
    mxEvent2.addListener(graph.cellEditor.textarea, "touchend", updateCssHandler);
    mxEvent2.addListener(graph.cellEditor.textarea, "mouseup", updateCssHandler);
    mxEvent2.addListener(graph.cellEditor.textarea, "keyup", updateCssHandler);
    this.listeners.push({
      destroy: function() {
      }
    });
    updateCssHandler();
  }
  return container;
};

// js/ArrangePanel.js
var ArrangePanel = function(format, editorUi, container) {
  BaseFormatPanel.call(this, format, editorUi, container);
  this.init();
};
extend(ArrangePanel, BaseFormatPanel);
ArrangePanel.prototype.init = function() {
  var graph = this.editorUi.editor.graph;
  var ss = this.format.getSelectionState();
  this.container.appendChild(this.addLayerOps(this.createPanel()));
  this.addGeometry(this.container);
  this.addEdgeGeometry(this.container);
  if (!ss.containsLabel || ss.edges.length == 0) {
    this.container.appendChild(this.addAngle(this.createPanel()));
  }
  if (!ss.containsLabel && ss.edges.length == 0 && ss.style.shape != "rectangle" && ss.style.shape != "label") {
    this.container.appendChild(this.addFlip(this.createPanel()));
  }
  if (ss.vertices.length > 1) {
    this.container.appendChild(this.addAlign(this.createPanel()));
    this.container.appendChild(this.addDistribute(this.createPanel()));
  }
  if (graph.isTable(ss.vertices[0]) || graph.isTableRow(ss.vertices[0]) || graph.isTableCell(ss.vertices[0])) {
    this.container.appendChild(this.addTable(this.createPanel()));
  }
  this.container.appendChild(this.addGroupOps(this.createPanel()));
  if (ss.containsLabel) {
    var span = document.createElement("div");
    span.style.width = "100%";
    span.style.marginTop = "0px";
    span.style.fontWeight = "bold";
    span.style.padding = "10px 0 0 18px";
    write(span, mxResources2.get("style"));
    this.container.appendChild(span);
    new StyleFormatPanel(this.format, this.editorUi, this.container);
  }
};
ArrangePanel.prototype.addTable = function(div) {
  var ui = this.editorUi;
  var editor = ui.editor;
  var graph = editor.graph;
  var ss = this.format.getSelectionState();
  div.style.paddingTop = "6px";
  div.style.paddingBottom = "10px";
  var span = document.createElement("div");
  span.style.marginTop = "2px";
  span.style.marginBottom = "8px";
  span.style.fontWeight = "bold";
  write(span, mxResources2.get("table"));
  div.appendChild(span);
  var panel = document.createElement("div");
  panel.style.position = "relative";
  panel.style.paddingLeft = "0px";
  panel.style.borderWidth = "0px";
  panel.className = "geToolbarContainer";
  var btns = [
    ui.toolbar.addButton("geSprite-insertcolumnbefore", mxResources2.get("insertColumnBefore"), bind(this, function() {
      try {
        graph.insertTableColumn(ss.vertices[0], true);
      } catch (e) {
        ui.handleError(e);
      }
    }), panel),
    ui.toolbar.addButton("geSprite-insertcolumnafter", mxResources2.get("insertColumnAfter"), bind(this, function() {
      try {
        graph.insertTableColumn(ss.vertices[0], false);
      } catch (e) {
        ui.handleError(e);
      }
    }), panel),
    ui.toolbar.addButton("geSprite-deletecolumn", mxResources2.get("deleteColumn"), bind(this, function() {
      try {
        graph.deleteTableColumn(ss.vertices[0]);
      } catch (e) {
        ui.handleError(e);
      }
    }), panel),
    ui.toolbar.addButton("geSprite-insertrowbefore", mxResources2.get("insertRowBefore"), bind(this, function() {
      try {
        graph.insertTableRow(ss.vertices[0], true);
      } catch (e) {
        ui.handleError(e);
      }
    }), panel),
    ui.toolbar.addButton("geSprite-insertrowafter", mxResources2.get("insertRowAfter"), bind(this, function() {
      try {
        graph.insertTableRow(ss.vertices[0], false);
      } catch (e) {
        ui.handleError(e);
      }
    }), panel),
    ui.toolbar.addButton("geSprite-deleterow", mxResources2.get("deleteRow"), bind(this, function() {
      try {
        graph.deleteTableRow(ss.vertices[0]);
      } catch (e) {
        ui.handleError(e);
      }
    }), panel)
  ];
  this.styleButtons(btns);
  div.appendChild(panel);
  btns[2].style.marginRight = "9px";
  return div;
};
ArrangePanel.prototype.addLayerOps = function(div) {
  var ui = this.editorUi;
  var btn = button(mxResources2.get("toFront"), function(evt) {
    ui.actions.get("toFront").funct();
  });
  btn.setAttribute("title", mxResources2.get("toFront") + " (" + this.editorUi.actions.get("toFront").shortcut + ")");
  btn.style.width = "100px";
  btn.style.marginRight = "2px";
  div.appendChild(btn);
  var btn = button(mxResources2.get("toBack"), function(evt) {
    ui.actions.get("toBack").funct();
  });
  btn.setAttribute("title", mxResources2.get("toBack") + " (" + this.editorUi.actions.get("toBack").shortcut + ")");
  btn.style.width = "100px";
  div.appendChild(btn);
  return div;
};
ArrangePanel.prototype.addGroupOps = function(div) {
  var ui = this.editorUi;
  var graph = ui.editor.graph;
  var cell2 = graph.getSelectionCell();
  var ss = this.format.getSelectionState();
  var count = 0;
  var btn = null;
  div.style.paddingTop = "8px";
  div.style.paddingBottom = "6px";
  if (graph.getSelectionCount() > 1) {
    btn = button(mxResources2.get("group"), function(evt) {
      ui.actions.get("group").funct();
    });
    btn.setAttribute("title", mxResources2.get("group") + " (" + this.editorUi.actions.get("group").shortcut + ")");
    btn.style.width = "202px";
    btn.style.marginBottom = "2px";
    div.appendChild(btn);
    count++;
  } else if (graph.getSelectionCount() == 1 && !graph.getModel().isEdge(cell2) && !graph.isSwimlane(cell2) && !graph.isTable(cell2) && !ss.row && !ss.cell && graph.getModel().getChildCount(cell2) > 0) {
    btn = button(mxResources2.get("ungroup"), function(evt) {
      ui.actions.get("ungroup").funct();
    });
    btn.setAttribute("title", mxResources2.get("ungroup") + " (" + this.editorUi.actions.get("ungroup").shortcut + ")");
    btn.style.width = "202px";
    btn.style.marginBottom = "2px";
    div.appendChild(btn);
    count++;
  }
  if (ss.vertices.length > 0) {
    if (count > 0) {
      br(div);
      count = 0;
    }
    var btn = button(mxResources2.get("copySize"), function(evt) {
      ui.actions.get("copySize").funct();
    });
    btn.setAttribute("title", mxResources2.get("copySize") + " (" + this.editorUi.actions.get("copySize").shortcut + ")");
    btn.style.width = "202px";
    btn.style.marginBottom = "2px";
    div.appendChild(btn);
    count++;
    if (ui.copiedSize != null) {
      var btn2 = button(mxResources2.get("pasteSize"), function(evt) {
        ui.actions.get("pasteSize").funct();
      });
      btn2.setAttribute("title", mxResources2.get("pasteSize") + " (" + this.editorUi.actions.get("pasteSize").shortcut + ")");
      div.appendChild(btn2);
      count++;
      btn.style.width = "100px";
      btn.style.marginBottom = "2px";
      btn2.style.width = "100px";
      btn2.style.marginBottom = "2px";
    }
  }
  if (graph.getSelectionCount() == 1 && graph.getModel().isVertex(cell2) && !ss.row && !ss.cell && graph.getModel().isVertex(graph.getModel().getParent(cell2))) {
    if (count > 0) {
      br(div);
    }
    btn = button(mxResources2.get("removeFromGroup"), function(evt) {
      ui.actions.get("removeFromGroup").funct();
    });
    btn.setAttribute("title", mxResources2.get("removeFromGroup"));
    btn.style.width = "202px";
    btn.style.marginBottom = "2px";
    div.appendChild(btn);
    count++;
  } else if (graph.getSelectionCount() > 0) {
    if (count > 0) {
      br(div);
    }
    btn = button(mxResources2.get("clearWaypoints"), bind(this, function(evt) {
      this.editorUi.actions.get("clearWaypoints").funct();
    }));
    btn.setAttribute("title", mxResources2.get("clearWaypoints") + " (" + this.editorUi.actions.get("clearWaypoints").shortcut + ")");
    btn.style.width = "202px";
    btn.style.marginBottom = "2px";
    div.appendChild(btn);
    count++;
  }
  if (graph.getSelectionCount() == 1) {
    if (count > 0) {
      br(div);
    }
    btn = button(mxResources2.get("editData"), bind(this, function(evt) {
      this.editorUi.actions.get("editData").funct();
    }));
    btn.setAttribute("title", mxResources2.get("editData") + " (" + this.editorUi.actions.get("editData").shortcut + ")");
    btn.style.width = "100px";
    btn.style.marginBottom = "2px";
    div.appendChild(btn);
    count++;
    btn = button(mxResources2.get("editLink"), bind(this, function(evt) {
      this.editorUi.actions.get("editLink").funct();
    }));
    btn.setAttribute("title", mxResources2.get("editLink"));
    btn.style.width = "100px";
    btn.style.marginLeft = "2px";
    btn.style.marginBottom = "2px";
    div.appendChild(btn);
    count++;
  }
  if (count == 0) {
    div.style.display = "none";
  }
  return div;
};
ArrangePanel.prototype.addAlign = function(div) {
  var graph = this.editorUi.editor.graph;
  div.style.paddingTop = "6px";
  div.style.paddingBottom = "12px";
  div.appendChild(this.createTitle(mxResources2.get("align")));
  var stylePanel = document.createElement("div");
  stylePanel.style.position = "relative";
  stylePanel.style.paddingLeft = "0px";
  stylePanel.style.borderWidth = "0px";
  stylePanel.className = "geToolbarContainer";
  if (mxClient.IS_QUIRKS) {
    div.style.height = "60px";
  }
  var left = this.editorUi.toolbar.addButton("geSprite-alignleft", mxResources2.get("left"), function() {
    graph.alignCells(mxConstants2.ALIGN_LEFT);
  }, stylePanel);
  var center = this.editorUi.toolbar.addButton("geSprite-aligncenter", mxResources2.get("center"), function() {
    graph.alignCells(mxConstants2.ALIGN_CENTER);
  }, stylePanel);
  var right = this.editorUi.toolbar.addButton("geSprite-alignright", mxResources2.get("right"), function() {
    graph.alignCells(mxConstants2.ALIGN_RIGHT);
  }, stylePanel);
  var top = this.editorUi.toolbar.addButton("geSprite-aligntop", mxResources2.get("top"), function() {
    graph.alignCells(mxConstants2.ALIGN_TOP);
  }, stylePanel);
  var middle = this.editorUi.toolbar.addButton("geSprite-alignmiddle", mxResources2.get("middle"), function() {
    graph.alignCells(mxConstants2.ALIGN_MIDDLE);
  }, stylePanel);
  var bottom = this.editorUi.toolbar.addButton("geSprite-alignbottom", mxResources2.get("bottom"), function() {
    graph.alignCells(mxConstants2.ALIGN_BOTTOM);
  }, stylePanel);
  this.styleButtons([left, center, right, top, middle, bottom]);
  right.style.marginRight = "6px";
  div.appendChild(stylePanel);
  return div;
};
ArrangePanel.prototype.addFlip = function(div) {
  var ui = this.editorUi;
  var editor = ui.editor;
  var graph = editor.graph;
  div.style.paddingTop = "6px";
  div.style.paddingBottom = "10px";
  var span = document.createElement("div");
  span.style.marginTop = "2px";
  span.style.marginBottom = "8px";
  span.style.fontWeight = "bold";
  write(span, mxResources2.get("flip"));
  div.appendChild(span);
  var btn = button(mxResources2.get("horizontal"), function(evt) {
    graph.toggleCellStyles(mxConstants2.STYLE_FLIPH, false);
  });
  btn.setAttribute("title", mxResources2.get("horizontal"));
  btn.style.width = "100px";
  btn.style.marginRight = "2px";
  div.appendChild(btn);
  var btn = button(mxResources2.get("vertical"), function(evt) {
    graph.toggleCellStyles(mxConstants2.STYLE_FLIPV, false);
  });
  btn.setAttribute("title", mxResources2.get("vertical"));
  btn.style.width = "100px";
  div.appendChild(btn);
  return div;
};
ArrangePanel.prototype.addDistribute = function(div) {
  var ui = this.editorUi;
  var editor = ui.editor;
  var graph = editor.graph;
  div.style.paddingTop = "6px";
  div.style.paddingBottom = "12px";
  div.appendChild(this.createTitle(mxResources2.get("distribute")));
  var btn = button(mxResources2.get("horizontal"), function(evt) {
    graph.distributeCells(true);
  });
  btn.setAttribute("title", mxResources2.get("horizontal"));
  btn.style.width = "100px";
  btn.style.marginRight = "2px";
  div.appendChild(btn);
  var btn = button(mxResources2.get("vertical"), function(evt) {
    graph.distributeCells(false);
  });
  btn.setAttribute("title", mxResources2.get("vertical"));
  btn.style.width = "100px";
  div.appendChild(btn);
  return div;
};
ArrangePanel.prototype.addAngle = function(div) {
  var ui = this.editorUi;
  var editor = ui.editor;
  var graph = editor.graph;
  var ss = this.format.getSelectionState();
  div.style.paddingBottom = "8px";
  var span = document.createElement("div");
  span.style.position = "absolute";
  span.style.width = "70px";
  span.style.marginTop = "0px";
  span.style.fontWeight = "bold";
  var input = null;
  var update = null;
  var btn = null;
  if (ss.rotatable && !ss.table && !ss.row && !ss.cell) {
    write(span, mxResources2.get("angle"));
    div.appendChild(span);
    input = this.addUnitInput(div, "\xB0", 20, 44, function() {
      update.apply(this, arguments);
    });
    br(div);
    div.style.paddingTop = "10px";
  } else {
    div.style.paddingTop = "8px";
  }
  if (!ss.containsLabel) {
    var label = mxResources2.get("reverse");
    if (ss.vertices.length > 0 && ss.edges.length > 0) {
      label = mxResources2.get("turn") + " / " + label;
    } else if (ss.vertices.length > 0) {
      label = mxResources2.get("turn");
    }
    btn = button(label, function(evt) {
      ui.actions.get("turn").funct(evt);
    });
    btn.setAttribute("title", label + " (" + this.editorUi.actions.get("turn").shortcut + ")");
    btn.style.width = "202px";
    div.appendChild(btn);
    if (input != null) {
      btn.style.marginTop = "8px";
    }
  }
  if (input != null) {
    var listener = bind(this, function(sender, evt, force) {
      if (force || document.activeElement != input) {
        ss = this.format.getSelectionState();
        var tmp = parseFloat(getValue(ss.style, mxConstants2.STYLE_ROTATION, 0));
        input.value = isNaN(tmp) ? "" : tmp + "\xB0";
      }
    });
    update = this.installInputHandler(input, mxConstants2.STYLE_ROTATION, 0, 0, 360, "\xB0", null, true);
    this.addKeyHandler(input, listener);
    graph.getModel().addListener(mxEvent2.CHANGE, listener);
    this.listeners.push({
      destroy: function() {
        graph.getModel().removeListener(listener);
      }
    });
    listener();
  }
  return div;
};
ArrangePanel.prototype.addEdgeGeometry = function(container) {
  var ui = this.editorUi;
  var graph = ui.editor.graph;
  var rect = this.format.getSelectionState();
  var div = this.createPanel();
  var span = document.createElement("div");
  span.style.position = "absolute";
  span.style.width = "70px";
  span.style.marginTop = "0px";
  span.style.fontWeight = "bold";
  write(span, mxResources2.get("width"));
  div.appendChild(span);
  var widthUpdate, xtUpdate, ytUpdate, xsUpdate, ysUpdate;
  var width = this.addUnitInput(div, "pt", 20, 44, function() {
    widthUpdate.apply(this, arguments);
  });
  br(div);
  this.addKeyHandler(width, listener);
  function widthUpdate(evt) {
    var value = parseInt(width.value);
    value = Math.min(999, Math.max(1, isNaN(value) ? 1 : value));
    if (value != getValue(rect.style, "width", mxCellRenderer2.defaultShapes["flexArrow"].prototype.defaultWidth)) {
      graph.setCellStyles("width", value, graph.getSelectionCells());
      ui.fireEvent(new mxEventObject("styleChanged", "keys", ["width"], "values", [value], "cells", graph.getSelectionCells()));
    }
    width.value = value + " pt";
    mxEvent2.consume(evt);
  }
  mxEvent2.addListener(width, "blur", widthUpdate);
  mxEvent2.addListener(width, "change", widthUpdate);
  container.appendChild(div);
  var divs = this.createPanel();
  divs.style.paddingBottom = "30px";
  var span = document.createElement("div");
  span.style.position = "absolute";
  span.style.width = "70px";
  span.style.marginTop = "0px";
  span.style.fontWeight = "bold";
  write(span, "Start");
  divs.appendChild(span);
  var xs = this.addUnitInput(divs, "pt", 84, 44, function() {
    xsUpdate.apply(this, arguments);
  });
  var ys = this.addUnitInput(divs, "pt", 20, 44, function() {
    ysUpdate.apply(this, arguments);
  });
  br(divs);
  this.addLabel(divs, mxResources2.get("left"), 84);
  this.addLabel(divs, mxResources2.get("top"), 20);
  container.appendChild(divs);
  this.addKeyHandler(xs, listener);
  this.addKeyHandler(ys, listener);
  var divt = this.createPanel();
  divt.style.paddingBottom = "30px";
  var span = document.createElement("div");
  span.style.position = "absolute";
  span.style.width = "70px";
  span.style.marginTop = "0px";
  span.style.fontWeight = "bold";
  write(span, "End");
  divt.appendChild(span);
  var xt = this.addUnitInput(divt, "pt", 84, 44, function() {
    xtUpdate.apply(this, arguments);
  });
  var yt = this.addUnitInput(divt, "pt", 20, 44, function() {
    ytUpdate.apply(this, arguments);
  });
  br(divt);
  this.addLabel(divt, mxResources2.get("left"), 84);
  this.addLabel(divt, mxResources2.get("top"), 20);
  container.appendChild(divt);
  this.addKeyHandler(xt, listener);
  this.addKeyHandler(yt, listener);
  var listener = bind(this, function(sender, evt, force) {
    rect = this.format.getSelectionState();
    var cell2 = graph.getSelectionCell();
    if (rect.style.shape == "link" || rect.style.shape == "flexArrow") {
      div.style.display = "";
      if (force || document.activeElement != width) {
        var value = getValue(rect.style, "width", mxCellRenderer2.defaultShapes["flexArrow"].prototype.defaultWidth);
        width.value = value + " pt";
      }
    } else {
      div.style.display = "none";
    }
    if (graph.getSelectionCount() == 1 && graph.model.isEdge(cell2)) {
      var geo = graph.model.getGeometry(cell2);
      if (geo.sourcePoint != null && graph.model.getTerminal(cell2, true) == null) {
        xs.value = geo.sourcePoint.x;
        ys.value = geo.sourcePoint.y;
      } else {
        divs.style.display = "none";
      }
      if (geo.targetPoint != null && graph.model.getTerminal(cell2, false) == null) {
        xt.value = geo.targetPoint.x;
        yt.value = geo.targetPoint.y;
      } else {
        divt.style.display = "none";
      }
    } else {
      divs.style.display = "none";
      divt.style.display = "none";
    }
  });
  xsUpdate = this.addEdgeGeometryHandler(xs, function(geo, value) {
    geo.sourcePoint.x = value;
  });
  ysUpdate = this.addEdgeGeometryHandler(ys, function(geo, value) {
    geo.sourcePoint.y = value;
  });
  xtUpdate = this.addEdgeGeometryHandler(xt, function(geo, value) {
    geo.targetPoint.x = value;
  });
  ytUpdate = this.addEdgeGeometryHandler(yt, function(geo, value) {
    geo.targetPoint.y = value;
  });
  graph.getModel().addListener(mxEvent2.CHANGE, listener);
  this.listeners.push({
    destroy: function() {
      graph.getModel().removeListener(listener);
    }
  });
  listener();
};
ArrangePanel.prototype.addGeometry = function(container) {
  var panel = this;
  var ui = this.editorUi;
  var graph = ui.editor.graph;
  var rect = this.format.getSelectionState();
  var div = this.createPanel();
  div.style.paddingBottom = "8px";
  var span = document.createElement("div");
  span.style.position = "absolute";
  span.style.width = "50px";
  span.style.marginTop = "0px";
  span.style.fontWeight = "bold";
  write(span, mxResources2.get("size"));
  div.appendChild(span);
  var widthUpdate, heightUpdate, leftUpdate, topUpdate;
  var width = this.addUnitInput(div, this.getUnit(), 84, 44, function() {
    widthUpdate.apply(this, arguments);
  }, this.getUnitStep(), null, null, this.isFloatUnit());
  var height = this.addUnitInput(div, this.getUnit(), 20, 44, function() {
    heightUpdate.apply(this, arguments);
  }, this.getUnitStep(), null, null, this.isFloatUnit());
  var autosizeBtn = document.createElement("div");
  autosizeBtn.className = "geSprite geSprite-fit";
  autosizeBtn.setAttribute("title", mxResources2.get("autosize") + " (" + this.editorUi.actions.get("autosize").shortcut + ")");
  autosizeBtn.style.position = "relative";
  autosizeBtn.style.cursor = "pointer";
  autosizeBtn.style.marginTop = "-3px";
  autosizeBtn.style.border = "0px";
  autosizeBtn.style.left = "42px";
  setOpacity(autosizeBtn, 50);
  mxEvent2.addListener(autosizeBtn, "mouseenter", function() {
    setOpacity(autosizeBtn, 100);
  });
  mxEvent2.addListener(autosizeBtn, "mouseleave", function() {
    setOpacity(autosizeBtn, 50);
  });
  mxEvent2.addListener(autosizeBtn, "click", function() {
    ui.actions.get("autosize").funct();
  });
  div.appendChild(autosizeBtn);
  if (rect.row) {
    width.style.visibility = "hidden";
    width.nextSibling.style.visibility = "hidden";
  } else {
    this.addLabel(div, mxResources2.get("width"), 84);
  }
  this.addLabel(div, mxResources2.get("height"), 20);
  br(div);
  var wrapper = document.createElement("div");
  wrapper.style.paddingTop = "8px";
  wrapper.style.paddingRight = "20px";
  wrapper.style.whiteSpace = "nowrap";
  wrapper.style.textAlign = "right";
  var opt = this.createCellOption(mxResources2.get("constrainProportions"), mxConstants2.STYLE_ASPECT, null, "fixed", "null");
  opt.style.width = "100%";
  wrapper.appendChild(opt);
  if (!rect.cell && !rect.row) {
    div.appendChild(wrapper);
  } else {
    autosizeBtn.style.visibility = "hidden";
  }
  var constrainCheckbox = opt.getElementsByTagName("input")[0];
  this.addKeyHandler(width, listener);
  this.addKeyHandler(height, listener);
  widthUpdate = this.addGeometryHandler(width, function(geo, value, cell2) {
    if (graph.isTableCell(cell2)) {
      graph.setTableColumnWidth(cell2, value - geo.width, true);
      return true;
    } else if (geo.width > 0) {
      var value = Math.max(1, panel.fromUnit(value));
      if (constrainCheckbox.checked) {
        geo.height = Math.round(geo.height * value * 100 / geo.width) / 100;
      }
      geo.width = value;
    }
  });
  heightUpdate = this.addGeometryHandler(height, function(geo, value, cell2) {
    if (graph.isTableCell(cell2)) {
      cell2 = graph.model.getParent(cell2);
    }
    if (graph.isTableRow(cell2)) {
      graph.setTableRowHeight(cell2, value - geo.height);
      return true;
    } else if (geo.height > 0) {
      var value = Math.max(1, panel.fromUnit(value));
      if (constrainCheckbox.checked) {
        geo.width = Math.round(geo.width * value * 100 / geo.height) / 100;
      }
      geo.height = value;
    }
  });
  if (rect.resizable || rect.row || rect.cell) {
    container.appendChild(div);
  }
  var div2 = this.createPanel();
  div2.style.paddingBottom = "30px";
  var span = document.createElement("div");
  span.style.position = "absolute";
  span.style.width = "70px";
  span.style.marginTop = "0px";
  span.style.fontWeight = "bold";
  write(span, mxResources2.get("position"));
  div2.appendChild(span);
  var left = this.addUnitInput(div2, this.getUnit(), 84, 44, function() {
    leftUpdate.apply(this, arguments);
  }, this.getUnitStep(), null, null, this.isFloatUnit());
  var top = this.addUnitInput(div2, this.getUnit(), 20, 44, function() {
    topUpdate.apply(this, arguments);
  }, this.getUnitStep(), null, null, this.isFloatUnit());
  br(div2);
  this.addLabel(div2, mxResources2.get("left"), 84);
  this.addLabel(div2, mxResources2.get("top"), 20);
  var listener = bind(this, function(sender, evt, force) {
    rect = this.format.getSelectionState();
    if (!rect.containsLabel && rect.vertices.length == graph.getSelectionCount() && rect.width != null && rect.height != null) {
      div.style.display = "";
      if (force || document.activeElement != width) {
        width.value = this.inUnit(rect.width) + (rect.width == "" ? "" : " " + this.getUnit());
      }
      if (force || document.activeElement != height) {
        height.value = this.inUnit(rect.height) + (rect.height == "" ? "" : " " + this.getUnit());
      }
    } else {
      div.style.display = "none";
    }
    if (rect.vertices.length == graph.getSelectionCount() && rect.x != null && rect.y != null) {
      div2.style.display = "";
      if (force || document.activeElement != left) {
        left.value = this.inUnit(rect.x) + (rect.x == "" ? "" : " " + this.getUnit());
      }
      if (force || document.activeElement != top) {
        top.value = this.inUnit(rect.y) + (rect.y == "" ? "" : " " + this.getUnit());
      }
    } else {
      div2.style.display = "none";
    }
  });
  this.addKeyHandler(left, listener);
  this.addKeyHandler(top, listener);
  graph.getModel().addListener(mxEvent2.CHANGE, listener);
  this.listeners.push({
    destroy: function() {
      graph.getModel().removeListener(listener);
    }
  });
  listener();
  leftUpdate = this.addGeometryHandler(left, function(geo, value) {
    value = panel.fromUnit(value);
    if (geo.relative) {
      geo.offset.x = value;
    } else {
      geo.x = value;
    }
  });
  topUpdate = this.addGeometryHandler(top, function(geo, value) {
    value = panel.fromUnit(value);
    if (geo.relative) {
      geo.offset.y = value;
    } else {
      geo.y = value;
    }
  });
  if (rect.movable) {
    container.appendChild(div2);
  }
};
ArrangePanel.prototype.addGeometryHandler = function(input, fn) {
  var ui = this.editorUi;
  var graph = ui.editor.graph;
  var initialValue = null;
  var panel = this;
  function update(evt) {
    if (input.value != "") {
      var value = parseFloat(input.value);
      if (isNaN(value)) {
        input.value = initialValue + " " + panel.getUnit();
      } else if (value != initialValue) {
        graph.getModel().beginUpdate();
        try {
          var cells = graph.getSelectionCells();
          for (var i = 0; i < cells.length; i++) {
            if (graph.getModel().isVertex(cells[i])) {
              var geo = graph.getCellGeometry(cells[i]);
              if (geo != null) {
                geo = geo.clone();
                if (!fn(geo, value, cells[i])) {
                  var state2 = graph.view.getState(cells[i]);
                  if (state2 != null && graph.isRecursiveVertexResize(state2)) {
                    graph.resizeChildCells(cells[i], geo);
                  }
                  graph.getModel().setGeometry(cells[i], geo);
                  graph.constrainChildCells(cells[i]);
                }
              }
            }
          }
        } finally {
          graph.getModel().endUpdate();
        }
        initialValue = value;
        input.value = value + " " + panel.getUnit();
      }
    }
    mxEvent2.consume(evt);
  }
  mxEvent2.addListener(input, "blur", update);
  mxEvent2.addListener(input, "change", update);
  mxEvent2.addListener(input, "focus", function() {
    initialValue = input.value;
  });
  return update;
};
ArrangePanel.prototype.addEdgeGeometryHandler = function(input, fn) {
  var ui = this.editorUi;
  var graph = ui.editor.graph;
  var initialValue = null;
  function update(evt) {
    if (input.value != "") {
      var value = parseFloat(input.value);
      if (isNaN(value)) {
        input.value = initialValue + " pt";
      } else if (value != initialValue) {
        graph.getModel().beginUpdate();
        try {
          var cells = graph.getSelectionCells();
          for (var i = 0; i < cells.length; i++) {
            if (graph.getModel().isEdge(cells[i])) {
              var geo = graph.getCellGeometry(cells[i]);
              if (geo != null) {
                geo = geo.clone();
                fn(geo, value);
                graph.getModel().setGeometry(cells[i], geo);
              }
            }
          }
        } finally {
          graph.getModel().endUpdate();
        }
        initialValue = value;
        input.value = value + " pt";
      }
    }
    mxEvent2.consume(evt);
  }
  mxEvent2.addListener(input, "blur", update);
  mxEvent2.addListener(input, "change", update);
  mxEvent2.addListener(input, "focus", function() {
    initialValue = input.value;
  });
  return update;
};

// js/Format.js
var Format = function(editorUi, container) {
  window.editorUi = editorUi;
  this.editorUi = editorUi;
  this.container = container;
  let threagileInit = `
threagile_version: 1.0.0
business_criticality: important # values: archive, operational, important, critical, mission-critical

tags_available:
  - linux
  - apache
  - mysql
  - jboss
  - keycloak
  - jenkins
  - git
  - oracle
  - some-erp
  - vmware
  - aws
  - aws:ec2
  - aws:s3
  - role:administrator 
  - role:it-sicherheitsbeauftragter
  - role:datenschutzbeauftragter 
  - role:fachadministrator 
  - role:endbenutzer 
  - role:entwickler 
  - role:externer-dienstleister 
  - role:pruefer 
  - role:redakteur 
  - role:leitungsebene 
`;
  let wow = YAML.parse(threagileInit);
  let wow2 = YAML.parseDocument(threagileInit);
  this.editorUi.editor.graph.model.threagile = YAML.parseDocument(threagileInit);
  let tags = this.editorUi.editor.graph.model.threagile.getIn("tags_avaiable");
};
Format.prototype.labelIndex = 0;
Format.prototype.diagramIndex = 0;
Format.prototype.currentIndex = 0;
Format.prototype.showCloseButton = true;
Format.prototype.inactiveTabBackgroundColor = "#f1f3f4";
Format.prototype.roundableShapes = [
  "label",
  "rectangle",
  "internalStorage",
  "corner",
  "parallelogram",
  "swimlane",
  "triangle",
  "trapezoid",
  "ext",
  "step",
  "tee",
  "process",
  "link",
  "rhombus",
  "offPageConnector",
  "loopLimit",
  "hexagon",
  "manualInput",
  "card",
  "curlyBracket",
  "singleArrow",
  "callout",
  "doubleArrow",
  "flexArrow",
  "umlLifeline"
];
Format.prototype.init = function() {
  var ui = this.editorUi;
  var editor = ui.editor;
  var graph = editor.graph;
  graph.connectionHandler.createTarget = true;
  graph.connectionHandler.connect = function(source, target, evt, dropTarget) {
    if (!graph.getModel().isVertex(source) || !graph.getModel().isVertex(target)) {
      return null;
    }
    return mxConnectionHandler.prototype.connect.apply(this, arguments);
  };
  graph.connectionHandler.isConnectableCell = function(cell2) {
    return graph.getModel().isVertex(cell2);
  };
  graph.connectionHandler.isValidSource = function(cell2) {
    return graph.getModel().isVertex(cell2);
  };
  graph.connectionHandler.isValidTarget = function(cell2) {
    return graph.getModel().isVertex(cell2);
  };
  graph.connectionHandler.getEdgeValidationError = function(source, target, existingEdge) {
    if (graph.getModel().isEdge(source) && graph.getModel().isEdge(target)) {
      return "Edges cannot be connected to other edges.";
    }
    return "";
  };
  this.update = bind(this, function(sender, evt) {
    this.clearSelectionState();
    this.refresh();
  });
  graph.getSelectionModel().addListener(mxEvent2.CHANGE, this.update);
  graph.addListener(mxEvent2.EDITING_STARTED, this.update);
  graph.addListener(mxEvent2.EDITING_STOPPED, this.update);
  graph.getModel().addListener(mxEvent2.CHANGE, this.update);
  graph.addListener(mxEvent2.ROOT, bind(this, function() {
    this.refresh();
  }));
  ui.addListener("styleChanged", bind(this, function(sender, evt) {
    this.refresh();
  }));
  editor.addListener("autosaveChanged", bind(this, function() {
    this.refresh();
  }));
  this.refresh();
};
Format.prototype.clearSelectionState = function() {
  this.selectionState = null;
};
Format.prototype.getSelectionState = function() {
  if (this.selectionState == null) {
    this.selectionState = this.createSelectionState();
  }
  return this.selectionState;
};
Format.prototype.createSelectionState = function() {
  var cells = this.editorUi.editor.graph.getSelectionCells();
  var result2 = this.initSelectionState();
  for (var i = 0; i < cells.length; i++) {
    this.updateSelectionStateForCell(result2, cells[i], cells);
  }
  return result2;
};
Format.prototype.initSelectionState = function() {
  return {
    vertices: [],
    edges: [],
    x: null,
    y: null,
    width: null,
    height: null,
    style: {},
    containsImage: false,
    containsLabel: false,
    fill: true,
    glass: true,
    rounded: true,
    autoSize: false,
    image: true,
    shadow: true,
    lineJumps: true,
    resizable: true,
    table: false,
    cell: false,
    row: false,
    movable: true,
    rotatable: true,
    stroke: true
  };
};
Format.prototype.updateSelectionStateForCell = function(result2, cell2, cells) {
  var graph = this.editorUi.editor.graph;
  if (graph.getModel().isVertex(cell2)) {
    result2.resizable = result2.resizable && graph.isCellResizable(cell2);
    result2.rotatable = result2.rotatable && graph.isCellRotatable(cell2);
    result2.movable = result2.movable && graph.isCellMovable(cell2) && !graph.isTableRow(cell2) && !graph.isTableCell(cell2);
    result2.table = result2.table || graph.isTable(cell2);
    result2.cell = result2.cell || graph.isTableCell(cell2);
    result2.row = result2.row || graph.isTableRow(cell2);
    result2.vertices.push(cell2);
    var geo = graph.getCellGeometry(cell2);
    if (geo != null) {
      if (geo.width > 0) {
        if (result2.width == null) {
          result2.width = geo.width;
        } else if (result2.width != geo.width) {
          result2.width = "";
        }
      } else {
        result2.containsLabel = true;
      }
      if (geo.height > 0) {
        if (result2.height == null) {
          result2.height = geo.height;
        } else if (result2.height != geo.height) {
          result2.height = "";
        }
      } else {
        result2.containsLabel = true;
      }
      if (!geo.relative || geo.offset != null) {
        var x = geo.relative ? geo.offset.x : geo.x;
        var y = geo.relative ? geo.offset.y : geo.y;
        if (result2.x == null) {
          result2.x = x;
        } else if (result2.x != x) {
          result2.x = "";
        }
        if (result2.y == null) {
          result2.y = y;
        } else if (result2.y != y) {
          result2.y = "";
        }
      }
    }
  } else if (graph.getModel().isEdge(cell2)) {
    result2.edges.push(cell2);
    result2.resizable = false;
    result2.rotatable = false;
    result2.movable = false;
  }
  var state2 = graph.view.getState(cell2);
  if (state2 != null) {
    result2.autoSize = result2.autoSize || this.isAutoSizeState(state2);
    result2.glass = result2.glass && this.isGlassState(state2);
    result2.rounded = result2.rounded && this.isRoundedState(state2);
    result2.lineJumps = result2.lineJumps && this.isLineJumpState(state2);
    result2.image = result2.image && this.isImageState(state2);
    result2.shadow = result2.shadow && this.isShadowState(state2);
    result2.fill = result2.fill && this.isFillState(state2);
    result2.stroke = result2.stroke && this.isStrokeState(state2);
    var shape = getValue(state2.style, mxConstants2.STYLE_SHAPE, null);
    result2.containsImage = result2.containsImage || shape == "image";
    for (var key in state2.style) {
      var value = state2.style[key];
      if (value != null) {
        if (result2.style[key] == null) {
          result2.style[key] = value;
        } else if (result2.style[key] != value) {
          result2.style[key] = "";
        }
      }
    }
  }
};
Format.prototype.isFillState = function(state2) {
  return !this.isSpecialColor(state2.style[mxConstants2.STYLE_FILLCOLOR]) && (state2.view.graph.model.isVertex(state2.cell) || getValue(state2.style, mxConstants2.STYLE_SHAPE, null) == "arrow" || getValue(state2.style, mxConstants2.STYLE_SHAPE, null) == "filledEdge" || getValue(state2.style, mxConstants2.STYLE_SHAPE, null) == "flexArrow");
};
Format.prototype.isStrokeState = function(state2) {
  return !this.isSpecialColor(state2.style[mxConstants2.STYLE_STROKECOLOR]);
};
Format.prototype.isSpecialColor = function(color) {
  return indexOf([
    mxConstants2.STYLE_STROKECOLOR,
    mxConstants2.STYLE_FILLCOLOR,
    "inherit",
    "swimlane",
    "indicated"
  ], color) >= 0;
};
Format.prototype.isGlassState = function(state2) {
  var shape = getValue(state2.style, mxConstants2.STYLE_SHAPE, null);
  return shape == "label" || shape == "rectangle" || shape == "internalStorage" || shape == "ext" || shape == "umlLifeline" || shape == "swimlane" || shape == "process";
};
Format.prototype.isRoundedState = function(state2) {
  return state2.shape != null ? state2.shape.isRoundable() : indexOf(this.roundableShapes, getValue(state2.style, mxConstants2.STYLE_SHAPE, null)) >= 0;
};
Format.prototype.isLineJumpState = function(state2) {
  var shape = getValue(state2.style, mxConstants2.STYLE_SHAPE, null);
  var curved = getValue(state2.style, mxConstants2.STYLE_CURVED, false);
  return !curved && (shape == "connector" || shape == "filledEdge");
};
Format.prototype.isAutoSizeState = function(state2) {
  return getValue(state2.style, mxConstants2.STYLE_AUTOSIZE, null) == "1";
};
Format.prototype.isImageState = function(state2) {
  var shape = getValue(state2.style, mxConstants2.STYLE_SHAPE, null);
  return shape == "label" || shape == "image";
};
Format.prototype.isShadowState = function(state2) {
  var shape = getValue(state2.style, mxConstants2.STYLE_SHAPE, null);
  return shape != "image";
};
Format.prototype.clear = function() {
  this.container.innerHTML = "";
  if (this.panels != null) {
    for (var i = 0; i < this.panels.length; i++) {
      this.panels[i].destroy();
    }
  }
  this.panels = [];
};
function isTrustBoundaries(cell2) {
  return cell2.style.includes("rounded=0") || cell2.style.includes("rounded=1") || cell2.style.includes("shape=rectangle");
}
Format.prototype.refresh = function() {
  if (this.container.style.width == "0px") {
    return;
  }
  this.clear();
  var ui = this.editorUi;
  var graph = ui.editor.graph;
  var div = document.createElement("div");
  div.style.whiteSpace = "nowrap";
  div.style.color = "rgb(112, 112, 112)";
  div.style.textAlign = "left";
  div.style.cursor = "default";
  var label = document.createElement("div");
  label.className = "geFormatSection";
  label.style.textAlign = "center";
  label.style.fontWeight = "bold";
  label.style.paddingTop = "8px";
  label.style.fontSize = "13px";
  label.style.borderWidth = "0px 0px 1px 1px";
  label.style.borderStyle = "solid";
  label.style.display = mxClient_default.IS_QUIRKS ? "inline" : "inline-block";
  label.style.height = mxClient_default.IS_QUIRKS ? "34px" : "25px";
  label.style.overflow = "hidden";
  label.style.width = "100%";
  this.container.appendChild(div);
  mxEvent2.addListener(label, mxClient_default.IS_POINTER ? "pointerdown" : "mousedown", bind(this, function(evt) {
    evt.preventDefault();
  }));
  var containsLabel = this.getSelectionState().containsLabel;
  var currentLabel = null;
  var currentPanel = null;
  var addClickHandler = bind(this, function(elt, panel, index) {
    var clickHandler = bind(this, function(evt) {
      var cell3 = graph.getSelectionCell();
      if (currentLabel != elt) {
        if (containsLabel) {
          this.labelIndex = index;
        } else if (graph.isSelectionEmpty()) {
          this.diagramIndex = index;
        } else if (cell3 != null && cell3.isEdge()) {
        } else {
          this.currentIndex = index;
        }
        if (currentLabel != null) {
          currentLabel.style.backgroundColor = this.inactiveTabBackgroundColor;
          currentLabel.style.borderBottomWidth = "1px";
        }
        currentLabel = elt;
        currentLabel.style.backgroundColor = "";
        currentLabel.style.borderBottomWidth = "0px";
        if (currentPanel != panel) {
          if (currentPanel != null) {
            currentPanel.style.display = "none";
          }
          currentPanel = panel;
          currentPanel.style.display = "";
        }
      }
    });
    mxEvent2.addListener(elt, "click", clickHandler);
    mxEvent2.addListener(elt, mxClient_default.IS_POINTER ? "pointerdown" : "mousedown", bind(this, function(evt) {
      evt.preventDefault();
    }));
    if (index == (containsLabel ? this.labelIndex : graph.isSelectionEmpty() ? this.diagramIndex : this.currentIndex)) {
      clickHandler();
    }
  });
  var idx = 0;
  var cell2 = graph.getSelectionCell();
  if (graph.isSelectionEmpty()) {
    write(label, mxResources2.get("diagram"));
    label.style.borderLeftWidth = "0px";
    div.appendChild(label);
    let diagramPanel = div.cloneNode(false);
    this.panels.push(new DiagramFormatPanel(this, ui, diagramPanel));
    this.container.appendChild(diagramPanel);
    if (Editor2.styles != null) {
      diagramPanel.style.display = "none";
      label.style.width = this.showCloseButton ? "106px" : "50%";
      label.style.cursor = "pointer";
      label.style.backgroundColor = this.inactiveTabBackgroundColor;
      var label2 = label.cloneNode(false);
      label2.style.borderLeftWidth = "1px";
      label2.style.borderRightWidth = "1px";
      label2.style.backgroundColor = this.inactiveTabBackgroundColor;
      addClickHandler(label, diagramPanel, idx++);
      let stylePanel2 = div.cloneNode(false);
      stylePanel2.style.display = "none";
      write(label2, mxResources2.get("style"));
      div.appendChild(label2);
      this.panels.push(new DiagramStylePanel(this, ui, stylePanel2));
      this.container.appendChild(stylePanel2);
      addClickHandler(label2, stylePanel2, idx++);
    }
    if (this.showCloseButton) {
      var label2 = label.cloneNode(false);
      label2.style.borderLeftWidth = "1px";
      label2.style.borderRightWidth = "1px";
      label2.style.borderBottomWidth = "1px";
      label2.style.backgroundColor = this.inactiveTabBackgroundColor;
      label2.style.position = "absolute";
      label2.style.right = "0px";
      label2.style.top = "0px";
      label2.style.width = "25px";
      var img = document.createElement("img");
      img.setAttribute("border", "0");
      img.setAttribute("src", Dialog2.prototype.closeImage);
      img.setAttribute("title", mxResources2.get("hide"));
      img.style.position = "absolute";
      img.style.display = "block";
      img.style.right = "0px";
      img.style.top = "8px";
      img.style.cursor = "pointer";
      img.style.marginTop = "1px";
      img.style.marginRight = "6px";
      img.style.border = "1px solid transparent";
      img.style.padding = "1px";
      img.style.opacity = 0.5;
      label2.appendChild(img);
      mxEvent2.addListener(img, "click", function() {
        ui.actions.get("formatPanel").funct();
      });
      div.appendChild(label2);
    }
  } else if (cell2 != null && graph.getSelectionCell().isVertex() && isTrustBoundaries(graph.getSelectionCell())) {
    label.style.backgroundColor = this.inactiveTabBackgroundColor;
    label.style.borderLeftWidth = "1px";
    label.style.cursor = "pointer";
    label.style.width = containsLabel ? "50%" : "33.3%";
    var label2 = label.cloneNode(false);
    var label3 = label2.cloneNode(false);
    label2.style.backgroundColor = this.inactiveTabBackgroundColor;
    label3.style.backgroundColor = this.inactiveTabBackgroundColor;
    if (containsLabel) {
      label2.style.borderLeftWidth = "0px";
    } else {
      label.style.borderLeftWidth = "0px";
      write(label, "Boundary");
      div.appendChild(label);
      var stylePanel = div.cloneNode(false);
      stylePanel.style.display = "none";
      this.panels.push(new BoundaryFormatPanel(this, ui, stylePanel));
      this.container.appendChild(stylePanel);
      addClickHandler(label, stylePanel, idx++);
    }
    write(label2, mxResources2.get("text"));
    div.appendChild(label2);
    let textPanel2 = div.cloneNode(false);
    textPanel2.style.display = "none";
    this.panels.push(new TextFormatPanel(this, ui, textPanel2));
    this.container.appendChild(textPanel2);
    write(label3, mxResources2.get("arrange"));
    div.appendChild(label3);
    let arrangePanel2 = div.cloneNode(false);
    arrangePanel2.style.display = "none";
    this.panels.push(new ArrangePanel(this, ui, arrangePanel2));
    var stylePanel = div.cloneNode(false);
    stylePanel.style.display = "none";
    this.panels.push(new StyleFormatPanel2(this, ui, arrangePanel2));
    this.container.appendChild(arrangePanel2);
    addClickHandler(label2, textPanel2, idx++);
    addClickHandler(label3, arrangePanel2, idx++);
  } else if (cell2 != null && cell2.isEdge()) {
    label.style.backgroundColor = this.inactiveTabBackgroundColor;
    label.style.borderLeftWidth = "1px";
    label.style.cursor = "pointer";
    label.style.width = containsLabel ? "50%" : "33.3%";
    let label22 = label.cloneNode(false);
    let label32 = label22.cloneNode(false);
    label22.style.backgroundColor = this.inactiveTabBackgroundColor;
    label32.style.backgroundColor = this.inactiveTabBackgroundColor;
    if (containsLabel) {
      label22.style.borderLeftWidth = "0px";
    } else {
      label.style.borderLeftWidth = "0px";
      write(label, "Exchange");
      div.appendChild(label);
      var stylePanel = div.cloneNode(false);
      stylePanel.style.display = "none";
      this.panels.push(new CommunicationFormatPanel(this, ui, stylePanel));
      this.container.appendChild(stylePanel);
      addClickHandler(label, stylePanel, idx++);
    }
    write(label22, mxResources2.get("text"));
    div.appendChild(label22);
    var textPanel = div.cloneNode(false);
    textPanel.style.display = "none";
    this.panels.push(new TextFormatPanel(this, ui, textPanel));
    this.container.appendChild(textPanel);
    write(label32, mxResources2.get("arrange"));
    div.appendChild(label32);
    var arrangePanel = div.cloneNode(false);
    arrangePanel.style.display = "none";
    this.panels.push(new ArrangePanel(this, ui, arrangePanel));
    var stylePanel = div.cloneNode(false);
    stylePanel.style.display = "none";
    this.panels.push(new StyleFormatPanel2(this, ui, arrangePanel));
    this.container.appendChild(arrangePanel);
    addClickHandler(label22, textPanel, idx++);
    addClickHandler(label32, arrangePanel, idx++);
  } else if (graph.isEditing()) {
    write(label, mxResources2.get("text"));
    div.appendChild(label);
    this.panels.push(new TextFormatPanel(this, ui, div));
  } else {
    label.style.backgroundColor = this.inactiveTabBackgroundColor;
    label.style.borderLeftWidth = "1px";
    label.style.cursor = "pointer";
    label.style.width = containsLabel ? "50%" : "33.3%";
    let label22 = label.cloneNode(false);
    let label32 = label22.cloneNode(false);
    let label4 = label.cloneNode(false);
    label22.style.backgroundColor = this.inactiveTabBackgroundColor;
    label32.style.backgroundColor = this.inactiveTabBackgroundColor;
    label4.style.backgroundColor = this.inactiveTabBackgroundColor;
    if (containsLabel) {
      label4.style.borderLeftWidth = "0px";
    } else {
      label4.style.borderLeftWidth = "0px";
      write(label4, "Asset");
      div.appendChild(label4);
      let stylePanel2 = div.cloneNode(false);
      stylePanel2.style.display = "none";
      this.panels.push(new AssetFormatPanel(this, ui, stylePanel2));
      this.container.appendChild(stylePanel2);
      addClickHandler(label4, stylePanel2, idx++);
    }
    write(label22, "Inspection");
    div.appendChild(label22);
    var textPanel = div.cloneNode(false);
    textPanel.style.display = "none";
    this.container.appendChild(textPanel);
    this.panels.push(new InspectionFormatPanel(this, ui, textPanel));
    write(label32, mxResources2.get("arrange"));
    div.appendChild(label32);
    var arrangePanel = div.cloneNode(false);
    arrangePanel.style.display = "none";
    this.panels.push(new ArrangePanel(this, ui, arrangePanel));
    var stylePanel = div.cloneNode(false);
    stylePanel.style.display = "none";
    this.panels.push(new StyleFormatPanel2(this, ui, arrangePanel));
    this.panels.push(new TextFormatPanel(this, ui, arrangePanel));
    this.container.appendChild(arrangePanel);
    addClickHandler(label22, textPanel, idx++);
    addClickHandler(label32, arrangePanel, idx++);
  }
};

// js/MyMxStencilRegistry.js
var MyMxStencilRegistry2 = class extends mxStencilRegistry {
  static addStencil(name, stencil) {
    this.stencils[name] = stencil;
  }
  static getStencil(name) {
    let result2 = this.stencils[name];
    if (result2 == null && mxCellRenderer.defaultShapes[name] == null && this.dynamicLoading) {
      let basename = this.getBasenameForStencil(name);
      if (basename != null) {
        const libs = this.libraries[basename];
        if (libs != null) {
          if (this.packages[basename] == null) {
            for (let i = 0; i < libs.length; i++) {
              const fname = libs[i];
              if (fname.toLowerCase().substring(fname.length - 4, fname.length) === ".xml") {
                this.loadStencilSet(fname, null);
              } else if (fname.toLowerCase().substring(fname.length - 3, fname.length) === ".js") {
                try {
                  if (this.allowEval) {
                    const req = mxUtils.load(fname);
                    if (req != null && req.getStatus() >= 200 && req.getStatus() <= 299) {
                      eval.call(window, req.getText());
                    }
                  }
                } catch (e) {
                  if (window.console != null) {
                    console.log("error in getStencil:", fname, e);
                  }
                }
              } else {
              }
            }
            this.packages[basename] = 1;
          }
        } else {
          basename = basename.replace("_-_", "_");
          this.loadStencilSet(STENCIL_PATH + "/" + basename + ".xml", null);
        }
        result2 = this.stencils[name];
      }
    }
    return result2;
  }
  static getBasenameForStencil(name) {
    let tmp = null;
    if (name != null && typeof name === "string") {
      const parts = name.split(".");
      if (parts.length > 0 && parts[0] === "mxgraph") {
        tmp = parts[1];
        for (let i = 2; i < parts.length - 1; i++) {
          tmp += "/" + parts[i];
        }
      }
    }
    return tmp;
  }
  static loadStencilSet(stencilFile, postStencilLoad, force, async) {
    force = force != null ? force : false;
    let xmlDoc = this.packages[stencilFile];
    if (force || xmlDoc == null) {
      let install = false;
      if (xmlDoc == null) {
        try {
          if (async) {
            this.loadStencil(stencilFile, mxUtils.bind(this, (xmlDoc2) => {
              if (xmlDoc2 != null && xmlDoc2.documentElement != null) {
                this.packages[stencilFile] = xmlDoc2;
                install = true;
                this.parseStencilSet(xmlDoc2.documentElement, postStencilLoad, install);
              }
            }));
            return;
          } else {
            xmlDoc = this.loadStencil(stencilFile);
            this.packages[stencilFile] = xmlDoc;
            install = true;
          }
        } catch (e) {
          if (window.console != null) {
            console.log("error in loadStencilSet:", stencilFile, e);
          }
        }
      }
      if (xmlDoc != null && xmlDoc.documentElement != null) {
        this.parseStencilSet(xmlDoc.documentElement, postStencilLoad, install);
      }
    }
  }
  static loadStencil(filename, fn) {
    if (fn != null) {
      mxUtils.get(filename, mxUtils.bind(this, (req) => {
        fn(req.getStatus() >= 200 && req.getStatus() <= 299 ? req.getXml() : null);
      }));
    } else {
      return mxUtils.load(filename).getXml();
    }
  }
  static parseStencilSets(stencils) {
    for (let i = 0; i < stencils.length; i++) {
      this.parseStencilSet(mxUtils.parseXml(stencils[i]).documentElement);
    }
  }
  static parseStencilSet(root, postStencilLoad, install) {
    if (root.nodeName === "stencils") {
      let shapes = root.firstChild;
      while (shapes != null) {
        if (shapes.nodeName === "shapes") {
          this.parseStencilSet(shapes, postStencilLoad, install);
        }
        shapes = shapes.nextSibling;
      }
    } else {
      install = install != null ? install : true;
      let shape = root.firstChild;
      let packageName = "";
      let name = root.getAttribute("name");
      if (name != null) {
        packageName = name + ".";
      }
      while (shape != null) {
        if (shape.nodeType === mxConstants.NODETYPE_ELEMENT) {
          name = shape.getAttribute("name");
          if (name != null) {
            packageName = packageName.toLowerCase();
            const stencilName = name.replace(/ /g, "_");
            if (install) {
              this.addStencil(packageName + stencilName.toLowerCase(), new mxStencil(shape));
            }
            if (postStencilLoad != null) {
              let w2 = shape.getAttribute("w");
              let h2 = shape.getAttribute("h");
              w2 = w2 == null ? 80 : parseInt(w2, 10);
              h2 = h2 == null ? 80 : parseInt(h2, 10);
              postStencilLoad(packageName, stencilName, name, w2, h2);
            }
          }
        }
        shape = shape.nextSibling;
      }
    }
  }
};
__publicField(MyMxStencilRegistry2, "libraries", {});
__publicField(MyMxStencilRegistry2, "dynamicLoading", true);
__publicField(MyMxStencilRegistry2, "allowEval", true);
__publicField(MyMxStencilRegistry2, "packages", []);
__publicField(MyMxStencilRegistry2, "stencils", {});

// js/Sidebar.js
function Sidebar2(editorUi, container) {
  this.editorUi = editorUi;
  this.container = container;
  this.palettes = new Object();
  this.taglist = new Object();
  this.showTooltips = true;
  this.graph = editorUi.createTemporaryGraph(this.editorUi.editor.graph.getStylesheet());
  this.graph.cellRenderer.minSvgStrokeWidth = this.minThumbStrokeWidth;
  this.graph.cellRenderer.antiAlias = this.thumbAntiAlias;
  this.graph.container.style.visibility = "hidden";
  this.graph.foldingEnabled = false;
  document.body.appendChild(this.graph.container);
  this.pointerUpHandler = bind(this, function() {
    this.showTooltips = true;
  });
  mxEvent2.addListener(document, mxClient_default.IS_POINTER ? "pointerup" : "mouseup", this.pointerUpHandler);
  this.pointerDownHandler = bind(this, function() {
    this.showTooltips = false;
    this.hideTooltip();
  });
  mxEvent2.addListener(document, mxClient_default.IS_POINTER ? "pointerdown" : "mousedown", this.pointerDownHandler);
  this.pointerMoveHandler = bind(this, function(evt) {
    var src = mxEvent2.getSource(evt);
    while (src != null) {
      if (src == this.currentElt) {
        return;
      }
      src = src.parentNode;
    }
    this.hideTooltip();
  });
  mxEvent2.addListener(document, mxClient_default.IS_POINTER ? "pointermove" : "mousemove", this.pointerMoveHandler);
  this.pointerOutHandler = bind(this, function(evt) {
    if (evt.toElement == null && evt.relatedTarget == null) {
      this.hideTooltip();
    }
  });
  mxEvent2.addListener(document, mxClient_default.IS_POINTER ? "pointerout" : "mouseout", this.pointerOutHandler);
  mxEvent2.addListener(container, "scroll", bind(this, function() {
    this.showTooltips = true;
    this.hideTooltip();
  }));
  this.init();
}
Sidebar2.prototype.init = function() {
  var dir = STENCIL_PATH;
  this.addGeneralPalette(true);
  var baseStyle = ";whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#000000;strokeWidth=2";
  var iconStyle = ";verticalLabelPosition=bottom;verticalAlign=top;align=center;fontStyle=1;fontSize=18;";
  var stencilGroups = [
    {
      id: "identity_security",
      title: "Identity & Security",
      expanded: false,
      stencils: [
        { file: "stencils/identityprovider.xml", title: "Identity Provider" },
        { file: "stencils/idsldap.xml", title: "Identity Store LDAP", style: iconStyle },
        { file: "stencils/idsdb.xml", title: "Identity Store Database", style: iconStyle },
        { file: "stencils/vault.xml", title: "Vault", style: iconStyle },
        { file: "stencils/hsm.xml", title: "HSM", style: iconStyle },
        { file: "stencils/waf.xml", title: "Web Application Firewall", style: iconStyle },
        { file: "stencils/ids.xml", title: "Intrusion Detection System", style: iconStyle },
        { file: "stencils/ips.xml", title: "Intrusion Prevention System", style: iconStyle }
      ]
    },
    {
      id: "web",
      title: "Web Related",
      expanded: false,
      stencils: [
        { file: "stencils/loadbalancer.xml", title: "Loadbalancer" },
        { file: "stencils/reverseproxy.xml", title: "Reverse Proxy" },
        { file: "stencils/webapp.xml", title: "Web Application" },
        { file: "stencils/webserver.xml", title: "Web Server" }
      ]
    },
    {
      id: "client",
      title: "Client Systems",
      expanded: false,
      stencils: [
        { file: "stencils/browser.xml", title: "Browser" },
        { file: "stencils/devops.xml", title: "DevOps Client", style: iconStyle },
        { file: "stencils/mobile.xml", title: "Mobile App", style: iconStyle },
        { file: "stencils/desktop.xml", title: "Desktop Client", style: iconStyle },
        { file: "stencils/clientsystem.xml", title: "Generic Client System", style: iconStyle }
      ]
    },
    {
      id: "development",
      title: "Development Related",
      expanded: false,
      stencils: [
        { file: "stencils/codeinspection.xml", title: "Code Inspection Platform" },
        { file: "stencils/git.xml", title: "Sourcecode Repository", style: iconStyle },
        { file: "stencils/buildpipeline.xml", title: "Build Pipeline", style: iconStyle },
        { file: "stencils/artifactregistry.xml", title: "Artifact Registry", style: iconStyle }
      ]
    },
    {
      id: "infrastructure",
      title: "Infrastructure & Services",
      expanded: false,
      stencils: [
        { file: "stencils/localfilesystem.xml", title: "Local File System", style: iconStyle },
        { file: "stencils/database.xml", title: "Database", style: iconStyle },
        { file: "stencils/ldapserver.xml", title: "LDAP Server", style: iconStyle },
        { file: "stencils/containerplatform.xml", title: "Container Platform", style: iconStyle },
        { file: "stencils/mainframe.xml", title: "Mainframe", style: iconStyle },
        { file: "stencils/blockstorage.xml", title: "Block Storage", style: iconStyle },
        { file: "stencils/webservicerest.xml", title: "WebService REST", style: iconStyle },
        { file: "stencils/webservicesoap.xml", title: "WebService SOAP", style: iconStyle }
      ]
    },
    {
      id: "messaging_processing",
      title: "Messaging & Processing",
      expanded: false,
      stencils: [
        { file: "stencils/mqueue.xml", title: "Message Queue", style: iconStyle },
        { file: "stencils/streamprocessing.xml", title: "Stream Processing", style: iconStyle },
        { file: "stencils/batchprocessing.xml", title: "Batch Processing", style: iconStyle },
        { file: "stencils/eventlistener.xml", title: "Event Listener", style: iconStyle }
      ]
    },
    {
      id: "network",
      title: "Network Components",
      expanded: false,
      stencils: [
        { file: "stencils/gateway.xml", title: "Gateway", style: iconStyle },
        { file: "stencils/servicemesh.xml", title: "Service Mesh", style: iconStyle }
      ]
    },
    {
      id: "data_analytics",
      title: "Data, Reporting & Analytics",
      expanded: false,
      stencils: [
        { file: "stencils/datalake.xml", title: "Data Lake", style: iconStyle },
        { file: "stencils/reportengine.xml", title: "Report Engine", style: iconStyle },
        { file: "stencils/ai.xml", title: "AI / ML Service", style: iconStyle },
        { file: "stencils/searchengine.xml", title: "Search Engine", style: iconStyle },
        { file: "stencils/searchindex.xml", title: "Search Index", style: iconStyle }
      ]
    },
    {
      id: "management_tools",
      title: "Management, Tools & Utilities",
      expanded: false,
      stencils: [
        { file: "stencils/cms.xml", title: "Content Management System", style: iconStyle },
        { file: "stencils/erp.xml", title: "ERP System", style: iconStyle },
        { file: "stencils/tool.xml", title: "Generic Tool", style: iconStyle },
        { file: "stencils/cli.xml", title: "Command Line Interface (CLI)", style: iconStyle },
        { file: "stencils/monitoring.xml", title: "Monitoring System", style: iconStyle },
        { file: "stencils/scheduler.xml", title: "Scheduler", style: iconStyle }
      ]
    },
    {
      id: "other",
      title: "Other",
      expanded: false,
      stencils: [
        { file: "stencils/unknown.xml", title: "Unknown Technology" },
        { file: "stencils/applicationserver.xml", title: "Application Server", style: iconStyle },
        { file: "stencils/ejb.xml", title: "EJB Container", style: iconStyle },
        { file: "stencils/serviceregistry.xml", title: "Service Registry", style: iconStyle },
        { file: "stencils/task.xml", title: "Generic Task", style: iconStyle },
        { file: "stencils/function.xml", title: "Function / Lambda", style: iconStyle },
        { file: "stencils/iotdevice.xml", title: "IoT Device", style: iconStyle },
        { file: "stencils/mailserver.xml", title: "Mail Server", style: iconStyle },
        { file: "stencils/library.xml", title: "Library", style: iconStyle }
      ]
    }
  ];
  stencilGroups.forEach(function(group) {
    this.addPalette(group.id, group.title, group.expanded, bind(this, function(content) {
      group.stencils.forEach(function(stencil) {
        var currentStyle = baseStyle + (stencil.style || "");
        MyMxStencilRegistry2.loadStencilSet(stencil.file, bind(this, function(packageName, stencilName, displayName, w2, h2) {
          var elt = this.createVertexTemplate("shape=" + packageName + stencilName.toLowerCase() + currentStyle, Math.round(w2 * 1), Math.round(h2 * 1), "", stencil.title, true, this.sidebarTitles);
          content.appendChild(elt);
        }), true, true);
      }, this);
    }));
  }, this);
  this.setCurrentSearchEntryLibrary();
  this.setCurrentSearchEntryLibrary("flowchart");
  this.setCurrentSearchEntryLibrary();
  this.setCurrentSearchEntryLibrary("clipart");
  this.addImagePalette("clipart", "Trust Boundaries", dir + "/clipart/", "_128x128.png", [
    "Earth_globe",
    "Empty_Folder",
    "Full_Folder",
    "Gear",
    "Lock",
    "Software",
    "Virus",
    "Email",
    "Database",
    "Router_Icon",
    "iPad",
    "iMac",
    "Laptop",
    "MacBook",
    "Monitor_Tower",
    "Printer",
    "Server_Tower",
    "Workstation",
    "Firewall_02",
    "Wireless_Router_N",
    "Credit_Card",
    "Piggy_Bank",
    "Graph",
    "Safe",
    "Shopping_Cart",
    "Suit1",
    "Suit2",
    "Suit3",
    "Pilot1",
    "Worker1",
    "Soldier1",
    "Doctor1",
    "Tech1",
    "Security1",
    "Telesales1"
  ], null, {
    Wireless_Router_N: "wireless router switch wap wifi access point wlan",
    Router_Icon: "router switch"
  });
  this.setCurrentSearchEntryLibrary();
};
Sidebar2.prototype.collapsedImage = !mxClient_default.IS_SVG ? IMAGE_PATH + "/collapsed.gif" : "data:image/gif;base64,R0lGODlhDQANAIABAJmZmf///yH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS4wLWMwNjAgNjEuMTM0Nzc3LCAyMDEwLzAyLzEyLTE3OjMyOjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozNUQyRTJFNjZGNUYxMUU1QjZEOThCNDYxMDQ2MzNCQiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozNUQyRTJFNzZGNUYxMUU1QjZEOThCNDYxMDQ2MzNCQiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjFERjc3MEUxNkY1RjExRTVCNkQ5OEI0NjEwNDYzM0JCIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjFERjc3MEUyNkY1RjExRTVCNkQ5OEI0NjEwNDYzM0JCIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAAQAsAAAAAA0ADQAAAhSMj6lrwAjcC1GyahV+dcZJgeIIFgA7";
Sidebar2.prototype.expandedImage = !mxClient_default.IS_SVG ? IMAGE_PATH + "/expanded.gif" : "data:image/gif;base64,R0lGODlhDQANAIABAJmZmf///yH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS4wLWMwNjAgNjEuMTM0Nzc3LCAyMDEwLzAyLzEyLTE3OjMyOjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoxREY3NzBERjZGNUYxMUU1QjZEOThCNDYxMDQ2MzNCQiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoxREY3NzBFMDZGNUYxMUU1QjZEOThCNDYxMDQ2MzNCQiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjFERjc3MERENkY1RjExRTVCNkQ5OEI0NjEwNDYzM0JCIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjFERjc3MERFNkY1RjExRTVCNkQ5OEI0NjEwNDYzM0JCIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAAQAsAAAAAA0ADQAAAhGMj6nL3QAjVHIu6azbvPtWAAA7";
Sidebar2.prototype.searchImage = !mxClient_default.IS_SVG ? IMAGE_PATH + "/search.png" : "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAEaSURBVHjabNGxS5VxFIfxz71XaWuQUJCG/gCHhgTD9VpEETg4aMOlQRp0EoezObgcd220KQiXmpretTAHQRBdojlQEJyukPdt+b1ywfvAGc7wnHP4nlZd1yKijQW8xzNc4Su+ZOYfQ3T6/f4YNvEJYzjELXp4VVXVz263+7cR2niBxAFeZ2YPi3iHR/gYERPDwhpOsd6sz8x/mfkNG3iOlWFhFj8y89J9KvzGXER0GuEaD42mgwHqUtoljbcRsTBCeINpfM/MgZLKPpaxFxGbOCqDXmILN7hoJrTKH+axhxmcYRxP0MIDnOBDZv5q1XUNIuJxifJp+UNV7t7BFM6xeic0RMQ4Bpl5W/ol7GISx/eEUUTECrbx+f8A8xhiZht9zsgAAAAASUVORK5CYII=";
Sidebar2.prototype.dragPreviewBorder = "1px dashed black";
Sidebar2.prototype.enableTooltips = true;
Sidebar2.prototype.tooltipBorder = 16;
Sidebar2.prototype.tooltipDelay = 300;
Sidebar2.prototype.dropTargetDelay = 200;
Sidebar2.prototype.gearImage = STENCIL_PATH + "/clipart/Gear_128x128.png";
Sidebar2.prototype.triangleUp = new Image();
Sidebar2.prototype.triangleUp.src = !mxClient_default.IS_SVG ? IMAGE_PATH + "/triangle-up.png" : "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAGHRFWHRTb2Z0d2FyZQBQYWludC5ORVQuYy52My41Ljg3O4uUAAAAU0lEQVQoU2P4z/CfAQp8//79/xMDHPf/ff8/goH/H4gajp8/f2F4z8+Pj/+/f/9AcPj//v3/B8P9/x/kB5D/DAx/6P8/0P9/BkP8/w8g34wzJgAATiNaE8wV0nUAAAAASUVORK5CYII=";
Sidebar2.prototype.triangleRight = new Image();
Sidebar2.prototype.triangleRight.src = !mxClient_default.IS_SVG ? IMAGE_PATH + "/triangle-right.png" : "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAGHRFWHRTb2Z0d2FyZQBQYWludC5ORVQuYy52My41Ljg3O4uUAAAAUklEQVQoU2P4z/CfAQoo/f//P5gY0P/H/v//f0AP/39gMPx/f//L8P//H4gY/f/7/w8M9///gPxbAEn4/x/AwP+f/38ENf//gPz/H4T6/z8w/APOBgB21yIHJcs0JAAAAABJRU5ErkJggg==";
Sidebar2.prototype.triangleDown = new Image();
Sidebar2.prototype.triangleDown.src = !mxClient_default.IS_SVG ? IMAGE_PATH + "/triangle-down.png" : "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAGHRFWHRTb2Z0d2FyZQBQYWludC5ORVQuYy52My41Ljg3O4uUAAAAU0lEQVQoU2P4z/CfAQrA/f//P4iBwP+f/39g+P+f/D8g3wD8/1f+H4T6//+/P2A2+P8/kAyG/v//fwz0/x/I/4f9/x8w/v/9/wckGAQAo3hWoEu2EWwAAAAASUVORK5CYII=";
Sidebar2.prototype.triangleLeft = new Image();
Sidebar2.prototype.triangleLeft.src = !mxClient_default.IS_SVG ? IMAGE_PATH + "/triangle-left.png" : "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAGHRFWHRTb2Z0d2FyZQBQYWludC5ORVQuYy52My41Ljg3O4uUAAAAU0lEQVQoU2P4z/CfAQrg/f//PxCg/v//PxD0/3/+PyDffwDS/0f+H0T9/0f+HwT9/0d+gAyG/v//fwTo/xfh/n8w/P/7/w8EHLgYANckYo212a34AAAAAElFTkSuQmCC";
Sidebar2.prototype.refreshTarget = new Image();
Sidebar2.prototype.refreshTarget.src = !mxClient_default.IS_SVG ? IMAGE_PATH + "/refresh.png" : "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfL3zoAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAGHRFWHRTb2Z0d2FyZQBQYWludC5ORVQuYy52My41Ljg3O4uUAAAAQElEQVQ4T2P4//8/Axww+M9/BgAPOKL9/P/f4T8gU//P+B8M9f/G/1f+H4T6/6P/LwT9/0cAkE14aQC0e0wU3sP5QAAAAABJRU5ErkJggg==";
Sidebar2.prototype.roundDrop = new Image();
Sidebar2.prototype.roundDrop.src = !mxClient_default.IS_SVG ? IMAGE_PATH + "/round-drop.png" : "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAGHRFWHRTb2Z0d2FyZQBQYWludC5ORVQuYy52My41Ljg3O4uUAAAANElEQVQoU2P4z/CfAQb/Gf7/+P8/Ar8GkIv/Gf7/i8E/BP4fCgI/BqL+H1Z+BgD2yIsg/k1s/QAAAABJRU5ErkJggg==";
Sidebar2.prototype.thumbWidth = 42;
Sidebar2.prototype.thumbHeight = 42;
Sidebar2.prototype.minThumbStrokeWidth = 1;
Sidebar2.prototype.thumbAntiAlias = false;
Sidebar2.prototype.thumbPadding = document.documentMode >= 5 ? 2 : 3;
Sidebar2.prototype.thumbBorder = 2;
if (urlParams["sidebar-entries"] != "large") {
  Sidebar2.prototype.thumbPadding = document.documentMode >= 5 ? 0 : 1;
  Sidebar2.prototype.thumbBorder = 1;
  Sidebar2.prototype.thumbWidth = 32;
  Sidebar2.prototype.thumbHeight = 30;
  Sidebar2.prototype.minThumbStrokeWidth = 1.3;
  Sidebar2.prototype.thumbAntiAlias = true;
}
Sidebar2.prototype.sidebarTitleSize = 9;
Sidebar2.prototype.sidebarTitles = false;
Sidebar2.prototype.tooltipTitles = true;
Sidebar2.prototype.maxTooltipWidth = 400;
Sidebar2.prototype.maxTooltipHeight = 400;
Sidebar2.prototype.addStencilsToIndex = true;
Sidebar2.prototype.defaultImageWidth = 80;
Sidebar2.prototype.defaultImageHeight = 80;
Sidebar2.prototype.getTooltipOffset = function() {
  return new mxPoint2(0, 0);
};
Sidebar2.prototype.showTooltip = function(elt, cells, w2, h2, title, showLabel) {
  if (this.enableTooltips && this.showTooltips) {
    if (this.currentElt != elt) {
      if (this.thread != null) {
        window.clearTimeout(this.thread);
        this.thread = null;
      }
      var show3 = bind(this, function() {
        if (this.tooltip == null) {
          this.tooltip = document.createElement("div");
          this.tooltip.className = "geSidebarTooltip";
          this.tooltip.style.zIndex = mxPopupMenu.prototype.zIndex - 1;
          document.body.appendChild(this.tooltip);
          this.graph2 = new Graph2(this.tooltip, null, null, this.editorUi.editor.graph.getStylesheet());
          this.graph2.resetViewOnRootChange = false;
          this.graph2.foldingEnabled = false;
          this.graph2.gridEnabled = false;
          this.graph2.autoScroll = false;
          this.graph2.setTooltips(false);
          this.graph2.setConnectable(false);
          this.graph2.setEnabled(false);
          if (!mxClient_default.IS_SVG) {
            this.graph2.view.canvas.style.position = "relative";
          }
        }
        this.graph2.model.clear();
        this.graph2.view.setTranslate(this.tooltipBorder, this.tooltipBorder);
        if (w2 > this.maxTooltipWidth || h2 > this.maxTooltipHeight) {
          this.graph2.view.scale = Math.round(Math.min(this.maxTooltipWidth / w2, this.maxTooltipHeight / h2) * 100) / 100;
        } else {
          this.graph2.view.scale = 1;
        }
        this.tooltip.style.display = "block";
        this.graph2.labelsVisible = showLabel == null || showLabel;
        var fo = mxClient_default.NO_FO;
        mxClient_default.NO_FO = Editor2.prototype.originalNoForeignObject;
        var temp2 = this.graph2.cloneCells(cells);
        this.editorUi.insertHandler(temp2, null, this.graph2.model);
        this.graph2.addCells(temp2);
        mxClient_default.NO_FO = fo;
        var bounds = this.graph2.getGraphBounds();
        var width = bounds.width + 2 * this.tooltipBorder + 4;
        var height = bounds.height + 2 * this.tooltipBorder;
        if (mxClient_default.IS_QUIRKS) {
          height += 4;
          this.tooltip.style.overflow = "hidden";
        } else {
          this.tooltip.style.overflow = "visible";
        }
        this.tooltip.style.width = width + "px";
        var w22 = width;
        if (this.tooltipTitles && title != null && title.length > 0) {
          if (this.tooltipTitle == null) {
            this.tooltipTitle = document.createElement("div");
            this.tooltipTitle.style.borderTop = "1px solid gray";
            this.tooltipTitle.style.textAlign = "center";
            this.tooltipTitle.style.width = "100%";
            this.tooltipTitle.style.overflow = "hidden";
            this.tooltipTitle.style.position = "absolute";
            this.tooltipTitle.style.paddingTop = "6px";
            this.tooltipTitle.style.bottom = "6px";
            this.tooltip.appendChild(this.tooltipTitle);
          } else {
            this.tooltipTitle.innerHTML = "";
          }
          this.tooltipTitle.style.display = "";
          write(this.tooltipTitle, title);
          w22 = Math.min(this.maxTooltipWidth, Math.max(width, this.tooltipTitle.scrollWidth + 4));
          var ddy = this.tooltipTitle.offsetHeight + 10;
          height += ddy;
          if (mxClient_default.IS_SVG) {
            this.tooltipTitle.style.marginTop = 2 - ddy + "px";
          } else {
            height -= 6;
            this.tooltipTitle.style.top = height - ddy + "px";
          }
        } else if (this.tooltipTitle != null && this.tooltipTitle.parentNode != null) {
          this.tooltipTitle.style.display = "none";
        }
        if (w22 > width) {
          this.tooltip.style.width = w22 + "px";
        }
        this.tooltip.style.height = height + "px";
        var x0 = -Math.round(bounds.x - this.tooltipBorder) + (w22 > width ? (w22 - width) / 2 : 0);
        var y0 = -Math.round(bounds.y - this.tooltipBorder);
        var b = document.body;
        var d = document.documentElement;
        var off = this.getTooltipOffset();
        var bottom = Math.max(b.clientHeight || 0, d.clientHeight);
        var left = this.container.clientWidth + this.editorUi.splitSize + 3 + this.editorUi.container.offsetLeft + off.x;
        var top = Math.min(bottom - height - 20, Math.max(0, this.editorUi.container.offsetTop + this.container.offsetTop + elt.offsetTop - this.container.scrollTop - height / 2 + 16)) + off.y;
        if (mxClient_default.IS_SVG) {
          if (x0 != 0 || y0 != 0) {
            this.graph2.view.canvas.setAttribute("transform", "translate(" + x0 + "," + y0 + ")");
          } else {
            this.graph2.view.canvas.removeAttribute("transform");
          }
        } else {
          this.graph2.view.drawPane.style.left = x0 + "px";
          this.graph2.view.drawPane.style.top = y0 + "px";
        }
        this.tooltip.style.position = "absolute";
        this.tooltip.style.left = left + "px";
        this.tooltip.style.top = top + "px";
      });
      if (this.tooltip != null && this.tooltip.style.display != "none") {
        show3();
      } else {
        this.thread = window.setTimeout(show3, this.tooltipDelay);
      }
      this.currentElt = elt;
    }
  }
};
Sidebar2.prototype.hideTooltip = function() {
  if (this.thread != null) {
    window.clearTimeout(this.thread);
    this.thread = null;
  }
  if (this.tooltip != null) {
    this.tooltip.style.display = "none";
    this.currentElt = null;
  }
};
Sidebar2.prototype.addDataEntry = function(tags, width, height, title, data) {
  return this.addEntry(tags, bind(this, function() {
    return this.createVertexTemplateFromData(data, width, height, title);
  }));
};
Sidebar2.prototype.addEntries = function(images) {
  for (var i = 0; i < images.length; i++) {
    bind(this, function(img) {
      var data = img.data;
      var tags = img.title != null ? img.title : "";
      if (img.tags != null) {
        tags += " " + img.tags;
      }
      if (data != null && tags.length > 0) {
        this.addEntry(tags, bind(this, function() {
          data = this.editorUi.convertDataUri(data);
          var s = "shape=image;verticalLabelPosition=bottom;verticalAlign=top;imageAspect=0;";
          if (img.aspect == "fixed") {
            s += "aspect=fixed;";
          }
          return this.createVertexTemplate(s + "image=" + data, img.w, img.h, "", img.title || "", false, false, true);
        }));
      } else if (img.xml != null && tags.length > 0) {
        this.addEntry(tags, bind(this, function() {
          var cells = this.editorUi.stringToCells(Graph2.decompress(img.xml));
          return this.createVertexTemplateFromCells(cells, img.w, img.h, img.title || "", true, false, true);
        }));
      }
    })(images[i]);
  }
};
Sidebar2.prototype.setCurrentSearchEntryLibrary = function(id, lib) {
  this.currentSearchEntryLibrary = id != null ? { id, lib } : null;
};
Sidebar2.prototype.addEntry = function(tags, fn) {
  if (this.taglist != null && tags != null && tags.length > 0) {
    if (this.currentSearchEntryLibrary != null) {
      fn.parentLibraries = [this.currentSearchEntryLibrary];
    }
    var tmp = tags.toLowerCase().replace(/[\/\,\(\)]/g, " ").split(" ");
    var tagList = [];
    var hash = {};
    for (var i = 0; i < tmp.length; i++) {
      if (hash[tmp[i]] == null) {
        hash[tmp[i]] = true;
        tagList.push(tmp[i]);
      }
      var normalized = tmp[i].replace(/\.*\d*$/, "");
      if (normalized != tmp[i]) {
        if (hash[normalized] == null) {
          hash[normalized] = true;
          tagList.push(normalized);
        }
      }
    }
    for (var i = 0; i < tagList.length; i++) {
      this.addEntryForTag(tagList[i], fn);
    }
  }
  return fn;
};
Sidebar2.prototype.addEntryForTag = function(tag, fn) {
  if (tag != null && tag.length > 1) {
    var entry = this.taglist[tag];
    if (typeof entry !== "object") {
      entry = { entries: [] };
      this.taglist[tag] = entry;
    }
    entry.entries.push(fn);
  }
};
Sidebar2.prototype.searchEntries = function(searchTerms, count, page, success, error2) {
  if (this.taglist != null && searchTerms != null) {
    var tmp = searchTerms.toLowerCase().split(" ");
    var dict = new mxDictionary();
    var max = (page + 1) * count;
    var results = [];
    var index = 0;
    for (var i = 0; i < tmp.length; i++) {
      if (tmp[i].length > 0) {
        var entry = this.taglist[tmp[i]];
        var tmpDict = new mxDictionary();
        if (entry != null) {
          var arr = entry.entries;
          results = [];
          for (var j = 0; j < arr.length; j++) {
            var entry = arr[j];
            if (index == 0 == (dict.get(entry) == null)) {
              tmpDict.put(entry, entry);
              results.push(entry);
              if (i == tmp.length - 1 && results.length == max) {
                success(results.slice(page * count, max), max, true, tmp);
                return;
              }
            }
          }
        } else {
          results = [];
        }
        dict = tmpDict;
        index++;
      }
    }
    var len = results.length;
    success(results.slice(page * count, (page + 1) * count), len, false, tmp);
  } else {
    success([], null, null, tmp);
  }
};
Sidebar2.prototype.filterTags = function(tags) {
  if (tags != null) {
    var arr = tags.split(" ");
    var result2 = [];
    var hash = {};
    for (var i = 0; i < arr.length; i++) {
      if (hash[arr[i]] == null) {
        hash[arr[i]] = "1";
        result2.push(arr[i]);
      }
    }
    return result2.join(" ");
  }
  return null;
};
Sidebar2.prototype.cloneCell = function(cell2, value) {
  var clone3 = cell2.clone();
  if (value != null) {
    clone3.value = value;
  }
  return clone3;
};
Sidebar2.prototype.showPopupMenuForEntry = function(elt, libs, evt) {
};
Sidebar2.prototype.addSearchPalette = function(expand) {
  var elt = document.createElement("div");
  elt.style.visibility = "hidden";
  this.container.appendChild(elt);
  var div = document.createElement("div");
  div.className = "geSidebar";
  div.style.boxSizing = "border-box";
  div.style.overflow = "hidden";
  div.style.width = "100%";
  div.style.padding = "8px";
  div.style.paddingTop = "14px";
  div.style.paddingBottom = "0px";
  if (!expand) {
    div.style.display = "none";
  }
  var inner = document.createElement("div");
  inner.style.whiteSpace = "nowrap";
  inner.style.textOverflow = "clip";
  inner.style.paddingBottom = "8px";
  inner.style.cursor = "default";
  var input = document.createElement("input");
  input.setAttribute("placeholder", mxResources2.get("searchShapes"));
  input.setAttribute("type", "text");
  input.style.fontSize = "12px";
  input.style.overflow = "hidden";
  input.style.boxSizing = "border-box";
  input.style.border = "solid 1px #d5d5d5";
  input.style.borderRadius = "4px";
  input.style.width = "100%";
  input.style.outline = "none";
  input.style.padding = "6px";
  input.style.paddingRight = "20px";
  inner.appendChild(input);
  var cross = document.createElement("img");
  cross.setAttribute("src", Sidebar2.prototype.searchImage);
  cross.setAttribute("title", mxResources2.get("search"));
  cross.style.position = "relative";
  cross.style.left = "-18px";
  if (mxClient_default.IS_QUIRKS) {
    input.style.height = "28px";
    cross.style.top = "-4px";
  } else {
    cross.style.top = "1px";
  }
  cross.style.background = "url('" + this.editorUi.editor.transparentImage + "')";
  var find;
  inner.appendChild(cross);
  div.appendChild(inner);
  var center = document.createElement("center");
  var button2 = button(mxResources2.get("moreResults"), function() {
    find();
  });
  button2.style.display = "none";
  button2.style.lineHeight = "normal";
  button2.style.fontSize = "12px";
  button2.style.padding = "6px 12px 6px 12px";
  button2.style.marginTop = "4px";
  button2.style.marginBottom = "8px";
  center.style.paddingTop = "4px";
  center.style.paddingBottom = "4px";
  center.appendChild(button2);
  div.appendChild(center);
  var searchTerm = "";
  var active = false;
  var complete = false;
  var page = 0;
  var hash = new Object();
  var count = 12;
  var clearDiv = bind(this, function() {
    active = false;
    this.currentSearch = null;
    var child = div.firstChild;
    while (child != null) {
      var next = child.nextSibling;
      if (child != inner && child != center) {
        child.parentNode.removeChild(child);
      }
      child = next;
    }
  });
  mxEvent2.addListener(cross, "click", function() {
    if (cross.getAttribute("src") == Dialog.prototype.closeImage) {
      cross.setAttribute("src", Sidebar2.prototype.searchImage);
      cross.setAttribute("title", mxResources2.get("search"));
      button2.style.display = "none";
      input.value = "";
      searchTerm = "";
      clearDiv();
    }
    input.focus();
  });
  find = bind(this, function() {
    count = 4 * Math.max(1, Math.floor(this.container.clientWidth / (this.thumbWidth + 10)));
    this.hideTooltip();
    if (input.value != "") {
      if (center.parentNode != null) {
        if (searchTerm != input.value) {
          clearDiv();
          searchTerm = input.value;
          hash = new Object();
          complete = false;
          page = 0;
        }
        if (!active && !complete) {
          button2.setAttribute("disabled", "true");
          button2.style.display = "";
          button2.style.cursor = "wait";
          button2.innerHTML = mxResources2.get("loading") + "...";
          active = true;
          var current2 = new Object();
          this.currentSearch = current2;
          this.searchEntries(searchTerm, count, page, bind(this, function(results, len, more, terms) {
            if (this.currentSearch == current2) {
              results = results != null ? results : [];
              active = false;
              page++;
              this.insertSearchHint(div, searchTerm, count, page, results, len, more, terms);
              if (results.length == 0 && page == 1) {
                searchTerm = "";
              }
              if (center.parentNode != null) {
                center.parentNode.removeChild(center);
              }
              for (var i = 0; i < results.length; i++) {
                bind(this, function(result2) {
                  try {
                    var elt2 = result2();
                    if (hash[elt2.innerHTML] == null) {
                      hash[elt2.innerHTML] = result2.parentLibraries != null ? result2.parentLibraries.slice() : [];
                      div.appendChild(elt2);
                    } else if (result2.parentLibraries != null) {
                      hash[elt2.innerHTML] = hash[elt2.innerHTML].concat(result2.parentLibraries);
                    }
                    mxEvent2.addGestureListeners(elt2, null, null, bind(this, function(evt) {
                      var libs = hash[elt2.innerHTML];
                      if (mxEvent2.isPopupTrigger(evt)) {
                        this.showPopupMenuForEntry(elt2, libs, evt);
                      }
                    }));
                    mxEvent2.disableContextMenu(elt2);
                  } catch (e) {
                  }
                })(results[i]);
              }
              if (more) {
                button2.removeAttribute("disabled");
                button2.innerHTML = mxResources2.get("moreResults");
              } else {
                button2.innerHTML = mxResources2.get("reset");
                button2.style.display = "none";
                complete = true;
              }
              button2.style.cursor = "";
              div.appendChild(center);
            }
          }), bind(this, function() {
            button2.style.cursor = "";
          }));
        }
      }
    } else {
      clearDiv();
      input.value = "";
      searchTerm = "";
      hash = new Object();
      button2.style.display = "none";
      complete = false;
      input.focus();
    }
  });
  mxEvent2.addListener(input, "keydown", bind(this, function(evt) {
    if (evt.keyCode == 13) {
      find();
      mxEvent2.consume(evt);
    }
  }));
  mxEvent2.addListener(input, "keyup", bind(this, function(evt) {
    if (input.value == "") {
      cross.setAttribute("src", Sidebar2.prototype.searchImage);
      cross.setAttribute("title", mxResources2.get("search"));
    } else {
      cross.setAttribute("src", Dialog.prototype.closeImage);
      cross.setAttribute("title", mxResources2.get("reset"));
    }
    if (input.value == "") {
      complete = true;
      button2.style.display = "none";
    } else if (input.value != searchTerm) {
      button2.style.display = "none";
      complete = false;
    } else if (!active) {
      if (complete) {
        button2.style.display = "none";
      } else {
        button2.style.display = "";
      }
    }
  }));
  mxEvent2.addListener(input, "mousedown", function(evt) {
    if (evt.stopPropagation) {
      evt.stopPropagation();
    }
    evt.cancelBubble = true;
  });
  mxEvent2.addListener(input, "selectstart", function(evt) {
    if (evt.stopPropagation) {
      evt.stopPropagation();
    }
    evt.cancelBubble = true;
  });
  var outer = document.createElement("div");
  outer.appendChild(div);
  this.container.appendChild(outer);
  this.palettes["search"] = [elt, outer];
};
Sidebar2.prototype.insertSearchHint = function(div, searchTerm, count, page, results, len, more, terms) {
  if (results.length == 0 && page == 1) {
    var err = document.createElement("div");
    err.className = "geTitle";
    err.style.cssText = "background-color:transparent;border-color:transparent;color:gray;padding:6px 0px 0px 0px !important;margin:4px 8px 4px 8px;text-align:center;cursor:default !important";
    write(err, mxResources2.get("noResultsFor", [searchTerm]));
    div.appendChild(err);
  }
};
Sidebar2.prototype.addGeneralPalette = function(expand) {
  var lineTags = "line lines connector connectors connection connections arrow arrows ";
  this.setCurrentSearchEntryLibrary("general", "general");
  var fns = [
    this.createVertexTemplateEntry("ellipse;whiteSpace=wrap;html=1;align=center;fillColor=#FFFFB7;verticalAlign=middle;fontSize=12;fontColor=#000000;fontStyle=1;", 120, 80, "key-123456", "<asset>", null, null, "<asset>"),
    this.createVertexTemplateEntry("shape=hexagon;whiteSpace=wrap;html=1;fillColor=#BDDFDF;align=center;verticalAlign=middle;fontSize=12;fontColor=#000000;fontStyle=1;", 120, 80, "key-123456", "<asset>", true, true, "hexagon preparation"),
    this.createVertexTemplateEntry("shape=cylinder3;whiteSpace=wrap;fillColor=#C5C5C5;html=1;align=center;verticalAlign=middle;spacingTop=10;fontSize=12;fontColor=#000000;fontStyle=1;", 100, 120, "key-123456", "<asset>", true, true, "cylinder data database")
  ];
  this.addPaletteFunctions("general", "Technical Asset", expand != null ? expand : true, fns);
  this.setCurrentSearchEntryLibrary();
};
Sidebar2.prototype.addMiscPalette = function(expand) {
  var sb = this;
  var lineTags = "line lines connector connectors connection connections arrow arrows ";
  this.setCurrentSearchEntryLibrary("general", "misc");
  var fns = [
    this.createVertexTemplateEntry("text;strokeColor=none;fillColor=none;html=1;fontSize=24;fontStyle=1;verticalAlign=middle;align=center;", 100, 40, "Title", "Title", null, null, "text heading title"),
    this.createVertexTemplateEntry("text;strokeColor=none;fillColor=none;html=1;whiteSpace=wrap;verticalAlign=middle;overflow=hidden;", 100, 80, "<ul><li>Value 1</li><li>Value 2</li><li>Value 3</li></ul>", "Unordered List"),
    this.createVertexTemplateEntry("text;strokeColor=none;fillColor=none;html=1;whiteSpace=wrap;verticalAlign=middle;overflow=hidden;", 100, 80, "<ol><li>Value 1</li><li>Value 2</li><li>Value 3</li></ol>", "Ordered List"),
    this.addDataEntry("table", 180, 120, "Table 1", "7ZjJTsMwEIafJleUhZZybVgucAFewDTT2pLjiewpaXl6xolLVQFqWBJArZRKns2xv5H7y4myvFxdW1HJWyxAR9lllOUWkdpRucpB6yiNVRFlF1GaxvyL0qsPokkTjSthwVCXgrQteBJ6Ca2ndTha6+BwUlR+SOLRu6aSSl7mRcLDWiqC+0rMfLzmTbDPkbB0r569K2Z7hoaEMmBDzQy1FpVTzWRthlS6uBFrXNLmNRtrGpYHlmD14RYbV9jfNWAJZNecUquCZMiYtBhiCWohN2WBTSxc61i81m6J8SBAex9g1h0gL5mU0HcwI2EWXVi+ZVVYrB6EXQAFR4XKENjLJ6bhgm+utM5Ro0du0PgXEVYhqGG+qX1EIiyDYQOY10kbKKMpP4wpj09G0Yh3k7OdbG1+fLqlHI0jy432c4BwVIPr3MD0aw08/YH+nfbbP2N89rZ/324NMsq5xppNqYoCTFfG2V7G454Qjw4c8WoX7wDEx0fiO3/wAyA/O+pAbzqw3m3TELIwOZQTdPZrsnB+4IiHl4UkPiIfWheS5CgMfQvDZEBhSD5xY/7fZyjZf63u7dD0fKv++5B/QRwO5ia8h3mP6sDm9tNeE9v58vcC"),
    this.addDataEntry("table", 180, 120, "Table 2", "7ZjBbqMwEIafhmuFISTptbTbS/eyrfbuBie2ZDzITEqyT79jMMlGWVTUBlqVSkTyjGeM+SbDLxPEab67t7yQPyETOojvgji1ANiM8l0qtA6iUGVBfBtEUUi/IPrRMcvq2bDgVhjskxA1CS9cb0XjaRwl7rV3lJIXboj82bluJOa0zVtGw0oqFI8FX7n5ih6CfCVyi4/qj3OFZK/AIFdGWJ+zAq15Uap6sSZCKp098D1ssb1Na7nobW4eKL/00Raqf02/f2FR7DoZ1C4P4F5ALtDuKaRSGUofsWw4hVKojWzTPLyQl41jc8g9IqWBp/p/wnF/wrRlVFz/EivkZtMH9jnMzELxxO1GoHcUoAwKe/dCNFpoa6V1ChpcTQwYdyOEwk9qsW5znwER8ha8B3NYtIaS3NBFmNLwKgkSepqUbHa06XLhFlMwJVr6J7g1BC+xEiX2LWD0tgLOLlC/2Vn9ftfDKGQXLaQxLvpYyHfXCIjpWkNFplRZJkxf2PGrsOcDsU46WV+2aT49690p5xHQzzvRx5NEf3j3j8B+8S0Rg0nE/rRMYyjGsrOVZl+0lRYfphjXnayTabEeXzFY2Ml+Pkn2Y0oGY9+aMbRmLEfUDHZ+EG+bafFFm4m9fiofrHvOD+Ut7eXEaH+AbnSfqK+nCX9A4SDz+DGxnjv51vgX"),
    this.addDataEntry("table title", 180, 120, "Table with Title 1", "7ZhRb6MwDMc/Da8nAmPdvZbu9nJ7WfcFMnAhUohR4o12n34OpKumrmqlDXa6VqJS/Lcdkp8bWSFK82Z9Z2Vb32MJOkpvozS3iDSMmnUOWkdJrMooXURJEvMvSv4c8IreG7fSgqFTEpIh4UXqZxiUR/mkYVAdbXRQXS1bP6Tem85ranitC8HDrlYEy1YW3t/xTlhzJC0t1auX0piFAg1JZcCGpAK1lq1T/WyLPqJWuvwrN/hM2/dsrfmKs5dhMT5balUZHhe8Sz/lPOwCLMH6IIleChjuABsgu+GQTpVUh4ibgVZcg6rqbVoWROkGoXrP3YHlQWD7Oed0j/NBxLxkUlI/QEHSVKfQ3odZWmwfpa2AgtCi8qhuX5iGC9pKaZ2jRl8Tg8a/iLANTg2rbe4TEmETDBvAvE/aQ8nm/DCmPP6VRRnvJmdb7Gx+fLilHI0jy/8EPwdIRx04OrWAyecF3ATEoUzH6nn1DeW8GrecxvjoXTm/XClksiuNHZu1KkswpyJPj56Z65EQZ2eOeP0R7wTEry/E+4RkOuSzS1sYuy3MJmwLN+dygmY/1hZ+nzni6duCiC/Ip+4LQlwaw9iNQYgJO4PYv2j/p4dIHL9mj3ZqRr5l//uQf6A7nM1V+AjzEdsDm7svgr3vwwfDNw=="),
    this.addDataEntry("table title", 180, 150, "Table with Title 2", "7Zhdb5swFIZ/DbcTHyVrbiFdb7Kbptq9Cw5YMj7IPi1kv37HYJK1FDWbQoOmSUSyz4dt3id+L/CitGrvNavL75Bz6UV3XpRqAOxHVZtyKb3QF7kXbbww9Onnhd8mskGX9WumucJzGsK+4YXJZ95HHtmT5H3U4EG6qClZbYfYZaOkxIrOuglo2JQC+a5mmc039CYUM8g07sRPG4p8CmSgkAnFtWvKQEpWG9GttukqSiHzLTvAMw77DLNkL1qeP0BjXLeGZkuLGde6p8V37qw2zaQoFI0zEsHumLiX5Bp5OylUF3Iq3XOoOOoDlTQix9JV3PZi+iUXRTm0xS7ITB8ojr0n3WngpH8fQzTCMEmAjoyCyQeeIVPFOTDGWuca6kemC44uUIOwUt29kBpHVYWUKUiwyBQouxFC7ZKS74feJ0CEaiDjhDku2okSJ/SQTKn/JfZiepuU5sFpTo8t15iCMqjpj2LX4Mxgww2eCzB8H+DBSewwfcQzugDOmxHO4KI8lbLVJ55/jMp/gwpI2r2EhqalyHOuztU8+vDS3MykcTzS+Ec3DP2Faz24U1+bGNpQqGLbd65mgNG+BvH7BZgLzupf8LO34JblZ6tP9LOvI5yX5bkcP1tdzc9uJ/1s4VrP52cTMK7gZ+v/fja3n60/0c8Cf8QzWvYl++s7tL6aoQXBpKMtXOz5HG2CxvyORtPTR4Uu9+qbwy8="),
    this.addDataEntry("crossfunctional cross-functional cross functional flowchart swimlane table", 400, 400, "Cross-Functional Flowchart", "7ZhRb5swEMc/DY+bMCRt97jQpi+tVC2fwINbbMnYyD4C6aefjaHpBrTRlNCoTALJPp9t+P25O5kgTvL6XtOCPaoMRBDfBXGilULfyusEhAiikGdBfBtEUWjvIFqPjJJmNCyoBonHTIj8hB0VJXiL3dyYL+tSpsiVpM55LVSVMqrROxvci9bZMFq4JtKfzrRKGRfZA92rEjtr11tpVT1wCcYOhM5ViTKXry0G7RYb/uwWXDgDw9wCuSW2WTGOsClo6gYri8uvIGhheLN1s4KGtNSG7+AHGL+Os0JdUJm1nUJxiaDvdhZQt/EvJXHTvpTbjAq+lbadgnO1hhYSaIR6FHRjainfg8oB9d66VDxD5j0WoRcjZMC3DP8yUuMN25e5B91so5VuWMa4J+P3FJW2JtLXrOK5oNLJxZTmz/blqXhNp3mO5cpe9smS8OsyWNp5ie2TQ99ezl1joqRBTXmDAajBCgxejprHKBcNK7fvBPIz3hOSRCcQctET8olRA+8JmSopIW2j8GOD6Sji8TDxepT4C9yTE1+OEo/mQ5xcTYn8ahR5PB/k0c2UyK9HC8SbX/mnLBAnqAlD8XK+onDTE+/fw+TiQF9fTin4Nl/O0xYAEs6X9LR5n5Ae6S7xv1lr/yf+4cQ/pN75Ej/pH88/UZyQkRPzR6R+0j9Bz4f0xMm/f8adD+qzZn/bPfw5bMb++LH4Gw=="),
    this.createVertexTemplateEntry("text;html=1;strokeColor=#c0c0c0;fillColor=#ffffff;overflow=fill;rounded=0;", 280, 160, '<table border="1" width="100%" height="100%" cellpadding="4" style="width:100%;height:100%;border-collapse:collapse;"><tr style="background-color:#A7C942;color:#ffffff;border:1px solid #98bf21;"><th align="left">Title 1</th><th align="left">Title 2</th><th align="left">Title 3</th></tr><tr style="border:1px solid #98bf21;"><td>Value 1</td><td>Value 2</td><td>Value 3</td></tr><tr style="background-color:#EAF2D3;border:1px solid #98bf21;"><td>Value 4</td><td>Value 5</td><td>Value 6</td></tr><tr style="border:1px solid #98bf21;"><td>Value 7</td><td>Value 8</td><td>Value 9</td></tr><tr style="background-color:#EAF2D3;border:1px solid #98bf21;"><td>Value 10</td><td>Value 11</td><td>Value 12</td></tr></table>', "HTML Table 1"),
    this.createVertexTemplateEntry("text;html=1;strokeColor=#c0c0c0;fillColor=none;overflow=fill;", 180, 140, '<table border="0" width="100%" height="100%" style="width:100%;height:100%;border-collapse:collapse;"><tr><td align="center">Value 1</td><td align="center">Value 2</td><td align="center">Value 3</td></tr><tr><td align="center">Value 4</td><td align="center">Value 5</td><td align="center">Value 6</td></tr><tr><td align="center">Value 7</td><td align="center">Value 8</td><td align="center">Value 9</td></tr></table>', "HTML Table 2"),
    this.createVertexTemplateEntry("text;html=1;strokeColor=none;fillColor=none;overflow=fill;", 180, 140, '<table border="1" width="100%" height="100%" style="width:100%;height:100%;border-collapse:collapse;"><tr><td align="center">Value 1</td><td align="center">Value 2</td><td align="center">Value 3</td></tr><tr><td align="center">Value 4</td><td align="center">Value 5</td><td align="center">Value 6</td></tr><tr><td align="center">Value 7</td><td align="center">Value 8</td><td align="center">Value 9</td></tr></table>', "HTML Table 3"),
    this.createVertexTemplateEntry("text;html=1;strokeColor=none;fillColor=none;overflow=fill;", 160, 140, '<table border="1" width="100%" height="100%" cellpadding="4" style="width:100%;height:100%;border-collapse:collapse;"><tr><th align="center"><b>Title</b></th></tr><tr><td align="center">Section 1.1\nSection 1.2\nSection 1.3</td></tr><tr><td align="center">Section 2.1\nSection 2.2\nSection 2.3</td></tr></table>', "HTML Table 4"),
    this.addEntry("link hyperlink", bind(this, function() {
      var cell2 = new mxCell("Link", new mxGeometry(0, 0, 60, 40), "text;html=1;strokeColor=none;fillColor=none;whiteSpace=wrap;align=center;verticalAlign=middle;fontColor=#0000EE;fontStyle=4;");
      cell2.vertex = true;
      this.graph.setLinkForCell(cell2, "https://www.draw.io");
      return this.createVertexTemplateFromCells([cell2], cell2.geometry.width, cell2.geometry.height, "Link");
    })),
    this.addEntry("timestamp date time text label", bind(this, function() {
      var cell2 = new mxCell("%date{ddd mmm dd yyyy HH:MM:ss}%", new mxGeometry(0, 0, 160, 20), "text;html=1;strokeColor=none;fillColor=none;align=center;verticalAlign=middle;whiteSpace=wrap;overflow=hidden;");
      cell2.vertex = true;
      this.graph.setAttributeForCell(cell2, "placeholders", "1");
      return this.createVertexTemplateFromCells([cell2], cell2.geometry.width, cell2.geometry.height, "Timestamp");
    })),
    this.addEntry("variable placeholder metadata hello world text label", bind(this, function() {
      var cell2 = new mxCell("%name% Text", new mxGeometry(0, 0, 80, 20), "text;html=1;strokeColor=none;fillColor=none;align=center;verticalAlign=middle;whiteSpace=wrap;overflow=hidden;");
      cell2.vertex = true;
      this.graph.setAttributeForCell(cell2, "placeholders", "1");
      this.graph.setAttributeForCell(cell2, "name", "Variable");
      return this.createVertexTemplateFromCells([cell2], cell2.geometry.width, cell2.geometry.height, "Variable");
    })),
    this.createVertexTemplateEntry("shape=ext;double=1;rounded=0;whiteSpace=wrap;html=1;", 120, 80, "", "Double Rectangle", null, null, "rect rectangle box double"),
    this.createVertexTemplateEntry("shape=ext;double=1;rounded=1;whiteSpace=wrap;html=1;", 120, 80, "", "Double Rounded Rectangle", null, null, "rounded rect rectangle box double"),
    this.createVertexTemplateEntry("ellipse;shape=doubleEllipse;whiteSpace=wrap;html=1;", 100, 60, "", "Double Ellipse", null, null, "oval ellipse start end state double"),
    this.createVertexTemplateEntry("shape=ext;double=1;whiteSpace=wrap;html=1;aspect=fixed;", 80, 80, "", "Double Square", null, null, "double square"),
    this.createVertexTemplateEntry("ellipse;shape=doubleEllipse;whiteSpace=wrap;html=1;aspect=fixed;", 80, 80, "", "Double Circle", null, null, "double circle"),
    this.createVertexTemplateEntry("rounded=1;whiteSpace=wrap;html=1;strokeWidth=2;fillWeight=4;hachureGap=8;hachureAngle=45;fillColor=#1ba1e2;sketch=1;", 120, 60, "", "Rectangle Sketch", true, null, "rectangle rect box text sketch comic retro"),
    this.createVertexTemplateEntry("ellipse;whiteSpace=wrap;html=1;strokeWidth=2;fillWeight=2;hachureGap=8;fillColor=#990000;fillStyle=dots;sketch=1;", 120, 60, "", "Ellipse Sketch", true, null, "ellipse oval sketch comic retro"),
    this.createVertexTemplateEntry("rhombus;whiteSpace=wrap;html=1;strokeWidth=2;fillWeight=-1;hachureGap=8;fillStyle=cross-hatch;fillColor=#006600;sketch=1;", 120, 60, "", "Diamond Sketch", true, null, "diamond sketch comic retro"),
    this.createVertexTemplateEntry("html=1;whiteSpace=wrap;shape=isoCube2;backgroundOutline=1;isoAngle=15;", 90, 100, "", "Isometric Cube", true, null, "cube box iso isometric"),
    this.createVertexTemplateEntry("html=1;whiteSpace=wrap;aspect=fixed;shape=isoRectangle;", 150, 90, "", "Isometric Square", true, null, "rectangle rect box iso isometric"),
    this.createEdgeTemplateEntry("edgeStyle=isometricEdgeStyle;endArrow=none;html=1;", 50, 100, "", "Isometric Edge 1"),
    this.createEdgeTemplateEntry("edgeStyle=isometricEdgeStyle;endArrow=none;html=1;elbow=vertical;", 50, 100, "", "Isometric Edge 2"),
    this.createVertexTemplateEntry("shape=curlyBracket;whiteSpace=wrap;html=1;rounded=1;", 20, 120, "", "Curly Bracket"),
    this.createVertexTemplateEntry("line;strokeWidth=2;html=1;", 160, 10, "", "Horizontal Line"),
    this.createVertexTemplateEntry("line;strokeWidth=2;direction=south;html=1;", 10, 160, "", "Vertical Line"),
    this.createVertexTemplateEntry("line;strokeWidth=4;html=1;perimeter=backbonePerimeter;points=[];outlineConnect=0;", 160, 10, "", "Horizontal Backbone", false, null, "backbone bus network"),
    this.createVertexTemplateEntry("line;strokeWidth=4;direction=south;html=1;perimeter=backbonePerimeter;points=[];outlineConnect=0;", 10, 160, "", "Vertical Backbone", false, null, "backbone bus network"),
    this.createVertexTemplateEntry("shape=crossbar;whiteSpace=wrap;html=1;rounded=1;", 120, 20, "", "Crossbar", false, null, "crossbar distance measure dimension unit"),
    this.createVertexTemplateEntry("shape=image;html=1;verticalLabelPosition=bottom;verticalAlign=top;imageAspect=1;aspect=fixed;image=" + this.gearImage, 52, 61, "", "Image (Fixed Aspect)", false, null, "fixed image icon symbol"),
    this.createVertexTemplateEntry("shape=image;html=1;verticalLabelPosition=bottom;verticalAlign=top;imageAspect=0;image=" + this.gearImage, 50, 60, "", "Image (Variable Aspect)", false, null, "strechted image icon symbol"),
    this.createVertexTemplateEntry("icon;html=1;image=" + this.gearImage, 60, 60, "Icon", "Icon", false, null, "icon image symbol"),
    this.createVertexTemplateEntry("label;whiteSpace=wrap;html=1;image=" + this.gearImage, 140, 60, "Label", "Label 1", null, null, "label image icon symbol"),
    this.createVertexTemplateEntry("label;whiteSpace=wrap;html=1;align=center;verticalAlign=bottom;spacingLeft=0;spacingBottom=4;imageAlign=center;imageVerticalAlign=top;image=" + this.gearImage, 120, 80, "Label", "Label 2", null, null, "label image icon symbol"),
    this.addEntry("shape group container", function() {
      var cell2 = new mxCell("Label", new mxGeometry(0, 0, 160, 70), "html=1;whiteSpace=wrap;container=1;recursiveResize=0;collapsible=0;");
      cell2.vertex = true;
      var symbol = new mxCell("", new mxGeometry(20, 20, 20, 30), "triangle;html=1;whiteSpace=wrap;");
      symbol.vertex = true;
      cell2.insert(symbol);
      return sb.createVertexTemplateFromCells([cell2], cell2.geometry.width, cell2.geometry.height, "Shape Group");
    }),
    this.createVertexTemplateEntry("shape=partialRectangle;whiteSpace=wrap;html=1;left=0;right=0;fillColor=none;", 120, 60, "", "Partial Rectangle"),
    this.createVertexTemplateEntry("shape=partialRectangle;whiteSpace=wrap;html=1;bottom=1;right=1;left=1;top=0;fillColor=none;routingCenterX=-0.5;", 120, 60, "", "Partial Rectangle"),
    this.createEdgeTemplateEntry("edgeStyle=segmentEdgeStyle;endArrow=classic;html=1;", 50, 50, "", "Manual Line", null, lineTags + "manual"),
    this.createEdgeTemplateEntry("shape=filledEdge;rounded=0;fixDash=1;endArrow=none;strokeWidth=10;fillColor=#ffffff;edgeStyle=orthogonalEdgeStyle;", 60, 40, "", "Filled Edge"),
    this.createEdgeTemplateEntry("edgeStyle=elbowEdgeStyle;elbow=horizontal;endArrow=classic;html=1;", 50, 50, "", "Horizontal Elbow", null, lineTags + "elbow horizontal"),
    this.createEdgeTemplateEntry("edgeStyle=elbowEdgeStyle;elbow=vertical;endArrow=classic;html=1;", 50, 50, "", "Vertical Elbow", null, lineTags + "elbow vertical")
  ];
  this.addPaletteFunctions("misc", mxResources2.get("misc"), expand != null ? expand : true, fns);
  this.setCurrentSearchEntryLibrary();
};
Sidebar2.prototype.addAdvancedPalette = function(expand) {
  this.setCurrentSearchEntryLibrary("general", "advanced");
  this.addPaletteFunctions("advanced", mxResources2.get("advanced"), expand != null ? expand : false, this.createAdvancedShapes());
  this.setCurrentSearchEntryLibrary();
};
Sidebar2.prototype.addBasicPalette = function(dir) {
  this.setCurrentSearchEntryLibrary("basic");
  this.setCurrentSearchEntryLibrary();
};
Sidebar2.prototype.createAdvancedShapes = function() {
  var sb = this;
  var field = new mxCell("List Item", new mxGeometry(0, 0, 60, 26), "text;strokeColor=none;fillColor=none;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;");
  field.vertex = true;
  return [
    this.createVertexTemplateEntry("shape=tapeData;whiteSpace=wrap;html=1;perimeter=ellipsePerimeter;", 80, 80, "", "Tape Data"),
    this.createVertexTemplateEntry("shape=manualInput;whiteSpace=wrap;html=1;", 80, 80, "", "Manual Input"),
    this.createVertexTemplateEntry("shape=loopLimit;whiteSpace=wrap;html=1;", 100, 80, "", "Loop Limit"),
    this.createVertexTemplateEntry("shape=offPageConnector;whiteSpace=wrap;html=1;", 80, 80, "", "Off Page Connector"),
    this.createVertexTemplateEntry("shape=delay;whiteSpace=wrap;html=1;", 80, 40, "", "Delay"),
    this.createVertexTemplateEntry("shape=display;whiteSpace=wrap;html=1;", 80, 40, "", "Display"),
    this.createVertexTemplateEntry("shape=singleArrow;direction=west;whiteSpace=wrap;html=1;", 100, 60, "", "Arrow Left"),
    this.createVertexTemplateEntry("shape=singleArrow;whiteSpace=wrap;html=1;", 100, 60, "", "Arrow Right"),
    this.createVertexTemplateEntry("shape=singleArrow;direction=north;whiteSpace=wrap;html=1;", 60, 100, "", "Arrow Up"),
    this.createVertexTemplateEntry("shape=singleArrow;direction=south;whiteSpace=wrap;html=1;", 60, 100, "", "Arrow Down"),
    this.createVertexTemplateEntry("shape=doubleArrow;whiteSpace=wrap;html=1;", 100, 60, "", "Double Arrow"),
    this.createVertexTemplateEntry("shape=doubleArrow;direction=south;whiteSpace=wrap;html=1;", 60, 100, "", "Double Arrow Vertical", null, null, "double arrow"),
    this.createVertexTemplateEntry("shape=actor;whiteSpace=wrap;html=1;", 40, 60, "", "User", null, null, "user person human"),
    this.createVertexTemplateEntry("shape=cross;whiteSpace=wrap;html=1;", 80, 80, "", "Cross"),
    this.createVertexTemplateEntry("shape=corner;whiteSpace=wrap;html=1;", 80, 80, "", "Corner"),
    this.createVertexTemplateEntry("shape=tee;whiteSpace=wrap;html=1;", 80, 80, "", "Tee"),
    this.createVertexTemplateEntry("shape=datastore;whiteSpace=wrap;html=1;", 60, 60, "", "Data Store", null, null, "data store cylinder database"),
    this.createVertexTemplateEntry("shape=orEllipse;perimeter=ellipsePerimeter;whiteSpace=wrap;html=1;backgroundOutline=1;", 80, 80, "", "Or", null, null, "or circle oval ellipse"),
    this.createVertexTemplateEntry("shape=sumEllipse;perimeter=ellipsePerimeter;whiteSpace=wrap;html=1;backgroundOutline=1;", 80, 80, "", "Sum", null, null, "sum circle oval ellipse"),
    this.createVertexTemplateEntry("shape=lineEllipse;perimeter=ellipsePerimeter;whiteSpace=wrap;html=1;backgroundOutline=1;", 80, 80, "", "Ellipse with horizontal divider", null, null, "circle oval ellipse"),
    this.createVertexTemplateEntry("shape=lineEllipse;line=vertical;perimeter=ellipsePerimeter;whiteSpace=wrap;html=1;backgroundOutline=1;", 80, 80, "", "Ellipse with vertical divider", null, null, "circle oval ellipse"),
    this.createVertexTemplateEntry("shape=sortShape;perimeter=rhombusPerimeter;whiteSpace=wrap;html=1;", 80, 80, "", "Sort", null, null, "sort"),
    this.createVertexTemplateEntry("shape=collate;whiteSpace=wrap;html=1;", 80, 80, "", "Collate", null, null, "collate"),
    this.createVertexTemplateEntry("shape=switch;whiteSpace=wrap;html=1;", 60, 60, "", "Switch", null, null, "switch router"),
    this.addEntry("process bar", function() {
      return sb.createVertexTemplateFromData("zZXRaoMwFIafJpcDjbNrb2233rRQ8AkyPdPQaCRJV+3T7yTG2rUVBoOtgpDzn/xJzncCIdGyateKNeVW5iBI9EqipZLS9KOqXYIQhAY8J9GKUBrgT+jbRDZ02aBhCmrzEwPtDZ9MHKBXdkpmoDWKCVN9VptO+Kw+8kqwGqMkK7nIN6yTB7uTNizbD1FSSsVPsjYMC1qFKHxwIZZSSIVxLZ1/nJNar5+oQPMT7IYCrqUta1ENzuqGaeOFTArBGs3f3Vmtoo2Se7ja1h00kSoHK4bBIKUNy3hdoPYU0mF91i9mT8EEL2ocZ3gKa00ayWujLZY4IfHKFonVDLsRGgXuQ90zBmWgneyTk3yT1iArMKrDKUeem9L3ajHrbSXwohxsQd/ggOleKM7ese048J2/fwuim1uQGmhQCW8vQMkacP3GCQgBFMftHEsr7cYYe95CnmKTPMFbYD8CQ++DGQy+/M5X4ku5wHYmdIktfvk9tecpavThqS3m/0YtnqIWPTy1cD77K2wYjo+Ay317I74A", 296, 100, "Process Bar");
    }),
    this.createVertexTemplateEntry("swimlane;", 200, 200, "Container", "Container", null, null, "container swimlane lane pool group"),
    this.addEntry("list group erd table", function() {
      var cell2 = new mxCell("List", new mxGeometry(0, 0, 140, 110), "swimlane;fontStyle=0;childLayout=stackLayout;horizontal=1;startSize=26;fillColor=none;horizontalStack=0;resizeParent=1;resizeParentMax=0;resizeLast=0;collapsible=1;marginBottom=0;");
      cell2.vertex = true;
      cell2.insert(sb.cloneCell(field, "Item 1"));
      cell2.insert(sb.cloneCell(field, "Item 2"));
      cell2.insert(sb.cloneCell(field, "Item 3"));
      return sb.createVertexTemplateFromCells([cell2], cell2.geometry.width, cell2.geometry.height, "List");
    }),
    this.addEntry("list item entry value group erd table", function() {
      return sb.createVertexTemplateFromCells([sb.cloneCell(field, "List Item")], field.geometry.width, field.geometry.height, "List Item");
    })
  ];
};
Sidebar2.prototype.addUmlPalette = function(expand) {
  var sb = this;
  var field = new mxCell("+ field: type", new mxGeometry(0, 0, 100, 26), "text;strokeColor=none;fillColor=none;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;");
  field.vertex = true;
  var divider = new mxCell("", new mxGeometry(0, 0, 40, 8), "line;strokeWidth=1;fillColor=none;align=left;verticalAlign=middle;spacingTop=-1;spacingLeft=3;spacingRight=3;rotatable=0;labelPosition=right;points=[];portConstraint=eastwest;");
  divider.vertex = true;
  var dt = "uml static class ";
  this.setCurrentSearchEntryLibrary("uml");
  var fns = [
    this.createVertexTemplateEntry("html=1;", 110, 50, "Object", "Object", null, null, dt + "object instance"),
    this.createVertexTemplateEntry("html=1;", 110, 50, "&laquo;interface&raquo;<br><b>Name</b>", "Interface", null, null, dt + "interface object instance annotated annotation"),
    this.addEntry(dt + "object instance", function() {
      var cell2 = new mxCell("Classname", new mxGeometry(0, 0, 160, 90), "swimlane;fontStyle=1;align=center;verticalAlign=top;childLayout=stackLayout;horizontal=1;startSize=26;horizontalStack=0;resizeParent=1;resizeParentMax=0;resizeLast=0;collapsible=1;marginBottom=0;");
      cell2.vertex = true;
      cell2.insert(field.clone());
      cell2.insert(divider.clone());
      cell2.insert(sb.cloneCell(field, "+ method(type): type"));
      return sb.createVertexTemplateFromCells([cell2], cell2.geometry.width, cell2.geometry.height, "Class");
    }),
    this.addEntry(dt + "section subsection", function() {
      var cell2 = new mxCell("Classname", new mxGeometry(0, 0, 140, 110), "swimlane;fontStyle=0;childLayout=stackLayout;horizontal=1;startSize=26;fillColor=none;horizontalStack=0;resizeParent=1;resizeParentMax=0;resizeLast=0;collapsible=1;marginBottom=0;");
      cell2.vertex = true;
      cell2.insert(field.clone());
      cell2.insert(field.clone());
      cell2.insert(field.clone());
      return sb.createVertexTemplateFromCells([cell2], cell2.geometry.width, cell2.geometry.height, "Class 2");
    }),
    this.addEntry(dt + "item member method function variable field attribute label", function() {
      return sb.createVertexTemplateFromCells([sb.cloneCell(field, "+ item: attribute")], field.geometry.width, field.geometry.height, "Item 1");
    }),
    this.addEntry(dt + "item member method function variable field attribute label", function() {
      var cell2 = new mxCell("item: attribute", new mxGeometry(0, 0, 120, field.geometry.height), "label;fontStyle=0;strokeColor=none;fillColor=none;align=left;verticalAlign=top;overflow=hidden;spacingLeft=28;spacingRight=4;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;imageWidth=16;imageHeight=16;image=" + sb.gearImage);
      cell2.vertex = true;
      return sb.createVertexTemplateFromCells([cell2], cell2.geometry.width, cell2.geometry.height, "Item 2");
    }),
    this.addEntry(dt + "divider hline line separator", function() {
      return sb.createVertexTemplateFromCells([divider.clone()], divider.geometry.width, divider.geometry.height, "Divider");
    }),
    this.addEntry(dt + "spacer space gap separator", function() {
      var cell2 = new mxCell("", new mxGeometry(0, 0, 20, 14), "text;strokeColor=none;fillColor=none;align=left;verticalAlign=middle;spacingTop=-1;spacingLeft=4;spacingRight=4;rotatable=0;labelPosition=right;points=[];portConstraint=eastwest;");
      cell2.vertex = true;
      return sb.createVertexTemplateFromCells([cell2.clone()], cell2.geometry.width, cell2.geometry.height, "Spacer");
    }),
    this.createVertexTemplateEntry("text;align=center;fontStyle=1;verticalAlign=middle;spacingLeft=3;spacingRight=3;strokeColor=none;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;", 80, 26, "Title", "Title", null, null, dt + "title label"),
    this.addEntry(dt + "component", function() {
      var cell2 = new mxCell("&laquo;Annotation&raquo;<br/><b>Component</b>", new mxGeometry(0, 0, 180, 90), "html=1;dropTarget=0;");
      cell2.vertex = true;
      var symbol = new mxCell("", new mxGeometry(1, 0, 20, 20), "shape=module;jettyWidth=8;jettyHeight=4;");
      symbol.vertex = true;
      symbol.geometry.relative = true;
      symbol.geometry.offset = new mxPoint2(-27, 7);
      cell2.insert(symbol);
      return sb.createVertexTemplateFromCells([cell2], cell2.geometry.width, cell2.geometry.height, "Component");
    }),
    this.addEntry(dt + "component", function() {
      var cell2 = new mxCell('<p style="margin:0px;margin-top:6px;text-align:center;"><b>Component</b></p><hr/><p style="margin:0px;margin-left:8px;">+ Attribute1: Type<br/>+ Attribute2: Type</p>', new mxGeometry(0, 0, 180, 90), "align=left;overflow=fill;html=1;dropTarget=0;");
      cell2.vertex = true;
      var symbol = new mxCell("", new mxGeometry(1, 0, 20, 20), "shape=component;jettyWidth=8;jettyHeight=4;");
      symbol.vertex = true;
      symbol.geometry.relative = true;
      symbol.geometry.offset = new mxPoint2(-24, 4);
      cell2.insert(symbol);
      return sb.createVertexTemplateFromCells([cell2], cell2.geometry.width, cell2.geometry.height, "Component with Attributes");
    }),
    this.createVertexTemplateEntry("verticalAlign=top;align=left;spacingTop=8;spacingLeft=2;spacingRight=12;shape=cube;size=10;direction=south;fontStyle=4;html=1;", 180, 120, "Block", "Block", null, null, dt + "block"),
    this.createVertexTemplateEntry("shape=module;align=left;spacingLeft=20;align=center;verticalAlign=top;", 100, 50, "Module", "Module", null, null, dt + "module component"),
    this.createVertexTemplateEntry("shape=folder;fontStyle=1;spacingTop=10;tabWidth=40;tabHeight=14;tabPosition=left;html=1;", 70, 50, "package", "Package", null, null, dt + "package"),
    this.createVertexTemplateEntry("verticalAlign=top;align=left;overflow=fill;fontSize=12;fontFamily=Helvetica;html=1;", 160, 90, '<p style="margin:0px;margin-top:4px;text-align:center;text-decoration:underline;"><b>Object:Type</b></p><hr/><p style="margin:0px;margin-left:8px;">field1 = value1<br/>field2 = value2<br>field3 = value3</p>', "Object", null, null, dt + "object instance"),
    this.createVertexTemplateEntry("verticalAlign=top;align=left;overflow=fill;html=1;", 180, 90, '<div style="box-sizing:border-box;width:100%;background:#e4e4e4;padding:2px;">Tablename</div><table style="width:100%;font-size:1em;" cellpadding="2" cellspacing="0"><tr><td>PK</td><td>uniqueId</td></tr><tr><td>FK1</td><td>foreignKey</td></tr><tr><td></td><td>fieldname</td></tr></table>', "Entity", null, null, "er entity table"),
    this.addEntry(dt + "object instance", function() {
      var cell2 = new mxCell('<p style="margin:0px;margin-top:4px;text-align:center;"><b>Class</b></p><hr size="1"/><div style="height:2px;"></div>', new mxGeometry(0, 0, 140, 60), "verticalAlign=top;align=left;overflow=fill;fontSize=12;fontFamily=Helvetica;html=1;");
      cell2.vertex = true;
      return sb.createVertexTemplateFromCells([cell2.clone()], cell2.geometry.width, cell2.geometry.height, "Class 3");
    }),
    this.addEntry(dt + "object instance", function() {
      var cell2 = new mxCell('<p style="margin:0px;margin-top:4px;text-align:center;"><b>Class</b></p><hr size="1"/><div style="height:2px;"></div><hr size="1"/><div style="height:2px;"></div>', new mxGeometry(0, 0, 140, 60), "verticalAlign=top;align=left;overflow=fill;fontSize=12;fontFamily=Helvetica;html=1;");
      cell2.vertex = true;
      return sb.createVertexTemplateFromCells([cell2.clone()], cell2.geometry.width, cell2.geometry.height, "Class 4");
    }),
    this.addEntry(dt + "object instance", function() {
      var cell2 = new mxCell('<p style="margin:0px;margin-top:4px;text-align:center;"><b>Class</b></p><hr size="1"/><p style="margin:0px;margin-left:4px;">+ field: Type</p><hr size="1"/><p style="margin:0px;margin-left:4px;">+ method(): Type</p>', new mxGeometry(0, 0, 160, 90), "verticalAlign=top;align=left;overflow=fill;fontSize=12;fontFamily=Helvetica;html=1;");
      cell2.vertex = true;
      return sb.createVertexTemplateFromCells([cell2.clone()], cell2.geometry.width, cell2.geometry.height, "Class 5");
    }),
    this.addEntry(dt + "object instance", function() {
      var cell2 = new mxCell('<p style="margin:0px;margin-top:4px;text-align:center;"><i>&lt;&lt;Interface&gt;&gt;</i><br/><b>Interface</b></p><hr size="1"/><p style="margin:0px;margin-left:4px;">+ field1: Type<br/>+ field2: Type</p><hr size="1"/><p style="margin:0px;margin-left:4px;">+ method1(Type): Type<br/>+ method2(Type, Type): Type</p>', new mxGeometry(0, 0, 190, 140), "verticalAlign=top;align=left;overflow=fill;fontSize=12;fontFamily=Helvetica;html=1;");
      cell2.vertex = true;
      return sb.createVertexTemplateFromCells([cell2.clone()], cell2.geometry.width, cell2.geometry.height, "Interface 2");
    }),
    this.createVertexTemplateEntry("shape=providedRequiredInterface;html=1;verticalLabelPosition=bottom;", 20, 20, "", "Provided/Required Interface", null, null, "uml provided required interface lollipop notation"),
    this.createVertexTemplateEntry("shape=requiredInterface;html=1;verticalLabelPosition=bottom;", 10, 20, "", "Required Interface", null, null, "uml required interface lollipop notation"),
    this.addEntry("uml lollipop notation provided required interface", function() {
      return sb.createVertexTemplateFromData("zVTBrptADPyavVYEkt4b0uQd3pMq5dD2uAUD27dgZJwE8vX1spsQlETtpVWRIjFjex3PmFVJWvc70m31hjlYlXxWSUqI7N/qPgVrVRyZXCUbFceR/FS8fRJdjNGo1QQN/0lB7AuO2h7AM57oeLCBIDw0Obj8SCVrJK6wxEbbV8RWyIWQP4F52Juzq9AHRqEqrm2IQpN/IsKTwAYb8MzWWBuO9B0hL2E2BGsqIQyxvJ9rzApD7QBrYBokhcBqNsf5UbrzsLzmXUu/oJET42jwGat5QYcHyiDkTDLKy03TiRrFfSx08m+FrrQtUkOZvZdbFKThmwMfVhf4fQ43/W3uZriiPPT+KKhjwnf4anKuQv//wsg+NPJ7/9d9Xf7eVykwbeeMOFWGYd/qzEVO8tHP/Suw4a2ujXV/+gXsEdhkOgSC8os44BQt0tggicZHeG1N2QiXibhAV48epRayEDd8MT7Ct06TUaXVWq027tCuhcx5VZjebeeaoDNn/WMcb/p+j0AM/dNr6InLl4Lgzylsk6OCgRWYsuI592gNZh5OhgmcblPv7+1l+ws=", 40, 10, "Lollipop Notation");
    }),
    this.createVertexTemplateEntry("shape=umlBoundary;whiteSpace=wrap;html=1;", 100, 80, "Boundary Object", "Boundary Object", null, null, "uml boundary object"),
    this.createVertexTemplateEntry("ellipse;shape=umlEntity;whiteSpace=wrap;html=1;", 80, 80, "Entity Object", "Entity Object", null, null, "uml entity object"),
    this.createVertexTemplateEntry("ellipse;shape=umlControl;whiteSpace=wrap;html=1;", 70, 80, "Control Object", "Control Object", null, null, "uml control object"),
    this.createVertexTemplateEntry("shape=umlActor;verticalLabelPosition=bottom;verticalAlign=top;html=1;", 30, 60, "Actor", "Actor", false, null, "uml actor"),
    this.createVertexTemplateEntry("ellipse;whiteSpace=wrap;html=1;", 140, 70, "Use Case", "Use Case", null, null, "uml use case usecase"),
    this.addEntry("uml activity state start", function() {
      var cell2 = new mxCell("", new mxGeometry(0, 0, 30, 30), "ellipse;html=1;shape=startState;fillColor=#000000;strokeColor=#ff0000;");
      cell2.vertex = true;
      var edge = new mxCell("", new mxGeometry(0, 0, 0, 0), "edgeStyle=orthogonalEdgeStyle;html=1;verticalAlign=bottom;endArrow=open;endSize=8;strokeColor=#ff0000;");
      edge.geometry.setTerminalPoint(new mxPoint2(15, 90), false);
      edge.geometry.relative = true;
      edge.edge = true;
      cell2.insertEdge(edge, true);
      return sb.createVertexTemplateFromCells([cell2, edge], 30, 90, "Start");
    }),
    this.addEntry("uml activity state", function() {
      var cell2 = new mxCell("Activity", new mxGeometry(0, 0, 120, 40), "rounded=1;whiteSpace=wrap;html=1;arcSize=40;fontColor=#000000;fillColor=#ffffc0;strokeColor=#ff0000;");
      cell2.vertex = true;
      var edge = new mxCell("", new mxGeometry(0, 0, 0, 0), "edgeStyle=orthogonalEdgeStyle;html=1;verticalAlign=bottom;endArrow=open;endSize=8;strokeColor=#ff0000;");
      edge.geometry.setTerminalPoint(new mxPoint2(60, 100), false);
      edge.geometry.relative = true;
      edge.edge = true;
      cell2.insertEdge(edge, true);
      return sb.createVertexTemplateFromCells([cell2, edge], 120, 100, "Activity");
    }),
    this.addEntry("uml activity composite state", function() {
      var cell2 = new mxCell("Composite State", new mxGeometry(0, 0, 160, 60), "swimlane;html=1;fontStyle=1;align=center;verticalAlign=middle;childLayout=stackLayout;horizontal=1;startSize=30;horizontalStack=0;resizeParent=0;resizeLast=1;container=0;fontColor=#000000;collapsible=0;rounded=1;arcSize=30;strokeColor=#ff0000;fillColor=#ffffc0;swimlaneFillColor=#ffffc0;dropTarget=0;");
      cell2.vertex = true;
      var cell1 = new mxCell("Subtitle", new mxGeometry(0, 0, 200, 26), "text;html=1;strokeColor=none;fillColor=none;align=center;verticalAlign=middle;spacingLeft=4;spacingRight=4;whiteSpace=wrap;overflow=hidden;rotatable=0;fontColor=#000000;");
      cell1.vertex = true;
      cell2.insert(cell1);
      var edge = new mxCell("", new mxGeometry(0, 0, 0, 0), "edgeStyle=orthogonalEdgeStyle;html=1;verticalAlign=bottom;endArrow=open;endSize=8;strokeColor=#ff0000;");
      edge.geometry.setTerminalPoint(new mxPoint2(80, 120), false);
      edge.geometry.relative = true;
      edge.edge = true;
      cell2.insertEdge(edge, true);
      return sb.createVertexTemplateFromCells([cell2, edge], 160, 120, "Composite State");
    }),
    this.addEntry("uml activity condition", function() {
      var cell2 = new mxCell("Condition", new mxGeometry(0, 0, 80, 40), "rhombus;whiteSpace=wrap;html=1;fillColor=#ffffc0;strokeColor=#ff0000;");
      cell2.vertex = true;
      var edge1 = new mxCell("no", new mxGeometry(0, 0, 0, 0), "edgeStyle=orthogonalEdgeStyle;html=1;align=left;verticalAlign=bottom;endArrow=open;endSize=8;strokeColor=#ff0000;");
      edge1.geometry.setTerminalPoint(new mxPoint2(180, 20), false);
      edge1.geometry.relative = true;
      edge1.geometry.x = -1;
      edge1.edge = true;
      cell2.insertEdge(edge1, true);
      var edge2 = new mxCell("yes", new mxGeometry(0, 0, 0, 0), "edgeStyle=orthogonalEdgeStyle;html=1;align=left;verticalAlign=top;endArrow=open;endSize=8;strokeColor=#ff0000;");
      edge2.geometry.setTerminalPoint(new mxPoint2(40, 100), false);
      edge2.geometry.relative = true;
      edge2.geometry.x = -1;
      edge2.edge = true;
      cell2.insertEdge(edge2, true);
      return sb.createVertexTemplateFromCells([cell2, edge1, edge2], 180, 100, "Condition");
    }),
    this.addEntry("uml activity fork join", function() {
      var cell2 = new mxCell("", new mxGeometry(0, 0, 200, 10), "shape=line;html=1;strokeWidth=6;strokeColor=#ff0000;");
      cell2.vertex = true;
      var edge = new mxCell("", new mxGeometry(0, 0, 0, 0), "edgeStyle=orthogonalEdgeStyle;html=1;verticalAlign=bottom;endArrow=open;endSize=8;strokeColor=#ff0000;");
      edge.geometry.setTerminalPoint(new mxPoint2(100, 80), false);
      edge.geometry.relative = true;
      edge.edge = true;
      cell2.insertEdge(edge, true);
      return sb.createVertexTemplateFromCells([cell2, edge], 200, 80, "Fork/Join");
    }),
    this.createVertexTemplateEntry("ellipse;html=1;shape=endState;fillColor=#000000;strokeColor=#ff0000;", 30, 30, "", "End", null, null, "uml activity state end"),
    this.createVertexTemplateEntry("shape=umlLifeline;perimeter=lifelinePerimeter;whiteSpace=wrap;html=1;container=1;collapsible=0;recursiveResize=0;outlineConnect=0;", 100, 300, ":Object", "Lifeline", null, null, "uml sequence participant lifeline"),
    this.createVertexTemplateEntry("shape=umlLifeline;participant=umlActor;perimeter=lifelinePerimeter;whiteSpace=wrap;html=1;container=1;collapsible=0;recursiveResize=0;verticalAlign=top;spacingTop=36;outlineConnect=0;", 20, 300, "", "Actor Lifeline", null, null, "uml sequence participant lifeline actor"),
    this.createVertexTemplateEntry("shape=umlLifeline;participant=umlBoundary;perimeter=lifelinePerimeter;whiteSpace=wrap;html=1;container=1;collapsible=0;recursiveResize=0;verticalAlign=top;spacingTop=36;outlineConnect=0;", 50, 300, "", "Boundary Lifeline", null, null, "uml sequence participant lifeline boundary"),
    this.createVertexTemplateEntry("shape=umlLifeline;participant=umlEntity;perimeter=lifelinePerimeter;whiteSpace=wrap;html=1;container=1;collapsible=0;recursiveResize=0;verticalAlign=top;spacingTop=36;outlineConnect=0;", 40, 300, "", "Entity Lifeline", null, null, "uml sequence participant lifeline entity"),
    this.createVertexTemplateEntry("shape=umlLifeline;participant=umlControl;perimeter=lifelinePerimeter;whiteSpace=wrap;html=1;container=1;collapsible=0;recursiveResize=0;verticalAlign=top;spacingTop=36;outlineConnect=0;", 40, 300, "", "Control Lifeline", null, null, "uml sequence participant lifeline control"),
    this.createVertexTemplateEntry("shape=umlFrame;whiteSpace=wrap;html=1;", 300, 200, "frame", "Frame", null, null, "uml sequence frame"),
    this.createVertexTemplateEntry("shape=umlDestroy;whiteSpace=wrap;html=1;strokeWidth=3;", 30, 30, "", "Destruction", null, null, "uml sequence destruction destroy"),
    this.addEntry("uml sequence invoke invocation call activation", function() {
      var cell2 = new mxCell("", new mxGeometry(0, 0, 10, 80), "html=1;points=[];perimeter=orthogonalPerimeter;");
      cell2.vertex = true;
      var edge = new mxCell("dispatch", new mxGeometry(0, 0, 0, 0), "html=1;verticalAlign=bottom;startArrow=oval;endArrow=block;startSize=8;");
      edge.geometry.setTerminalPoint(new mxPoint2(-60, 0), true);
      edge.geometry.relative = true;
      edge.edge = true;
      cell2.insertEdge(edge, false);
      return sb.createVertexTemplateFromCells([cell2, edge], 10, 80, "Found Message");
    }),
    this.addEntry("uml sequence invoke call delegation synchronous invocation activation", function() {
      var cell2 = new mxCell("", new mxGeometry(0, 0, 10, 80), "html=1;points=[];perimeter=orthogonalPerimeter;");
      cell2.vertex = true;
      var edge1 = new mxCell("dispatch", new mxGeometry(0, 0, 0, 0), "html=1;verticalAlign=bottom;endArrow=block;entryX=0;entryY=0;");
      edge1.geometry.setTerminalPoint(new mxPoint2(-70, 0), true);
      edge1.geometry.relative = true;
      edge1.edge = true;
      cell2.insertEdge(edge1, false);
      var edge2 = new mxCell("return", new mxGeometry(0, 0, 0, 0), "html=1;verticalAlign=bottom;endArrow=open;dashed=1;endSize=8;exitX=0;exitY=0.95;");
      edge2.geometry.setTerminalPoint(new mxPoint2(-70, 76), false);
      edge2.geometry.relative = true;
      edge2.edge = true;
      cell2.insertEdge(edge2, true);
      return sb.createVertexTemplateFromCells([cell2, edge1, edge2], 10, 80, "Synchronous Invocation");
    }),
    this.addEntry("uml sequence self call recursion delegation activation", function() {
      var cell2 = new mxCell("", new mxGeometry(0, 20, 10, 40), "html=1;points=[];perimeter=orthogonalPerimeter;");
      cell2.vertex = true;
      var edge = new mxCell("self call", new mxGeometry(0, 0, 0, 0), "edgeStyle=orthogonalEdgeStyle;html=1;align=left;spacingLeft=2;endArrow=block;rounded=0;entryX=1;entryY=0;");
      edge.geometry.setTerminalPoint(new mxPoint2(5, 0), true);
      edge.geometry.points = [new mxPoint2(30, 0)];
      edge.geometry.relative = true;
      edge.edge = true;
      cell2.insertEdge(edge, false);
      return sb.createVertexTemplateFromCells([cell2, edge], 10, 60, "Self Call");
    }),
    this.addEntry("uml sequence invoke call delegation callback activation", function() {
      return sb.createVertexTemplateFromData("xZRNT8MwDIZ/Ta6oaymD47rBTkiTuMAxW6wmIm0q19s6fj1OE3V0Y2iCA4dK8euP2I+riGxedUuUjX52CqzIHkU2R+conKpuDtaKNDFKZAuRpgl/In264J303qSRCDVdk5CGhJ20WwhKEFo62ChoqritxURkReNMTa2X80LkC68AmgoIkEWHpF3pamlXR7WIFwASdBeb7KXY4RIc5+KBQ/ZGkY4RYY5Egyl1zLqLmmyDXQ6Zx4n5EIf+HkB2BmAjrV3LzftPIPw4hgNn1pQ1a2tH5Cp2QK1miG7vNeu4iJe4pdeY2BtvbCQDGlAljMCQxBJotJ8rWCFYSWY3LvUdmZi68rvkkLiU6QnL1m1xAzHoBOdw61WEb88II9AW67/ydQ2wq1Cy1aAGvOrFfPh6997qDA3g+dxzv3nIL6MPU/8T+kMw8+m4QPgdfrEJNo8PSQj/+s58Ag==", 10, 60, "Callback");
    }),
    this.createVertexTemplateEntry("html=1;points=[];perimeter=orthogonalPerimeter;", 10, 80, "", "Activation", null, null, "uml sequence activation"),
    this.createVertexTemplateEntry("shape=partialRectangle;html=1;top=1;align=left;dashed=1;", 200, 20, "Template1 signature", "Template signature", null, null, "template signature"),
    this.createVertexTemplateEntry("shape=partialRectangle;html=1;top=1;align=left;dashed=1;", 200, 50, "Template parameter 1\nTemplate parameter 2", "Template signature", null, null, "template signature"),
    this.createVertexTemplateEntry("shape=note2;boundedLbl=1;whiteSpace=wrap;html=1;size=25;verticalAlign=top;align=center;", 120, 60, "Comment1 body", "Note", null, null, "uml note"),
    this.addEntry("uml sequence self call recursion delegation activation", function() {
      var cell2 = new mxCell("Constraint1 specification", new mxGeometry(0, 0, 160, 60), "shape=note2;boundedLbl=1;whiteSpace=wrap;html=1;size=25;verticalAlign=top;align=center;");
      cell2.vertex = true;
      var label = new mxCell("<<keyword>>", new mxGeometry(0, 0, cell2.geometry.width, 25), "resizeWidth=1;part=1;strokeColor=none;fillColor=none;align=left;spacingLeft=5;");
      label.geometry.relative = true;
      label.vertex = true;
      cell2.insert(label);
      return sb.createVertexTemplateFromCells([cell2], cell2.geometry.width, cell2.geometry.height, "Note");
    }),
    this.addEntry(dt + "classifier", function() {
      var cell1 = new mxCell("&lt;&lt;keyword&gt;&gt;<br><b>Classifier1</b><br>{abstract}", new mxGeometry(0, 0, 140, 183), "swimlane;fontStyle=0;align=center;verticalAlign=top;childLayout=stackLayout;horizontal=1;startSize=55;horizontalStack=0;resizeParent=1;resizeParentMax=0;resizeLast=0;collapsible=0;marginBottom=0;html=1;");
      cell1.vertex = true;
      var field1 = new mxCell("attributes", new mxGeometry(0, 0, 140, 20), "text;html=1;strokeColor=none;fillColor=none;align=center;verticalAlign=middle;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;");
      field1.vertex = true;
      cell1.insert(field1);
      var field2 = new mxCell("attribute1", new mxGeometry(0, 0, 140, 20), "text;html=1;strokeColor=none;fillColor=none;align=left;verticalAlign=middle;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;");
      field2.vertex = true;
      cell1.insert(field2);
      var field3 = new mxCell("inherited attribute2", new mxGeometry(0, 0, 140, 20), "text;html=1;strokeColor=none;fillColor=none;align=left;verticalAlign=middle;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;fontColor=#808080;");
      field3.vertex = true;
      cell1.insert(field3);
      var field4 = new mxCell("...", new mxGeometry(0, 0, 140, 20), "text;html=1;strokeColor=none;fillColor=none;align=left;verticalAlign=middle;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;");
      field4.vertex = true;
      cell1.insert(field4);
      cell1.insert(divider.clone());
      var field5 = new mxCell("operations", new mxGeometry(0, 0, 140, 20), "text;html=1;strokeColor=none;fillColor=none;align=center;verticalAlign=middle;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;");
      field5.vertex = true;
      cell1.insert(field5);
      var field6 = new mxCell("operation1", new mxGeometry(0, 0, 140, 20), "text;html=1;strokeColor=none;fillColor=none;align=left;verticalAlign=middle;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;");
      field6.vertex = true;
      cell1.insert(field6);
      return sb.createVertexTemplateFromCells([cell1], cell1.geometry.width, cell1.geometry.height, "Classifier");
    }),
    this.createVertexTemplateEntry("shape=process;fixedSize=1;size=5;fontStyle=1;", 140, 40, "Classifier1", "Classifier", null, null, "classifier"),
    this.addEntry(dt + "classifier", function() {
      var cell1 = new mxCell("Classifier1", new mxGeometry(0, 0, 140, 183), "swimlane;fontStyle=1;align=center;verticalAlign=top;childLayout=stackLayout;horizontal=1;startSize=30;horizontalStack=0;resizeParent=1;resizeParentMax=0;resizeLast=0;collapsible=0;marginBottom=0;html=1;");
      cell1.vertex = true;
      var field1 = new mxCell("internal structure", new mxGeometry(0, 0, 140, 30), "html=1;strokeColor=none;fillColor=none;align=center;verticalAlign=middle;spacingLeft=4;spacingRight=4;rotatable=0;points=[[0,0.5],[1,0.5]];resizeWidth=1;");
      field1.vertex = true;
      cell1.insert(field1);
      var cell2 = new mxCell("", new mxGeometry(0, 0, 140, 140), "strokeColor=none;fillColor=none;");
      cell2.vertex = true;
      cell1.insert(cell2);
      var field2 = new mxCell("property1", new mxGeometry(0, 0, 100, 30), "html=1;align=center;verticalAlign=middle;rotatable=0;");
      field2.geometry.relative = true;
      field2.geometry.offset = new mxPoint2(20, 20);
      field2.vertex = true;
      cell2.insert(field2);
      var field3 = new mxCell("property2", new mxGeometry(0, 0, 100, 30), "html=1;align=center;verticalAlign=middle;rotatable=0;");
      field3.geometry.relative = true;
      field3.geometry.offset = new mxPoint2(20, 90);
      field3.vertex = true;
      cell2.insert(field3);
      var assoc1 = new mxCell("connector1", new mxGeometry(0, 0, 0, 0), "edgeStyle=none;endArrow=none;verticalAlign=middle;labelBackgroundColor=none;endSize=12;html=1;align=left;endFill=0;exitX=0.15;exitY=1;entryX=0.15;entryY=0;spacingLeft=4;");
      assoc1.geometry.relative = true;
      assoc1.edge = true;
      field2.insertEdge(assoc1, true);
      field3.insertEdge(assoc1, false);
      cell2.insert(assoc1);
      return sb.createVertexTemplateFromCells([cell1], cell1.geometry.width, cell1.geometry.height, "Classifier");
    }),
    this.createVertexTemplateEntry("fontStyle=1;", 140, 30, "Association1", "Association", null, null, "association"),
    this.addEntry(dt + "classifier", function() {
      var cell1 = new mxCell("Instance1", new mxGeometry(0, 0, 140, 138), "swimlane;fontStyle=4;align=center;verticalAlign=top;childLayout=stackLayout;horizontal=1;startSize=30;horizontalStack=0;resizeParent=1;resizeParentMax=0;resizeLast=0;collapsible=0;marginBottom=0;html=1;");
      cell1.vertex = true;
      var field1 = new mxCell("slot1", new mxGeometry(0, 0, 140, 30), "html=1;strokeColor=none;fillColor=none;align=left;verticalAlign=middle;spacingLeft=4;spacingRight=4;rotatable=0;points=[[0,0.5],[1,0.5]];resizeWidth=1;");
      field1.vertex = true;
      cell1.insert(field1);
      cell1.insert(divider.clone());
      var field2 = new mxCell("internal structure", new mxGeometry(0, 0, 140, 20), "html=1;strokeColor=none;fillColor=none;align=center;verticalAlign=middle;spacingLeft=4;spacingRight=4;rotatable=0;points=[[0,0.5],[1,0.5]];resizeWidth=1;");
      field2.vertex = true;
      cell1.insert(field2);
      var cell2 = new mxCell("", new mxGeometry(0, 0, 140, 50), "strokeColor=none;fillColor=none;");
      cell2.vertex = true;
      cell1.insert(cell2);
      var field3 = new mxCell("instance2", new mxGeometry(0, 0, 80, 30), "html=1;align=center;verticalAlign=middle;rotatable=0;");
      field3.geometry.relative = true;
      field3.geometry.offset = new mxPoint2(30, 10);
      field3.vertex = true;
      cell2.insert(field3);
      return sb.createVertexTemplateFromCells([cell1], cell1.geometry.width, cell1.geometry.height, "Classifier");
    }),
    this.createVertexTemplateEntry("fontStyle=0;", 120, 40, "Instance1 value", "Instance", null, null, "instance"),
    this.addEntry(dt + "classifier", function() {
      var cell1 = new mxCell("&lt;&lt;enumeration&gt;&gt;<br><b>Enum1</b>", new mxGeometry(0, 0, 140, 70), "swimlane;fontStyle=0;align=center;verticalAlign=top;childLayout=stackLayout;horizontal=1;startSize=40;horizontalStack=0;resizeParent=1;resizeParentMax=0;resizeLast=0;collapsible=0;marginBottom=0;html=1;");
      cell1.vertex = true;
      var field1 = new mxCell("literal1", new mxGeometry(0, 0, 140, 30), "text;html=1;strokeColor=none;fillColor=none;align=left;verticalAlign=middle;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;");
      field1.vertex = true;
      cell1.insert(field1);
      return sb.createVertexTemplateFromCells([cell1], cell1.geometry.width, cell1.geometry.height, "Classifier");
    }),
    this.addEntry(dt + "classifier", function() {
      var cell1 = new mxCell("0..1", new mxGeometry(0, 0, 120, 50), "align=right;verticalAlign=top;spacingRight=2;");
      cell1.vertex = true;
      var field1 = new mxCell("Property1", new mxGeometry(0, 1, 120, 30), "text;html=1;strokeColor=none;fillColor=none;align=center;verticalAlign=middle;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;resizeWidth=1;");
      field1.geometry.relative = true;
      field1.geometry.offset = new mxPoint2(0, -30);
      field1.vertex = true;
      cell1.insert(field1);
      return sb.createVertexTemplateFromCells([cell1], cell1.geometry.width, cell1.geometry.height, "Classifier");
    }),
    this.createVertexTemplateEntry("fontStyle=0;dashed=1;", 140, 30, "Property1", "Property", null, null, "property"),
    this.createVertexTemplateEntry("fontStyle=0;labelPosition=right;verticalLabelPosition=middle;align=left;verticalAlign=middle;spacingLeft=2;", 30, 30, "port1", "Port", null, null, "port"),
    this.addEntry(dt + "component", function() {
      var cell1 = new mxCell("", new mxGeometry(0, 0, 140, 200), "fontStyle=1;align=center;verticalAlign=top;childLayout=stackLayout;horizontal=1;horizontalStack=0;resizeParent=1;resizeParentMax=0;resizeLast=0;marginBottom=0;");
      cell1.vertex = true;
      var cell2 = new mxCell("Component", new mxGeometry(0, 0, 140, 40), "html=1;align=left;spacingLeft=4;verticalAlign=top;strokeColor=none;fillColor=none;");
      cell2.vertex = true;
      cell1.insert(cell2);
      var symbol = new mxCell("", new mxGeometry(1, 0, 16, 20), "shape=module;jettyWidth=10;jettyHeight=4;");
      symbol.vertex = true;
      symbol.geometry.relative = true;
      symbol.geometry.offset = new mxPoint2(-25, 9);
      cell2.insert(symbol);
      cell1.insert(divider.clone());
      var cell3 = new mxCell("provided interfaces", new mxGeometry(0, 0, 140, 25), "html=1;align=center;spacingLeft=4;verticalAlign=top;strokeColor=none;fillColor=none;");
      cell3.vertex = true;
      cell1.insert(cell3);
      var cell4 = new mxCell("Interface1", new mxGeometry(0, 0, 140, 25), "html=1;align=left;spacingLeft=4;verticalAlign=top;strokeColor=none;fillColor=none;");
      cell4.vertex = true;
      cell1.insert(cell4);
      cell1.insert(divider.clone());
      var cell5 = new mxCell("required interfaces", new mxGeometry(0, 0, 140, 25), "html=1;align=center;spacingLeft=4;verticalAlign=top;strokeColor=none;fillColor=none;");
      cell5.vertex = true;
      cell1.insert(cell5);
      var cell6 = new mxCell("Interface2", new mxGeometry(0, 0, 140, 30), "html=1;align=left;spacingLeft=4;verticalAlign=top;strokeColor=none;fillColor=none;");
      cell6.vertex = true;
      cell1.insert(cell6);
      return sb.createVertexTemplateFromCells([cell1], cell1.geometry.width, cell1.geometry.height, "Component");
    }),
    this.addEntry(dt + "classifier", function() {
      var cell1 = new mxCell("", new mxGeometry(0, 0, 270, 230), "shape=ellipse;container=1;horizontal=1;horizontalStack=0;resizeParent=1;resizeParentMax=0;resizeLast=0;html=1;dashed=1;collapsible=0;");
      cell1.vertex = true;
      var field1 = new mxCell("Collaboration1", new mxGeometry(0, 0, 270, 30), "html=1;strokeColor=none;fillColor=none;align=center;verticalAlign=middle;spacingLeft=4;spacingRight=4;rotatable=0;points=[[0,0.5],[1,0.5]];resizeWidth=1;");
      field1.vertex = true;
      cell1.insert(field1);
      var divider1 = new mxCell("", new mxGeometry(0.145, 0, 192, 8), "line;strokeWidth=1;fillColor=none;rotatable=0;labelPosition=right;points=[];portConstraint=eastwest;dashed=1;resizeWidth=1;");
      divider1.geometry.relative = true;
      divider1.geometry.offset = new mxPoint2(0, 30);
      divider1.vertex = true;
      cell1.insert(divider1);
      var field2 = new mxCell("Classifier1", new mxGeometry(0, 0, 100, 30), "html=1;align=center;verticalAlign=middle;rotatable=0;");
      field2.geometry.relative = true;
      field2.geometry.offset = new mxPoint2(85, 50);
      field2.vertex = true;
      cell1.insert(field2);
      var field3 = new mxCell("Collaboration use 1", new mxGeometry(0, 0, 140, 30), "shape=ellipse;html=1;align=center;verticalAlign=middle;rotatable=0;dashed=1;");
      field3.geometry.relative = true;
      field3.geometry.offset = new mxPoint2(65, 110);
      field3.vertex = true;
      cell1.insert(field3);
      var assoc1 = new mxCell("property1", new mxGeometry(0, 0, 0, 0), "edgeStyle=none;endArrow=none;verticalAlign=middle;labelBackgroundColor=none;endSize=12;html=1;align=left;endFill=0;spacingLeft=4;");
      assoc1.geometry.relative = true;
      assoc1.edge = true;
      field2.insertEdge(assoc1, true);
      field3.insertEdge(assoc1, false);
      cell1.insert(assoc1);
      var field4 = new mxCell("Classifier2", new mxGeometry(0, 0, 100, 30), "html=1;align=center;verticalAlign=middle;rotatable=0;");
      field4.geometry.relative = true;
      field4.geometry.offset = new mxPoint2(85, 170);
      field4.vertex = true;
      cell1.insert(field4);
      var assoc2 = new mxCell("property1", new mxGeometry(0, 0, 0, 0), "edgeStyle=none;endArrow=none;verticalAlign=middle;labelBackgroundColor=none;endSize=12;html=1;align=left;endFill=0;spacingLeft=4;");
      assoc2.geometry.relative = true;
      assoc2.edge = true;
      field3.insertEdge(assoc2, true);
      field4.insertEdge(assoc2, false);
      cell1.insert(assoc2);
      return sb.createVertexTemplateFromCells([cell1], cell1.geometry.width, cell1.geometry.height, "Classifier");
    }),
    this.createVertexTemplateEntry("shape=folder;fontStyle=1;tabWidth=80;tabHeight=30;tabPosition=left;html=1;boundedLbl=1;", 150, 80, "Package1", "Package", null, null, dt + "package"),
    this.addEntry(dt + "package", function() {
      var cell1 = new mxCell("Package1", new mxGeometry(0, 0, 150, 100), "shape=folder;fontStyle=1;tabWidth=110;tabHeight=30;tabPosition=left;html=1;boundedLbl=1;labelInHeader=1;");
      cell1.vertex = true;
      var field1 = new mxCell("Packaged element1", new mxGeometry(0, 0, 110, 30), "html=1;");
      field1.geometry.relative = true;
      field1.geometry.offset = new mxPoint2(20, 50);
      field1.vertex = true;
      cell1.insert(field1);
      return sb.createVertexTemplateFromCells([cell1], cell1.geometry.width, cell1.geometry.height, "Classifier");
    }),
    this.addEntry(dt + "package", function() {
      var cell1 = new mxCell("Model1", new mxGeometry(0, 0, 150, 80), "shape=folder;fontStyle=1;tabWidth=110;tabHeight=30;tabPosition=left;html=1;boundedLbl=1;folderSymbol=triangle;");
      cell1.vertex = true;
      return sb.createVertexTemplateFromCells([cell1], cell1.geometry.width, cell1.geometry.height, "Package");
    }),
    this.addEntry(dt + "stereotype", function() {
      var cell1 = new mxCell("", new mxGeometry(0, 0, 160, 75), "shape=note2;size=25;childLayout=stackLayout;horizontalStack=0;resizeParent=1;resizeParentMax=0;resizeLast=0;collapsible=0;marginBottom=0;html=1;container=1;");
      cell1.vertex = true;
      var field1 = new mxCell("&lt;&lt;stereotype1&gt;&gt;", new mxGeometry(0, 0, 160, 25), "text;html=1;strokeColor=none;fillColor=none;align=left;verticalAlign=middle;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;");
      field1.vertex = true;
      cell1.insert(field1);
      var field2 = new mxCell("stereotype property 1", new mxGeometry(0, 0, 160, 25), "text;html=1;strokeColor=none;fillColor=none;align=left;verticalAlign=middle;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;");
      field2.vertex = true;
      cell1.insert(field2);
      var field3 = new mxCell("stereotype property 2", new mxGeometry(0, 0, 160, 25), "text;html=1;strokeColor=none;fillColor=none;align=left;verticalAlign=middle;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;");
      field3.vertex = true;
      cell1.insert(field3);
      return sb.createVertexTemplateFromCells([cell1], cell1.geometry.width, cell1.geometry.height, "Stereotype");
    }),
    this.addEntry(dt + "class", function() {
      var cell1 = new mxCell("Class1", new mxGeometry(0, 0, 140, 79), "swimlane;fontStyle=1;align=center;verticalAlign=middle;childLayout=stackLayout;horizontal=1;startSize=29;horizontalStack=0;resizeParent=1;resizeParentMax=0;resizeLast=0;collapsible=0;marginBottom=0;html=1;");
      cell1.vertex = true;
      var field1 = new mxCell("&lt;&lt;stereotype1&gt;&gt;", new mxGeometry(0, 0, 140, 25), "text;html=1;strokeColor=none;fillColor=none;align=center;verticalAlign=middle;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;");
      field1.vertex = true;
      cell1.insert(field1);
      var field2 = new mxCell("stereotype property 1", new mxGeometry(0, 0, 140, 25), "text;html=1;strokeColor=none;fillColor=none;align=left;verticalAlign=middle;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;");
      field2.vertex = true;
      cell1.insert(field2);
      return sb.createVertexTemplateFromCells([cell1], cell1.geometry.width, cell1.geometry.height, "Class");
    }),
    this.createVertexTemplateEntry("text;html=1;align=center;", 200, 25, "&lt;&lt;stereotype1, stereotype2...&gt;&gt;", "Label", null, null, dt + "label"),
    this.createVertexTemplateEntry("ellipse;", 50, 25, "icon", "Icon", null, null, dt + "icon"),
    this.addEntry(dt + "region", function() {
      var cell1 = new mxCell("", new mxGeometry(60, 0, 10, 100), "line;strokeWidth=1;direction=south;html=1;dashed=1;dashPattern=20 20;");
      cell1.vertex = true;
      var cell2 = new mxCell("Region 1", new mxGeometry(0, 40, 60, 20), "text;align=right;");
      cell2.vertex = true;
      var cell3 = new mxCell("Region 2", new mxGeometry(70, 40, 60, 20), "text;align=left;");
      cell3.vertex = true;
      return sb.createVertexTemplateFromCells([cell1, cell2, cell3], 130, cell1.geometry.height, "Region");
    }),
    this.addEntry(dt + "State", function() {
      var cell1 = new mxCell("State1<br>[invariant1]<br>&lt;&lt;extended/final&gt;&gt;", new mxGeometry(0, 0, 140, 176), "swimlane;fontStyle=4;align=center;verticalAlign=top;childLayout=stackLayout;horizontal=1;startSize=60;horizontalStack=0;resizeParent=1;resizeParentMax=0;resizeLast=0;collapsible=0;marginBottom=0;html=1;rounded=1;absoluteArcSize=1;arcSize=50;");
      cell1.vertex = true;
      var field1 = new mxCell("", new mxGeometry(0, 0, 140, 50), "fillColor=none;strokeColor=none;container=1;collapsible=0;");
      field1.vertex = true;
      cell1.insert(field1);
      var field2 = new mxCell("State2", new mxGeometry(30, 10, 80, 30), "html=1;align=center;verticalAlign=middle;rounded=1;absoluteArcSize=1;arcSize=10;");
      field2.vertex = true;
      field1.insert(field2);
      cell1.insert(divider.clone());
      var field3 = new mxCell("behavior1", new mxGeometry(0, 0, 140, 25), "fillColor=none;strokeColor=none;align=left;verticalAlign=middle;spacingLeft=5;");
      field3.vertex = true;
      cell1.insert(field3);
      cell1.insert(divider.clone());
      var field4 = new mxCell("transition1", new mxGeometry(0, 0, 140, 25), "fillColor=none;strokeColor=none;align=left;verticalAlign=middle;spacingLeft=5;");
      field4.vertex = true;
      cell1.insert(field4);
      return sb.createVertexTemplateFromCells([cell1], cell1.geometry.width, cell1.geometry.height, "State");
    }),
    this.createVertexTemplateEntry("html=1;align=center;verticalAlign=top;rounded=1;absoluteArcSize=1;arcSize=10;dashed=1;", 140, 40, "State1", "State", null, null, dt + "state"),
    this.createVertexTemplateEntry("html=1;align=center;verticalAlign=top;rounded=1;absoluteArcSize=1;arcSize=10;dashed=0;", 140, 40, "State", "State", null, null, dt + "state"),
    this.createVertexTemplateEntry("shape=folder;align=center;verticalAlign=middle;fontStyle=0;tabWidth=100;tabHeight=30;tabPosition=left;html=1;boundedLbl=1;labelInHeader=1;rounded=1;absoluteArcSize=1;arcSize=10;", 140, 90, "State1", "State", null, null, dt + "state"),
    this.createVertexTemplateEntry("html=1;align=center;verticalAlign=top;rounded=1;absoluteArcSize=1;arcSize=10;dashed=0;", 140, 40, "State1, State2, ...", "State", null, null, dt + "state"),
    this.createVertexTemplateEntry("shape=umlState;rounded=1;verticalAlign=top;spacingTop=5;umlStateSymbol=collapseState;absoluteArcSize=1;arcSize=10;", 140, 60, "State1", "State", null, null, dt + "state"),
    this.addEntry(dt + "State", function() {
      var cell1 = new mxCell("State1", new mxGeometry(40, 0, 140, 50), "shape=umlState;rounded=1;verticalAlign=middle;align=center;absoluteArcSize=1;arcSize=10;umlStateConnection=connPointRefEntry;boundedLbl=1;");
      cell1.vertex = true;
      var field1 = new mxCell("Entry1", new mxGeometry(0, 40, 50, 20), "text;verticalAlign=middle;align=center;");
      field1.vertex = true;
      cell1.insert(field1);
      return sb.createVertexTemplateFromCells([cell1, field1], 180, 60, "State");
    }),
    this.addEntry(dt + "State", function() {
      var cell1 = new mxCell("State1", new mxGeometry(40, 0, 140, 50), "shape=umlState;rounded=1;verticalAlign=middle;spacingTop=0;absoluteArcSize=1;arcSize=10;umlStateConnection=connPointRefExit;boundedLbl=1;");
      cell1.vertex = true;
      var field1 = new mxCell("Exit1", new mxGeometry(0, 40, 50, 20), "text;verticalAlign=middle;align=center;");
      field1.vertex = true;
      cell1.insert(field1);
      return sb.createVertexTemplateFromCells([cell1, field1], 180, 60, "State");
    }),
    this.createVertexTemplateEntry("ellipse;fillColor=#000000;strokeColor=none;", 30, 30, "", "Initial state", null, null, dt + "initial state"),
    this.createVertexTemplateEntry("ellipse;html=1;shape=endState;fillColor=#000000;strokeColor=#000000;", 30, 30, "", "Final state", null, null, dt + "final state"),
    this.createVertexTemplateEntry("ellipse;fillColor=#ffffff;strokeColor=#000000;", 30, 30, "H", "Shallow History", null, null, dt + "shallow history"),
    this.createVertexTemplateEntry("ellipse;fillColor=#ffffff;strokeColor=#000000;", 30, 30, "H*", "Deep History", null, null, dt + "deep history"),
    this.createVertexTemplateEntry("ellipse;fillColor=#ffffff;strokeColor=#000000;", 30, 30, "", "Entry Point", null, null, dt + "entry point"),
    this.createVertexTemplateEntry("shape=sumEllipse;perimeter=ellipsePerimeter;whiteSpace=wrap;html=1;backgroundOutline=1;", 30, 30, "", "Exit Point", null, null, dt + "exit point"),
    this.createVertexTemplateEntry("ellipse;fillColor=#000000;strokeColor=none;", 20, 20, "", "Junction", null, null, dt + "junction"),
    this.createVertexTemplateEntry("rhombus;", 30, 30, "", "Choice", null, null, dt + "choice"),
    this.createVertexTemplateEntry("shape=umlDestroy;", 30, 30, "", "Terminate", null, null, dt + "terminate"),
    this.createVertexTemplateEntry("html=1;points=[];perimeter=orthogonalPerimeter;fillColor=#000000;strokeColor=none;", 5, 80, "", "Join/Fork", null, null, dt + "join fork"),
    this.createVertexTemplateEntry("text;align=center;verticalAlign=middle;dashed=0;fillColor=#ffffff;strokeColor=#000000;", 140, 40, "OpaqueAction1 spec.", "Opaque Action", null, null, dt + "opaque action"),
    this.createEdgeTemplateEntry("html=1;verticalAlign=bottom;startArrow=oval;startFill=1;endArrow=block;startSize=8;", 60, 0, "dispatch", "Found Message 1", null, "uml sequence message call invoke dispatch"),
    this.createEdgeTemplateEntry("html=1;verticalAlign=bottom;startArrow=circle;startFill=1;endArrow=open;startSize=6;endSize=8;", 80, 0, "dispatch", "Found Message 2", null, "uml sequence message call invoke dispatch"),
    this.createEdgeTemplateEntry("html=1;verticalAlign=bottom;endArrow=block;", 80, 0, "dispatch", "Message", null, "uml sequence message call invoke dispatch"),
    this.addEntry("uml sequence return message", function() {
      var edge = new mxCell("return", new mxGeometry(0, 0, 0, 0), "html=1;verticalAlign=bottom;endArrow=open;dashed=1;endSize=8;");
      edge.geometry.setTerminalPoint(new mxPoint2(80, 0), true);
      edge.geometry.setTerminalPoint(new mxPoint2(0, 0), false);
      edge.geometry.relative = true;
      edge.edge = true;
      return sb.createEdgeTemplateFromCells([edge], 80, 0, "Return");
    }),
    this.addEntry("uml relation", function() {
      var edge = new mxCell("name", new mxGeometry(0, 0, 0, 0), "endArrow=block;endFill=1;html=1;edgeStyle=orthogonalEdgeStyle;align=left;verticalAlign=top;");
      edge.geometry.setTerminalPoint(new mxPoint2(0, 0), true);
      edge.geometry.setTerminalPoint(new mxPoint2(160, 0), false);
      edge.geometry.relative = true;
      edge.geometry.x = -1;
      edge.edge = true;
      var cell2 = new mxCell("1", new mxGeometry(-1, 0, 0, 0), "edgeLabel;resizable=0;html=1;align=left;verticalAlign=bottom;");
      cell2.geometry.relative = true;
      cell2.setConnectable(false);
      cell2.vertex = true;
      edge.insert(cell2);
      return sb.createEdgeTemplateFromCells([edge], 160, 0, "Relation 1");
    }),
    this.addEntry("uml association", function() {
      var edge = new mxCell("", new mxGeometry(0, 0, 0, 0), "endArrow=none;html=1;edgeStyle=orthogonalEdgeStyle;");
      edge.geometry.setTerminalPoint(new mxPoint2(0, 0), true);
      edge.geometry.setTerminalPoint(new mxPoint2(160, 0), false);
      edge.geometry.relative = true;
      edge.edge = true;
      var cell1 = new mxCell("parent", new mxGeometry(-1, 0, 0, 0), "edgeLabel;resizable=0;html=1;align=left;verticalAlign=bottom;");
      cell1.geometry.relative = true;
      cell1.setConnectable(false);
      cell1.vertex = true;
      edge.insert(cell1);
      var cell2 = new mxCell("child", new mxGeometry(1, 0, 0, 0), "edgeLabel;resizable=0;html=1;align=right;verticalAlign=bottom;");
      cell2.geometry.relative = true;
      cell2.setConnectable(false);
      cell2.vertex = true;
      edge.insert(cell2);
      return sb.createEdgeTemplateFromCells([edge], 160, 0, "Association 1");
    }),
    this.addEntry("uml aggregation", function() {
      var edge = new mxCell("1", new mxGeometry(0, 0, 0, 0), "endArrow=open;html=1;endSize=12;startArrow=diamondThin;startSize=14;startFill=0;edgeStyle=orthogonalEdgeStyle;align=left;verticalAlign=bottom;");
      edge.geometry.setTerminalPoint(new mxPoint2(0, 0), true);
      edge.geometry.setTerminalPoint(new mxPoint2(160, 0), false);
      edge.geometry.relative = true;
      edge.geometry.x = -1;
      edge.geometry.y = 3;
      edge.edge = true;
      return sb.createEdgeTemplateFromCells([edge], 160, 0, "Aggregation 1");
    }),
    this.addEntry("uml composition", function() {
      var edge = new mxCell("1", new mxGeometry(0, 0, 0, 0), "endArrow=open;html=1;endSize=12;startArrow=diamondThin;startSize=14;startFill=1;edgeStyle=orthogonalEdgeStyle;align=left;verticalAlign=bottom;");
      edge.geometry.setTerminalPoint(new mxPoint2(0, 0), true);
      edge.geometry.setTerminalPoint(new mxPoint2(160, 0), false);
      edge.geometry.relative = true;
      edge.geometry.x = -1;
      edge.geometry.y = 3;
      edge.edge = true;
      return sb.createEdgeTemplateFromCells([edge], 160, 0, "Composition 1");
    }),
    this.addEntry("uml relation", function() {
      var edge = new mxCell("Relation", new mxGeometry(0, 0, 0, 0), "endArrow=open;html=1;endSize=12;startArrow=diamondThin;startSize=14;startFill=0;edgeStyle=orthogonalEdgeStyle;");
      edge.geometry.setTerminalPoint(new mxPoint2(0, 0), true);
      edge.geometry.setTerminalPoint(new mxPoint2(160, 0), false);
      edge.geometry.relative = true;
      edge.edge = true;
      var cell1 = new mxCell("0..n", new mxGeometry(-1, 0, 0, 0), "edgeLabel;resizable=0;html=1;align=left;verticalAlign=top;");
      cell1.geometry.relative = true;
      cell1.setConnectable(false);
      cell1.vertex = true;
      edge.insert(cell1);
      var cell2 = new mxCell("1", new mxGeometry(1, 0, 0, 0), "edgeLabel;resizable=0;html=1;align=right;verticalAlign=top;");
      cell2.geometry.relative = true;
      cell2.setConnectable(false);
      cell2.vertex = true;
      edge.insert(cell2);
      return sb.createEdgeTemplateFromCells([edge], 160, 0, "Relation 2");
    }),
    this.createEdgeTemplateEntry("endArrow=open;endSize=12;dashed=1;html=1;", 160, 0, "Use", "Dependency", null, "uml dependency use"),
    this.createEdgeTemplateEntry("endArrow=block;endSize=16;endFill=0;html=1;", 160, 0, "Extends", "Generalization", null, "uml generalization extend"),
    this.createEdgeTemplateEntry("endArrow=block;startArrow=block;endFill=1;startFill=1;html=1;", 160, 0, "", "Association 2", null, "uml association"),
    this.createEdgeTemplateEntry("endArrow=open;startArrow=circlePlus;endFill=0;startFill=0;endSize=8;html=1;", 160, 0, "", "Inner Class", null, "uml inner class"),
    this.createEdgeTemplateEntry("endArrow=open;startArrow=cross;endFill=0;startFill=0;endSize=8;startSize=10;html=1;", 160, 0, "", "Terminate", null, "uml terminate"),
    this.createEdgeTemplateEntry("endArrow=block;dashed=1;endFill=0;endSize=12;html=1;", 160, 0, "", "Implementation", null, "uml realization implementation"),
    this.createEdgeTemplateEntry("endArrow=diamondThin;endFill=0;endSize=24;html=1;", 160, 0, "", "Aggregation 2", null, "uml aggregation"),
    this.createEdgeTemplateEntry("endArrow=diamondThin;endFill=1;endSize=24;html=1;", 160, 0, "", "Composition 2", null, "uml composition"),
    this.createEdgeTemplateEntry("endArrow=open;endFill=1;endSize=12;html=1;", 160, 0, "", "Association 3", null, "uml association")
  ];
  this.addPaletteFunctions("uml", mxResources2.get("uml"), expand || false, fns);
  this.setCurrentSearchEntryLibrary();
};
Sidebar2.prototype.addBpmnPalette = function(dir, expand) {
  var sb = this;
  this.setCurrentSearchEntryLibrary("bpmn");
  var fns = [
    this.createVertexTemplateEntry("shape=ext;rounded=1;html=1;whiteSpace=wrap;", 120, 80, "Task", "Process", null, null, "bpmn task process"),
    this.createVertexTemplateEntry("shape=ext;rounded=1;html=1;whiteSpace=wrap;double=1;", 120, 80, "Transaction", "Transaction", null, null, "bpmn transaction"),
    this.createVertexTemplateEntry("shape=ext;rounded=1;html=1;whiteSpace=wrap;dashed=1;dashPattern=1 4;", 120, 80, "Event\nSub-Process", "Event Sub-Process", null, null, "bpmn event subprocess sub process sub-process"),
    this.createVertexTemplateEntry("shape=ext;rounded=1;html=1;whiteSpace=wrap;strokeWidth=3;", 120, 80, "Call Activity", "Call Activity", null, null, "bpmn call activity"),
    this.addEntry("bpmn subprocess sub process sub-process", function() {
      var cell2 = new mxCell("Sub-Process", new mxGeometry(0, 0, 120, 80), "html=1;whiteSpace=wrap;rounded=1;dropTarget=0;");
      cell2.vertex = true;
      var cell1 = new mxCell("", new mxGeometry(0.5, 1, 14, 14), "html=1;shape=plus;outlineConnect=0;");
      cell1.vertex = true;
      cell1.geometry.relative = true;
      cell1.geometry.offset = new mxPoint2(-7, -14);
      cell2.insert(cell1);
      return sb.createVertexTemplateFromCells([cell2], cell2.geometry.width, cell2.geometry.height, "Sub-Process");
    }),
    this.addEntry(this.getTagsForStencil("mxgraph.bpmn", "loop", "subprocess sub process sub-process looped").join(" "), function() {
      var cell2 = new mxCell("Looped\nSub-Process", new mxGeometry(0, 0, 120, 80), "html=1;whiteSpace=wrap;rounded=1;dropTarget=0;");
      cell2.vertex = true;
      var cell1 = new mxCell("", new mxGeometry(0.5, 1, 14, 14), "html=1;shape=mxgraph.bpmn.loop;outlineConnect=0;");
      cell1.vertex = true;
      cell1.geometry.relative = true;
      cell1.geometry.offset = new mxPoint2(-15, -14);
      cell2.insert(cell1);
      var cell22 = new mxCell("", new mxGeometry(0.5, 1, 14, 14), "html=1;shape=plus;");
      cell22.vertex = true;
      cell22.geometry.relative = true;
      cell22.geometry.offset = new mxPoint2(1, -14);
      cell2.insert(cell22);
      return sb.createVertexTemplateFromCells([cell2], cell2.geometry.width, cell2.geometry.height, "Looped Sub-Process");
    }),
    this.addEntry("bpmn receive task", function() {
      var cell2 = new mxCell("Receive", new mxGeometry(0, 0, 120, 80), "html=1;whiteSpace=wrap;rounded=1;dropTarget=0;");
      cell2.vertex = true;
      var cell1 = new mxCell("", new mxGeometry(0, 0, 20, 14), "html=1;shape=message;outlineConnect=0;");
      cell1.vertex = true;
      cell1.geometry.relative = true;
      cell1.geometry.offset = new mxPoint2(7, 7);
      cell2.insert(cell1);
      return sb.createVertexTemplateFromCells([cell2], cell2.geometry.width, cell2.geometry.height, "Receive Task");
    }),
    this.addEntry(this.getTagsForStencil("mxgraph.bpmn", "user_task").join(" "), function() {
      var cell2 = new mxCell("User", new mxGeometry(0, 0, 120, 80), "html=1;whiteSpace=wrap;rounded=1;dropTarget=0;");
      cell2.vertex = true;
      var cell1 = new mxCell("", new mxGeometry(0, 0, 14, 14), "html=1;shape=mxgraph.bpmn.user_task;outlineConnect=0;");
      cell1.vertex = true;
      cell1.geometry.relative = true;
      cell1.geometry.offset = new mxPoint2(7, 7);
      cell2.insert(cell1);
      var cell22 = new mxCell("", new mxGeometry(0.5, 1, 14, 14), "html=1;shape=plus;outlineConnect=0;");
      cell22.vertex = true;
      cell22.geometry.relative = true;
      cell22.geometry.offset = new mxPoint2(-7, -14);
      cell2.insert(cell22);
      return sb.createVertexTemplateFromCells([cell2], cell2.geometry.width, cell2.geometry.height, "User Task");
    }),
    this.addEntry(this.getTagsForStencil("mxgraph.bpmn", "timer_start", "attached").join(" "), function() {
      var cell2 = new mxCell("Process", new mxGeometry(0, 0, 120, 80), "html=1;whiteSpace=wrap;rounded=1;dropTarget=0;");
      cell2.vertex = true;
      var cell1 = new mxCell("", new mxGeometry(1, 1, 30, 30), "shape=mxgraph.bpmn.timer_start;perimeter=ellipsePerimeter;html=1;verticalLabelPosition=bottom;verticalAlign=top;outlineConnect=0;");
      cell1.vertex = true;
      cell1.geometry.relative = true;
      cell1.geometry.offset = new mxPoint2(-40, -15);
      cell2.insert(cell1);
      return sb.createVertexTemplateFromCells([cell2], 120, 95, "Attached Timer Event 1");
    }),
    this.addEntry(this.getTagsForStencil("mxgraph.bpmn", "timer_start", "attached").join(" "), function() {
      var cell2 = new mxCell("Process", new mxGeometry(0, 0, 120, 80), "html=1;whiteSpace=wrap;rounded=1;dropTarget=0;");
      cell2.vertex = true;
      var cell1 = new mxCell("", new mxGeometry(1, 0, 30, 30), "shape=mxgraph.bpmn.timer_start;perimeter=ellipsePerimeter;html=1;labelPosition=right;align=left;outlineConnect=0;");
      cell1.vertex = true;
      cell1.geometry.relative = true;
      cell1.geometry.offset = new mxPoint2(-15, 10);
      cell2.insert(cell1);
      return sb.createVertexTemplateFromCells([cell2], 135, 80, "Attached Timer Event 2");
    }),
    this.createVertexTemplateEntry("swimlane;html=1;horizontal=0;startSize=20;", 320, 240, "Pool", "Pool", null, null, "bpmn pool"),
    this.createVertexTemplateEntry("swimlane;html=1;horizontal=0;swimlaneLine=0;", 300, 120, "Lane", "Lane", null, null, "bpmn lane"),
    this.createVertexTemplateEntry("shape=hexagon;html=1;whiteSpace=wrap;perimeter=hexagonPerimeter;rounded=0;", 60, 50, "", "Conversation", null, null, "bpmn conversation"),
    this.createVertexTemplateEntry("shape=hexagon;html=1;whiteSpace=wrap;perimeter=hexagonPerimeter;strokeWidth=4;rounded=0;", 60, 50, "", "Call Conversation", null, null, "bpmn call conversation"),
    this.addEntry("bpmn subconversation sub conversation sub-conversation", function() {
      var cell2 = new mxCell("", new mxGeometry(0, 0, 60, 50), "shape=hexagon;whiteSpace=wrap;html=1;perimeter=hexagonPerimeter;rounded=0;dropTarget=0;");
      cell2.vertex = true;
      var cell1 = new mxCell("", new mxGeometry(0.5, 1, 14, 14), "html=1;shape=plus;");
      cell1.vertex = true;
      cell1.geometry.relative = true;
      cell1.geometry.offset = new mxPoint2(-7, -14);
      cell2.insert(cell1);
      return sb.createVertexTemplateFromCells([cell2], cell2.geometry.width, cell2.geometry.height, "Sub-Conversation");
    }),
    this.addEntry("bpmn data object", function() {
      var cell2 = new mxCell("", new mxGeometry(0, 0, 40, 60), "shape=note;whiteSpace=wrap;size=16;html=1;dropTarget=0;");
      cell2.vertex = true;
      var cell1 = new mxCell("", new mxGeometry(0, 0, 14, 14), "html=1;shape=singleArrow;arrowWidth=0.4;arrowSize=0.4;outlineConnect=0;");
      cell1.vertex = true;
      cell1.geometry.relative = true;
      cell1.geometry.offset = new mxPoint2(2, 2);
      cell2.insert(cell1);
      var cell22 = new mxCell("", new mxGeometry(0.5, 1, 14, 14), "html=1;whiteSpace=wrap;shape=parallelMarker;outlineConnect=0;");
      cell22.vertex = true;
      cell22.geometry.relative = true;
      cell22.geometry.offset = new mxPoint2(-7, -14);
      cell2.insert(cell22);
      return sb.createVertexTemplateFromCells([cell2], cell2.geometry.width, cell2.geometry.height, "Data Object");
    }),
    this.createVertexTemplateEntry("shape=datastore;whiteSpace=wrap;html=1;", 60, 60, "", "Data Store", null, null, "bpmn data store"),
    this.createVertexTemplateEntry("shape=plus;html=1;outlineConnect=0;", 14, 14, "", "Sub-Process Marker", null, null, "bpmn subprocess sub process sub-process marker"),
    this.createVertexTemplateEntry("shape=mxgraph.bpmn.loop;html=1;outlineConnect=0;", 14, 14, "", "Loop Marker", null, null, "bpmn loop marker"),
    this.createVertexTemplateEntry("shape=parallelMarker;html=1;outlineConnect=0;", 14, 14, "", "Parallel MI Marker", null, null, "bpmn parallel mi marker"),
    this.createVertexTemplateEntry("shape=parallelMarker;direction=south;html=1;outlineConnect=0;", 14, 14, "", "Sequential MI Marker", null, null, "bpmn sequential mi marker"),
    this.createVertexTemplateEntry("shape=mxgraph.bpmn.ad_hoc;fillColor=#000000;html=1;outlineConnect=0;", 14, 14, "", "Ad Hoc Marker", null, null, "bpmn ad hoc marker"),
    this.createVertexTemplateEntry("shape=mxgraph.bpmn.compensation;html=1;outlineConnect=0;", 14, 14, "", "Compensation Marker", null, null, "bpmn compensation marker"),
    this.createVertexTemplateEntry("shape=message;whiteSpace=wrap;html=1;outlineConnect=0;fillColor=#000000;strokeColor=#ffffff;strokeWidth=2;", 40, 30, "", "Send Task", null, null, "bpmn send task"),
    this.createVertexTemplateEntry("shape=message;whiteSpace=wrap;html=1;outlineConnect=0;", 40, 30, "", "Receive Task", null, null, "bpmn receive task"),
    this.createVertexTemplateEntry("shape=mxgraph.bpmn.user_task;html=1;outlineConnect=0;", 14, 14, "", "User Task", null, null, this.getTagsForStencil("mxgraph.bpmn", "user_task").join(" ")),
    this.createVertexTemplateEntry("shape=mxgraph.bpmn.manual_task;html=1;outlineConnect=0;", 14, 14, "", "Manual Task", null, null, this.getTagsForStencil("mxgraph.bpmn", "user_task").join(" ")),
    this.createVertexTemplateEntry("shape=mxgraph.bpmn.business_rule_task;html=1;outlineConnect=0;", 14, 14, "", "Business Rule Task", null, null, this.getTagsForStencil("mxgraph.bpmn", "business_rule_task").join(" ")),
    this.createVertexTemplateEntry("shape=mxgraph.bpmn.service_task;html=1;outlineConnect=0;", 14, 14, "", "Service Task", null, null, this.getTagsForStencil("mxgraph.bpmn", "service_task").join(" ")),
    this.createVertexTemplateEntry("shape=mxgraph.bpmn.script_task;html=1;outlineConnect=0;", 14, 14, "", "Script Task", null, null, this.getTagsForStencil("mxgraph.bpmn", "script_task").join(" ")),
    this.createVertexTemplateEntry("html=1;shape=mxgraph.flowchart.annotation_2;align=left;labelPosition=right;", 50, 100, "", "Annotation", null, null, this.getTagsForStencil("bpmn", "annotation_1", "bpmn business process model ").join(" ")),
    this.addDataEntry("crossfunctional cross-functional cross functional flowchart swimlane table", 400, 400, "Cross-Functional Flowchart", "7ZhRb5swEMc/DY+bMCRt97jQpi+tVC2fwINbbMnYyD4C6aefjaHpBrTRlNCoTALJPp9t+P25O5kgTvL6XtOCPaoMRBDfBXGilULfyusEhAiikGdBfBtEUWjvIFqPjJJmNCyoBonHTIj8hB0VJXiL3dyYL+tSpsiVpM55LVSVMqrROxvci9bZMFq4JtKfzrRKGRfZA92rEjtr11tpVT1wCcYOhM5ViTKXry0G7RYb/uwWXDgDw9wCuSW2WTGOsClo6gYri8uvIGhheLN1s4KGtNSG7+AHGL+Os0JdUJm1nUJxiaDvdhZQt/EvJXHTvpTbjAq+lbadgnO1hhYSaIR6FHRjainfg8oB9d66VDxD5j0WoRcjZMC3DP8yUuMN25e5B91so5VuWMa4J+P3FJW2JtLXrOK5oNLJxZTmz/blqXhNp3mO5cpe9smS8OsyWNp5ie2TQ99ezl1joqRBTXmDAajBCgxejprHKBcNK7fvBPIz3hOSRCcQctET8olRA+8JmSopIW2j8GOD6Sji8TDxepT4C9yTE1+OEo/mQ5xcTYn8ahR5PB/k0c2UyK9HC8SbX/mnLBAnqAlD8XK+onDTE+/fw+TiQF9fTin4Nl/O0xYAEs6X9LR5n5Ae6S7xv1lr/yf+4cQ/pN75Ej/pH88/UZyQkRPzR6R+0j9Bz4f0xMm/f8adD+qzZn/bPfw5bMb++LH4Gw=="),
    this.addDataEntry("container swimlane pool horizontal", 480, 380, "Horizontal Pool 1", "zZRLbsIwEIZP4709TlHXhJYNSEicwCIjbNWJkWNKwumZxA6IlrRUaisWlmb+eX8LM5mXzdyrnV66Ai2TL0zm3rkQrbLJ0VoG3BRMzhgAp8fgdSQq+ijfKY9VuKcAYsG7snuMyso5G8U6tDaJ9cGUVlXkTXUoacuZIHOjjS0WqnX7blYd1OZt8KYea3PE1bCI+CAtVUMq7/o5b46uCmroSn18WFMm+XCdse5GpLq0OPqAzejxvZQun6MrMfiWUg6mCDpmZM8RENdotjqVyUFUdRS259oLSzISztto5Se0i44gcHEn3i9A/IQB3GbQpmi69DskAn4BSTaGBB4Jicj+k8nTGBP5SExg8odMyL38eH3s6kM8AQ=="),
    this.addDataEntry("container swimlane pool horizontal", 480, 360, "Horizontal Pool 2", "zZTBbsIwDIafJvfU6dDOlI0LSEg8QUQtEi1tUBJGy9PPbcJQWTsxaZs4VLJ//07sT1WYKKpm6eRBrW2JhokXJgpnbYhR1RRoDAOuSyYWDIDTx+B1opr1VX6QDutwTwPEhndpjhiVjbUmij60Jon+pCsja8rmKlQ05SKjcKe0KVeytcfuLh/k7u2SzR16fcbNZZDsRlrLhlTenWedPts6SJMEOseFLTkph6Fj212RbGlwdAGbyeV7KW2+RFthcC1ZTroMKjry5wiIK9R7ldrELInSR2H/2XtlSUHCOY5WfEG76ggCz+7E+w2InzCAcQapIf0fAySzESQZ/AKSfAoJPCKS9mbzf0H0NIVIPDAiyP8QEaXX97CvDZ7LDw=="),
    this.createVertexTemplateEntry("swimlane;startSize=20;horizontal=0;", 320, 120, "Lane", "Horizontal Swimlane", null, null, "swimlane lane pool"),
    this.addDataEntry("container swimlane pool horizontal", 360, 480, "Vertical Pool 1", "xZRBbsIwEEVP4709ThFrQssGJKSewCIjbNXGyDEl4fSdxKa0NJFQVTULSzP/e+T5b2EmS9esgjrqja/QMvnMZBm8j6lyTYnWMuCmYnLJADgdBi8jruhdflQBD/GRAUgD78qeMClb720S69jaLNZn46w6ULfQ0dGWS0HlThtbrVXrT91bdVS7t2u3CFibC26vi4g7aaMaUjmpNBbiKxnUQyfkjTBEbEZT9VKOtELvMIaWrpxNFXW6IWcpOddo9jqPFfMsqjoJ+8/ZGyQqMqdhZvIHs3WHBrh4kNvvIsNw5Da7OdgXAgKGCMz+gEAxRgCmINDcxZ2CyNMYETkhESj+jwi1t1+r9759ah8="),
    this.addDataEntry("container swimlane pool vertical", 380, 480, "Vertical Pool 2", "xZTPbsIwDMafJvf86dDOlI0LSEg8QUQtEi1pUBJGy9PPbdJ1G1TqhXGoZH/219g/RSGitM3ay5PaugoMEW9ElN65mCLblGAM4VRXRKwI5xQ/wt8nqqyv0pP0UMc5Bp4Mn9KcISk750wSQ2xNFsNFWyNrzJYqWpxyxTA8KG2qjWzduTsrRHn4GLKlh6CvsBsGYX+krWxQpaiizcc9FjDnnaCc11dXR2lyxyjsuyPy3/Lg4CM0k8v3Ut58Dc5C9C22XHQVVeoQrwkQVaCPKtuKQZQhCcdv78gSg4zzPlpxg3bTEeSUzcR7Q2bWyvz+ytmQr8NPAow/ikAxRYA/kQAr/hPByxQC8cxLsHggAkzH56uv/XrdvgA="),
    this.createVertexTemplateEntry("swimlane;startSize=20;", 120, 320, "Lane", "Vertical Swimlane", null, null, "swimlane lane pool"),
    this.createVertexTemplateEntry("rounded=1;arcSize=10;dashed=1;strokeColor=#000000;fillColor=none;gradientColor=none;dashPattern=8 3 1 3;strokeWidth=2;", 200, 200, "", "Group", null, null, this.getTagsForStencil("bpmn", "group", "bpmn business process model ").join(" ")),
    this.createEdgeTemplateEntry("endArrow=block;endFill=1;endSize=6;html=1;", 100, 0, "", "Sequence Flow", null, "bpmn sequence flow"),
    this.createEdgeTemplateEntry("startArrow=dash;startSize=8;endArrow=block;endFill=1;endSize=6;html=1;", 100, 0, "", "Default Flow", null, "bpmn default flow"),
    this.createEdgeTemplateEntry("startArrow=diamondThin;startFill=0;startSize=14;endArrow=block;endFill=1;endSize=6;html=1;", 100, 0, "", "Conditional Flow", null, "bpmn conditional flow"),
    this.createEdgeTemplateEntry("startArrow=oval;startFill=0;startSize=7;endArrow=block;endFill=0;endSize=10;dashed=1;html=1;", 100, 0, "", "Message Flow 1", null, "bpmn message flow"),
    this.addEntry("bpmn message flow", function() {
      var edge = new mxCell("", new mxGeometry(0, 0, 0, 0), "startArrow=oval;startFill=0;startSize=7;endArrow=block;endFill=0;endSize=10;dashed=1;html=1;");
      edge.geometry.setTerminalPoint(new mxPoint2(0, 0), true);
      edge.geometry.setTerminalPoint(new mxPoint2(100, 0), false);
      edge.geometry.relative = true;
      edge.edge = true;
      var cell2 = new mxCell("", new mxGeometry(0, 0, 20, 14), "shape=message;html=1;outlineConnect=0;");
      cell2.geometry.relative = true;
      cell2.vertex = true;
      cell2.geometry.offset = new mxPoint2(-10, -7);
      edge.insert(cell2);
      return sb.createEdgeTemplateFromCells([edge], 100, 0, "Message Flow 2");
    }),
    this.createEdgeTemplateEntry("shape=link;html=1;", 100, 0, "", "Link", null, "bpmn link")
  ];
  this.addPaletteFunctions("bpmn", "BPMN " + mxResources2.get("general"), false, fns);
  this.setCurrentSearchEntryLibrary();
};
Sidebar2.prototype.createTitle = function(label) {
  var elt = document.createElement("a");
  elt.setAttribute("title", mxResources2.get("sidebarTooltip"));
  elt.className = "geTitle";
  write(elt, label);
  return elt;
};
Sidebar2.prototype.createThumb = function(cells, width, height, parent2, title, showLabel, showTitle, realWidth, realHeight) {
  this.graph.labelsVisible = showLabel == null || showLabel;
  var fo = mxClient_default.NO_FO;
  mxClient_default.NO_FO = Editor2.prototype.originalNoForeignObject;
  this.graph.view.scaleAndTranslate(1, 0, 0);
  this.graph.addCells(cells);
  var bounds = this.graph.getGraphBounds();
  var s = Math.floor(Math.min((width - 2 * this.thumbBorder) / bounds.width, (height - 2 * this.thumbBorder) / bounds.height) * 100) / 100;
  this.graph.view.scaleAndTranslate(s, Math.floor((width - bounds.width * s) / 2 / s - bounds.x), Math.floor((height - bounds.height * s) / 2 / s - bounds.y));
  var node = null;
  if (this.graph.dialect == mxConstants2.DIALECT_SVG && !mxClient_default.NO_FO && this.graph.view.getCanvas().ownerSVGElement != null) {
    node = this.graph.view.getCanvas().ownerSVGElement.cloneNode(true);
  } else {
    node = this.graph.container.cloneNode(false);
    node.innerHTML = this.graph.container.innerHTML;
    if (mxClient_default.IS_QUIRKS || document.documentMode == 8) {
      node.firstChild.style.overflow = "visible";
    }
  }
  this.graph.getModel().clear();
  mxClient_default.NO_FO = fo;
  if (mxClient_default.IS_IE6) {
    parent2.style.backgroundImage = "url(" + this.editorUi.editor.transparentImage + ")";
  }
  node.style.position = "relative";
  node.style.overflow = "hidden";
  node.style.left = this.thumbBorder + "px";
  node.style.top = this.thumbBorder + "px";
  node.style.width = width + "px";
  node.style.height = height + "px";
  node.style.visibility = "";
  node.style.minWidth = "";
  node.style.minHeight = "";
  parent2.appendChild(node);
  if (this.sidebarTitles && title != null && showTitle != false) {
    var border = mxClient_default.IS_QUIRKS ? 2 * this.thumbPadding + 2 : 0;
    parent2.style.height = this.thumbHeight + border + this.sidebarTitleSize + 8 + "px";
    var div = document.createElement("div");
    div.style.fontSize = this.sidebarTitleSize + "px";
    div.style.color = "#303030";
    div.style.textAlign = "center";
    div.style.whiteSpace = "nowrap";
    if (mxClient_default.IS_IE) {
      div.style.height = this.sidebarTitleSize + 12 + "px";
    }
    div.style.paddingTop = "4px";
    write(div, title);
    parent2.appendChild(div);
  }
  return bounds;
};
Sidebar2.prototype.createItem = function(cells, title, showLabel, showTitle, width, height, allowCellsInserted) {
  var elt = document.createElement("a");
  elt.className = "geItem";
  elt.style.overflow = "hidden";
  var border = mxClient_default.IS_QUIRKS ? 8 + 2 * this.thumbPadding : 2 * this.thumbBorder;
  elt.style.width = this.thumbWidth + border + "px";
  elt.style.height = this.thumbHeight + border + "px";
  elt.style.padding = this.thumbPadding + "px";
  if (mxClient_default.IS_IE6) {
    elt.style.border = "none";
  }
  mxEvent2.addListener(elt, "click", function(evt) {
    mxEvent2.consume(evt);
  });
  this.createThumb(cells, this.thumbWidth, this.thumbHeight, elt, title, showLabel, showTitle, width, height);
  var bounds = new mxRectangle(0, 0, width, height);
  if (cells.length > 1 || cells[0].vertex) {
    var ds = this.createDragSource(elt, this.createDropHandler(cells, true, allowCellsInserted, bounds), this.createDragPreview(width, height), cells, bounds);
    this.addClickHandler(elt, ds, cells);
    ds.isGuidesEnabled = bind(this, function() {
      return this.editorUi.editor.graph.graphHandler.guidesEnabled;
    });
  } else if (cells[0] != null && cells[0].edge) {
    var ds = this.createDragSource(elt, this.createDropHandler(cells, false, allowCellsInserted, bounds), this.createDragPreview(width, height), cells, bounds);
    this.addClickHandler(elt, ds, cells);
  }
  if (!mxClient_default.IS_IOS) {
    mxEvent2.addGestureListeners(elt, null, bind(this, function(evt) {
      if (mxEvent2.isMouseEvent(evt)) {
        this.showTooltip(elt, cells, bounds.width, bounds.height, title, showLabel);
      }
    }));
  }
  return elt;
};
Sidebar2.prototype.updateShapes = function(source, targets) {
  var graph = this.editorUi.editor.graph;
  var sourceCellStyle = graph.getCellStyle(source);
  var result2 = [];
  graph.model.beginUpdate();
  try {
    var cellStyle = graph.getModel().getStyle(source);
    var styles = [
      "shadow",
      "dashed",
      "dashPattern",
      "fontFamily",
      "fontSize",
      "fontColor",
      "align",
      "startFill",
      "startSize",
      "endFill",
      "endSize",
      "strokeColor",
      "strokeWidth",
      "fillColor",
      "gradientColor",
      "html",
      "part",
      "noEdgeStyle",
      "edgeStyle",
      "elbow",
      "childLayout",
      "recursiveResize",
      "container",
      "collapsible",
      "connectable",
      "comic",
      "sketch",
      "fillWeight",
      "hachureGap",
      "hachureAngle",
      "jiggle",
      "disableMultiStroke",
      "disableMultiStrokeFill",
      "fillStyle",
      "curveFitting",
      "simplification",
      "sketchStyle"
    ];
    for (var i = 0; i < targets.length; i++) {
      var targetCell = targets[i];
      if (graph.getModel().isVertex(targetCell) == graph.getModel().isVertex(source) || graph.getModel().isEdge(targetCell) == graph.getModel().isEdge(source)) {
        var style = graph.getCurrentCellStyle(targets[i]);
        graph.getModel().setStyle(targetCell, cellStyle);
        if (getValue(style, "composite", "0") == "1") {
          var childCount = graph.model.getChildCount(targetCell);
          for (var j = childCount; j >= 0; j--) {
            graph.model.remove(graph.model.getChildAt(targetCell, j));
          }
        }
        if (style[mxConstants2.STYLE_SHAPE] == "umlLifeline" && sourceCellStyle[mxConstants2.STYLE_SHAPE] != "umlLifeline") {
          graph.setCellStyles(mxConstants2.STYLE_SHAPE, "umlLifeline", [
            targetCell
          ]);
          graph.setCellStyles("participant", sourceCellStyle[mxConstants2.STYLE_SHAPE], [targetCell]);
        }
        for (var j = 0; j < styles.length; j++) {
          var value = style[styles[j]];
          if (value != null) {
            graph.setCellStyles(styles[j], value, [targetCell]);
          }
        }
        result2.push(targetCell);
      }
    }
  } finally {
    graph.model.endUpdate();
  }
  return result2;
};
Sidebar2.prototype.createDropHandler = function(cells, allowSplit, allowCellsInserted, bounds) {
  allowCellsInserted = allowCellsInserted != null ? allowCellsInserted : true;
  return bind(this, function(graph, evt, target, x, y, force) {
    var elt = force ? null : mxEvent2.isTouchEvent(evt) || mxEvent2.isPenEvent(evt) ? document.elementFromPoint(mxEvent2.getClientX(evt), mxEvent2.getClientY(evt)) : mxEvent2.getSource(evt);
    while (elt != null && elt != this.container) {
      elt = elt.parentNode;
    }
    if (elt == null && graph.isEnabled()) {
      cells = graph.getImportableCells(cells);
      if (cells.length > 0) {
        graph.stopEditing();
        var validDropTarget = target != null && !mxEvent2.isAltDown(evt) ? graph.isValidDropTarget(target, cells, evt) : false;
        var select = null;
        if (target != null && !validDropTarget) {
          target = null;
        }
        if (!graph.isCellLocked(target || graph.getDefaultParent())) {
          graph.model.beginUpdate();
          try {
            x = Math.round(x);
            y = Math.round(y);
            if (allowSplit && graph.isSplitTarget(target, cells, evt)) {
              var s = graph.view.scale;
              var tr = graph.view.translate;
              var tx = (x + tr.x) * s;
              var ty = (y + tr.y) * s;
              var clones = graph.cloneCells(cells);
              graph.splitEdge(target, clones, null, x - bounds.width / 2, y - bounds.height / 2, tx, ty);
              select = clones;
            } else if (cells.length > 0) {
              select = graph.importCells(cells, x, y, target);
            }
            if (graph.layoutManager != null) {
              var layout = graph.layoutManager.getLayout(target);
              if (layout != null) {
                var s = graph.view.scale;
                var tr = graph.view.translate;
                var tx = (x + tr.x) * s;
                var ty = (y + tr.y) * s;
                for (var i = 0; i < select.length; i++) {
                  layout.moveCell(select[i], tx, ty);
                }
              }
            }
            if (allowCellsInserted && (evt == null || !mxEvent2.isShiftDown(evt))) {
              graph.fireEvent(new mxEventObject2("cellsInserted", "cells", select));
            }
          } catch (e) {
            this.editorUi.handleError(e);
          } finally {
            graph.model.endUpdate();
          }
          if (select != null && select.length > 0) {
            graph.scrollCellToVisible(select[0]);
            graph.setSelectionCells(select);
          }
          if (graph.editAfterInsert && evt != null && mxEvent2.isMouseEvent(evt) && select != null && select.length == 1) {
            window.setTimeout(function() {
              graph.startEditing(select[0]);
            }, 0);
          }
        }
      }
      mxEvent2.consume(evt);
    }
  });
};
Sidebar2.prototype.createDragPreview = function(width, height) {
  var elt = document.createElement("div");
  elt.style.border = this.dragPreviewBorder;
  elt.style.width = width + "px";
  elt.style.height = height + "px";
  return elt;
};
Sidebar2.prototype.dropAndConnect = function(source, targets, direction, dropCellIndex, evt) {
  var geo = this.getDropAndConnectGeometry(source, targets[dropCellIndex], direction, targets);
  var tmp = [];
  if (geo != null) {
    var graph = this.editorUi.editor.graph;
    var editingCell = null;
    graph.model.beginUpdate();
    try {
      var sourceGeo = graph.getCellGeometry(source);
      var geo2 = graph.getCellGeometry(targets[dropCellIndex]);
      var targetParent = graph.model.getParent(source);
      var validLayout = true;
      if (graph.layoutManager != null) {
        var layout = graph.layoutManager.getLayout(targetParent);
        if (layout != null && layout.constructor == mxStackLayout) {
          validLayout = false;
        }
      }
      var tmp = graph.model.isEdge(source) ? null : graph.view.getState(targetParent);
      var dx = 0;
      var dy = 0;
      if (tmp != null) {
        var offset = tmp.origin;
        dx = offset.x;
        dy = offset.y;
        var pt = geo.getTerminalPoint(false);
        if (pt != null) {
          pt.x += offset.x;
          pt.y += offset.y;
        }
      }
      var useParent = !graph.isTableRow(source) && !graph.isTableCell(source) && (graph.model.isEdge(source) || sourceGeo != null && !sourceGeo.relative && validLayout);
      var tempTarget = graph.getCellAt((geo.x + dx + graph.view.translate.x) * graph.view.scale, (geo.y + dy + graph.view.translate.y) * graph.view.scale, null, null, null, function(state2, x, y) {
        return !graph.isContainer(state2.cell);
      });
      if (tempTarget != null && tempTarget != targetParent) {
        tmp = graph.view.getState(tempTarget);
        if (tmp != null) {
          var offset = tmp.origin;
          targetParent = tempTarget;
          useParent = true;
          if (!graph.model.isEdge(source)) {
            geo.x -= offset.x - dx;
            geo.y -= offset.y - dy;
          }
        }
      } else if (!validLayout || graph.isTableRow(source) || graph.isTableCell(source)) {
        geo.x += dx;
        geo.y += dy;
      }
      dx = geo2.x;
      dy = geo2.y;
      if (graph.model.isEdge(targets[dropCellIndex])) {
        dx = 0;
        dy = 0;
      }
      targets = graph.importCells(targets, geo.x - (useParent ? dx : 0), geo.y - (useParent ? dy : 0), useParent ? targetParent : null);
      tmp = targets;
      if (graph.model.isEdge(source)) {
        graph.model.setTerminal(source, targets[dropCellIndex], direction == mxConstants2.DIRECTION_NORTH);
      } else if (graph.model.isEdge(targets[dropCellIndex])) {
        graph.model.setTerminal(targets[dropCellIndex], source, true);
        var geo3 = graph.getCellGeometry(targets[dropCellIndex]);
        geo3.points = null;
        if (geo3.getTerminalPoint(false) != null) {
          geo3.setTerminalPoint(geo.getTerminalPoint(false), false);
        } else if (useParent && graph.model.isVertex(targetParent)) {
          var tmpState = graph.view.getState(targetParent);
          var offset = tmpState.cell != graph.view.currentRoot ? tmpState.origin : new mxPoint2(0, 0);
          graph.cellsMoved(targets, offset.x, offset.y, null, null, true);
        }
      } else {
        geo2 = graph.getCellGeometry(targets[dropCellIndex]);
        dx = geo.x - Math.round(geo2.x);
        dy = geo.y - Math.round(geo2.y);
        geo.x = Math.round(geo2.x);
        geo.y = Math.round(geo2.y);
        graph.model.setGeometry(targets[dropCellIndex], geo);
        graph.cellsMoved(targets, dx, dy, null, null, true);
        tmp = targets.slice();
        editingCell = tmp.length == 1 ? tmp[0] : null;
        targets.push(graph.insertEdge(null, null, "", source, targets[dropCellIndex], graph.createCurrentEdgeStyle()));
      }
      if (evt == null || !mxEvent2.isShiftDown(evt)) {
        graph.fireEvent(new mxEventObject2("cellsInserted", "cells", targets));
      }
    } catch (e) {
      this.editorUi.handleError(e);
    } finally {
      graph.model.endUpdate();
    }
    if (graph.editAfterInsert && evt != null && mxEvent2.isMouseEvent(evt) && editingCell != null) {
      window.setTimeout(function() {
        graph.startEditing(editingCell);
      }, 0);
    }
  }
  return tmp;
};
Sidebar2.prototype.getDropAndConnectGeometry = function(source, target, direction, targets) {
  var graph = this.editorUi.editor.graph;
  var view = graph.view;
  var keepSize = targets.length > 1;
  var geo = graph.getCellGeometry(source);
  var geo2 = graph.getCellGeometry(target);
  if (geo != null && geo2 != null) {
    geo2 = geo2.clone();
    if (graph.model.isEdge(source)) {
      var state2 = graph.view.getState(source);
      var pts = state2.absolutePoints;
      var p0 = pts[0];
      var pe = pts[pts.length - 1];
      if (direction == mxConstants2.DIRECTION_NORTH) {
        geo2.x = p0.x / view.scale - view.translate.x - geo2.width / 2;
        geo2.y = p0.y / view.scale - view.translate.y - geo2.height / 2;
      } else {
        geo2.x = pe.x / view.scale - view.translate.x - geo2.width / 2;
        geo2.y = pe.y / view.scale - view.translate.y - geo2.height / 2;
      }
    } else {
      if (geo.relative) {
        var state2 = graph.view.getState(source);
        geo = geo.clone();
        geo.x = (state2.x - view.translate.x) / view.scale;
        geo.y = (state2.y - view.translate.y) / view.scale;
      }
      var length = graph.defaultEdgeLength;
      if (graph.model.isEdge(target) && geo2.getTerminalPoint(true) != null && geo2.getTerminalPoint(false) != null) {
        var p0 = geo2.getTerminalPoint(true);
        var pe = geo2.getTerminalPoint(false);
        var dx = pe.x - p0.x;
        var dy = pe.y - p0.y;
        length = Math.sqrt(dx * dx + dy * dy);
        geo2.x = geo.getCenterX();
        geo2.y = geo.getCenterY();
        geo2.width = 1;
        geo2.height = 1;
        if (direction == mxConstants2.DIRECTION_NORTH) {
          geo2.height = length;
          geo2.y = geo.y - length;
          geo2.setTerminalPoint(new mxPoint2(geo2.x, geo2.y), false);
        } else if (direction == mxConstants2.DIRECTION_EAST) {
          geo2.width = length;
          geo2.x = geo.x + geo.width;
          geo2.setTerminalPoint(new mxPoint2(geo2.x + geo2.width, geo2.y), false);
        } else if (direction == mxConstants2.DIRECTION_SOUTH) {
          geo2.height = length;
          geo2.y = geo.y + geo.height;
          geo2.setTerminalPoint(new mxPoint2(geo2.x, geo2.y + geo2.height), false);
        } else if (direction == mxConstants2.DIRECTION_WEST) {
          geo2.width = length;
          geo2.x = geo.x - length;
          geo2.setTerminalPoint(new mxPoint2(geo2.x, geo2.y), false);
        }
      } else {
        if (!keepSize && geo2.width > 45 && geo2.height > 45 && geo.width > 45 && geo.height > 45) {
          geo2.width = geo2.width * (geo.height / geo2.height);
          geo2.height = geo.height;
        }
        geo2.x = geo.x + geo.width / 2 - geo2.width / 2;
        geo2.y = geo.y + geo.height / 2 - geo2.height / 2;
        if (direction == mxConstants2.DIRECTION_NORTH) {
          geo2.y = geo2.y - geo.height / 2 - geo2.height / 2 - length;
        } else if (direction == mxConstants2.DIRECTION_EAST) {
          geo2.x = geo2.x + geo.width / 2 + geo2.width / 2 + length;
        } else if (direction == mxConstants2.DIRECTION_SOUTH) {
          geo2.y = geo2.y + geo.height / 2 + geo2.height / 2 + length;
        } else if (direction == mxConstants2.DIRECTION_WEST) {
          geo2.x = geo2.x - geo.width / 2 - geo2.width / 2 - length;
        }
        if (graph.model.isEdge(target) && geo2.getTerminalPoint(true) != null && target.getTerminal(false) != null) {
          var targetGeo = graph.getCellGeometry(target.getTerminal(false));
          if (targetGeo != null) {
            if (direction == mxConstants2.DIRECTION_NORTH) {
              geo2.x -= targetGeo.getCenterX();
              geo2.y -= targetGeo.getCenterY() + targetGeo.height / 2;
            } else if (direction == mxConstants2.DIRECTION_EAST) {
              geo2.x -= targetGeo.getCenterX() - targetGeo.width / 2;
              geo2.y -= targetGeo.getCenterY();
            } else if (direction == mxConstants2.DIRECTION_SOUTH) {
              geo2.x -= targetGeo.getCenterX();
              geo2.y -= targetGeo.getCenterY() - targetGeo.height / 2;
            } else if (direction == mxConstants2.DIRECTION_WEST) {
              geo2.x -= targetGeo.getCenterX() + targetGeo.width / 2;
              geo2.y -= targetGeo.getCenterY();
            }
          }
        }
      }
    }
  }
  return geo2;
};
Sidebar2.prototype.isDropStyleEnabled = function(cells, firstVertex) {
  var result2 = true;
  if (firstVertex != null && cells.length == 1) {
    var vstyle = this.graph.getCellStyle(cells[firstVertex]);
    if (vstyle != null) {
      result2 = getValue(vstyle, mxConstants2.STYLE_STROKECOLOR, mxConstants2.NONE) != mxConstants2.NONE || getValue(vstyle, mxConstants2.STYLE_FILLCOLOR, mxConstants2.NONE) != mxConstants2.NONE;
    }
  }
  return result2;
};
Sidebar2.prototype.isDropStyleTargetIgnored = function(state2) {
  return this.graph.isSwimlane(state2.cell) || this.graph.isTableCell(state2.cell) || this.graph.isTableRow(state2.cell) || this.graph.isTable(state2.cell);
};
Sidebar2.prototype.createDragSource = function(elt, dropHandler, preview, cells, bounds) {
  var ui = this.editorUi;
  var graph = ui.editor.graph;
  var freeSourceEdge = null;
  var firstVertex = null;
  var sidebar = this;
  for (var i = 0; i < cells.length; i++) {
    if (firstVertex == null && graph.model.isVertex(cells[i])) {
      firstVertex = i;
    } else if (freeSourceEdge == null && graph.model.isEdge(cells[i]) && graph.model.getTerminal(cells[i], true) == null) {
      freeSourceEdge = i;
    }
    if (firstVertex != null && freeSourceEdge != null) {
      break;
    }
  }
  var dropStyleEnabled = this.isDropStyleEnabled(cells, firstVertex);
  var dragSource = makeDraggable(elt, graph, bind(this, function(graph2, evt, target, x, y) {
    if (this.updateThread != null) {
      window.clearTimeout(this.updateThread);
    }
    if (cells != null && currentStyleTarget != null && activeArrow == styleTarget) {
      var tmp = graph2.isCellSelected(currentStyleTarget.cell) ? graph2.getSelectionCells() : [currentStyleTarget.cell];
      var updatedCells = this.updateShapes(graph2.model.isEdge(currentStyleTarget.cell) ? cells[0] : cells[firstVertex], tmp);
      graph2.setSelectionCells(updatedCells);
    } else if (cells != null && activeArrow != null && currentTargetState != null && activeArrow != styleTarget) {
      var index = graph2.model.isEdge(currentTargetState.cell) || freeSourceEdge == null ? firstVertex : freeSourceEdge;
      graph2.setSelectionCells(this.dropAndConnect(currentTargetState.cell, cells, direction, index, evt));
    } else {
      dropHandler.apply(this, arguments);
    }
    if (this.editorUi.hoverIcons != null) {
      this.editorUi.hoverIcons.update(graph2.view.getState(graph2.getSelectionCell()));
    }
  }), preview, 0, 0, graph.autoscroll, true, true);
  graph.addListener(mxEvent2.ESCAPE, function(sender, evt) {
    if (dragSource.isActive()) {
      dragSource.reset();
    }
  });
  var mouseDown2 = dragSource.mouseDown;
  dragSource.mouseDown = function(evt) {
    if (!mxEvent2.isPopupTrigger(evt) && !mxEvent2.isMultiTouchEvent(evt)) {
      graph.stopEditing();
      mouseDown2.apply(this, arguments);
    }
  };
  var sidebar = this;
  function createArrow2(img, tooltip) {
    var arrow = null;
    if (mxClient_default.IS_IE && !mxClient_default.IS_SVG) {
      if (mxClient_default.IS_IE6 && document.compatMode != "CSS1Compat") {
        arrow = document.createElement(mxClient_default.VML_PREFIX + ":image");
        arrow.setAttribute("src", img.src);
        arrow.style.borderStyle = "none";
      } else {
        arrow = document.createElement("div");
        arrow.style.backgroundImage = "url(" + img.src + ")";
        arrow.style.backgroundPosition = "center";
        arrow.style.backgroundRepeat = "no-repeat";
      }
      arrow.style.width = img.width + 4 + "px";
      arrow.style.height = img.height + 4 + "px";
      arrow.style.display = mxClient_default.IS_QUIRKS ? "inline" : "inline-block";
    } else {
      arrow = createImage(img.src);
      arrow.style.width = img.width + "px";
      arrow.style.height = img.height + "px";
    }
    if (tooltip != null) {
      arrow.setAttribute("title", tooltip);
    }
    setOpacity(arrow, img == sidebar.refreshTarget ? 30 : 20);
    arrow.style.position = "absolute";
    arrow.style.cursor = "crosshair";
    return arrow;
  }
  var currentTargetState = null;
  var currentStateHandle = null;
  var currentStyleTarget = null;
  var activeTarget = false;
  var arrowUp = createArrow2(this.triangleUp, mxResources2.get("connect"));
  var arrowRight = createArrow2(this.triangleRight, mxResources2.get("connect"));
  var arrowDown = createArrow2(this.triangleDown, mxResources2.get("connect"));
  var arrowLeft = createArrow2(this.triangleLeft, mxResources2.get("connect"));
  var styleTarget = createArrow2(this.refreshTarget, mxResources2.get("replace"));
  var styleTargetParent = null;
  var roundSource = createArrow2(this.roundDrop);
  var roundTarget = createArrow2(this.roundDrop);
  var direction = mxConstants2.DIRECTION_NORTH;
  var activeArrow = null;
  function checkArrow(x, y, bounds2, arrow) {
    if (arrow.parentNode != null) {
      if (contains(bounds2, x, y)) {
        setOpacity(arrow, 100);
        activeArrow = arrow;
      } else {
        setOpacity(arrow, arrow == styleTarget ? 30 : 20);
      }
    }
    return bounds2;
  }
  var dsCreatePreviewElement = dragSource.createPreviewElement;
  dragSource.createPreviewElement = function(graph2) {
    var elt2 = dsCreatePreviewElement.apply(this, arguments);
    if (mxClient_default.IS_SVG) {
      elt2.style.pointerEvents = "none";
    }
    this.previewElementWidth = elt2.style.width;
    this.previewElementHeight = elt2.style.height;
    return elt2;
  };
  var dragEnter = dragSource.dragEnter;
  dragSource.dragEnter = function(graph2, evt) {
    if (ui.hoverIcons != null) {
      ui.hoverIcons.setDisplay("none");
    }
    dragEnter.apply(this, arguments);
  };
  var dragExit = dragSource.dragExit;
  dragSource.dragExit = function(graph2, evt) {
    if (ui.hoverIcons != null) {
      ui.hoverIcons.setDisplay("");
    }
    dragExit.apply(this, arguments);
  };
  dragSource.dragOver = function(graph2, evt) {
    mxDragSource.prototype.dragOver.apply(this, arguments);
    if (this.currentGuide != null && activeArrow != null) {
      this.currentGuide.hide();
    }
    if (this.previewElement != null) {
      var view = graph2.view;
      if (currentStyleTarget != null && activeArrow == styleTarget) {
        this.previewElement.style.display = graph2.model.isEdge(currentStyleTarget.cell) ? "none" : "";
        this.previewElement.style.left = currentStyleTarget.x + "px";
        this.previewElement.style.top = currentStyleTarget.y + "px";
        this.previewElement.style.width = currentStyleTarget.width + "px";
        this.previewElement.style.height = currentStyleTarget.height + "px";
      } else if (currentTargetState != null && activeArrow != null) {
        if (dragSource.currentHighlight != null && dragSource.currentHighlight.state != null) {
          dragSource.currentHighlight.hide();
        }
        var index = graph2.model.isEdge(currentTargetState.cell) || freeSourceEdge == null ? firstVertex : freeSourceEdge;
        var geo = sidebar.getDropAndConnectGeometry(currentTargetState.cell, cells[index], direction, cells);
        var geo2 = !graph2.model.isEdge(currentTargetState.cell) ? graph2.getCellGeometry(currentTargetState.cell) : null;
        var geo3 = graph2.getCellGeometry(cells[index]);
        var parent2 = graph2.model.getParent(currentTargetState.cell);
        var dx = view.translate.x * view.scale;
        var dy = view.translate.y * view.scale;
        if (geo2 != null && !geo2.relative && graph2.model.isVertex(parent2) && parent2 != view.currentRoot) {
          var pState = view.getState(parent2);
          dx = pState.x;
          dy = pState.y;
        }
        var dx2 = geo3.x;
        var dy2 = geo3.y;
        if (graph2.model.isEdge(cells[index])) {
          dx2 = 0;
          dy2 = 0;
        }
        this.previewElement.style.left = (geo.x - dx2) * view.scale + dx + "px";
        this.previewElement.style.top = (geo.y - dy2) * view.scale + dy + "px";
        if (cells.length == 1) {
          this.previewElement.style.width = geo.width * view.scale + "px";
          this.previewElement.style.height = geo.height * view.scale + "px";
        }
        this.previewElement.style.display = "";
      } else if (dragSource.currentHighlight.state != null && graph2.model.isEdge(dragSource.currentHighlight.state.cell)) {
        this.previewElement.style.left = Math.round(parseInt(this.previewElement.style.left) - bounds.width * view.scale / 2) + "px";
        this.previewElement.style.top = Math.round(parseInt(this.previewElement.style.top) - bounds.height * view.scale / 2) + "px";
      } else {
        this.previewElement.style.width = this.previewElementWidth;
        this.previewElement.style.height = this.previewElementHeight;
        this.previewElement.style.display = "";
      }
    }
  };
  var startTime = new Date().getTime();
  var timeOnTarget = 0;
  var prev = null;
  var sourceCellStyle = this.editorUi.editor.graph.getCellStyle(cells[0]);
  dragSource.getDropTarget = bind(this, function(graph2, x, y, evt) {
    var cell2 = !mxEvent2.isAltDown(evt) && cells != null ? graph2.getCellAt(x, y, null, null, null, function(state3, x2, y2) {
      return graph2.isContainer(state3.cell);
    }) : null;
    if (cell2 != null && !this.graph.isCellConnectable(cell2) && !this.graph.model.isEdge(cell2)) {
      var parent2 = this.graph.getModel().getParent(cell2);
      if (this.graph.getModel().isVertex(parent2) && this.graph.isCellConnectable(parent2)) {
        cell2 = parent2;
      }
    }
    if (graph2.isCellLocked(cell2)) {
      cell2 = null;
    }
    var state2 = graph2.view.getState(cell2);
    activeArrow = null;
    var bbox = null;
    if (prev != state2) {
      startTime = new Date().getTime();
      timeOnTarget = 0;
      prev = state2;
      if (this.updateThread != null) {
        window.clearTimeout(this.updateThread);
      }
      if (state2 != null) {
        this.updateThread = window.setTimeout(function() {
          if (activeArrow == null) {
            prev = state2;
            dragSource.getDropTarget(graph2, x, y, evt);
          }
        }, this.dropTargetDelay + 10);
      }
    } else {
      timeOnTarget = new Date().getTime() - startTime;
    }
    if (dropStyleEnabled && timeOnTarget < 2500 && state2 != null && !mxEvent2.isShiftDown(evt) && (getValue(state2.style, mxConstants2.STYLE_SHAPE) != getValue(sourceCellStyle, mxConstants2.STYLE_SHAPE) && (getValue(state2.style, mxConstants2.STYLE_STROKECOLOR, mxConstants2.NONE) != mxConstants2.NONE || getValue(state2.style, mxConstants2.STYLE_FILLCOLOR, mxConstants2.NONE) != mxConstants2.NONE || getValue(state2.style, mxConstants2.STYLE_GRADIENTCOLOR, mxConstants2.NONE) != mxConstants2.NONE) || getValue(sourceCellStyle, mxConstants2.STYLE_SHAPE) == "image" || timeOnTarget > 1500 || graph2.model.isEdge(state2.cell)) && timeOnTarget > this.dropTargetDelay && !this.isDropStyleTargetIgnored(state2) && (graph2.model.isVertex(state2.cell) && firstVertex != null || graph2.model.isEdge(state2.cell) && graph2.model.isEdge(cells[0]))) {
      currentStyleTarget = state2;
      var tmp = graph2.model.isEdge(state2.cell) ? graph2.view.getPoint(state2) : new mxPoint2(state2.getCenterX(), state2.getCenterY());
      tmp = new mxRectangle(tmp.x - this.refreshTarget.width / 2, tmp.y - this.refreshTarget.height / 2, this.refreshTarget.width, this.refreshTarget.height);
      styleTarget.style.left = Math.floor(tmp.x) + "px";
      styleTarget.style.top = Math.floor(tmp.y) + "px";
      if (styleTargetParent == null) {
        graph2.container.appendChild(styleTarget);
        styleTargetParent = styleTarget.parentNode;
      }
      checkArrow(x, y, tmp, styleTarget);
    } else if (currentStyleTarget == null || !contains(currentStyleTarget, x, y) || timeOnTarget > 1500 && !mxEvent2.isShiftDown(evt)) {
      currentStyleTarget = null;
      if (styleTargetParent != null) {
        styleTarget.parentNode.removeChild(styleTarget);
        styleTargetParent = null;
      }
    } else if (currentStyleTarget != null && styleTargetParent != null) {
      var tmp = graph2.model.isEdge(currentStyleTarget.cell) ? graph2.view.getPoint(currentStyleTarget) : new mxPoint2(currentStyleTarget.getCenterX(), currentStyleTarget.getCenterY());
      tmp = new mxRectangle(tmp.x - this.refreshTarget.width / 2, tmp.y - this.refreshTarget.height / 2, this.refreshTarget.width, this.refreshTarget.height);
      checkArrow(x, y, tmp, styleTarget);
    }
    if (activeTarget && currentTargetState != null && !mxEvent2.isAltDown(evt) && activeArrow == null) {
      bbox = mxRectangle.fromRectangle(currentTargetState);
      if (graph2.model.isEdge(currentTargetState.cell)) {
        var pts = currentTargetState.absolutePoints;
        if (roundSource.parentNode != null) {
          var p0 = pts[0];
          bbox.add(checkArrow(x, y, new mxRectangle(p0.x - this.roundDrop.width / 2, p0.y - this.roundDrop.height / 2, this.roundDrop.width, this.roundDrop.height), roundSource));
        }
        if (roundTarget.parentNode != null) {
          var pe = pts[pts.length - 1];
          bbox.add(checkArrow(x, y, new mxRectangle(pe.x - this.roundDrop.width / 2, pe.y - this.roundDrop.height / 2, this.roundDrop.width, this.roundDrop.height), roundTarget));
        }
      } else {
        var bds = mxRectangle.fromRectangle(currentTargetState);
        if (currentTargetState.shape != null && currentTargetState.shape.boundingBox != null) {
          bds = mxRectangle.fromRectangle(currentTargetState.shape.boundingBox);
        }
        bds.grow(this.graph.tolerance);
        bds.grow(HoverIcons.prototype.arrowSpacing);
        var handler = this.graph.selectionCellsHandler.getHandler(currentTargetState.cell);
        if (handler != null) {
          bds.x -= handler.horizontalOffset / 2;
          bds.y -= handler.verticalOffset / 2;
          bds.width += handler.horizontalOffset;
          bds.height += handler.verticalOffset;
          if (handler.rotationShape != null && handler.rotationShape.node != null && handler.rotationShape.node.style.visibility != "hidden" && handler.rotationShape.node.style.display != "none" && handler.rotationShape.boundingBox != null) {
            bds.add(handler.rotationShape.boundingBox);
          }
        }
        bbox.add(checkArrow(x, y, new mxRectangle(currentTargetState.getCenterX() - this.triangleUp.width / 2, bds.y - this.triangleUp.height, this.triangleUp.width, this.triangleUp.height), arrowUp));
        bbox.add(checkArrow(x, y, new mxRectangle(bds.x + bds.width, currentTargetState.getCenterY() - this.triangleRight.height / 2, this.triangleRight.width, this.triangleRight.height), arrowRight));
        bbox.add(checkArrow(x, y, new mxRectangle(currentTargetState.getCenterX() - this.triangleDown.width / 2, bds.y + bds.height, this.triangleDown.width, this.triangleDown.height), arrowDown));
        bbox.add(checkArrow(x, y, new mxRectangle(bds.x - this.triangleLeft.width, currentTargetState.getCenterY() - this.triangleLeft.height / 2, this.triangleLeft.width, this.triangleLeft.height), arrowLeft));
      }
      if (bbox != null) {
        bbox.grow(10);
      }
    }
    direction = mxConstants2.DIRECTION_NORTH;
    if (activeArrow == arrowRight) {
      direction = mxConstants2.DIRECTION_EAST;
    } else if (activeArrow == arrowDown || activeArrow == roundTarget) {
      direction = mxConstants2.DIRECTION_SOUTH;
    } else if (activeArrow == arrowLeft) {
      direction = mxConstants2.DIRECTION_WEST;
    }
    if (currentStyleTarget != null && activeArrow == styleTarget) {
      state2 = currentStyleTarget;
    }
    var validTarget = (firstVertex == null || graph2.isCellConnectable(cells[firstVertex])) && (graph2.model.isEdge(cell2) && firstVertex != null || graph2.model.isVertex(cell2) && graph2.isCellConnectable(cell2));
    if (currentTargetState != null && timeOnTarget >= 5e3 || currentTargetState != state2 && (bbox == null || !contains(bbox, x, y) || timeOnTarget > 500 && activeArrow == null && validTarget)) {
      activeTarget = false;
      currentTargetState = timeOnTarget < 5e3 && timeOnTarget > this.dropTargetDelay || graph2.model.isEdge(cell2) ? state2 : null;
      if (currentTargetState != null && validTarget) {
        var elts = [
          roundSource,
          roundTarget,
          arrowUp,
          arrowRight,
          arrowDown,
          arrowLeft
        ];
        for (var i2 = 0; i2 < elts.length; i2++) {
          if (elts[i2].parentNode != null) {
            elts[i2].parentNode.removeChild(elts[i2]);
          }
        }
        if (graph2.model.isEdge(cell2)) {
          var pts = state2.absolutePoints;
          if (pts != null) {
            var p0 = pts[0];
            var pe = pts[pts.length - 1];
            var tol = graph2.tolerance;
            var box = new mxRectangle(x - tol, y - tol, 2 * tol, 2 * tol);
            roundSource.style.left = Math.floor(p0.x - this.roundDrop.width / 2) + "px";
            roundSource.style.top = Math.floor(p0.y - this.roundDrop.height / 2) + "px";
            roundTarget.style.left = Math.floor(pe.x - this.roundDrop.width / 2) + "px";
            roundTarget.style.top = Math.floor(pe.y - this.roundDrop.height / 2) + "px";
            if (graph2.model.getTerminal(cell2, true) == null) {
              graph2.container.appendChild(roundSource);
            }
            if (graph2.model.getTerminal(cell2, false) == null) {
              graph2.container.appendChild(roundTarget);
            }
          }
        } else {
          var bds = mxRectangle.fromRectangle(state2);
          if (state2.shape != null && state2.shape.boundingBox != null) {
            bds = mxRectangle.fromRectangle(state2.shape.boundingBox);
          }
          bds.grow(this.graph.tolerance);
          bds.grow(HoverIcons.prototype.arrowSpacing);
          var handler = this.graph.selectionCellsHandler.getHandler(state2.cell);
          if (handler != null) {
            bds.x -= handler.horizontalOffset / 2;
            bds.y -= handler.verticalOffset / 2;
            bds.width += handler.horizontalOffset;
            bds.height += handler.verticalOffset;
            if (handler.rotationShape != null && handler.rotationShape.node != null && handler.rotationShape.node.style.visibility != "hidden" && handler.rotationShape.node.style.display != "none" && handler.rotationShape.boundingBox != null) {
              bds.add(handler.rotationShape.boundingBox);
            }
          }
          arrowUp.style.left = Math.floor(state2.getCenterX() - this.triangleUp.width / 2) + "px";
          arrowUp.style.top = Math.floor(bds.y - this.triangleUp.height) + "px";
          arrowRight.style.left = Math.floor(bds.x + bds.width) + "px";
          arrowRight.style.top = Math.floor(state2.getCenterY() - this.triangleRight.height / 2) + "px";
          arrowDown.style.left = arrowUp.style.left;
          arrowDown.style.top = Math.floor(bds.y + bds.height) + "px";
          arrowLeft.style.left = Math.floor(bds.x - this.triangleLeft.width) + "px";
          arrowLeft.style.top = arrowRight.style.top;
          if (state2.style["portConstraint"] != "eastwest") {
            graph2.container.appendChild(arrowUp);
            graph2.container.appendChild(arrowDown);
          }
          graph2.container.appendChild(arrowRight);
          graph2.container.appendChild(arrowLeft);
        }
        if (state2 != null) {
          currentStateHandle = graph2.selectionCellsHandler.getHandler(state2.cell);
          if (currentStateHandle != null && currentStateHandle.setHandlesVisible != null) {
            currentStateHandle.setHandlesVisible(false);
          }
        }
        activeTarget = true;
      } else {
        var elts = [
          roundSource,
          roundTarget,
          arrowUp,
          arrowRight,
          arrowDown,
          arrowLeft
        ];
        for (var i2 = 0; i2 < elts.length; i2++) {
          if (elts[i2].parentNode != null) {
            elts[i2].parentNode.removeChild(elts[i2]);
          }
        }
      }
    }
    if (!activeTarget && currentStateHandle != null) {
      currentStateHandle.setHandlesVisible(true);
    }
    var target = (!mxEvent2.isAltDown(evt) || mxEvent2.isShiftDown(evt)) && !(currentStyleTarget != null && activeArrow == styleTarget) ? mxDragSource.prototype.getDropTarget.apply(this, arguments) : null;
    var model = graph2.getModel();
    if (target != null) {
      if (activeArrow != null || !graph2.isSplitTarget(target, cells, evt)) {
        while (target != null && !graph2.isValidDropTarget(target, cells, evt) && model.isVertex(model.getParent(target))) {
          target = model.getParent(target);
        }
        if (target != null && (graph2.view.currentRoot == target || !graph2.isValidRoot(target) && graph2.getModel().getChildCount(target) == 0 || graph2.isCellLocked(target) || model.isEdge(target) || !graph2.isValidDropTarget(target, cells, evt))) {
          target = null;
        }
      }
    }
    return target;
  });
  dragSource.stopDrag = function() {
    mxDragSource.prototype.stopDrag.apply(this, arguments);
    var elts = [
      roundSource,
      roundTarget,
      styleTarget,
      arrowUp,
      arrowRight,
      arrowDown,
      arrowLeft
    ];
    for (var i2 = 0; i2 < elts.length; i2++) {
      if (elts[i2].parentNode != null) {
        elts[i2].parentNode.removeChild(elts[i2]);
      }
    }
    if (currentTargetState != null && currentStateHandle != null) {
      currentStateHandle.reset();
    }
    currentStateHandle = null;
    currentTargetState = null;
    currentStyleTarget = null;
    styleTargetParent = null;
    activeArrow = null;
  };
  return dragSource;
};
Sidebar2.prototype.itemClicked = function(cells, ds, evt, elt) {
  var graph = this.editorUi.editor.graph;
  graph.container.focus();
  if (mxEvent2.isAltDown(evt) && graph.getSelectionCount() == 1 && graph.model.isVertex(graph.getSelectionCell())) {
    var firstVertex = null;
    for (var i = 0; i < cells.length && firstVertex == null; i++) {
      if (graph.model.isVertex(cells[i])) {
        firstVertex = i;
      }
    }
    if (firstVertex != null) {
      graph.setSelectionCells(this.dropAndConnect(graph.getSelectionCell(), cells, mxEvent2.isMetaDown(evt) || mxEvent2.isControlDown(evt) ? mxEvent2.isShiftDown(evt) ? mxConstants2.DIRECTION_WEST : mxConstants2.DIRECTION_NORTH : mxEvent2.isShiftDown(evt) ? mxConstants2.DIRECTION_EAST : mxConstants2.DIRECTION_SOUTH, firstVertex, evt));
      graph.scrollCellToVisible(graph.getSelectionCell());
    }
  } else if (mxEvent2.isShiftDown(evt) && !graph.isSelectionEmpty()) {
    this.updateShapes(cells[0], graph.getSelectionCells());
    graph.scrollCellToVisible(graph.getSelectionCell());
  } else {
    var pt = mxEvent2.isAltDown(evt) ? graph.getFreeInsertPoint() : graph.getCenterInsertPoint(graph.getBoundingBoxFromGeometry(cells, true));
    ds.drop(graph, evt, null, pt.x, pt.y, true);
  }
};
Sidebar2.prototype.addClickHandler = function(elt, ds, cells) {
  var graph = this.editorUi.editor.graph;
  var oldMouseDown = ds.mouseDown;
  var oldMouseMove = ds.mouseMove;
  var oldMouseUp = ds.mouseUp;
  var tol = graph.tolerance;
  var first = null;
  var sb = this;
  ds.mouseDown = function(evt) {
    oldMouseDown.apply(this, arguments);
    first = new mxPoint2(mxEvent2.getClientX(evt), mxEvent2.getClientY(evt));
    if (this.dragElement != null) {
      this.dragElement.style.display = "none";
      setOpacity(elt, 50);
    }
  };
  ds.mouseMove = function(evt) {
    if (this.dragElement != null && this.dragElement.style.display == "none" && first != null && (Math.abs(first.x - mxEvent2.getClientX(evt)) > tol || Math.abs(first.y - mxEvent2.getClientY(evt)) > tol)) {
      this.dragElement.style.display = "";
      setOpacity(elt, 100);
    }
    oldMouseMove.apply(this, arguments);
  };
  ds.mouseUp = function(evt) {
    try {
      if (!mxEvent2.isPopupTrigger(evt) && this.currentGraph == null && this.dragElement != null && this.dragElement.style.display == "none") {
        sb.itemClicked(cells, ds, evt, elt);
      }
      oldMouseUp.apply(ds, arguments);
      setOpacity(elt, 100);
      first = null;
      sb.currentElt = elt;
    } catch (e) {
      ds.reset();
      sb.editorUi.handleError(e);
    }
  };
};
Sidebar2.prototype.createVertexTemplateEntry = function(style, width, height, value, title, showLabel, showTitle, tags) {
  tags = tags != null && tags.length > 0 ? tags : title != null ? title.toLowerCase() : "";
  return this.addEntry(tags, bind(this, function() {
    return this.createVertexTemplate(style, width, height, value, title, showLabel, showTitle);
  }));
};
Sidebar2.prototype.createVertexTemplate = function(style, width, height, value, title, showLabel, showTitle, allowCellsInserted) {
  var cells = [
    new mxCell(value != null ? value : "", new mxGeometry(0, 0, width, height), style)
  ];
  cells[0].vertex = true;
  if (style.includes("shape=rectangle")) {
    cells[0].setConnectable(false);
  }
  return this.createVertexTemplateFromCells(cells, width, height, title, showLabel, showTitle, allowCellsInserted);
};
Sidebar2.prototype.createVertexTemplateFromData = function(data, width, height, title, showLabel, showTitle, allowCellsInserted) {
  var doc = parseXml(mxGraph.decompress(data));
  var codec = new mxCodec(doc);
  var model = new mxGraphModel();
  codec.decode(doc.documentElement, model);
  var cells = this.graph.cloneCells(model.root.getChildAt(0).children);
  return this.createVertexTemplateFromCells(cells, width, height, title, showLabel, showTitle, allowCellsInserted);
};
Sidebar2.prototype.createVertexTemplateFromCells = function(cells, width, height, title, showLabel, showTitle, allowCellsInserted) {
  return this.createItem(cells, title, showLabel, showTitle, width, height, allowCellsInserted);
};
Sidebar2.prototype.createEdgeTemplateEntry = function(style, width, height, value, title, showLabel, tags, allowCellsInserted) {
  tags = tags != null && tags.length > 0 ? tags : title.toLowerCase();
  return this.addEntry(tags, bind(this, function() {
    return this.createEdgeTemplate(style, width, height, value, title, showLabel, allowCellsInserted);
  }));
};
Sidebar2.prototype.createEdgeTemplate = function(style, width, height, value, title, showLabel, allowCellsInserted) {
  var cell2 = new mxCell(value != null ? value : "", new mxGeometry(0, 0, width, height), style);
  cell2.geometry.setTerminalPoint(new mxPoint2(0, height), true);
  cell2.geometry.setTerminalPoint(new mxPoint2(width, 0), false);
  cell2.geometry.relative = true;
  cell2.edge = true;
  return this.createEdgeTemplateFromCells([cell2], width, height, title, showLabel, allowCellsInserted);
};
Sidebar2.prototype.createEdgeTemplateFromCells = function(cells, width, height, title, showLabel, allowCellsInserted) {
  return this.createItem(cells, title, showLabel, true, width, height, allowCellsInserted);
};
Sidebar2.prototype.addPaletteFunctions = function(id, title, expanded, fns) {
  this.addPalette(id, title, expanded, bind(this, function(content) {
    for (var i = 0; i < fns.length; i++) {
      content.appendChild(fns[i](content));
    }
  }));
};
Sidebar2.prototype.addPalette = function(id, title, expanded, onInit) {
  var elt = this.createTitle(title);
  this.container.appendChild(elt);
  var div = document.createElement("div");
  div.className = "geSidebar";
  if (mxClient_default.IS_POINTER) {
    div.style.touchAction = "none";
  }
  if (expanded) {
    onInit(div);
    onInit = null;
  } else {
    div.style.display = "none";
  }
  this.addFoldingHandler(elt, div, onInit);
  var outer = document.createElement("div");
  outer.appendChild(div);
  this.container.appendChild(outer);
  if (id != null) {
    this.palettes[id] = [elt, outer];
  }
  return div;
};
Sidebar2.prototype.addFoldingHandler = function(title, content, funct) {
  var initialized = false;
  if (!mxClient_default.IS_IE || document.documentMode >= 8) {
    title.style.backgroundImage = content.style.display == "none" ? "url('" + this.collapsedImage + "')" : "url('" + this.expandedImage + "')";
  }
  title.style.backgroundRepeat = "no-repeat";
  title.style.backgroundPosition = "0% 50%";
  mxEvent2.addListener(title, "click", bind(this, function(evt) {
    if (content.style.display == "none") {
      if (!initialized) {
        initialized = true;
        if (funct != null) {
          title.style.cursor = "wait";
          var prev = title.innerHTML;
          title.innerHTML = mxResources2.get("loading") + "...";
          window.setTimeout(function() {
            content.style.display = "block";
            title.style.cursor = "";
            title.innerHTML = prev;
            var fo = mxClient_default.NO_FO;
            mxClient_default.NO_FO = Editor2.prototype.originalNoForeignObject;
            funct(content, title);
            mxClient_default.NO_FO = fo;
          }, mxClient_default.IS_FF ? 20 : 0);
        } else {
          content.style.display = "block";
        }
      } else {
        content.style.display = "block";
      }
      title.style.backgroundImage = "url('" + this.expandedImage + "')";
    } else {
      title.style.backgroundImage = "url('" + this.collapsedImage + "')";
      content.style.display = "none";
    }
    mxEvent2.consume(evt);
  }));
  if (!mxClient_default.IS_QUIRKS) {
    mxEvent2.addListener(title, mxClient_default.IS_POINTER ? "pointerdown" : "mousedown", bind(this, function(evt) {
      evt.preventDefault();
    }));
  }
};
Sidebar2.prototype.removePalette = function(id) {
  var elts = this.palettes[id];
  if (elts != null) {
    this.palettes[id] = null;
    for (var i = 0; i < elts.length; i++) {
      this.container.removeChild(elts[i]);
    }
    return true;
  }
  return false;
};
Sidebar2.prototype.addImagePalette = function(id, title, prefix, postfix, items, titles, tags) {
  var showTitles = titles != null;
  var fns = [];
  fns.push(this.createVertexTemplateEntry("shape=rectangle;fillColor=#FFFFFF;strokeWidth=2;verticalAlign=top;align=center;spacingTop=-5;fontSize=12;fontColor=#000000;fontStyle=1;", 720, 360, "Trust Boundary", "Trust Boundary", true, true, "rect rectangle box"));
  this.addPaletteFunctions(id, title, false, fns);
};
Sidebar2.prototype.getTagsForStencil = function(packageName, stencilName, moreTags) {
  var tags = packageName.split(".");
  for (var i = 1; i < tags.length; i++) {
    tags[i] = tags[i].replace(/_/g, " ");
  }
  tags.push(stencilName.replace(/_/g, " "));
  if (moreTags != null) {
    tags.push(moreTags);
  }
  return tags.slice(1, tags.length);
};
Sidebar2.prototype.addStencilPalette = function(id, title, stencilFile, style, ignore, onInit, scale, tags, customFns, groupId) {
  scale = scale != null ? scale : 1;
  if (this.addStencilsToIndex) {
    var fns = [];
    if (customFns != null) {
      for (var i = 0; i < customFns.length; i++) {
        fns.push(customFns[i]);
      }
    }
    MyMxStencilRegistry2.loadStencilSet(stencilFile, bind(this, function(packageName, stencilName, displayName, w2, h2) {
      if (ignore == null || indexOf(ignore, stencilName) < 0) {
        var tmp = this.getTagsForStencil(packageName, stencilName);
        var tmpTags = tags != null ? tags[stencilName] : null;
        if (tmpTags != null) {
          tmp.push(tmpTags);
        }
        fns.push(this.createVertexTemplateEntry("shape=" + packageName + stencilName.toLowerCase() + style, Math.round(w2 * scale), Math.round(h2 * scale), stencilName.replace(/_/g, " "), stencilName.replace(/_/g, " "), null, null, this.filterTags(tmp.join(" "))));
      }
    }), true, true);
    this.addPaletteFunctions(id, title, false, fns);
  } else {
    this.addPalette(id, title, false, bind(this, function(content) {
      if (style == null) {
        style = "";
      }
      if (onInit != null) {
        onInit.call(this, content);
      }
      if (customFns != null) {
        for (var i2 = 0; i2 < customFns.length; i2++) {
          customFns[i2](content);
        }
      }
      MyMxStencilRegistry2.loadStencilSet(stencilFile, bind(this, function(packageName, stencilName, displayName, w2, h2) {
        if (ignore == null || indexOf(ignore, stencilName) < 0) {
          content.appendChild(this.createVertexTemplate("shape=" + packageName + stencilName.toLowerCase() + style, Math.round(w2 * scale), Math.round(h2 * scale), stencilName.replace(/_/g, " "), stencilName.replace(/_/g, " "), true));
        }
      }), true);
    }));
  }
};
Sidebar2.prototype.destroy = function() {
  if (this.graph != null) {
    if (this.graph.container != null && this.graph.container.parentNode != null) {
      this.graph.container.parentNode.removeChild(this.graph.container);
    }
    this.graph.destroy();
    this.graph = null;
  }
  if (this.pointerUpHandler != null) {
    mxEvent2.removeListener(document, mxClient_default.IS_POINTER ? "pointerup" : "mouseup", this.pointerUpHandler);
    this.pointerUpHandler = null;
  }
  if (this.pointerDownHandler != null) {
    mxEvent2.removeListener(document, mxClient_default.IS_POINTER ? "pointerdown" : "mousedown", this.pointerDownHandler);
    this.pointerDownHandler = null;
  }
  if (this.pointerMoveHandler != null) {
    mxEvent2.removeListener(document, mxClient_default.IS_POINTER ? "pointermove" : "mousemove", this.pointerMoveHandler);
    this.pointerMoveHandler = null;
  }
  if (this.pointerOutHandler != null) {
    mxEvent2.removeListener(document, mxClient_default.IS_POINTER ? "pointerout" : "mouseout", this.pointerOutHandler);
    this.pointerOutHandler = null;
  }
};

// js/Toolbar.js
function Toolbar(editorUi, container) {
  this.editorUi = editorUi;
  this.container = container;
  this.staticElements = [];
  this.dropdownImageHtml = '<img border="0" style="position:absolute;right:4px;top:' + (!editorUi.constructor.compactUi ? 8 : 6) + 'px;" src="' + this.dropdownImage + '" valign="middle"/>';
  this.init();
  this.gestureHandler = bind(this, function(evt) {
    if (this.editorUi.currentMenu != null && mxEvent2.getSource(evt) != this.editorUi.currentMenu.div) {
      this.hideMenu();
    }
  });
  mxEvent2.addGestureListeners(document, this.gestureHandler);
}
Toolbar.prototype.dropdownImage = !mxClient2.IS_SVG ? IMAGE_PATH + "/dropdown.gif" : "data:image/gif;base64,R0lGODlhDQANAIABAHt7e////yH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS4wLWMwNjAgNjEuMTM0Nzc3LCAyMDEwLzAyLzEyLTE3OjMyOjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpCREM1NkJFMjE0NEMxMUU1ODk1Q0M5MjQ0MTA4QjNDMSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpCREM1NkJFMzE0NEMxMUU1ODk1Q0M5MjQ0MTA4QjNDMSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkQzOUMzMjZCMTQ0QjExRTU4OTVDQzkyNDQxMDhCM0MxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkQzOUMzMjZDMTQ0QjExRTU4OTVDQzkyNDQxMDhCM0MxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAAQAsAAAAAA0ADQAAAhGMj6nL3QAjVHIu6azbvPtWAAA7";
Toolbar.prototype.selectedBackground = "#d0d0d0";
Toolbar.prototype.unselectedBackground = "none";
Toolbar.prototype.staticElements = null;
Toolbar.prototype.init = function() {
  var sw = screen.width;
  sw -= screen.height > 740 ? 56 : 0;
  if (sw >= 700) {
    var formatMenu = this.addMenu("", mxResources2.get("view") + " (" + mxResources2.get("panTooltip") + ")", true, "viewPanels", null, true);
    this.addDropDownArrow(formatMenu, "geSprite-formatpanel", 38, 50, -4, -3, 36, -8);
    this.addSeparator();
  }
  var viewMenu = this.addMenu("", mxResources2.get("zoom") + " (Alt+Mousewheel)", true, "viewZoom", null, true);
  viewMenu.showDisabled = true;
  viewMenu.style.whiteSpace = "nowrap";
  viewMenu.style.position = "relative";
  viewMenu.style.overflow = "hidden";
  if (EditorUi.compactUi) {
    viewMenu.style.width = mxClient2.IS_QUIRKS ? "58px" : "50px";
  } else {
    viewMenu.style.width = mxClient2.IS_QUIRKS ? "62px" : "36px";
  }
  if (sw >= 420) {
    this.addSeparator();
    var elts = this.addItems(["zoomIn", "zoomOut"]);
    elts[0].setAttribute("title", mxResources2.get("zoomIn") + " (" + this.editorUi.actions.get("zoomIn").shortcut + ")");
    elts[1].setAttribute("title", mxResources2.get("zoomOut") + " (" + this.editorUi.actions.get("zoomOut").shortcut + ")");
  }
  this.updateZoom = bind(this, function() {
    viewMenu.innerHTML = Math.round(this.editorUi.editor.graph.view.scale * 100) + "%" + this.dropdownImageHtml;
    if (EditorUi.compactUi) {
      viewMenu.getElementsByTagName("img")[0].style.right = "1px";
      viewMenu.getElementsByTagName("img")[0].style.top = "5px";
    }
  });
  this.editorUi.editor.graph.view.addListener(mxEvent2.EVENT_SCALE, this.updateZoom);
  this.editorUi.editor.addListener("resetGraphView", this.updateZoom);
  var elts = this.addItems(["-", "undo", "redo"]);
  elts[1].setAttribute("title", mxResources2.get("undo") + " (" + this.editorUi.actions.get("undo").shortcut + ")");
  elts[2].setAttribute("title", mxResources2.get("redo") + " (" + this.editorUi.actions.get("redo").shortcut + ")");
  if (sw >= 320) {
    var elts = this.addItems(["-", "delete"]);
    elts[1].setAttribute("title", mxResources2.get("delete") + " (" + this.editorUi.actions.get("delete").shortcut + ")");
  }
  if (sw >= 550) {
    this.addItems(["-", "toFront", "toBack"]);
  }
  if (sw >= 740) {
    this.addItems(["-", "fillColor"]);
    if (sw >= 780) {
      this.addItems(["strokeColor"]);
      if (sw >= 820) {
        this.addItems(["shadow"]);
      }
    }
  }
  if (sw >= 400) {
    this.addSeparator();
    if (sw >= 440) {
      this.edgeShapeMenu = this.addMenuFunction("", mxResources2.get("connection"), false, bind(this, function(menu) {
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_SHAPE, "width"], [null, null], "geIcon geSprite geSprite-connection", null, true).setAttribute("title", mxResources2.get("line"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_SHAPE, "width"], ["link", null], "geIcon geSprite geSprite-linkedge", null, true).setAttribute("title", mxResources2.get("link"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_SHAPE, "width"], ["flexArrow", null], "geIcon geSprite geSprite-arrow", null, true).setAttribute("title", mxResources2.get("arrow"));
        this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_SHAPE, "width"], ["arrow", null], "geIcon geSprite geSprite-simplearrow", null, true).setAttribute("title", mxResources2.get("simpleArrow"));
      }));
      this.addDropDownArrow(this.edgeShapeMenu, "geSprite-connection", 44, 50, 0, 0, 22, -4);
    }
    this.edgeStyleMenu = this.addMenuFunction("geSprite-orthogonal", mxResources2.get("waypoints"), false, bind(this, function(menu) {
      this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_EDGE, mxConstants2.STYLE_CURVED, mxConstants2.STYLE_NOEDGESTYLE], [null, null, null], "geIcon geSprite geSprite-straight", null, true).setAttribute("title", mxResources2.get("straight"));
      this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_EDGE, mxConstants2.STYLE_CURVED, mxConstants2.STYLE_NOEDGESTYLE], ["orthogonalEdgeStyle", null, null], "geIcon geSprite geSprite-orthogonal", null, true).setAttribute("title", mxResources2.get("orthogonal"));
      this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_EDGE, mxConstants2.STYLE_ELBOW, mxConstants2.STYLE_CURVED, mxConstants2.STYLE_NOEDGESTYLE], ["elbowEdgeStyle", null, null, null], "geIcon geSprite geSprite-horizontalelbow", null, true).setAttribute("title", mxResources2.get("simple"));
      this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_EDGE, mxConstants2.STYLE_ELBOW, mxConstants2.STYLE_CURVED, mxConstants2.STYLE_NOEDGESTYLE], ["elbowEdgeStyle", "vertical", null, null], "geIcon geSprite geSprite-verticalelbow", null, true).setAttribute("title", mxResources2.get("simple"));
      this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_EDGE, mxConstants2.STYLE_ELBOW, mxConstants2.STYLE_CURVED, mxConstants2.STYLE_NOEDGESTYLE], ["isometricEdgeStyle", null, null, null], "geIcon geSprite geSprite-horizontalisometric", null, true).setAttribute("title", mxResources2.get("isometric"));
      this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_EDGE, mxConstants2.STYLE_ELBOW, mxConstants2.STYLE_CURVED, mxConstants2.STYLE_NOEDGESTYLE], ["isometricEdgeStyle", "vertical", null, null], "geIcon geSprite geSprite-verticalisometric", null, true).setAttribute("title", mxResources2.get("isometric"));
      this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_EDGE, mxConstants2.STYLE_CURVED, mxConstants2.STYLE_NOEDGESTYLE], ["orthogonalEdgeStyle", "1", null], "geIcon geSprite geSprite-curved", null, true).setAttribute("title", mxResources2.get("curved"));
      this.editorUi.menus.edgeStyleChange(menu, "", [mxConstants2.STYLE_EDGE, mxConstants2.STYLE_CURVED, mxConstants2.STYLE_NOEDGESTYLE], ["entityRelationEdgeStyle", null, null], "geIcon geSprite geSprite-entity", null, true).setAttribute("title", mxResources2.get("entityRelation"));
    }));
    this.addDropDownArrow(this.edgeStyleMenu, "geSprite-orthogonal", 44, 50, 0, 0, 22, -4);
  }
  this.addSeparator();
  var insertMenu = this.addMenu("", mxResources2.get("insert") + " (" + mxResources2.get("doubleClickTooltip") + ")", true, "insert", null, true);
  this.addDropDownArrow(insertMenu, "geSprite-plus", 38, 48, -4, -3, 36, -8);
  this.addTableDropDown();
};
Toolbar.prototype.addTableDropDown = function() {
  this.addSeparator();
  var menuElt = this.addMenuFunction("geIcon geSprite geSprite-table", mxResources2.get("table"), false, bind(this, function(menu2) {
    var graph = this.editorUi.editor.graph;
    var cell2 = graph.getSelectionCell();
    if (!graph.isTableCell(cell2) && !graph.isTableRow(cell2) && !graph.isTable(cell2)) {
      this.editorUi.menus.addInsertTableCellItem(menu2);
    } else {
      var elt = menu2.addItem("", null, bind(this, function() {
        try {
          graph.insertTableColumn(cell2, true);
        } catch (e) {
          this.editorUi.handleError(e);
        }
      }), null, "geIcon geSprite geSprite-insertcolumnbefore");
      elt.setAttribute("title", mxResources2.get("insertColumnBefore"));
      elt = menu2.addItem("", null, bind(this, function() {
        try {
          graph.insertTableColumn(cell2, false);
        } catch (e) {
          this.editorUi.handleError(e);
        }
      }), null, "geIcon geSprite geSprite-insertcolumnafter");
      elt.setAttribute("title", mxResources2.get("insertColumnAfter"));
      elt = menu2.addItem("Delete column", null, bind(this, function() {
        if (cell2 != null) {
          try {
            graph.deleteTableColumn(cell2);
          } catch (e) {
            this.editorUi.handleError(e);
          }
        }
      }), null, "geIcon geSprite geSprite-deletecolumn");
      elt.setAttribute("title", mxResources2.get("deleteColumn"));
      elt = menu2.addItem("", null, bind(this, function() {
        try {
          graph.insertTableRow(cell2, true);
        } catch (e) {
          this.editorUi.handleError(e);
        }
      }), null, "geIcon geSprite geSprite-insertrowbefore");
      elt.setAttribute("title", mxResources2.get("insertRowBefore"));
      elt = menu2.addItem("", null, bind(this, function() {
        try {
          graph.insertTableRow(cell2, false);
        } catch (e) {
          this.editorUi.handleError(e);
        }
      }), null, "geIcon geSprite geSprite-insertrowafter");
      elt.setAttribute("title", mxResources2.get("insertRowAfter"));
      elt = menu2.addItem("", null, bind(this, function() {
        try {
          graph.deleteTableRow(cell2);
        } catch (e) {
          this.editorUi.handleError(e);
        }
      }), null, "geIcon geSprite geSprite-deleterow");
      elt.setAttribute("title", mxResources2.get("deleteRow"));
    }
  }));
  menuElt.style.position = "relative";
  menuElt.style.whiteSpace = "nowrap";
  menuElt.style.overflow = "hidden";
  menuElt.innerHTML = '<div class="geSprite geSprite-table" style="margin-left:-2px;"></div>' + this.dropdownImageHtml;
  menuElt.style.width = mxClient2.IS_QUIRKS ? "50px" : "30px";
  if (EditorUi.compactUi) {
    menuElt.getElementsByTagName("img")[0].style.left = "22px";
    menuElt.getElementsByTagName("img")[0].style.top = "5px";
  }
  var menu = this.editorUi.menus.get("insert");
  if (menu != null && typeof menuElt.setEnabled === "function") {
    menu.addListener("stateChanged", function() {
      menuElt.setEnabled(menu.enabled);
    });
  }
  return menuElt;
};
Toolbar.prototype.addDropDownArrow = function(menu, sprite, width, atlasWidth, left, top, atlasDelta, atlasLeft) {
  atlasDelta = atlasDelta != null ? atlasDelta : 32;
  left = EditorUi.compactUi ? left : atlasLeft;
  menu.style.whiteSpace = "nowrap";
  menu.style.overflow = "hidden";
  menu.style.position = "relative";
  menu.innerHTML = '<div class="geSprite ' + sprite + '" style="margin-left:' + left + "px;margin-top:" + top + 'px;"></div>' + this.dropdownImageHtml;
  menu.style.width = mxClient2.IS_QUIRKS ? atlasWidth + "px" : atlasWidth - atlasDelta + "px";
  if (mxClient2.IS_QUIRKS) {
    menu.style.height = EditorUi.compactUi ? "24px" : "26px";
  }
  if (EditorUi.compactUi) {
    menu.getElementsByTagName("img")[0].style.left = "24px";
    menu.getElementsByTagName("img")[0].style.top = "5px";
    menu.style.width = mxClient2.IS_QUIRKS ? width + "px" : width - 10 + "px";
  }
};
Toolbar.prototype.setFontName = function(value) {
  if (this.fontMenu != null) {
    this.fontMenu.innerHTML = '<div style="width:60px;overflow:hidden;display:inline-block;">' + htmlEntities(value) + "</div>" + this.dropdownImageHtml;
  }
};
Toolbar.prototype.setFontSize = function(value) {
  if (this.sizeMenu != null) {
    this.sizeMenu.innerHTML = '<div style="width:24px;overflow:hidden;display:inline-block;">' + htmlEntities(value) + "</div>" + this.dropdownImageHtml;
  }
};
Toolbar.prototype.createTextToolbar = function() {
  var graph = this.editorUi.editor.graph;
  var styleElt = this.addMenu("", mxResources2.get("style"), true, "formatBlock");
  styleElt.style.position = "relative";
  styleElt.style.whiteSpace = "nowrap";
  styleElt.style.overflow = "hidden";
  styleElt.innerHTML = mxResources2.get("style") + this.dropdownImageHtml;
  if (EditorUi.compactUi) {
    styleElt.style.paddingRight = "18px";
    styleElt.getElementsByTagName("img")[0].style.right = "1px";
    styleElt.getElementsByTagName("img")[0].style.top = "5px";
  }
  this.addSeparator();
  this.fontMenu = this.addMenu("", mxResources2.get("fontFamily"), true, "fontFamily");
  this.fontMenu.style.position = "relative";
  this.fontMenu.style.whiteSpace = "nowrap";
  this.fontMenu.style.overflow = "hidden";
  this.fontMenu.style.width = mxClient2.IS_QUIRKS ? "80px" : "60px";
  this.setFontName(Menus.prototype.defaultFont);
  if (EditorUi.compactUi) {
    this.fontMenu.style.paddingRight = "18px";
    this.fontMenu.getElementsByTagName("img")[0].style.right = "1px";
    this.fontMenu.getElementsByTagName("img")[0].style.top = "5px";
  }
  this.addSeparator();
  this.sizeMenu = this.addMenu(Menus.prototype.defaultFontSize, mxResources2.get("fontSize"), true, "fontSize");
  this.sizeMenu.style.position = "relative";
  this.sizeMenu.style.whiteSpace = "nowrap";
  this.sizeMenu.style.overflow = "hidden";
  this.sizeMenu.style.width = mxClient2.IS_QUIRKS ? "44px" : "24px";
  this.setFontSize(Menus.prototype.defaultFontSize);
  if (EditorUi.compactUi) {
    this.sizeMenu.style.paddingRight = "18px";
    this.sizeMenu.getElementsByTagName("img")[0].style.right = "1px";
    this.sizeMenu.getElementsByTagName("img")[0].style.top = "5px";
  }
  var elts = this.addItems(["-", "undo", "redo", "-", "bold", "italic", "underline"]);
  elts[1].setAttribute("title", mxResources2.get("undo") + " (" + this.editorUi.actions.get("undo").shortcut + ")");
  elts[2].setAttribute("title", mxResources2.get("redo") + " (" + this.editorUi.actions.get("redo").shortcut + ")");
  elts[4].setAttribute("title", mxResources2.get("bold") + " (" + this.editorUi.actions.get("bold").shortcut + ")");
  elts[5].setAttribute("title", mxResources2.get("italic") + " (" + this.editorUi.actions.get("italic").shortcut + ")");
  elts[6].setAttribute("title", mxResources2.get("underline") + " (" + this.editorUi.actions.get("underline").shortcut + ")");
  var alignMenu = this.addMenuFunction("", mxResources2.get("align"), false, bind(this, function(menu) {
    elt = menu.addItem("", null, bind(this, function(evt) {
      graph.cellEditor.alignText(mxConstants2.ALIGN_LEFT, evt);
    }), null, "geIcon geSprite geSprite-left");
    elt.setAttribute("title", mxResources2.get("left"));
    elt = menu.addItem("", null, bind(this, function(evt) {
      graph.cellEditor.alignText(mxConstants2.ALIGN_CENTER, evt);
    }), null, "geIcon geSprite geSprite-center");
    elt.setAttribute("title", mxResources2.get("center"));
    elt = menu.addItem("", null, bind(this, function(evt) {
      graph.cellEditor.alignText(mxConstants2.ALIGN_RIGHT, evt);
    }), null, "geIcon geSprite geSprite-right");
    elt.setAttribute("title", mxResources2.get("right"));
    elt = menu.addItem("", null, bind(this, function() {
      document.execCommand("justifyfull", false, null);
    }), null, "geIcon geSprite geSprite-justifyfull");
    elt.setAttribute("title", mxResources2.get("justifyfull"));
    elt = menu.addItem("", null, bind(this, function() {
      document.execCommand("insertorderedlist", false, null);
    }), null, "geIcon geSprite geSprite-orderedlist");
    elt.setAttribute("title", mxResources2.get("numberedList"));
    elt = menu.addItem("", null, bind(this, function() {
      document.execCommand("insertunorderedlist", false, null);
    }), null, "geIcon geSprite geSprite-unorderedlist");
    elt.setAttribute("title", mxResources2.get("bulletedList"));
    elt = menu.addItem("", null, bind(this, function() {
      document.execCommand("outdent", false, null);
    }), null, "geIcon geSprite geSprite-outdent");
    elt.setAttribute("title", mxResources2.get("decreaseIndent"));
    elt = menu.addItem("", null, bind(this, function() {
      document.execCommand("indent", false, null);
    }), null, "geIcon geSprite geSprite-indent");
    elt.setAttribute("title", mxResources2.get("increaseIndent"));
  }));
  alignMenu.style.position = "relative";
  alignMenu.style.whiteSpace = "nowrap";
  alignMenu.style.overflow = "hidden";
  alignMenu.innerHTML = '<div class="geSprite geSprite-left" style="margin-left:-2px;"></div>' + this.dropdownImageHtml;
  alignMenu.style.width = mxClient2.IS_QUIRKS ? "50px" : "30px";
  if (EditorUi.compactUi) {
    alignMenu.getElementsByTagName("img")[0].style.left = "22px";
    alignMenu.getElementsByTagName("img")[0].style.top = "5px";
  }
  var formatMenu = this.addMenuFunction("", mxResources2.get("format"), false, bind(this, function(menu) {
    elt = menu.addItem("", null, this.editorUi.actions.get("subscript").funct, null, "geIcon geSprite geSprite-subscript");
    elt.setAttribute("title", mxResources2.get("subscript") + " (" + Editor2.ctrlKey + "+,)");
    elt = menu.addItem("", null, this.editorUi.actions.get("superscript").funct, null, "geIcon geSprite geSprite-superscript");
    elt.setAttribute("title", mxResources2.get("superscript") + " (" + Editor2.ctrlKey + "+.)");
    elt = menu.addItem("", null, this.editorUi.actions.get("fontColor").funct, null, "geIcon geSprite geSprite-fontcolor");
    elt.setAttribute("title", mxResources2.get("fontColor"));
    elt = menu.addItem("", null, this.editorUi.actions.get("backgroundColor").funct, null, "geIcon geSprite geSprite-fontbackground");
    elt.setAttribute("title", mxResources2.get("backgroundColor"));
    elt = menu.addItem("", null, bind(this, function() {
      document.execCommand("removeformat", false, null);
    }), null, "geIcon geSprite geSprite-removeformat");
    elt.setAttribute("title", mxResources2.get("removeFormat"));
  }));
  formatMenu.style.position = "relative";
  formatMenu.style.whiteSpace = "nowrap";
  formatMenu.style.overflow = "hidden";
  formatMenu.innerHTML = '<div class="geSprite geSprite-dots" style="margin-left:-2px;"></div>' + this.dropdownImageHtml;
  formatMenu.style.width = mxClient2.IS_QUIRKS ? "50px" : "30px";
  if (EditorUi.compactUi) {
    formatMenu.getElementsByTagName("img")[0].style.left = "22px";
    formatMenu.getElementsByTagName("img")[0].style.top = "5px";
  }
  this.addSeparator();
  this.addButton("geIcon geSprite geSprite-code", mxResources2.get("html"), function() {
    graph.cellEditor.toggleViewMode();
    if (graph.cellEditor.textarea.innerHTML.length > 0 && (graph.cellEditor.textarea.innerHTML != "&nbsp;" || !graph.cellEditor.clearOnChange)) {
      window.setTimeout(function() {
        document.execCommand("selectAll", false, null);
      });
    }
  });
  this.addSeparator();
  var insertMenu = this.addMenuFunction("", mxResources2.get("insert"), true, bind(this, function(menu) {
    menu.addItem(mxResources2.get("insertLink"), null, bind(this, function() {
      this.editorUi.actions.get("link").funct();
    }));
    menu.addItem(mxResources2.get("insertImage"), null, bind(this, function() {
      this.editorUi.actions.get("image").funct();
    }));
    menu.addItem(mxResources2.get("insertHorizontalRule"), null, bind(this, function() {
      document.execCommand("inserthorizontalrule", false, null);
    }));
  }));
  insertMenu.style.whiteSpace = "nowrap";
  insertMenu.style.overflow = "hidden";
  insertMenu.style.position = "relative";
  insertMenu.innerHTML = '<div class="geSprite geSprite-plus" style="margin-left:-4px;margin-top:-3px;"></div>' + this.dropdownImageHtml;
  insertMenu.style.width = mxClient2.IS_QUIRKS ? "36px" : "16px";
  if (EditorUi.compactUi) {
    insertMenu.getElementsByTagName("img")[0].style.left = "24px";
    insertMenu.getElementsByTagName("img")[0].style.top = "5px";
    insertMenu.style.width = mxClient2.IS_QUIRKS ? "50px" : "30px";
  }
  this.addSeparator();
  var elt = this.addMenuFunction("geIcon geSprite geSprite-table", mxResources2.get("table"), false, bind(this, function(menu) {
    var elt2 = graph.getSelectedElement();
    var cell2 = graph.getParentByNames(elt2, ["TD", "TH"], graph.cellEditor.text2);
    var row = graph.getParentByName(elt2, "TR", graph.cellEditor.text2);
    if (row == null) {
      let createTable = function(rows, cols) {
        var html = ["<table>"];
        for (var i = 0; i < rows; i++) {
          html.push("<tr>");
          for (var j = 0; j < cols; j++) {
            html.push("<td><br></td>");
          }
          html.push("</tr>");
        }
        html.push("</table>");
        return html.join("");
      };
      ;
      this.editorUi.menus.addInsertTableItem(menu);
    } else {
      var table = graph.getParentByName(row, "TABLE", graph.cellEditor.text2);
      elt2 = menu.addItem("", null, bind(this, function() {
        try {
          graph.selectNode(graph.insertColumn(table, cell2 != null ? cell2.cellIndex : 0));
        } catch (e) {
          this.editorUi.handleError(e);
        }
      }), null, "geIcon geSprite geSprite-insertcolumnbefore");
      elt2.setAttribute("title", mxResources2.get("insertColumnBefore"));
      elt2 = menu.addItem("", null, bind(this, function() {
        try {
          graph.selectNode(graph.insertColumn(table, cell2 != null ? cell2.cellIndex + 1 : -1));
        } catch (e) {
          this.editorUi.handleError(e);
        }
      }), null, "geIcon geSprite geSprite-insertcolumnafter");
      elt2.setAttribute("title", mxResources2.get("insertColumnAfter"));
      elt2 = menu.addItem("Delete column", null, bind(this, function() {
        if (cell2 != null) {
          try {
            graph.deleteColumn(table, cell2.cellIndex);
          } catch (e) {
            this.editorUi.handleError(e);
          }
        }
      }), null, "geIcon geSprite geSprite-deletecolumn");
      elt2.setAttribute("title", mxResources2.get("deleteColumn"));
      elt2 = menu.addItem("", null, bind(this, function() {
        try {
          graph.selectNode(graph.insertRow(table, row.sectionRowIndex));
        } catch (e) {
          this.editorUi.handleError(e);
        }
      }), null, "geIcon geSprite geSprite-insertrowbefore");
      elt2.setAttribute("title", mxResources2.get("insertRowBefore"));
      elt2 = menu.addItem("", null, bind(this, function() {
        try {
          graph.selectNode(graph.insertRow(table, row.sectionRowIndex + 1));
        } catch (e) {
          this.editorUi.handleError(e);
        }
      }), null, "geIcon geSprite geSprite-insertrowafter");
      elt2.setAttribute("title", mxResources2.get("insertRowAfter"));
      elt2 = menu.addItem("", null, bind(this, function() {
        try {
          graph.deleteRow(table, row.sectionRowIndex);
        } catch (e) {
          this.editorUi.handleError(e);
        }
      }), null, "geIcon geSprite geSprite-deleterow");
      elt2.setAttribute("title", mxResources2.get("deleteRow"));
      elt2 = menu.addItem("", null, bind(this, function() {
        var color = table.style.borderColor.replace(/\brgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/g, function($0, $1, $2, $3) {
          return "#" + ("0" + Number($1).toString(16)).substr(-2) + ("0" + Number($2).toString(16)).substr(-2) + ("0" + Number($3).toString(16)).substr(-2);
        });
        this.editorUi.pickColor(color, function(newColor) {
          if (newColor == null || newColor == mxConstants2.NONE) {
            table.removeAttribute("border");
            table.style.border = "";
            table.style.borderCollapse = "";
          } else {
            table.setAttribute("border", "1");
            table.style.border = "1px solid " + newColor;
            table.style.borderCollapse = "collapse";
          }
        });
      }), null, "geIcon geSprite geSprite-strokecolor");
      elt2.setAttribute("title", mxResources2.get("borderColor"));
      elt2 = menu.addItem("", null, bind(this, function() {
        var color = table.style.backgroundColor.replace(/\brgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/g, function($0, $1, $2, $3) {
          return "#" + ("0" + Number($1).toString(16)).substr(-2) + ("0" + Number($2).toString(16)).substr(-2) + ("0" + Number($3).toString(16)).substr(-2);
        });
        this.editorUi.pickColor(color, function(newColor) {
          if (newColor == null || newColor == mxConstants2.NONE) {
            table.style.backgroundColor = "";
          } else {
            table.style.backgroundColor = newColor;
          }
        });
      }), null, "geIcon geSprite geSprite-fillcolor");
      elt2.setAttribute("title", mxResources2.get("backgroundColor"));
      elt2 = menu.addItem("", null, bind(this, function() {
        var value = table.getAttribute("cellPadding") || 0;
        var dlg = new FilenameDialog2(this.editorUi, value, mxResources2.get("apply"), bind(this, function(newValue) {
          if (newValue != null && newValue.length > 0) {
            table.setAttribute("cellPadding", newValue);
          } else {
            table.removeAttribute("cellPadding");
          }
        }), mxResources2.get("spacing"));
        this.editorUi.showDialog(dlg.container, 300, 80, true, true);
        dlg.init();
      }), null, "geIcon geSprite geSprite-fit");
      elt2.setAttribute("title", mxResources2.get("spacing"));
      elt2 = menu.addItem("", null, bind(this, function() {
        table.setAttribute("align", "left");
      }), null, "geIcon geSprite geSprite-left");
      elt2.setAttribute("title", mxResources2.get("left"));
      elt2 = menu.addItem("", null, bind(this, function() {
        table.setAttribute("align", "center");
      }), null, "geIcon geSprite geSprite-center");
      elt2.setAttribute("title", mxResources2.get("center"));
      elt2 = menu.addItem("", null, bind(this, function() {
        table.setAttribute("align", "right");
      }), null, "geIcon geSprite geSprite-right");
      elt2.setAttribute("title", mxResources2.get("right"));
    }
  }));
  elt.style.position = "relative";
  elt.style.whiteSpace = "nowrap";
  elt.style.overflow = "hidden";
  elt.innerHTML = '<div class="geSprite geSprite-table" style="margin-left:-2px;"></div>' + this.dropdownImageHtml;
  elt.style.width = mxClient2.IS_QUIRKS ? "50px" : "30px";
  if (EditorUi.compactUi) {
    elt.getElementsByTagName("img")[0].style.left = "22px";
    elt.getElementsByTagName("img")[0].style.top = "5px";
  }
};
Toolbar.prototype.hideMenu = function() {
  this.editorUi.hideCurrentMenu();
};
Toolbar.prototype.addMenu = function(label, tooltip, showLabels, name, c, showAll, ignoreState) {
  var menu = this.editorUi.menus.get(name);
  var elt = this.addMenuFunction(label, tooltip, showLabels, function() {
    menu.funct.apply(menu, arguments);
  }, c, showAll);
  if (!ignoreState && typeof elt.setEnabled === "function") {
    menu.addListener("stateChanged", function() {
      elt.setEnabled(menu.enabled);
    });
  }
  return elt;
};
Toolbar.prototype.addMenuFunction = function(label, tooltip, showLabels, funct, c, showAll) {
  return this.addMenuFunctionInContainer(c != null ? c : this.container, label, tooltip, showLabels, funct, showAll);
};
Toolbar.prototype.addMenuFunctionInContainer = function(container, label, tooltip, showLabels, funct, showAll) {
  var elt = showLabels ? this.createLabel(label) : this.createButton(label);
  this.initElement(elt, tooltip);
  this.addMenuHandler(elt, showLabels, funct, showAll);
  container.appendChild(elt);
  return elt;
};
Toolbar.prototype.addSeparator = function(c) {
  c = c != null ? c : this.container;
  var elt = document.createElement("div");
  elt.className = "geSeparator";
  c.appendChild(elt);
  return elt;
};
Toolbar.prototype.addItems = function(keys, c, ignoreDisabled) {
  var items = [];
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (key == "-") {
      items.push(this.addSeparator(c));
    } else {
      items.push(this.addItem("geSprite-" + key.toLowerCase(), key, c, ignoreDisabled));
    }
  }
  return items;
};
Toolbar.prototype.addItem = function(sprite, key, c, ignoreDisabled) {
  var action = this.editorUi.actions.get(key);
  var elt = null;
  if (action != null) {
    var tooltip = action.label;
    if (action.shortcut != null) {
      tooltip += " (" + action.shortcut + ")";
    }
    elt = this.addButton(sprite, tooltip, action.funct, c);
    if (!ignoreDisabled && typeof elt.setEnabled === "function") {
      elt.setEnabled(action.enabled);
      action.addListener("stateChanged", function() {
        elt.setEnabled(action.enabled);
      });
    }
  }
  return elt;
};
Toolbar.prototype.addButton = function(classname, tooltip, funct, c) {
  var elt = this.createButton(classname);
  c = c != null ? c : this.container;
  this.initElement(elt, tooltip);
  this.addClickHandler(elt, funct);
  c.appendChild(elt);
  return elt;
};
Toolbar.prototype.initElement = function(elt, tooltip) {
  if (tooltip != null) {
    elt.setAttribute("title", tooltip);
  }
  this.addEnabledState(elt);
};
Toolbar.prototype.addEnabledState = function(elt) {
  var classname = elt.className;
  elt.setEnabled = function(value) {
    elt.enabled = value;
    if (value) {
      elt.className = classname;
    } else {
      elt.className = classname + " mxDisabled";
    }
  };
  elt.setEnabled(true);
};
Toolbar.prototype.addClickHandler = function(elt, funct) {
  if (funct != null) {
    mxEvent2.addListener(elt, "click", function(evt) {
      if (elt.enabled) {
        funct(evt);
      }
      mxEvent2.consume(evt);
    });
    mxEvent2.addListener(elt, mxClient2.IS_POINTER ? "pointerdown" : "mousedown", bind(this, function(evt) {
      evt.preventDefault();
    }));
  }
};
Toolbar.prototype.createButton = function(classname) {
  var elt = document.createElement("a");
  elt.className = "geButton";
  var inner = document.createElement("div");
  if (classname != null) {
    inner.className = "geSprite " + classname;
  }
  elt.appendChild(inner);
  return elt;
};
Toolbar.prototype.createLabel = function(label, tooltip) {
  var elt = document.createElement("a");
  elt.className = "geLabel";
  write(elt, label);
  return elt;
};
Toolbar.prototype.addMenuHandler = function(elt, showLabels, funct, showAll) {
  if (funct != null) {
    var graph = this.editorUi.editor.graph;
    var menu = null;
    var show3 = true;
    mxEvent2.addListener(elt, "click", bind(this, function(evt) {
      if (show3 && (elt.enabled == null || elt.enabled)) {
        graph.popupMenuHandler.hideMenu();
        menu = new mxPopupMenu(funct);
        menu.div.className += " geToolbarMenu";
        menu.showDisabled = showAll;
        menu.labels = showLabels;
        menu.autoExpand = true;
        var offset = getOffset(elt);
        menu.popup(offset.x, offset.y + elt.offsetHeight, null, evt);
        this.editorUi.setCurrentMenu(menu, elt);
        if (!showLabels && menu.div.scrollHeight > menu.div.clientHeight) {
          menu.div.style.width = "40px";
        }
        menu.hideMenu = bind(this, function() {
          mxPopupMenu.prototype.hideMenu.apply(menu, arguments);
          this.editorUi.resetCurrentMenu();
          menu.destroy();
        });
        menu.addListener(mxEvent2.EVENT_HIDE, bind(this, function() {
          this.currentElt = null;
        }));
      }
      show3 = true;
      mxEvent2.consume(evt);
    }));
    mxEvent2.addListener(elt, mxClient2.IS_POINTER ? "pointerdown" : "mousedown", bind(this, function(evt) {
      show3 = this.currentElt != elt;
      evt.preventDefault();
    }));
  }
};
Toolbar.prototype.destroy = function() {
  if (this.gestureHandler != null) {
    mxEvent2.removeGestureListeners(document, this.gestureHandler);
    this.gestureHandler = null;
  }
};

// js/graph/mxKeyHandler.js
var mxKeyHandler = function(graph, target) {
  if (graph != null) {
    this.graph = graph;
    this.target = target || document.documentElement;
    this.normalKeys = [];
    this.shiftKeys = [];
    this.controlKeys = [];
    this.controlShiftKeys = [];
    this.keydownHandler = bind(this, (evt) => {
      this.keyDown(evt);
    });
    mxEvent2.addListener(this.target, "keydown", this.keydownHandler);
    if (mxClient_default.IS_IE) {
      mxEvent2.addListener(window, "unload", bind(this, () => {
        this.destroy();
      }));
    }
  }
};
mxKeyHandler.prototype.graph = null;
mxKeyHandler.prototype.target = null;
mxKeyHandler.prototype.normalKeys = null;
mxKeyHandler.prototype.shiftKeys = null;
mxKeyHandler.prototype.controlKeys = null;
mxKeyHandler.prototype.controlShiftKeys = null;
mxKeyHandler.prototype.enabled = true;
mxKeyHandler.prototype.isEnabled = function() {
  return this.enabled;
};
mxKeyHandler.prototype.setEnabled = function(enabled) {
  this.enabled = enabled;
};
mxKeyHandler.prototype.bindKey = function(code, funct) {
  this.normalKeys[code] = funct;
};
mxKeyHandler.prototype.bindShiftKey = function(code, funct) {
  this.shiftKeys[code] = funct;
};
mxKeyHandler.prototype.bindControlKey = function(code, funct) {
  this.controlKeys[code] = funct;
};
mxKeyHandler.prototype.bindControlShiftKey = function(code, funct) {
  this.controlShiftKeys[code] = funct;
};
mxKeyHandler.prototype.isControlDown = function(evt) {
  return mxEvent2.isControlDown(evt);
};
mxKeyHandler.prototype.getFunction = function(evt) {
  if (evt != null && !mxEvent2.isAltDown(evt)) {
    if (this.isControlDown(evt)) {
      return mxEvent2.isShiftDown(evt) ? this.controlShiftKeys[evt.keyCode] : this.controlKeys[evt.keyCode];
    } else {
      return mxEvent2.isShiftDown(evt) ? this.shiftKeys[evt.keyCode] : this.normalKeys[evt.keyCode];
    }
  }
  return null;
};
mxKeyHandler.prototype.isGraphEvent = function(evt) {
  const source = mxEvent2.getSource(evt);
  if (source === this.target || source.parentNode === this.target || this.graph.cellEditor != null && this.graph.cellEditor.isEventSource(evt)) {
    return true;
  }
  return isAncestorNode(this.graph.container, source);
};
mxKeyHandler.prototype.keyDown = function(evt) {
  if (this.isEnabledForEvent(evt)) {
    if (evt.keyCode === 27) {
      this.escape(evt);
    } else if (!this.isEventIgnored(evt)) {
      const boundFunction = this.getFunction(evt);
      if (boundFunction != null) {
        boundFunction(evt);
        mxEvent2.consume(evt);
      }
    }
  }
};
mxKeyHandler.prototype.isEnabledForEvent = function(evt) {
  return this.graph.isEnabled() && !mxEvent2.isConsumed(evt) && this.isGraphEvent(evt) && this.isEnabled();
};
mxKeyHandler.prototype.isEventIgnored = function(evt) {
  return this.graph.isEditing();
};
mxKeyHandler.prototype.escape = function(evt) {
  if (this.graph.isEscapeEnabled()) {
    this.graph.escape(evt);
  }
};
mxKeyHandler.prototype.destroy = function() {
  if (this.target != null && this.keydownHandler != null) {
    mxEvent2.removeListener(this.target, "keydown", this.keydownHandler);
    this.keydownHandler = null;
  }
  this.target = null;
};

// js/graph/mxAnimation.js
var mxAnimation = function(delay) {
  this.delay = delay != null ? delay : 20;
};
mxAnimation.prototype = new mxEventSource();
mxAnimation.prototype.constructor = mxAnimation;
mxAnimation.prototype.delay = null;
mxAnimation.prototype.thread = null;
mxAnimation.prototype.isRunning = function() {
  return this.thread != null;
};
mxAnimation.prototype.startAnimation = function() {
  if (this.thread == null) {
    this.thread = window.setInterval(bind(this, this.updateAnimation), this.delay);
  }
};
mxAnimation.prototype.updateAnimation = function() {
  this.fireEvent(new mxEventObject2(mxEvent2.EXECUTE));
};
mxAnimation.prototype.stopAnimation = function() {
  if (this.thread != null) {
    window.clearInterval(this.thread);
    this.thread = null;
    this.fireEvent(new mxEventObject2(mxEvent2.DONE));
  }
};

// js/graph/mxCellStatePreview.js
var mxCellStatePreview = function(graph) {
  this.deltas = new mxDictionary();
  this.graph = graph;
};
mxCellStatePreview.prototype.graph = null;
mxCellStatePreview.prototype.deltas = null;
mxCellStatePreview.prototype.count = 0;
mxCellStatePreview.prototype.isEmpty = function() {
  return this.count === 0;
};
mxCellStatePreview.prototype.moveState = function(state2, dx, dy, add = true, includeEdges = true) {
  let delta = this.deltas.get(state2.cell);
  if (delta == null) {
    delta = { point: new mxPoint2(dx, dy), state: state2 };
    this.deltas.put(state2.cell, delta);
    this.count++;
  } else if (add) {
    delta.point.x += dx;
    delta.point.y += dy;
  } else {
    delta.point.x = dx;
    delta.point.y = dy;
  }
  if (includeEdges) {
    this.addEdges(state2);
  }
  return delta.point;
};
mxCellStatePreview.prototype.show = function(visitor) {
  this.deltas.visit(bind(this, (key, delta) => {
    this.translateState(delta.state, delta.point.x, delta.point.y);
  }));
  this.deltas.visit(bind(this, (key, delta) => {
    this.revalidateState(delta.state, delta.point.x, delta.point.y, visitor);
  }));
};
mxCellStatePreview.prototype.translateState = function(state2, dx, dy) {
  if (state2 != null) {
    const model = this.graph.getModel();
    if (model.isVertex(state2.cell)) {
      state2.view.updateCellState(state2);
      const geo = model.getGeometry(state2.cell);
      if ((dx !== 0 || dy !== 0) && geo != null && (!geo.relative || this.deltas.get(state2.cell) != null)) {
        state2.x += dx;
        state2.y += dy;
      }
    }
    const childCount = model.getChildCount(state2.cell);
    for (let i = 0; i < childCount; i++) {
      const childState = state2.view.getState(model.getChildAt(state2.cell, i));
      this.translateState(childState, dx, dy);
    }
  }
};
mxCellStatePreview.prototype.revalidateState = function(state2, dx, dy, visitor) {
  if (state2 != null) {
    const model = this.graph.getModel();
    if (model.isEdge(state2.cell)) {
      state2.view.updateCellState(state2);
    }
    const geo = this.graph.getCellGeometry(state2.cell);
    const parentState = state2.view.getState(model.getParent(state2.cell));
    if ((dx !== 0 || dy !== 0) && geo != null && geo.relative && model.isVertex(state2.cell) && (parentState == null || model.isVertex(parentState.cell) || this.deltas.get(state2.cell) != null)) {
      state2.x += dx;
      state2.y += dy;
    }
    this.graph.cellRenderer.redraw(state2);
    if (visitor != null) {
      visitor(state2);
    }
    const childCount = model.getChildCount(state2.cell);
    for (let i = 0; i < childCount; i++) {
      const child = this.graph.view.getState(model.getChildAt(state2.cell, i));
      this.revalidateState(child, dx, dy, visitor);
    }
  }
};
mxCellStatePreview.prototype.addEdges = function(state2) {
  const model = this.graph.getModel();
  const edgeCount = model.getEdgeCount(state2.cell);
  for (let i = 0; i < edgeCount; i++) {
    const edgeState = state2.view.getState(model.getEdgeAt(state2.cell, i));
    if (edgeState != null) {
      this.moveState(edgeState, 0, 0);
    }
  }
};

// js/graph/mxMorphing.js
var mxMorphing = function(graph, steps, ease, delay) {
  mxAnimation.call(this, delay);
  this.graph = graph;
  this.steps = steps != null ? steps : 6;
  this.ease = ease != null ? ease : 1.5;
};
mxMorphing.prototype = new mxAnimation();
mxMorphing.prototype.constructor = mxMorphing;
mxMorphing.prototype.graph = null;
mxMorphing.prototype.steps = null;
mxMorphing.prototype.step = 0;
mxMorphing.prototype.ease = null;
mxMorphing.prototype.cells = null;
mxMorphing.prototype.updateAnimation = function() {
  mxAnimation.prototype.updateAnimation.apply(this, arguments);
  const move = new mxCellStatePreview(this.graph);
  if (this.cells != null) {
    for (let i = 0; i < this.cells.length; i++) {
      this.animateCell(this.cells[i], move, false);
    }
  } else {
    this.animateCell(this.graph.getModel().getRoot(), move, true);
  }
  this.show(move);
  if (move.isEmpty() || this.step++ >= this.steps) {
    this.stopAnimation();
  }
};
mxMorphing.prototype.show = function(move) {
  move.show();
};
mxMorphing.prototype.animateCell = function(cell2, move, recurse) {
  const state2 = this.graph.getView().getState(cell2);
  let delta = null;
  if (state2 != null) {
    delta = this.getDelta(state2);
    if (this.graph.getModel().isVertex(cell2) && (delta.x !== 0 || delta.y !== 0)) {
      const translate = this.graph.view.getTranslate();
      const scale = this.graph.view.getScale();
      delta.x += translate.x * scale;
      delta.y += translate.y * scale;
      move.moveState(state2, -delta.x / this.ease, -delta.y / this.ease);
    }
  }
  if (recurse && !this.stopRecursion(state2, delta)) {
    const childCount = this.graph.getModel().getChildCount(cell2);
    for (let i = 0; i < childCount; i++) {
      this.animateCell(this.graph.getModel().getChildAt(cell2, i), move, recurse);
    }
  }
};
mxMorphing.prototype.stopRecursion = function(state2, delta) {
  return delta != null && (delta.x !== 0 || delta.y !== 0);
};
mxMorphing.prototype.getDelta = function(state2) {
  const origin = this.getOriginForCell(state2.cell);
  const translate = this.graph.getView().getTranslate();
  const scale = this.graph.getView().getScale();
  const x = state2.x / scale - translate.x;
  const y = state2.y / scale - translate.y;
  return new mxPoint2((origin.x - x) * scale, (origin.y - y) * scale);
};
mxMorphing.prototype.getOriginForCell = function(cell2) {
  let result2 = null;
  if (cell2 != null) {
    const parent2 = this.graph.getModel().getParent(cell2);
    const geo = this.graph.getCellGeometry(cell2);
    result2 = this.getOriginForCell(parent2);
    if (geo != null) {
      if (geo.relative) {
        const pgeo = this.graph.getCellGeometry(parent2);
        if (pgeo != null) {
          result2.x += geo.x * pgeo.width;
          result2.y += geo.y * pgeo.height;
        }
      } else {
        result2.x += geo.x;
        result2.y += geo.y;
      }
    }
  }
  if (result2 == null) {
    const t = this.graph.view.getTranslate();
    result2 = new mxPoint2(-t.x, -t.y);
  }
  return result2;
};

// js/EditorUi.js
var EditorUi = function(editor, container, lightbox) {
  mxEventSource.call(this);
  this.destroyFunctions = [];
  this.editor = editor || new Editor2();
  this.container = container || document.body;
  let undoManager = this.editor.undoManager;
  let self = this;
  var graph = this.editor.graph;
  graph.lightbox = lightbox;
  this.initialDefaultVertexStyle = clone(graph.defaultVertexStyle);
  this.initialDefaultEdgeStyle = clone(graph.defaultEdgeStyle);
  if (graph.useCssTransforms) {
    this.lazyZoomDelay = 0;
  }
  if (mxClient2.IS_SVG) {
    mxPopupMenu.prototype.submenuImage = "data:image/gif;base64,R0lGODlhCQAJAIAAAP///zMzMyH5BAEAAAAALAAAAAAJAAkAAAIPhI8WebHsHopSOVgb26AAADs=";
  } else {
    new Image().src = mxPopupMenu.prototype.submenuImage;
  }
  if (!mxClient2.IS_SVG && mxConnectionHandler.prototype.connectImage != null) {
    new Image().src = mxConnectionHandler.prototype.connectImage.src;
  }
  if (this.editor.chromeless && !this.editor.editable) {
    this.footerHeight = 0;
    graph.isEnabled = function() {
      return false;
    };
    graph.panningHandler.isForcePanningEvent = function(me) {
      return !mxEvent2.isPopupTrigger(me.getEvent());
    };
  }
  this.actions = new Actions(this);
  this.menus = this.createMenus();
  if (!graph.standalone) {
    this.createDivs();
    this.createUi();
    this.refresh();
    var textEditing = bind(this, function(evt) {
      if (evt == null) {
        evt = window.event;
      }
      return graph.isEditing() || evt != null && this.isSelectionAllowed(evt);
    });
    if (this.container == document.body) {
      this.menubarContainer.onselectstart = textEditing;
      this.menubarContainer.onmousedown = textEditing;
      this.toolbarContainer.onselectstart = textEditing;
      this.toolbarContainer.onmousedown = textEditing;
      this.diagramContainer.onselectstart = textEditing;
      this.diagramContainer.onmousedown = textEditing;
      this.sidebarContainer.onselectstart = textEditing;
      this.sidebarContainer.onmousedown = textEditing;
      this.formatContainer.onselectstart = textEditing;
      this.formatContainer.onmousedown = textEditing;
      this.footerContainer.onselectstart = textEditing;
      this.footerContainer.onmousedown = textEditing;
      if (this.tabContainer != null) {
        this.tabContainer.onselectstart = textEditing;
      }
    }
    if (!this.editor.chromeless || this.editor.editable) {
      var linkHandler = function(evt) {
        if (evt != null) {
          var source = mxEvent2.getSource(evt);
          if (source.nodeName == "A") {
            while (source != null) {
              if (source.className == "geHint") {
                return true;
              }
              source = source.parentNode;
            }
          }
        }
        return textEditing(evt);
      };
      if (mxClient2.IS_IE && (typeof document.documentMode === "undefined" || document.documentMode < 9)) {
        mxEvent2.addListener(this.diagramContainer, "contextmenu", linkHandler);
      } else {
        this.diagramContainer.oncontextmenu = linkHandler;
      }
    } else {
      graph.panningHandler.usePopupTrigger = false;
    }
    graph.init(this.diagramContainer);
    if (mxClient2.IS_SVG && graph.view.getDrawPane() != null) {
      var root = graph.view.getDrawPane().ownerSVGElement;
      if (root != null) {
        root.style.position = "absolute";
      }
    }
    this.hoverIcons = this.createHoverIcons();
    if (graph.graphHandler != null) {
      var graphHandlerStart = graph.graphHandler.start;
      graph.graphHandler.start = function() {
        if (ui.hoverIcons != null) {
          ui.hoverIcons.reset();
        }
        graphHandlerStart.apply(this, arguments);
      };
    }
    mxEvent2.addListener(this.diagramContainer, "mousemove", bind(this, function(evt) {
      var off = getOffset(this.diagramContainer);
      if (mxEvent2.getClientX(evt) - off.x - this.diagramContainer.clientWidth > 0 || mxEvent2.getClientY(evt) - off.y - this.diagramContainer.clientHeight > 0) {
        this.diagramContainer.setAttribute("title", mxResources2.get("panTooltip"));
      } else {
        this.diagramContainer.removeAttribute("title");
      }
    }));
    var spaceKeyPressed = false;
    var hoverIconsIsResetEvent = this.hoverIcons.isResetEvent;
    this.hoverIcons.isResetEvent = function(evt, allowShift) {
      return spaceKeyPressed || hoverIconsIsResetEvent.apply(this, arguments);
    };
    this.keydownHandler = bind(this, function(evt) {
      if (evt.which == 32 && !graph.isEditing()) {
        spaceKeyPressed = true;
        this.hoverIcons.reset();
        graph.container.style.cursor = "move";
        if (!graph.isEditing() && mxEvent2.getSource(evt) == graph.container) {
          mxEvent2.consume(evt);
        }
      } else if (!mxEvent2.isConsumed(evt) && evt.keyCode == 27) {
        this.hideDialog(null, true);
      }
    });
    mxEvent2.addListener(document, "keydown", this.keydownHandler);
    this.keyupHandler = bind(this, function(evt) {
      graph.container.style.cursor = "";
      spaceKeyPressed = false;
    });
    mxEvent2.addListener(document, "keyup", this.keyupHandler);
    var panningHandlerIsForcePanningEvent = graph.panningHandler.isForcePanningEvent;
    graph.panningHandler.isForcePanningEvent = function(me) {
      return panningHandlerIsForcePanningEvent.apply(this, arguments) || spaceKeyPressed || mxEvent2.isMouseEvent(me.getEvent()) && (this.usePopupTrigger || !mxEvent2.isPopupTrigger(me.getEvent())) && (!mxEvent2.isControlDown(me.getEvent()) && mxEvent2.isRightMouseButton(me.getEvent()) || mxEvent2.isMiddleMouseButton(me.getEvent()));
    };
    var cellEditorIsStopEditingEvent = graph.cellEditor.isStopEditingEvent;
    graph.cellEditor.isStopEditingEvent = function(evt) {
      return cellEditorIsStopEditingEvent.apply(this, arguments) || evt.keyCode == 13 && (!mxClient2.IS_SF && mxEvent2.isControlDown(evt) || mxClient2.IS_MAC && mxEvent2.isMetaDown(evt) || mxClient2.IS_SF && mxEvent2.isShiftDown(evt));
    };
    var graphIsZoomWheelEvent = graph.isZoomWheelEvent;
    graph.isZoomWheelEvent = function() {
      return spaceKeyPressed || graphIsZoomWheelEvent.apply(this, arguments);
    };
    var textMode = false;
    var fontMenu = null;
    var sizeMenu = null;
    var nodes = null;
    var updateToolbar = bind(this, function() {
      if (this.toolbar != null && textMode != graph.cellEditor.isContentEditing()) {
        var node = this.toolbar.container.firstChild;
        var newNodes = [];
        while (node != null) {
          var tmp = node.nextSibling;
          if (indexOf(this.toolbar.staticElements, node) < 0) {
            node.parentNode.removeChild(node);
            newNodes.push(node);
          }
          node = tmp;
        }
        var tmp1 = this.toolbar.fontMenu;
        var tmp2 = this.toolbar.sizeMenu;
        if (nodes == null) {
          this.toolbar.createTextToolbar();
        } else {
          for (var i2 = 0; i2 < nodes.length; i2++) {
            this.toolbar.container.appendChild(nodes[i2]);
          }
          this.toolbar.fontMenu = fontMenu;
          this.toolbar.sizeMenu = sizeMenu;
        }
        textMode = graph.cellEditor.isContentEditing();
        fontMenu = tmp1;
        sizeMenu = tmp2;
        nodes = newNodes;
      }
    });
    var ui = this;
    var cellEditorStartEditing = graph.cellEditor.startEditing;
    graph.cellEditor.startEditing = function() {
      cellEditorStartEditing.apply(this, arguments);
      updateToolbar();
      if (graph.cellEditor.isContentEditing()) {
        var updating = false;
        var updateCssHandler = function() {
          if (!updating) {
            updating = true;
            window.setTimeout(function() {
              var node = graph.getSelectedEditingElement();
              if (node != null) {
                var css = getCurrentStyle(node);
                if (css != null && ui.toolbar != null) {
                  ui.toolbar.setFontName(Graph2.stripQuotes(css.fontFamily));
                  ui.toolbar.setFontSize(parseInt(css.fontSize));
                }
              }
              updating = false;
            }, 0);
          }
        };
        mxEvent2.addListener(graph.cellEditor.textarea, "input", updateCssHandler);
        mxEvent2.addListener(graph.cellEditor.textarea, "touchend", updateCssHandler);
        mxEvent2.addListener(graph.cellEditor.textarea, "mouseup", updateCssHandler);
        mxEvent2.addListener(graph.cellEditor.textarea, "keyup", updateCssHandler);
        updateCssHandler();
      }
    };
    var cellEditorStopEditing = graph.cellEditor.stopEditing;
    graph.cellEditor.stopEditing = function(cell2, trigger) {
      try {
        cellEditorStopEditing.apply(this, arguments);
        updateToolbar();
      } catch (e) {
        ui.handleError(e);
      }
    };
    graph.container.setAttribute("tabindex", "0");
    graph.container.style.cursor = "default";
    if (window.self === window.top && graph.container.parentNode != null) {
      try {
        graph.container.focus();
      } catch (e) {
      }
    }
    var graphFireMouseEvent = graph.fireMouseEvent;
    graph.fireMouseEvent = function(evtName, me, sender) {
      if (evtName == mxEvent2.MOUSE_DOWN) {
        this.container.focus();
      }
      graphFireMouseEvent.apply(this, arguments);
    };
    graph.popupMenuHandler.autoExpand = true;
    if (this.menus != null) {
      graph.popupMenuHandler.factoryMethod = bind(this, function(menu, cell2, evt) {
        this.menus.createPopupMenu(menu, cell2, evt);
      });
    }
    mxEvent2.addGestureListeners(document, bind(this, function(evt) {
      graph.popupMenuHandler.hideMenu();
    }));
    this.keyHandler = this.createKeyHandler(editor);
    this.getKeyHandler = function() {
      return keyHandler;
    };
    var styles = [
      "rounded",
      "shadow",
      "glass",
      "dashed",
      "dashPattern",
      "labelBackgroundColor",
      "comic",
      "sketch",
      "fillWeight",
      "hachureGap",
      "hachureAngle",
      "jiggle",
      "disableMultiStroke",
      "disableMultiStrokeFill",
      "fillStyle",
      "curveFitting",
      "simplification",
      "sketchStyle"
    ];
    var connectStyles = [
      "shape",
      "edgeStyle",
      "curved",
      "rounded",
      "elbow",
      "jumpStyle",
      "jumpSize",
      "comic",
      "sketch",
      "fillWeight",
      "hachureGap",
      "hachureAngle",
      "jiggle",
      "disableMultiStroke",
      "disableMultiStrokeFill",
      "fillStyle",
      "curveFitting",
      "simplification",
      "sketchStyle"
    ];
    this.setDefaultStyle = function(cell2) {
      try {
        var state2 = graph.view.getState(cell2);
        if (state2 != null) {
          var clone3 = cell2.clone();
          clone3.style = "";
          var defaultStyle = graph.getCellStyle(clone3);
          var values = [];
          var keys = [];
          for (var key in state2.style) {
            if (defaultStyle[key] != state2.style[key]) {
              values.push(state2.style[key]);
              keys.push(key);
            }
          }
          var cellStyle = graph.getModel().getStyle(state2.cell);
          var tokens = cellStyle != null ? cellStyle.split(";") : [];
          for (var i2 = 0; i2 < tokens.length; i2++) {
            var tmp = tokens[i2];
            var pos = tmp.indexOf("=");
            if (pos >= 0) {
              var key = tmp.substring(0, pos);
              var value = tmp.substring(pos + 1);
              if (defaultStyle[key] != null && value == "none") {
                values.push(value);
                keys.push(key);
              }
            }
          }
          if (graph.getModel().isEdge(state2.cell)) {
            graph.currentEdgeStyle = {};
          } else {
            graph.currentVertexStyle = {};
          }
          this.fireEvent(new mxEventObject2("styleChanged", "keys", keys, "values", values, "cells", [state2.cell]));
        }
      } catch (e) {
        this.handleError(e);
      }
    };
    this.clearDefaultStyle = function() {
      graph.currentEdgeStyle = clone(graph.defaultEdgeStyle);
      graph.currentVertexStyle = clone(graph.defaultVertexStyle);
      this.fireEvent(new mxEventObject2("styleChanged", "keys", [], "values", [], "cells", []));
    };
    var valueStyles = ["fontFamily", "fontSource", "fontSize", "fontColor"];
    var alwaysEdgeStyles = [
      "edgeStyle",
      "startArrow",
      "startFill",
      "startSize",
      "endArrow",
      "endFill",
      "endSize"
    ];
    var keyGroups = [
      [
        "startArrow",
        "startFill",
        "startSize",
        "sourcePerimeterSpacing",
        "endArrow",
        "endFill",
        "endSize",
        "targetPerimeterSpacing"
      ],
      ["strokeColor", "strokeWidth"],
      ["fillColor", "gradientColor"],
      valueStyles,
      ["opacity"],
      ["align"],
      ["html"]
    ];
    for (var i = 0; i < keyGroups.length; i++) {
      for (var j = 0; j < keyGroups[i].length; j++) {
        styles.push(keyGroups[i][j]);
      }
    }
    for (var i = 0; i < connectStyles.length; i++) {
      if (indexOf(styles, connectStyles[i]) < 0) {
        styles.push(connectStyles[i]);
      }
    }
    var insertHandler = function(cells, asText, model) {
      model = model != null ? model : graph.getModel();
      model.beginUpdate();
      try {
        for (var i2 = 0; i2 < cells.length; i2++) {
          var cell2 = cells[i2];
          var appliedStyles;
          if (asText) {
            appliedStyles = ["fontSize", "fontFamily", "fontColor"];
          } else {
            var cellStyle = model.getStyle(cell2);
            var tokens = cellStyle != null ? cellStyle.split(";") : [];
            appliedStyles = styles.slice();
            for (var j2 = 0; j2 < tokens.length; j2++) {
              var tmp = tokens[j2];
              var pos = tmp.indexOf("=");
              if (pos >= 0) {
                var key = tmp.substring(0, pos);
                var index = indexOf(appliedStyles, key);
                if (index >= 0) {
                  appliedStyles.splice(index, 1);
                }
                for (var k = 0; k < keyGroups.length; k++) {
                  var group = keyGroups[k];
                  if (indexOf(group, key) >= 0) {
                    for (var l = 0; l < group.length; l++) {
                      var index2 = indexOf(appliedStyles, group[l]);
                      if (index2 >= 0) {
                        appliedStyles.splice(index2, 1);
                      }
                    }
                  }
                }
              }
            }
          }
          var edge = model.isEdge(cell2);
          var current2 = edge ? graph.currentEdgeStyle : graph.currentVertexStyle;
          var newStyle = model.getStyle(cell2);
          for (var j2 = 0; j2 < appliedStyles.length; j2++) {
            var key = appliedStyles[j2];
            var styleValue = current2[key];
            if (styleValue != null && (key != "shape" || edge)) {
              if (!edge || indexOf(connectStyles, key) < 0) {
                newStyle = setStyle(newStyle, key, styleValue);
              }
            }
          }
          model.setStyle(cell2, newStyle);
        }
      } finally {
        model.endUpdate();
      }
    };
    graph.addListener("cellsInserted", function(sender, evt) {
      insertHandler(evt.getProperty("cells"));
    });
    graph.addListener("textInserted", function(sender, evt) {
      insertHandler(evt.getProperty("cells"), true);
    });
    this.insertHandler = insertHandler;
    graph.connectionHandler.addListener(mxEvent2.CONNECT, function(sender, evt) {
      var cells = [evt.getProperty("cell")];
      if (evt.getProperty("terminalInserted")) {
        cells.push(evt.getProperty("terminal"));
      }
      insertHandler(cells);
    });
    this.addListener("styleChanged", bind(this, function(sender, evt) {
      var cells = evt.getProperty("cells");
      var vertex = false;
      var edge = false;
      if (cells.length > 0) {
        for (var i2 = 0; i2 < cells.length; i2++) {
          vertex = graph.getModel().isVertex(cells[i2]) || vertex;
          edge = graph.getModel().isEdge(cells[i2]) || edge;
          if (edge && vertex) {
            break;
          }
        }
      } else {
        vertex = true;
        edge = true;
      }
      var keys = evt.getProperty("keys");
      var values = evt.getProperty("values");
      for (var i2 = 0; i2 < keys.length; i2++) {
        var common = indexOf(valueStyles, keys[i2]) >= 0;
        if (keys[i2] != "strokeColor" || values[i2] != null && values[i2] != "none") {
          if (indexOf(connectStyles, keys[i2]) >= 0) {
            if (edge || indexOf(alwaysEdgeStyles, keys[i2]) >= 0) {
              if (values[i2] == null) {
                delete graph.currentEdgeStyle[keys[i2]];
              } else {
                graph.currentEdgeStyle[keys[i2]] = values[i2];
              }
            } else if (vertex && indexOf(styles, keys[i2]) >= 0) {
              if (values[i2] == null) {
                delete graph.currentVertexStyle[keys[i2]];
              } else {
                graph.currentVertexStyle[keys[i2]] = values[i2];
              }
            }
          } else if (indexOf(styles, keys[i2]) >= 0) {
            if (vertex || common) {
              if (values[i2] == null) {
                delete graph.currentVertexStyle[keys[i2]];
              } else {
                graph.currentVertexStyle[keys[i2]] = values[i2];
              }
            }
            if (edge || common || indexOf(alwaysEdgeStyles, keys[i2]) >= 0) {
              if (values[i2] == null) {
                delete graph.currentEdgeStyle[keys[i2]];
              } else {
                graph.currentEdgeStyle[keys[i2]] = values[i2];
              }
            }
          }
        }
      }
      if (this.toolbar != null) {
        this.toolbar.setFontName(graph.currentVertexStyle["fontFamily"] || Menus.prototype.defaultFont);
        this.toolbar.setFontSize(graph.currentVertexStyle["fontSize"] || Menus.prototype.defaultFontSize);
        if (this.toolbar.edgeStyleMenu != null) {
          var edgeStyleDiv = this.toolbar.edgeStyleMenu.getElementsByTagName("div")[0];
          if (graph.currentEdgeStyle["edgeStyle"] == "orthogonalEdgeStyle" && graph.currentEdgeStyle["curved"] == "1") {
            edgeStyleDiv.className = "geSprite geSprite-curved";
          } else if (graph.currentEdgeStyle["edgeStyle"] == "straight" || graph.currentEdgeStyle["edgeStyle"] == "none" || graph.currentEdgeStyle["edgeStyle"] == null) {
            edgeStyleDiv.className = "geSprite geSprite-straight";
          } else if (graph.currentEdgeStyle["edgeStyle"] == "entityRelationEdgeStyle") {
            edgeStyleDiv.className = "geSprite geSprite-entity";
          } else if (graph.currentEdgeStyle["edgeStyle"] == "elbowEdgeStyle") {
            edgeStyleDiv.className = "geSprite geSprite-" + (graph.currentEdgeStyle["elbow"] == "vertical" ? "verticalelbow" : "horizontalelbow");
          } else if (graph.currentEdgeStyle["edgeStyle"] == "isometricEdgeStyle") {
            edgeStyleDiv.className = "geSprite geSprite-" + (graph.currentEdgeStyle["elbow"] == "vertical" ? "verticalisometric" : "horizontalisometric");
          } else {
            edgeStyleDiv.className = "geSprite geSprite-orthogonal";
          }
        }
        if (this.toolbar.edgeShapeMenu != null) {
          var edgeShapeDiv = this.toolbar.edgeShapeMenu.getElementsByTagName("div")[0];
          if (graph.currentEdgeStyle["shape"] == "link") {
            edgeShapeDiv.className = "geSprite geSprite-linkedge";
          } else if (graph.currentEdgeStyle["shape"] == "flexArrow") {
            edgeShapeDiv.className = "geSprite geSprite-arrow";
          } else if (graph.currentEdgeStyle["shape"] == "arrow") {
            edgeShapeDiv.className = "geSprite geSprite-simplearrow";
          } else {
            edgeShapeDiv.className = "geSprite geSprite-connection";
          }
        }
        if (this.toolbar.lineStartMenu != null) {
          var lineStartDiv = this.toolbar.lineStartMenu.getElementsByTagName("div")[0];
          lineStartDiv.className = this.getCssClassForMarker("start", graph.currentEdgeStyle["shape"], graph.currentEdgeStyle[mxConstants2.STYLE_STARTARROW], getValue(graph.currentEdgeStyle, "startFill", "1"));
        }
        if (this.toolbar.lineEndMenu != null) {
          var lineEndDiv = this.toolbar.lineEndMenu.getElementsByTagName("div")[0];
          lineEndDiv.className = this.getCssClassForMarker("end", graph.currentEdgeStyle["shape"], graph.currentEdgeStyle[mxConstants2.STYLE_ENDARROW], getValue(graph.currentEdgeStyle, "endFill", "1"));
        }
      }
    }));
    if (this.toolbar != null) {
      var update = bind(this, function() {
        var ff = graph.currentVertexStyle["fontFamily"] || "Helvetica";
        var fs = String(graph.currentVertexStyle["fontSize"] || "12");
        var state2 = graph.getView().getState(graph.getSelectionCell());
        if (state2 != null) {
          ff = state2.style[mxConstants2.STYLE_FONTFAMILY] || ff;
          fs = state2.style[mxConstants2.STYLE_FONTSIZE] || fs;
          if (ff.length > 10) {
            ff = ff.substring(0, 8) + "...";
          }
        }
        this.toolbar.setFontName(ff);
        this.toolbar.setFontSize(fs);
      });
      graph.getSelectionModel().addListener(mxEvent2.CHANGE, update);
      graph.getModel().addListener(mxEvent2.CHANGE, update);
    }
    graph.addListener(mxEvent2.CELLS_ADDED, function(sender, evt) {
      var cells = evt.getProperty("cells");
      var parent2 = evt.getProperty("parent");
      if (cells != null && cells.length > 0) {
        cells.forEach((cell2) => {
          if (graph.getModel().isVertex(cell2)) {
            var cellStyle = graph.getModel().getStyle(cell2);
            let type = "unknown";
            if (cellStyle && cellStyle.includes("shape=cloud"))
              type = "cloud";
            else if (cellStyle && cellStyle.includes("ellipse"))
              type = "process";
            else if (cellStyle && cellStyle.includes("cylinder"))
              type = "datastore";
            else if (cellStyle && cellStyle.includes("rhombus"))
              type = "gateway";
            console.log(`CELL ADDED: ${cell2.id}, Type: ${type}, Style: ${cellStyle}`);
          } else if (graph.getModel().isEdge(cell2)) {
            console.log(`EDGE ADDED: ${cell2.id}`);
          }
        });
      }
      if (graph.getModel().isLayer(parent2) && !graph.isCellVisible(parent2) && cells != null && cells.length > 0) {
        graph.getModel().setVisible(parent2, true);
      }
    });
    this.gestureHandler = bind(this, function(evt) {
      if (this.currentMenu != null && mxEvent2.getSource(evt) != this.currentMenu.div) {
        this.hideCurrentMenu();
      }
    });
    mxEvent2.addGestureListeners(document, this.gestureHandler);
    this.resizeHandler = bind(this, function() {
      window.setTimeout(bind(this, function() {
        if (this.editor.graph != null) {
          this.refresh();
        }
      }), 0);
    });
    mxEvent2.addListener(window, "resize", this.resizeHandler);
    this.orientationChangeHandler = bind(this, function() {
      this.refresh();
    });
    mxEvent2.addListener(window, "orientationchange", this.orientationChangeHandler);
    if (mxClient2.IS_IOS && !window.navigator.standalone) {
      this.scrollHandler = bind(this, function() {
        window.scrollTo(0, 0);
      });
      mxEvent2.addListener(window, "scroll", this.scrollHandler);
    }
    this.editor.addListener("resetGraphView", bind(this, function() {
      this.resetScrollbars();
    }));
    this.addListener("gridEnabledChanged", bind(this, function() {
      graph.view.validateBackground();
    }));
    this.addListener("backgroundColorChanged", bind(this, function() {
      graph.view.validateBackground();
    }));
    graph.addListener("gridSizeChanged", bind(this, function() {
      if (graph.isGridEnabled()) {
        graph.view.validateBackground();
      }
    }));
    this.editor.resetGraph();
  }
  this.init();
  if (!graph.standalone) {
    this.open();
  }
  this.addUndoListener();
  const commAnimator = new CommunicationAnimator(this);
  this.communicationAnimator = commAnimator;
};
extend(EditorUi, mxEventSource);
EditorUi.compactUi = true;
EditorUi.prototype.splitSize = mxClient2.IS_TOUCH || mxClient2.IS_POINTER ? 12 : 8;
EditorUi.prototype.menubarHeight = 30;
EditorUi.prototype.formatEnabled = true;
EditorUi.prototype.formatWidth = 240;
EditorUi.prototype.toolbarHeight = 38;
EditorUi.prototype.footerHeight = 28;
EditorUi.prototype.sidebarFooterHeight = 34;
EditorUi.prototype.hsplitPosition = screen.width <= 640 ? 118 : urlParams2["sidebar-entries"] != "large" ? 212 : 240;
EditorUi.prototype.allowAnimation = true;
EditorUi.prototype.lightboxMaxFitScale = 2;
EditorUi.prototype.lightboxVerticalDivider = 4;
EditorUi.prototype.hsplitClickEnabled = false;
EditorUi.prototype.init = function() {
  var graph = this.editor.graph;
  if (!graph.standalone) {
    if (urlParams2["shape-picker"] != "0") {
      this.installShapePicker();
    }
    mxEvent2.addListener(graph.container, "scroll", bind(this, function() {
      graph.tooltipHandler.hide();
      if (graph.connectionHandler != null && graph.connectionHandler.constraintHandler != null) {
        graph.connectionHandler.constraintHandler.reset();
      }
    }));
    graph.addListener(mxEvent2.ESCAPE, bind(this, function() {
      graph.tooltipHandler.hide();
      var rb = graph.getRubberband();
      if (rb != null) {
        rb.cancel();
      }
    }));
    mxEvent2.addListener(graph.container, "keydown", bind(this, function(evt) {
      this.onKeyDown(evt);
    }));
    mxEvent2.addListener(graph.container, "keypress", bind(this, function(evt) {
      this.onKeyPress(evt);
    }));
    this.addBeforeUnloadListener();
    graph.getSelectionModel().addListener(mxEvent2.CHANGE, bind(this, function() {
      this.updateActionStates();
    }));
    graph.getModel().addListener(mxEvent2.CHANGE, bind(this, function() {
      this.updateActionStates();
    }));
    var graphSetDefaultParent = graph.setDefaultParent;
    var ui = this;
    this.editor.graph.setDefaultParent = function() {
      graphSetDefaultParent.apply(this, arguments);
      ui.updateActionStates();
    };
    graph.editLink = ui.actions.get("editLink").funct;
    this.updateActionStates();
    this.initClipboard();
    this.initCanvas();
    if (this.format != null) {
      this.format.init();
    }
  }
};
EditorUi.prototype.installShapePicker = function() {
  var graph = this.editor.graph;
  var ui = this;
  graph.addListener(mxEvent2.FIRE_MOUSE_EVENT, bind(this, function(sender, evt) {
    if (evt.getProperty("eventName") == "mouseDown") {
      ui.hideShapePicker();
    }
  }));
  graph.addListener(mxEvent2.ESCAPE, bind(this, function() {
    ui.hideShapePicker(true);
  }));
  graph.getSelectionModel().addListener(mxEvent2.CHANGE, bind(this, function() {
    ui.hideShapePicker(true);
  }));
  graph.getModel().addListener(mxEvent2.CHANGE, bind(this, function() {
    ui.hideShapePicker(true);
  }));
  var popupMenuHandlerIsMenuShowing = graph.popupMenuHandler.isMenuShowing;
  graph.popupMenuHandler.isMenuShowing = function() {
    return popupMenuHandlerIsMenuShowing.apply(this, arguments) || ui.shapePicker != null;
  };
  var graphDblClick = graph.dblClick;
  graph.dblClick = function(evt, cell2) {
    if (this.isEnabled()) {
      if (cell2 == null && ui.sidebar != null && !mxEvent2.isShiftDown(evt)) {
        mxEvent2.consume(evt);
        var pt = convertPoint(this.container, mxEvent2.getClientX(evt), mxEvent2.getClientY(evt));
        window.setTimeout(bind(this, function() {
          ui.showShapePicker(pt.x, pt.y);
        }), 30);
      } else {
        graphDblClick.apply(this, arguments);
      }
    }
  };
  if (this.hoverIcons != null) {
    var hoverIconsDrag = this.hoverIcons.drag;
    this.hoverIcons.drag = function() {
      ui.hideShapePicker();
      hoverIconsDrag.apply(this, arguments);
    };
    var hoverIconsExecute = this.hoverIcons.execute;
    this.hoverIcons.execute = function(state2, dir, me) {
      var evt = me.getEvent();
      if (!this.graph.isCloneEvent(evt) && !mxEvent2.isShiftDown(evt)) {
        this.graph.connectVertex(state2.cell, dir, this.graph.defaultEdgeLength, evt, null, null, bind(this, function(x, y, execute) {
          var temp2 = graph.getCompositeParent(state2.cell);
          var geo = graph.getCellGeometry(temp2);
          me.consume();
          while (temp2 != null && graph.model.isVertex(temp2) && geo != null && geo.relative) {
            cell = temp2;
            temp2 = graph.model.getParent(cell);
            geo = graph.getCellGeometry(temp2);
          }
          window.setTimeout(bind(this, function() {
            ui.showShapePicker(me.getGraphX(), me.getGraphY(), temp2, bind(this, function(cell2) {
              execute(cell2);
            }), dir);
          }), 30);
        }), bind(this, function(result2) {
          this.graph.selectCellsForConnectVertex(result2, evt, this);
        }));
      } else {
        hoverIconsExecute.apply(this, arguments);
      }
    };
  }
};
EditorUi.prototype.showShapePicker = function(x, y, source, callback, direction) {
  var cells = this.getCellsForShapePicker(source);
  if (cells != null && cells.length > 0) {
    var ui = this;
    var graph = this.editor.graph;
    var div = document.createElement("div");
    var sourceState = graph.view.getState(source);
    var style = source != null && (sourceState == null || !graph.isTransparentState(sourceState)) ? graph.copyStyle(source) : null;
    div.className = "geToolbarContainer geSidebarContainer geSidebar";
    div.style.cssText = "position:absolute;left:" + x + "px;top:" + y + "px;width:140px;border-radius:10px;padding:4px;text-align:center;box-shadow:0px 0px 3px 1px #d1d1d1;padding: 6px 0 8px 0;";
    setPrefixedStyle(div.style, "transform", "translate(-22px,-22px)");
    if (graph.background != null && graph.background != mxConstants2.NONE) {
      div.style.backgroundColor = graph.background;
    }
    graph.container.appendChild(div);
    var addCell = bind(this, function(cell2) {
      var node = document.createElement("a");
      node.className = "geItem";
      node.style.cssText = "position:relative;display:inline-block;position:relative;width:30px;height:30px;cursor:pointer;overflow:hidden;padding:3px 0 0 3px;";
      div.appendChild(node);
      if (style != null) {
        this.sidebar.graph.pasteStyle(style, [cell2]);
      } else {
        ui.insertHandler([cell2], cell2.value != "", this.sidebar.graph.model);
      }
      this.sidebar.createThumb([cell2], 25, 25, node, null, true, false, cell2.geometry.width, cell2.geometry.height);
      mxEvent2.addListener(node, "click", function() {
        var clone3 = graph.cloneCell(cell2);
        if (callback != null) {
          callback(clone3);
        } else {
          clone3.geometry.x = graph.snap(Math.round(x / graph.view.scale) - graph.view.translate.x - cell2.geometry.width / 2);
          clone3.geometry.y = graph.snap(Math.round(y / graph.view.scale) - graph.view.translate.y - cell2.geometry.height / 2);
          graph.model.beginUpdate();
          try {
            graph.addCell(clone3);
          } finally {
            graph.model.endUpdate();
          }
          graph.setSelectionCell(clone3);
          graph.scrollCellToVisible(clone3);
          graph.startEditingAtCell(clone3);
          if (ui.hoverIcons != null) {
            ui.hoverIcons.update(graph.view.getState(clone3));
          }
        }
        ui.hideShapePicker();
      });
    });
    for (var i = 0; i < cells.length; i++) {
      addCell(cells[i]);
    }
    if (ui.hoverIcons != null) {
      ui.hoverIcons.reset();
    }
    graph.popupMenuHandler.hideMenu();
    graph.tooltipHandler.hideTooltip();
    this.hideCurrentMenu();
    this.hideShapePicker();
    this.shapePickerCallback = callback;
    this.shapePicker = div;
  }
};
EditorUi.prototype.getCellsForShapePicker = function(cell2) {
  var createVertex = bind(this, function(style, w2, h2, value) {
    return this.editor.graph.createVertex(null, null, value || "", 0, 0, w2 || 120, h2 || 60, style, false);
  });
  return [
    cell2 != null ? this.editor.graph.cloneCell(cell2) : createVertex("text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;", 40, 20, "Text"),
    createVertex("whiteSpace=wrap;html=1;"),
    createVertex("ellipse;whiteSpace=wrap;html=1;", 120, 80),
    createVertex("rhombus;whiteSpace=wrap;html=1;", 80, 80),
    createVertex("shape=parallelogram;perimeter=parallelogramPerimeter;whiteSpace=wrap;html=1;fixedSize=1;"),
    createVertex("shape=trapezoid;perimeter=trapezoidPerimeter;whiteSpace=wrap;html=1;fixedSize=1;", 120, 60),
    createVertex("shape=hexagon;perimeter=hexagonPerimeter2;whiteSpace=wrap;html=1;fixedSize=1;", 120, 80),
    createVertex("shape=step;perimeter=stepPerimeter;whiteSpace=wrap;html=1;fixedSize=1;", 120, 80),
    createVertex("shape=process;whiteSpace=wrap;html=1;backgroundOutline=1;"),
    createVertex("shape=cube;whiteSpace=wrap;html=1;boundedLbl=1;backgroundOutline=1;darkOpacity=0.05;darkOpacity2=0.1;", 120, 80),
    createVertex("shape=note;whiteSpace=wrap;html=1;backgroundOutline=1;darkOpacity=0.05;", 80, 100),
    createVertex("triangle;whiteSpace=wrap;html=1;", 60, 80),
    createVertex("shape=document;whiteSpace=wrap;html=1;boundedLbl=1;", 120, 80),
    createVertex("shape=tape;whiteSpace=wrap;html=1;", 120, 100),
    createVertex("ellipse;shape=cloud;whiteSpace=wrap;html=1;", 120, 80),
    createVertex("shape=cylinder;whiteSpace=wrap;html=1;boundedLbl=1;backgroundOutline=1;", 60, 80)
  ];
};
EditorUi.prototype.hideShapePicker = function(cancel) {
  if (this.shapePicker != null) {
    this.shapePicker.parentNode.removeChild(this.shapePicker);
    this.shapePicker = null;
    if (!cancel && this.shapePickerCallback != null) {
      this.shapePickerCallback();
    }
    this.shapePickerCallback = null;
  }
};
EditorUi.prototype.onKeyDown = function(evt) {
  var graph = this.editor.graph;
  if (evt.which == 9 && graph.isEnabled() && !mxEvent2.isAltDown(evt) && (!graph.isEditing() || !mxEvent2.isShiftDown(evt))) {
    if (graph.isEditing()) {
      graph.stopEditing(false);
    } else {
      graph.selectCell(!mxEvent2.isShiftDown(evt));
    }
    mxEvent2.consume(evt);
  }
};
EditorUi.prototype.onKeyPress = function(evt) {
  var graph = this.editor.graph;
  if (this.isImmediateEditingEvent(evt) && !graph.isEditing() && !graph.isSelectionEmpty() && evt.which !== 0 && evt.which !== 27 && !mxEvent2.isAltDown(evt) && !mxEvent2.isControlDown(evt) && !mxEvent2.isMetaDown(evt)) {
    graph.escape();
    graph.startEditing();
    if (mxClient2.IS_FF) {
      var ce = graph.cellEditor;
      if (ce.textarea != null) {
        ce.textarea.innerHTML = String.fromCharCode(evt.which);
        var range = document.createRange();
        range.selectNodeContents(ce.textarea);
        range.collapse(false);
        var sel2 = window.getSelection();
        sel2.removeAllRanges();
        sel2.addRange(range);
      }
    }
  }
};
EditorUi.prototype.isImmediateEditingEvent = function(evt) {
  return true;
};
EditorUi.prototype.getCssClassForMarker = function(prefix, shape, marker, fill) {
  var result2 = "";
  if (shape == "flexArrow") {
    result2 = marker != null && marker != mxConstants2.NONE ? "geSprite geSprite-" + prefix + "blocktrans" : "geSprite geSprite-noarrow";
  } else {
    if (marker == "box" || marker == "halfCircle") {
      result2 = "geSprite geSvgSprite geSprite-" + marker + (prefix == "end" ? " geFlipSprite" : "");
    } else if (marker == mxConstants2.ARROW_CLASSIC) {
      result2 = fill == "1" ? "geSprite geSprite-" + prefix + "classic" : "geSprite geSprite-" + prefix + "classictrans";
    } else if (marker == mxConstants2.ARROW_CLASSIC_THIN) {
      result2 = fill == "1" ? "geSprite geSprite-" + prefix + "classicthin" : "geSprite geSprite-" + prefix + "classicthintrans";
    } else if (marker == mxConstants2.ARROW_OPEN) {
      result2 = "geSprite geSprite-" + prefix + "open";
    } else if (marker == mxConstants2.ARROW_OPEN_THIN) {
      result2 = "geSprite geSprite-" + prefix + "openthin";
    } else if (marker == mxConstants2.ARROW_BLOCK) {
      result2 = fill == "1" ? "geSprite geSprite-" + prefix + "block" : "geSprite geSprite-" + prefix + "blocktrans";
    } else if (marker == mxConstants2.ARROW_BLOCK_THIN) {
      result2 = fill == "1" ? "geSprite geSprite-" + prefix + "blockthin" : "geSprite geSprite-" + prefix + "blockthintrans";
    } else if (marker == mxConstants2.ARROW_OVAL) {
      result2 = fill == "1" ? "geSprite geSprite-" + prefix + "oval" : "geSprite geSprite-" + prefix + "ovaltrans";
    } else if (marker == mxConstants2.ARROW_DIAMOND) {
      result2 = fill == "1" ? "geSprite geSprite-" + prefix + "diamond" : "geSprite geSprite-" + prefix + "diamondtrans";
    } else if (marker == mxConstants2.ARROW_DIAMOND_THIN) {
      result2 = fill == "1" ? "geSprite geSprite-" + prefix + "thindiamond" : "geSprite geSprite-" + prefix + "thindiamondtrans";
    } else if (marker == "openAsync") {
      result2 = "geSprite geSprite-" + prefix + "openasync";
    } else if (marker == "dash") {
      result2 = "geSprite geSprite-" + prefix + "dash";
    } else if (marker == "cross") {
      result2 = "geSprite geSprite-" + prefix + "cross";
    } else if (marker == "async") {
      result2 = fill == "1" ? "geSprite geSprite-" + prefix + "async" : "geSprite geSprite-" + prefix + "asynctrans";
    } else if (marker == "circle" || marker == "circlePlus") {
      result2 = fill == "1" || marker == "circle" ? "geSprite geSprite-" + prefix + "circle" : "geSprite geSprite-" + prefix + "circleplus";
    } else if (marker == "ERone") {
      result2 = "geSprite geSprite-" + prefix + "erone";
    } else if (marker == "ERmandOne") {
      result2 = "geSprite geSprite-" + prefix + "eronetoone";
    } else if (marker == "ERmany") {
      result2 = "geSprite geSprite-" + prefix + "ermany";
    } else if (marker == "ERoneToMany") {
      result2 = "geSprite geSprite-" + prefix + "eronetomany";
    } else if (marker == "ERzeroToOne") {
      result2 = "geSprite geSprite-" + prefix + "eroneopt";
    } else if (marker == "ERzeroToMany") {
      result2 = "geSprite geSprite-" + prefix + "ermanyopt";
    } else {
      result2 = "geSprite geSprite-noarrow";
    }
  }
  return result2;
};
EditorUi.prototype.createMenus = function() {
  return null;
};
EditorUi.prototype.updatePasteActionStates = function() {
  var graph = this.editor.graph;
  var paste = this.actions.get("paste");
  var pasteHere = this.actions.get("pasteHere");
  paste.setEnabled(this.editor.graph.cellEditor.isContentEditing() || !mxClipboard.isEmpty() && graph.isEnabled() && !graph.isCellLocked(graph.getDefaultParent()));
  pasteHere.setEnabled(paste.isEnabled());
};
EditorUi.prototype.initClipboard = function() {
  var ui = this;
  var mxClipboardCut = mxClipboard.cut;
  mxClipboard.cut = function(graph) {
    if (graph.cellEditor.isContentEditing()) {
      document.execCommand("cut", false, null);
    } else {
      mxClipboardCut.apply(this, arguments);
    }
    ui.updatePasteActionStates();
  };
  var mxClipboardCopy = mxClipboard.copy;
  mxClipboard.copy = function(graph) {
    var result2 = null;
    if (graph.cellEditor.isContentEditing()) {
      document.execCommand("copy", false, null);
    } else {
      result2 = result2 || graph.getSelectionCells();
      result2 = graph.getExportableCells(graph.model.getTopmostCells(result2));
      var cloneMap = new Object();
      var lookup = graph.createCellLookup(result2);
      var clones = graph.cloneCells(result2, null, cloneMap);
      var model = new mxGraphModel();
      var parent2 = model.getChildAt(model.getRoot(), 0);
      for (var i = 0; i < clones.length; i++) {
        model.add(parent2, clones[i]);
        var state2 = graph.view.getState(result2[i]);
        if (state2 != null) {
          var geo = graph.getCellGeometry(clones[i]);
          if (geo != null && geo.relative && !model.isEdge(result2[i]) && lookup[mxObjectIdentity.get(model.getParent(result2[i]))] == null) {
            geo.offset = null;
            geo.relative = false;
            geo.x = state2.x / state2.view.scale - state2.view.translate.x;
            geo.y = state2.y / state2.view.scale - state2.view.translate.y;
          }
        }
      }
      graph.updateCustomLinks(graph.createCellMapping(cloneMap, lookup), clones);
      mxClipboard.insertCount = 1;
      mxClipboard.setCells(clones);
    }
    ui.updatePasteActionStates();
    return result2;
  };
  var mxClipboardPaste = mxClipboard.paste;
  mxClipboard.paste = function(graph) {
    var result2 = null;
    if (graph.cellEditor.isContentEditing()) {
      document.execCommand("paste", false, null);
    } else {
      result2 = mxClipboardPaste.apply(this, arguments);
    }
    ui.updatePasteActionStates();
    return result2;
  };
  var cellEditorStartEditing = this.editor.graph.cellEditor.startEditing;
  this.editor.graph.cellEditor.startEditing = function() {
    cellEditorStartEditing.apply(this, arguments);
    ui.updatePasteActionStates();
  };
  var cellEditorStopEditing = this.editor.graph.cellEditor.stopEditing;
  this.editor.graph.cellEditor.stopEditing = function(cell2, trigger) {
    cellEditorStopEditing.apply(this, arguments);
    ui.updatePasteActionStates();
  };
  this.updatePasteActionStates();
};
EditorUi.prototype.lazyZoomDelay = 20;
EditorUi.prototype.wheelZoomDelay = 400;
EditorUi.prototype.buttonZoomDelay = 600;
EditorUi.prototype.initCanvas = function() {
  var graph = this.editor.graph;
  graph.timerAutoScroll = true;
  graph.getPagePadding = function() {
    return new mxPoint2(Math.max(0, Math.round((graph.container.offsetWidth - 34) / graph.view.scale)), Math.max(0, Math.round((graph.container.offsetHeight - 34) / graph.view.scale)));
  };
  graph.view.getBackgroundPageBounds = function() {
    var layout = this.graph.getPageLayout();
    var page = this.graph.getPageSize();
    return new mxRectangle(this.scale * (this.translate.x + layout.x * page.width), this.scale * (this.translate.y + layout.y * page.height), this.scale * layout.width * page.width, this.scale * layout.height * page.height);
  };
  graph.getPreferredPageSize = function(bounds, width, height) {
    var pages = this.getPageLayout();
    var size = this.getPageSize();
    return new mxRectangle(0, 0, pages.width * size.width, pages.height * size.height);
  };
  var resize = null;
  var ui = this;
  if (this.editor.isChromelessView()) {
    resize = bind(this, function(autoscale, maxScale, cx, cy) {
      if (graph.container != null && !graph.isViewer()) {
        cx = cx != null ? cx : 0;
        cy = cy != null ? cy : 0;
        var bds = graph.pageVisible ? graph.view.getBackgroundPageBounds() : graph.getGraphBounds();
        var scroll = hasScrollbars(graph.container);
        var tr = graph.view.translate;
        var s = graph.view.scale;
        var b = mxRectangle.fromRectangle(bds);
        b.x = b.x / s - tr.x;
        b.y = b.y / s - tr.y;
        b.width /= s;
        b.height /= s;
        var st = graph.container.scrollTop;
        var sl = graph.container.scrollLeft;
        var sb = mxClient2.IS_QUIRKS || document.documentMode >= 8 ? 20 : 14;
        if (document.documentMode == 8 || document.documentMode == 9) {
          sb += 3;
        }
        var cw = graph.container.offsetWidth - sb;
        var ch = graph.container.offsetHeight - sb;
        var ns = autoscale ? Math.max(0.3, Math.min(maxScale || 1, cw / b.width)) : s;
        var dx = (cw - ns * b.width) / 2 / ns;
        var dy = this.lightboxVerticalDivider == 0 ? 0 : (ch - ns * b.height) / this.lightboxVerticalDivider / ns;
        if (scroll) {
          dx = Math.max(dx, 0);
          dy = Math.max(dy, 0);
        }
        if (scroll || bds.width < cw || bds.height < ch) {
          graph.view.scaleAndTranslate(ns, Math.floor(dx - b.x), Math.floor(dy - b.y));
          graph.container.scrollTop = st * ns / s;
          graph.container.scrollLeft = sl * ns / s;
        } else if (cx != 0 || cy != 0) {
          var t = graph.view.translate;
          graph.view.setTranslate(Math.floor(t.x + cx / s), Math.floor(t.y + cy / s));
        }
      }
    });
    this.chromelessResize = resize;
    this.chromelessWindowResize = bind(this, function() {
      this.chromelessResize(false);
    });
    var autoscaleResize = bind(this, function() {
      this.chromelessWindowResize(false);
    });
    mxEvent2.addListener(window, "resize", autoscaleResize);
    this.destroyFunctions.push(function() {
      mxEvent2.removeListener(window, "resize", autoscaleResize);
    });
    this.editor.addListener("resetGraphView", bind(this, function() {
      this.chromelessResize(true);
    }));
    this.actions.get("zoomIn").funct = bind(this, function(evt) {
      graph.zoomIn();
      this.chromelessResize(false);
    });
    this.actions.get("zoomOut").funct = bind(this, function(evt) {
      graph.zoomOut();
      this.chromelessResize(false);
    });
    if (urlParams2["toolbar"] != "0") {
      var toolbarConfig = JSON.parse(decodeURIComponent(urlParams2["toolbar-config"] || "{}"));
      this.chromelessToolbar = document.createElement("div");
      this.chromelessToolbar.style.position = "fixed";
      this.chromelessToolbar.style.overflow = "hidden";
      this.chromelessToolbar.style.boxSizing = "border-box";
      this.chromelessToolbar.style.whiteSpace = "nowrap";
      this.chromelessToolbar.style.backgroundColor = "#000000";
      this.chromelessToolbar.style.padding = "10px 10px 8px 10px";
      this.chromelessToolbar.style.left = graph.isViewer() ? "0" : "50%";
      if (!mxClient2.IS_VML) {
        setPrefixedStyle(this.chromelessToolbar.style, "borderRadius", "20px");
        setPrefixedStyle(this.chromelessToolbar.style, "transition", "opacity 600ms ease-in-out");
      }
      var updateChromelessToolbarPosition = bind(this, function() {
        var css = getCurrentStyle(graph.container);
        if (graph.isViewer()) {
          this.chromelessToolbar.style.top = "0";
        } else {
          this.chromelessToolbar.style.bottom = (css != null ? parseInt(css["margin-bottom"] || 0) : 0) + (this.tabContainer != null ? 20 + parseInt(this.tabContainer.style.height) : 20) + "px";
        }
      });
      this.editor.addListener("resetGraphView", updateChromelessToolbarPosition);
      updateChromelessToolbarPosition();
      var btnCount = 0;
      var addButton = bind(this, function(fn, imgSrc, tip) {
        btnCount++;
        var a = document.createElement("span");
        a.style.paddingLeft = "8px";
        a.style.paddingRight = "8px";
        a.style.cursor = "pointer";
        mxEvent2.addListener(a, "click", fn);
        if (tip != null) {
          a.setAttribute("title", tip);
        }
        var img = document.createElement("img");
        img.setAttribute("border", "0");
        img.setAttribute("src", imgSrc);
        a.appendChild(img);
        this.chromelessToolbar.appendChild(a);
        return a;
      });
      if (toolbarConfig.backBtn != null) {
        addButton(bind(this, function(evt) {
          window.location.href = toolbarConfig.backBtn.url;
          mxEvent2.consume(evt);
        }), Editor2.backLargeImage, mxResources2.get("back", null, "Back"));
      }
      if (this.isPagesEnabled()) {
        var prevButton = addButton(bind(this, function(evt) {
          this.actions.get("previousPage").funct();
          mxEvent2.consume(evt);
        }), Editor2.previousLargeImage, mxResources2.get("previousPage"));
        var pageInfo = document.createElement("div");
        pageInfo.style.display = "inline-block";
        pageInfo.style.verticalAlign = "top";
        pageInfo.style.fontFamily = "Helvetica,Arial";
        pageInfo.style.marginTop = "8px";
        pageInfo.style.fontSize = "14px";
        pageInfo.style.color = "#ffffff";
        this.chromelessToolbar.appendChild(pageInfo);
        var nextButton = addButton(bind(this, function(evt) {
          this.actions.get("nextPage").funct();
          mxEvent2.consume(evt);
        }), Editor2.nextLargeImage, mxResources2.get("nextPage"));
        var updatePageInfo = bind(this, function() {
          if (this.pages != null && this.pages.length > 1 && this.currentPage != null) {
            pageInfo.innerHTML = "";
            write(pageInfo, indexOf(this.pages, this.currentPage) + 1 + " / " + this.pages.length);
          }
        });
        prevButton.style.paddingLeft = "0px";
        prevButton.style.paddingRight = "4px";
        nextButton.style.paddingLeft = "4px";
        nextButton.style.paddingRight = "0px";
        var updatePageButtons = bind(this, function() {
          if (this.pages != null && this.pages.length > 1 && this.currentPage != null) {
            nextButton.style.display = "";
            prevButton.style.display = "";
            pageInfo.style.display = "inline-block";
          } else {
            nextButton.style.display = "none";
            prevButton.style.display = "none";
            pageInfo.style.display = "none";
          }
          updatePageInfo();
        });
        this.editor.addListener("resetGraphView", updatePageButtons);
        this.editor.addListener("pageSelected", updatePageInfo);
      }
      addButton(bind(this, function(evt) {
        this.actions.get("zoomOut").funct();
        mxEvent2.consume(evt);
      }), Editor2.zoomOutLargeImage, mxResources2.get("zoomOut") + " (Alt+Mousewheel)");
      addButton(bind(this, function(evt) {
        this.actions.get("zoomIn").funct();
        mxEvent2.consume(evt);
      }), Editor2.zoomInLargeImage, mxResources2.get("zoomIn") + " (Alt+Mousewheel)");
      addButton(bind(this, function(evt) {
        if (graph.isLightboxView()) {
          if (graph.view.scale == 1) {
            this.lightboxFit();
          } else {
            graph.zoomTo(1);
          }
          this.chromelessResize(false);
        } else {
          this.chromelessResize(true);
        }
        mxEvent2.consume(evt);
      }), Editor2.actualSizeLargeImage, mxResources2.get("fit"));
      var fadeThread = null;
      var fadeThread2 = null;
      var fadeOut3 = bind(this, function(delay) {
        if (fadeThread != null) {
          window.clearTimeout(fadeThread);
          fadeThread = null;
        }
        if (fadeThread2 != null) {
          window.clearTimeout(fadeThread2);
          fadeThread2 = null;
        }
        fadeThread = window.setTimeout(bind(this, function() {
          setOpacity(this.chromelessToolbar, 0);
          fadeThread = null;
          fadeThread2 = window.setTimeout(bind(this, function() {
            this.chromelessToolbar.style.display = "none";
            fadeThread2 = null;
          }), 600);
        }), delay || 200);
      });
      var fadeIn = bind(this, function(opacity) {
        if (fadeThread != null) {
          window.clearTimeout(fadeThread);
          fadeThread = null;
        }
        if (fadeThread2 != null) {
          window.clearTimeout(fadeThread2);
          fadeThread2 = null;
        }
        this.chromelessToolbar.style.display = "";
        setOpacity(this.chromelessToolbar, opacity || 30);
      });
      if (urlParams2["layers"] == "1") {
        this.layersDialog = null;
        var layersButton = addButton(bind(this, function(evt) {
          if (this.layersDialog != null) {
            this.layersDialog.parentNode.removeChild(this.layersDialog);
            this.layersDialog = null;
          } else {
            this.layersDialog = graph.createLayersDialog();
            mxEvent2.addListener(this.layersDialog, "mouseleave", bind(this, function() {
              this.layersDialog.parentNode.removeChild(this.layersDialog);
              this.layersDialog = null;
            }));
            var r = layersButton.getBoundingClientRect();
            setPrefixedStyle(this.layersDialog.style, "borderRadius", "5px");
            this.layersDialog.style.position = "fixed";
            this.layersDialog.style.fontFamily = "Helvetica,Arial";
            this.layersDialog.style.backgroundColor = "#000000";
            this.layersDialog.style.width = "160px";
            this.layersDialog.style.padding = "4px 2px 4px 2px";
            this.layersDialog.style.color = "#ffffff";
            setOpacity(this.layersDialog, 70);
            this.layersDialog.style.left = r.left + "px";
            this.layersDialog.style.bottom = parseInt(this.chromelessToolbar.style.bottom) + this.chromelessToolbar.offsetHeight + 4 + "px";
            var style = getCurrentStyle(this.editor.graph.container);
            this.layersDialog.style.zIndex = style.zIndex;
            document.body.appendChild(this.layersDialog);
          }
          mxEvent2.consume(evt);
        }), Editor2.layersLargeImage, mxResources2.get("layers"));
        var model = graph.getModel();
        model.addListener(mxEvent2.CHANGE, function() {
          layersButton.style.display = model.getChildCount(model.root) > 1 ? "" : "none";
        });
      }
      if (urlParams2["openInSameWin"] != "1") {
        this.addChromelessToolbarItems(addButton);
      }
      if (this.editor.editButtonLink != null || this.editor.editButtonFunc != null) {
        addButton(bind(this, function(evt) {
          if (this.editor.editButtonFunc != null) {
            this.editor.editButtonFunc();
          } else if (this.editor.editButtonLink == "_blank") {
            this.editor.editAsNew(this.getEditBlankXml());
          } else {
            graph.openLink(this.editor.editButtonLink, "editWindow");
          }
          mxEvent2.consume(evt);
        }), Editor2.editLargeImage, mxResources2.get("edit"));
      }
      if (this.lightboxToolbarActions != null) {
        for (var i = 0; i < this.lightboxToolbarActions.length; i++) {
          var lbAction = this.lightboxToolbarActions[i];
          addButton(lbAction.fn, lbAction.icon, lbAction.tooltip);
        }
      }
      if (toolbarConfig.refreshBtn != null) {
        addButton(bind(this, function(evt) {
          if (toolbarConfig.refreshBtn.url) {
            window.location.href = toolbarConfig.refreshBtn.url;
          } else {
            window.location.reload();
          }
          mxEvent2.consume(evt);
        }), Editor2.refreshLargeImage, mxResources2.get("refresh", null, "Refresh"));
      }
      if (toolbarConfig.fullscreenBtn != null && window.self !== window.top) {
        addButton(bind(this, function(evt) {
          if (toolbarConfig.fullscreenBtn.url) {
            graph.openLink(toolbarConfig.fullscreenBtn.url);
          } else {
            graph.openLink(window.location.href);
          }
          mxEvent2.consume(evt);
        }), Editor2.fullscreenLargeImage, mxResources2.get("openInNewWindow", null, "Open in New Window"));
      }
      if (toolbarConfig.closeBtn && window.self === window.top || graph.lightbox && (urlParams2["close"] == "1" || this.container != document.body)) {
        addButton(bind(this, function(evt) {
          if (urlParams2["close"] == "1" || toolbarConfig.closeBtn) {
            window.close();
          } else {
            this.destroy();
            mxEvent2.consume(evt);
          }
        }), Editor2.closeLargeImage, mxResources2.get("close") + " (Escape)");
      }
      this.chromelessToolbar.style.display = "none";
      if (!graph.isViewer()) {
        setPrefixedStyle(this.chromelessToolbar.style, "transform", "translate(-50%,0)");
      }
      graph.container.appendChild(this.chromelessToolbar);
      mxEvent2.addListener(graph.container, mxClient2.IS_POINTER ? "pointermove" : "mousemove", bind(this, function(evt) {
        if (!mxEvent2.isTouchEvent(evt)) {
          if (!mxEvent2.isShiftDown(evt)) {
            fadeIn(30);
          }
          fadeOut3();
        }
      }));
      mxEvent2.addListener(this.chromelessToolbar, mxClient2.IS_POINTER ? "pointermove" : "mousemove", function(evt) {
        mxEvent2.consume(evt);
      });
      mxEvent2.addListener(this.chromelessToolbar, "mouseenter", bind(this, function(evt) {
        if (!mxEvent2.isShiftDown(evt)) {
          fadeIn(100);
        } else {
          fadeOut3();
        }
      }));
      mxEvent2.addListener(this.chromelessToolbar, "mousemove", bind(this, function(evt) {
        if (!mxEvent2.isShiftDown(evt)) {
          fadeIn(100);
        } else {
          fadeOut3();
        }
        mxEvent2.consume(evt);
      }));
      mxEvent2.addListener(this.chromelessToolbar, "mouseleave", bind(this, function(evt) {
        if (!mxEvent2.isTouchEvent(evt)) {
          fadeIn(30);
        }
      }));
      var tol = graph.getTolerance();
      graph.addMouseListener({
        startX: 0,
        startY: 0,
        scrollLeft: 0,
        scrollTop: 0,
        mouseDown: function(sender, me) {
          this.startX = me.getGraphX();
          this.startY = me.getGraphY();
          this.scrollLeft = graph.container.scrollLeft;
          this.scrollTop = graph.container.scrollTop;
        },
        mouseMove: function(sender, me) {
        },
        mouseUp: function(sender, me) {
          if (mxEvent2.isTouchEvent(me.getEvent())) {
            if (Math.abs(this.scrollLeft - graph.container.scrollLeft) < tol && Math.abs(this.scrollTop - graph.container.scrollTop) < tol && Math.abs(this.startX - me.getGraphX()) < tol && Math.abs(this.startY - me.getGraphY()) < tol) {
              if (parseFloat(ui.chromelessToolbar.style.opacity || 0) > 0) {
                fadeOut3();
              } else {
                fadeIn(30);
              }
            }
          }
        }
      });
    }
    if (!this.editor.editable) {
      this.addChromelessClickHandler();
    }
  } else if (this.editor.extendCanvas) {
    var graphViewValidate2 = graph.view.validate;
    graph.view.validate = function() {
      if (this.graph.container != null && hasScrollbars(this.graph.container)) {
        var pad = this.graph.getPagePadding();
        var size = this.graph.getPageSize();
        var tx = this.translate.x;
        var ty = this.translate.y;
        this.translate.x = pad.x - (this.x0 || 0) * size.width;
        this.translate.y = pad.y - (this.y0 || 0) * size.height;
      }
      graphViewValidate2.apply(this, arguments);
    };
    if (!graph.isViewer()) {
      var graphSizeDidChange = graph.sizeDidChange;
      graph.sizeDidChange = function() {
        if (this.container != null && hasScrollbars(this.container)) {
          var pages = this.getPageLayout();
          var pad = this.getPagePadding();
          var size = this.getPageSize();
          var minw = Math.ceil(2 * pad.x + pages.width * size.width);
          var minh = Math.ceil(2 * pad.y + pages.height * size.height);
          var min = graph.minimumGraphSize;
          if (min == null || min.width != minw || min.height != minh) {
            graph.minimumGraphSize = new mxRectangle(0, 0, minw, minh);
          }
          var dx = pad.x - pages.x * size.width;
          var dy = pad.y - pages.y * size.height;
          if (!this.autoTranslate && (this.view.translate.x != dx || this.view.translate.y != dy)) {
            this.autoTranslate = true;
            this.view.x0 = pages.x;
            this.view.y0 = pages.y;
            var tx = graph.view.translate.x;
            var ty = graph.view.translate.y;
            graph.view.setTranslate(dx, dy);
            graph.container.scrollLeft += Math.round((dx - tx) * graph.view.scale);
            graph.container.scrollTop += Math.round((dy - ty) * graph.view.scale);
            this.autoTranslate = false;
            return;
          }
          graphSizeDidChange.apply(this, arguments);
        } else {
          this.fireEvent(new mxEventObject2(mxEvent2.SIZE, "bounds", this.getGraphBounds()));
        }
      };
    }
  }
  var bgGroup = graph.view.getBackgroundPane();
  var mainGroup = graph.view.getDrawPane();
  graph.cumulativeZoomFactor = 1;
  var updateZoomTimeout = null;
  var cursorPosition = null;
  var scrollPosition = null;
  var forcedZoom = null;
  var filter = null;
  var scheduleZoom = function(delay) {
    if (updateZoomTimeout != null) {
      window.clearTimeout(updateZoomTimeout);
    }
    window.setTimeout(function() {
      if (!graph.isMouseDown || forcedZoom) {
        updateZoomTimeout = window.setTimeout(bind(this, function() {
          if (graph.isFastZoomEnabled()) {
            if (graph.view.backgroundPageShape != null && graph.view.backgroundPageShape.node != null) {
              setPrefixedStyle(graph.view.backgroundPageShape.node.style, "transform-origin", null);
              setPrefixedStyle(graph.view.backgroundPageShape.node.style, "transform", null);
            }
            mainGroup.style.transformOrigin = "";
            bgGroup.style.transformOrigin = "";
            if (mxClient2.IS_SF) {
              mainGroup.style.transform = "scale(1)";
              bgGroup.style.transform = "scale(1)";
              window.setTimeout(function() {
                mainGroup.style.transform = "";
                bgGroup.style.transform = "";
              }, 0);
            } else {
              mainGroup.style.transform = "";
              bgGroup.style.transform = "";
            }
            graph.view.getDecoratorPane().style.opacity = "";
            graph.view.getOverlayPane().style.opacity = "";
          }
          var sp = new mxPoint2(graph.container.scrollLeft, graph.container.scrollTop);
          var offset = getOffset(graph.container);
          var prev = graph.view.scale;
          var dx = 0;
          var dy = 0;
          if (cursorPosition != null) {
            dx = graph.container.offsetWidth / 2 - cursorPosition.x + offset.x;
            dy = graph.container.offsetHeight / 2 - cursorPosition.y + offset.y;
          }
          graph.zoom(graph.cumulativeZoomFactor);
          var s = graph.view.scale;
          if (s != prev) {
            if (scrollPosition != null) {
              dx += sp.x - scrollPosition.x;
              dy += sp.y - scrollPosition.y;
            }
            if (resize != null) {
              ui.chromelessResize(false, null, dx * (graph.cumulativeZoomFactor - 1), dy * (graph.cumulativeZoomFactor - 1));
            }
            if (hasScrollbars(graph.container) && (dx != 0 || dy != 0)) {
              graph.container.scrollLeft -= dx * (graph.cumulativeZoomFactor - 1);
              graph.container.scrollTop -= dy * (graph.cumulativeZoomFactor - 1);
            }
          }
          if (filter != null) {
            mainGroup.setAttribute("filter", filter);
          }
          graph.cumulativeZoomFactor = 1;
          updateZoomTimeout = null;
          scrollPosition = null;
          cursorPosition = null;
          forcedZoom = null;
          filter = null;
        }), delay != null ? delay : graph.isFastZoomEnabled() ? ui.wheelZoomDelay : ui.lazyZoomDelay);
      }
    }, 0);
  };
  graph.lazyZoom = function(zoomIn, ignoreCursorPosition, delay) {
    ignoreCursorPosition = ignoreCursorPosition || !graph.scrollbars;
    if (ignoreCursorPosition) {
      cursorPosition = new mxPoint2(graph.container.offsetLeft + graph.container.clientWidth / 2, graph.container.offsetTop + graph.container.clientHeight / 2);
    }
    if (zoomIn) {
      if (this.view.scale * this.cumulativeZoomFactor <= 0.15) {
        this.cumulativeZoomFactor *= (this.view.scale + 0.05) / this.view.scale;
      } else {
        this.cumulativeZoomFactor *= this.zoomFactor;
        this.cumulativeZoomFactor = Math.round(this.view.scale * this.cumulativeZoomFactor * 20) / 20 / this.view.scale;
      }
    } else {
      if (this.view.scale * this.cumulativeZoomFactor <= 0.15) {
        this.cumulativeZoomFactor *= (this.view.scale - 0.05) / this.view.scale;
      } else {
        this.cumulativeZoomFactor /= this.zoomFactor;
        this.cumulativeZoomFactor = Math.round(this.view.scale * this.cumulativeZoomFactor * 20) / 20 / this.view.scale;
      }
    }
    this.cumulativeZoomFactor = Math.max(0.05, Math.min(this.view.scale * this.cumulativeZoomFactor, 160)) / this.view.scale;
    if (graph.isFastZoomEnabled()) {
      if (filter == null && mainGroup.getAttribute("filter") != "") {
        filter = mainGroup.getAttribute("filter");
        mainGroup.removeAttribute("filter");
      }
      scrollPosition = new mxPoint2(graph.container.scrollLeft, graph.container.scrollTop);
      var cx = ignoreCursorPosition ? graph.container.scrollLeft + graph.container.clientWidth / 2 : cursorPosition.x + graph.container.scrollLeft - graph.container.offsetLeft;
      var cy = ignoreCursorPosition ? graph.container.scrollTop + graph.container.clientHeight / 2 : cursorPosition.y + graph.container.scrollTop - graph.container.offsetTop;
      mainGroup.style.transformOrigin = cx + "px " + cy + "px";
      mainGroup.style.transform = "scale(" + this.cumulativeZoomFactor + ")";
      bgGroup.style.transformOrigin = cx + "px " + cy + "px";
      bgGroup.style.transform = "scale(" + this.cumulativeZoomFactor + ")";
      if (graph.view.backgroundPageShape != null && graph.view.backgroundPageShape.node != null) {
        var page = graph.view.backgroundPageShape.node;
        setPrefixedStyle(page.style, "transform-origin", (ignoreCursorPosition ? graph.container.clientWidth / 2 + graph.container.scrollLeft - page.offsetLeft + "px" : cursorPosition.x + graph.container.scrollLeft - page.offsetLeft - graph.container.offsetLeft + "px") + " " + (ignoreCursorPosition ? graph.container.clientHeight / 2 + graph.container.scrollTop - page.offsetTop + "px" : cursorPosition.y + graph.container.scrollTop - page.offsetTop - graph.container.offsetTop + "px"));
        setPrefixedStyle(page.style, "transform", "scale(" + this.cumulativeZoomFactor + ")");
      }
      graph.view.getDecoratorPane().style.opacity = "0";
      graph.view.getOverlayPane().style.opacity = "0";
      if (ui.hoverIcons != null) {
        ui.hoverIcons.reset();
      }
    }
    scheduleZoom(delay);
  };
  mxEvent2.addGestureListeners(graph.container, function(evt) {
    if (updateZoomTimeout != null) {
      window.clearTimeout(updateZoomTimeout);
    }
  }, null, function(evt) {
    if (graph.cumulativeZoomFactor != 1) {
      scheduleZoom(0);
    }
  });
  mxEvent2.addListener(graph.container, "scroll", function(evt) {
    if (updateZoomTimeout != null && !graph.isMouseDown && graph.cumulativeZoomFactor != 1) {
      scheduleZoom(0);
    }
  });
  mxEvent2.addMouseWheelListener(bind(this, function(evt, up, force, cx, cy) {
    if (this.dialogs == null || this.dialogs.length == 0) {
      if (!graph.scrollbars && !force && graph.isScrollWheelEvent(evt)) {
        var t = graph.view.getTranslate();
        var step = 40 / graph.view.scale;
        if (!mxEvent2.isShiftDown(evt)) {
          graph.view.setTranslate(t.x, t.y + (up ? step : -step));
        } else {
          graph.view.setTranslate(t.x + (up ? -step : step), t.y);
        }
      } else if (force || graph.isZoomWheelEvent(evt)) {
        var source = mxEvent2.getSource(evt);
        while (source != null) {
          if (source == graph.container) {
            graph.tooltipHandler.hideTooltip();
            cursorPosition = cx != null && cy != null ? new mxPoint2(cx, cy) : new mxPoint2(mxEvent2.getClientX(evt), mxEvent2.getClientY(evt));
            forcedZoom = force;
            graph.lazyZoom(up);
            mxEvent2.consume(evt);
            return false;
          }
          source = source.parentNode;
        }
      }
    }
  }), graph.container);
  graph.panningHandler.zoomGraph = function(evt) {
    graph.cumulativeZoomFactor = evt.scale;
    graph.lazyZoom(evt.scale > 0, true);
    mxEvent2.consume(evt);
  };
};
EditorUi.prototype.addChromelessToolbarItems = function(addButton) {
  addButton(bind(this, function(evt) {
    this.actions.get("print").funct();
    mxEvent2.consume(evt);
  }), Editor2.printLargeImage, mxResources2.get("print"));
};
EditorUi.prototype.isPagesEnabled = function() {
  return this.editor.editable || urlParams2["hide-pages"] != "1";
};
EditorUi.prototype.createTemporaryGraph = function(stylesheet) {
  var graph = new Graph2(document.createElement("div"));
  graph.stylesheet.styles = clone(stylesheet.styles);
  graph.resetViewOnRootChange = false;
  graph.setConnectable(false);
  graph.gridEnabled = false;
  graph.autoScroll = false;
  graph.setTooltips(false);
  graph.setEnabled(false);
  graph.setSplitEnabled(false);
  graph.container.style.visibility = "hidden";
  graph.container.style.position = "absolute";
  graph.container.style.overflow = "hidden";
  graph.container.style.height = "1px";
  graph.container.style.width = "1px";
  return graph;
};
EditorUi.prototype.addChromelessClickHandler = function() {
  var hl = urlParams2["highlight"];
  if (hl != null && hl.length > 0) {
    hl = "#" + hl;
  }
  this.editor.graph.addClickHandler(hl);
};
EditorUi.prototype.toggleFormatPanel = function(visible) {
  visible = visible != null ? visible : this.formatWidth == 0;
  if (this.format != null) {
    this.formatWidth = visible ? 240 : 0;
    this.formatContainer.style.display = visible ? "" : "none";
    this.refresh();
    this.format.refresh();
    this.fireEvent(new mxEventObject2("formatWidthChanged"));
  }
};
EditorUi.prototype.lightboxFit = function(maxHeight) {
  if (this.isDiagramEmpty()) {
    this.editor.graph.view.setScale(1);
  } else {
    var p = urlParams2["border"];
    var border = 60;
    if (p != null) {
      border = parseInt(p);
    }
    this.editor.graph.maxFitScale = this.lightboxMaxFitScale;
    this.editor.graph.fit(border, null, null, null, null, null, maxHeight);
    this.editor.graph.maxFitScale = null;
  }
};
EditorUi.prototype.isDiagramEmpty = function() {
  var model = this.editor.graph.getModel();
  return model.getChildCount(model.root) == 1 && model.getChildCount(model.getChildAt(model.root, 0)) == 0;
};
EditorUi.prototype.isSelectionAllowed = function(evt) {
  return mxEvent2.getSource(evt).nodeName == "SELECT" || mxEvent2.getSource(evt).nodeName == "INPUT" && isAncestorNode(this.formatContainer, mxEvent2.getSource(evt));
};
EditorUi.prototype.addBeforeUnloadListener = function() {
  window.onbeforeunload = bind(this, function() {
    if (!this.editor.isChromelessView()) {
      return this.onBeforeUnload();
    }
  });
};
EditorUi.prototype.onBeforeUnload = function() {
  if (this.editor.modified) {
    return mxResources2.get("allChangesLost");
  }
};
EditorUi.prototype.open = function() {
  try {
    if (window.opener != null && window.opener.openFile != null) {
      window.opener.openFile.setConsumer(bind(this, function(xml2, filename) {
        try {
          var doc = parseXml(xml2);
          this.editor.setGraphXml(doc.documentElement);
          this.editor.setModified(false);
          this.editor.undoManager.clear();
          if (filename != null) {
            this.editor.setFilename(filename);
            this.updateDocumentTitle();
          }
          return;
        } catch (e) {
          alert2(mxResources2.get("invalidOrMissingFile") + ": " + e.message);
        }
      }));
    }
  } catch (e) {
  }
  this.editor.graph.view.validate();
  this.editor.graph.sizeDidChange();
  this.editor.fireEvent(new mxEventObject2("resetGraphView"));
};
EditorUi.prototype.showPopupMenu = function(fn, x, y, evt) {
  this.editor.graph.popupMenuHandler.hideMenu();
  var menu = new mxPopupMenu(fn);
  menu.div.className += " geMenubarMenu";
  menu.smartSeparators = true;
  menu.showDisabled = true;
  menu.autoExpand = true;
  menu.hideMenu = bind(this, function() {
    mxPopupMenu.prototype.hideMenu.apply(menu, arguments);
    menu.destroy();
  });
  menu.popup(x, y, null, evt);
  this.setCurrentMenu(menu);
};
EditorUi.prototype.setCurrentMenu = function(menu, elt) {
  this.currentMenuElt = elt;
  this.currentMenu = menu;
};
EditorUi.prototype.resetCurrentMenu = function() {
  this.currentMenuElt = null;
  this.currentMenu = null;
};
EditorUi.prototype.hideCurrentMenu = function() {
  if (this.currentMenu != null) {
    this.currentMenu.hideMenu();
    this.resetCurrentMenu();
  }
};
EditorUi.prototype.updateDocumentTitle = function() {
  var title = this.editor.getOrCreateFilename();
  if (this.editor.appName != null) {
    title += " - " + this.editor.appName;
  }
  document.title = title;
};
EditorUi.prototype.createHoverIcons = function() {
  return new HoverIcons(this.editor.graph);
};
EditorUi.prototype.redo = function() {
  try {
    var graph = this.editor.graph;
    if (graph.isEditing()) {
      document.execCommand("redo", false, null);
    } else {
      this.editor.undoManager.redo();
    }
  } catch (e) {
  }
};
EditorUi.prototype.undo = function() {
  try {
    var graph = this.editor.graph;
    if (graph.isEditing()) {
      var value = graph.cellEditor.textarea.innerHTML;
      document.execCommand("undo", false, null);
      if (value == graph.cellEditor.textarea.innerHTML) {
        graph.stopEditing(true);
        this.editor.undoManager.undo();
      }
    } else {
      this.editor.undoManager.undo();
    }
  } catch (e) {
  }
};
EditorUi.prototype.canRedo = function() {
  return this.editor.graph.isEditing() || this.editor.undoManager.canRedo();
};
EditorUi.prototype.canUndo = function() {
  return this.editor.graph.isEditing() || this.editor.undoManager.canUndo();
};
EditorUi.prototype.getEditBlankXml = function() {
  return getXml(this.editor.getGraphXml());
};
EditorUi.prototype.getUrl = function(pathname) {
  var href = pathname != null ? pathname : window.location.pathname;
  var parms = href.indexOf("?") > 0 ? 1 : 0;
  for (var key in urlParams2) {
    if (parms == 0) {
      href += "?";
    } else {
      href += "&";
    }
    href += key + "=" + urlParams2[key];
    parms++;
  }
  return href;
};
EditorUi.prototype.setScrollbars = function(value) {
  var graph = this.editor.graph;
  var prev = graph.container.style.overflow;
  graph.scrollbars = value;
  this.editor.updateGraphComponents();
  if (prev != graph.container.style.overflow) {
    graph.container.scrollTop = 0;
    graph.container.scrollLeft = 0;
    graph.view.scaleAndTranslate(1, 0, 0);
    this.resetScrollbars();
  }
  this.fireEvent(new mxEventObject2("scrollbarsChanged"));
};
EditorUi.prototype.hasScrollbars = function() {
  return this.editor.graph.scrollbars;
};
EditorUi.prototype.resetScrollbars = function() {
  var graph = this.editor.graph;
  if (!this.editor.extendCanvas) {
    graph.container.scrollTop = 0;
    graph.container.scrollLeft = 0;
    if (!hasScrollbars(graph.container)) {
      graph.view.setTranslate(0, 0);
    }
  } else if (!this.editor.isChromelessView()) {
    if (hasScrollbars(graph.container)) {
      if (graph.pageVisible) {
        var pad = graph.getPagePadding();
        graph.container.scrollTop = Math.floor(pad.y - this.editor.initialTopSpacing) - 1;
        graph.container.scrollLeft = Math.floor(Math.min(pad.x, (graph.container.scrollWidth - graph.container.clientWidth) / 2)) - 1;
        var bounds = graph.getGraphBounds();
        if (bounds.width > 0 && bounds.height > 0) {
          if (bounds.x > graph.container.scrollLeft + graph.container.clientWidth * 0.9) {
            graph.container.scrollLeft = Math.min(bounds.x + bounds.width - graph.container.clientWidth, bounds.x - 10);
          }
          if (bounds.y > graph.container.scrollTop + graph.container.clientHeight * 0.9) {
            graph.container.scrollTop = Math.min(bounds.y + bounds.height - graph.container.clientHeight, bounds.y - 10);
          }
        }
      } else {
        var bounds = graph.getGraphBounds();
        var width = Math.max(bounds.width, graph.scrollTileSize.width * graph.view.scale);
        var height = Math.max(bounds.height, graph.scrollTileSize.height * graph.view.scale);
        graph.container.scrollTop = Math.floor(Math.max(0, bounds.y - Math.max(20, (graph.container.clientHeight - height) / 4)));
        graph.container.scrollLeft = Math.floor(Math.max(0, bounds.x - Math.max(0, (graph.container.clientWidth - width) / 2)));
      }
    } else {
      var b = mxRectangle.fromRectangle(graph.pageVisible ? graph.view.getBackgroundPageBounds() : graph.getGraphBounds());
      var tr = graph.view.translate;
      var s = graph.view.scale;
      b.x = b.x / s - tr.x;
      b.y = b.y / s - tr.y;
      b.width /= s;
      b.height /= s;
      var dy = graph.pageVisible ? 0 : Math.max(0, (graph.container.clientHeight - b.height) / 4);
      graph.view.setTranslate(Math.floor(Math.max(0, (graph.container.clientWidth - b.width) / 2) - b.x + 2), Math.floor(dy - b.y + 1));
    }
  }
};
EditorUi.prototype.setPageVisible = function(value) {
  var graph = this.editor.graph;
  var hasScrollbars2 = hasScrollbars(graph.container);
  var tx = 0;
  var ty = 0;
  if (hasScrollbars2) {
    tx = graph.view.translate.x * graph.view.scale - graph.container.scrollLeft;
    ty = graph.view.translate.y * graph.view.scale - graph.container.scrollTop;
  }
  graph.pageVisible = value;
  graph.pageBreaksVisible = value;
  graph.preferPageSize = value;
  graph.view.validateBackground();
  if (hasScrollbars2) {
    var cells = graph.getSelectionCells();
    graph.clearSelection();
    graph.setSelectionCells(cells);
  }
  graph.sizeDidChange();
  if (hasScrollbars2) {
    graph.container.scrollLeft = graph.view.translate.x * graph.view.scale - tx;
    graph.container.scrollTop = graph.view.translate.y * graph.view.scale - ty;
  }
  this.fireEvent(new mxEventObject2("pageViewChanged"));
};
function ChangeGridColor2(ui, color) {
  this.ui = ui;
  this.color = color;
}
ChangeGridColor2.prototype.execute = function() {
  var temp2 = this.ui.editor.graph.view.gridColor;
  this.ui.setGridColor(this.color);
  this.color = temp2;
};
(function() {
  var codec = new mxObjectCodec(new ChangeGridColor2(), ["ui"]);
  mxCodecRegistry.register(codec);
})();
function ChangePageSetup2(ui, color, image, format, pageScale) {
  this.ui = ui;
  this.color = color;
  this.previousColor = color;
  this.image = image;
  this.previousImage = image;
  this.format = format;
  this.previousFormat = format;
  this.pageScale = pageScale;
  this.previousPageScale = pageScale;
  this.ignoreColor = false;
  this.ignoreImage = false;
}
ChangePageSetup2.prototype.execute = function() {
  var graph = this.ui.editor.graph;
  if (!this.ignoreColor) {
    this.color = this.previousColor;
    var tmp = graph.background;
    this.ui.setBackgroundColor(this.previousColor);
    this.previousColor = tmp;
  }
  if (!this.ignoreImage) {
    this.image = this.previousImage;
    var tmp = graph.backgroundImage;
    this.ui.setBackgroundImage(this.previousImage);
    this.previousImage = tmp;
  }
  if (this.previousFormat != null) {
    this.format = this.previousFormat;
    var tmp = graph.pageFormat;
    if (this.previousFormat.width != tmp.width || this.previousFormat.height != tmp.height) {
      this.ui.setPageFormat(this.previousFormat);
      this.previousFormat = tmp;
    }
  }
  if (this.foldingEnabled != null && this.foldingEnabled != this.ui.editor.graph.foldingEnabled) {
    this.ui.setFoldingEnabled(this.foldingEnabled);
    this.foldingEnabled = !this.foldingEnabled;
  }
  if (this.previousPageScale != null) {
    var currentPageScale = this.ui.editor.graph.pageScale;
    if (this.previousPageScale != currentPageScale) {
      this.ui.setPageScale(this.previousPageScale);
      this.previousPageScale = currentPageScale;
    }
  }
};
(function() {
  var codec = new mxObjectCodec(new ChangePageSetup2(), [
    "ui",
    "previousColor",
    "previousImage",
    "previousFormat",
    "previousPageScale"
  ]);
  codec.afterDecode = function(dec, node, obj) {
    obj.previousColor = obj.color;
    obj.previousImage = obj.image;
    obj.previousFormat = obj.format;
    obj.previousPageScale = obj.pageScale;
    if (obj.foldingEnabled != null) {
      obj.foldingEnabled = !obj.foldingEnabled;
    }
    return obj;
  };
  mxCodecRegistry.register(codec);
})();
EditorUi.prototype.setBackgroundColor = function(value) {
  this.editor.graph.background = value;
  this.editor.graph.view.validateBackground();
  this.fireEvent(new mxEventObject2("backgroundColorChanged"));
};
EditorUi.prototype.setFoldingEnabled = function(value) {
  this.editor.graph.foldingEnabled = value;
  this.editor.graph.view.revalidate();
  this.fireEvent(new mxEventObject2("foldingEnabledChanged"));
};
EditorUi.prototype.setPageFormat = function(value) {
  this.editor.graph.pageFormat = value;
  if (!this.editor.graph.pageVisible) {
    this.actions.get("pageView").funct();
  } else {
    this.editor.graph.view.validateBackground();
    this.editor.graph.sizeDidChange();
  }
  this.fireEvent(new mxEventObject2("pageFormatChanged"));
};
EditorUi.prototype.setPageScale = function(value) {
  this.editor.graph.pageScale = value;
  if (!this.editor.graph.pageVisible) {
    this.actions.get("pageView").funct();
  } else {
    this.editor.graph.view.validateBackground();
    this.editor.graph.sizeDidChange();
  }
  this.fireEvent(new mxEventObject2("pageScaleChanged"));
};
EditorUi.prototype.setGridColor = function(value) {
  this.editor.graph.view.gridColor = value;
  this.editor.graph.view.validateBackground();
  this.fireEvent(new mxEventObject2("gridColorChanged"));
};
EditorUi.prototype.addUndoListener = function() {
  var undo = this.actions.get("undo");
  var redo = this.actions.get("redo");
  var undoMgr = this.editor.undoManager;
  var undoListener = bind(this, function() {
    undo.setEnabled(this.canUndo());
    redo.setEnabled(this.canRedo());
  });
  undoMgr.addListener(mxEvent2.ADD, undoListener);
  undoMgr.addListener(mxEvent2.UNDO, undoListener);
  undoMgr.addListener(mxEvent2.REDO, undoListener);
  undoMgr.addListener(mxEvent2.CLEAR, undoListener);
  var cellEditorStartEditing = this.editor.graph.cellEditor.startEditing;
  this.editor.graph.cellEditor.startEditing = function() {
    cellEditorStartEditing.apply(this, arguments);
    undoListener();
  };
  var cellEditorStopEditing = this.editor.graph.cellEditor.stopEditing;
  this.editor.graph.cellEditor.stopEditing = function(cell2, trigger) {
    cellEditorStopEditing.apply(this, arguments);
    undoListener();
  };
  undoListener();
};
EditorUi.prototype.updateActionStates = function() {
  var graph = this.editor.graph;
  var selected = !graph.isSelectionEmpty();
  var vertexSelected = false;
  var groupSelected = false;
  var edgeSelected = false;
  var cells = graph.getSelectionCells();
  if (cells != null) {
    for (var i = 0; i < cells.length; i++) {
      var cell2 = cells[i];
      if (graph.getModel().isEdge(cell2)) {
        edgeSelected = true;
      }
      if (graph.getModel().isVertex(cell2)) {
        vertexSelected = true;
        if (graph.getModel().getChildCount(cell2) > 0 || graph.isContainer(cell2)) {
          groupSelected = true;
        }
      }
      if (edgeSelected && vertexSelected) {
        break;
      }
    }
  }
  var actions = [
    "cut",
    "copy",
    "bold",
    "italic",
    "underline",
    "delete",
    "duplicate",
    "editStyle",
    "editTooltip",
    "editLink",
    "backgroundColor",
    "borderColor",
    "edit",
    "toFront",
    "toBack",
    "lockUnlock",
    "solid",
    "dashed",
    "pasteSize",
    "dotted",
    "fillColor",
    "gradientColor",
    "shadow",
    "fontColor",
    "formattedText",
    "rounded",
    "toggleRounded",
    "sharp",
    "strokeColor"
  ];
  for (var i = 0; i < actions.length; i++) {
    this.actions.get(actions[i]).setEnabled(selected);
  }
  this.actions.get("setAsDefaultStyle").setEnabled(graph.getSelectionCount() == 1);
  this.actions.get("clearWaypoints").setEnabled(!graph.isSelectionEmpty());
  this.actions.get("copySize").setEnabled(graph.getSelectionCount() == 1);
  this.actions.get("turn").setEnabled(!graph.isSelectionEmpty());
  this.actions.get("curved").setEnabled(edgeSelected);
  this.actions.get("rotation").setEnabled(vertexSelected);
  this.actions.get("wordWrap").setEnabled(vertexSelected);
  this.actions.get("autosize").setEnabled(vertexSelected);
  var oneVertexSelected = vertexSelected && graph.getSelectionCount() == 1;
  this.actions.get("group").setEnabled(graph.getSelectionCount() > 1 || oneVertexSelected && !graph.isContainer(graph.getSelectionCell()));
  this.actions.get("ungroup").setEnabled(groupSelected);
  this.actions.get("removeFromGroup").setEnabled(oneVertexSelected && graph.getModel().isVertex(graph.getModel().getParent(graph.getSelectionCell())));
  var state2 = graph.view.getState(graph.getSelectionCell());
  this.menus.get("navigation").setEnabled(selected || graph.view.currentRoot != null);
  this.actions.get("collapsible").setEnabled(vertexSelected && (graph.isContainer(graph.getSelectionCell()) || graph.model.getChildCount(graph.getSelectionCell()) > 0));
  this.actions.get("home").setEnabled(graph.view.currentRoot != null);
  this.actions.get("exitGroup").setEnabled(graph.view.currentRoot != null);
  this.actions.get("enterGroup").setEnabled(graph.getSelectionCount() == 1 && graph.isValidRoot(graph.getSelectionCell()));
  var foldable = graph.getSelectionCount() == 1 && graph.isCellFoldable(graph.getSelectionCell());
  this.actions.get("expand").setEnabled(foldable);
  this.actions.get("collapse").setEnabled(foldable);
  this.actions.get("editLink").setEnabled(graph.getSelectionCount() == 1);
  this.actions.get("openLink").setEnabled(graph.getSelectionCount() == 1 && graph.getLinkForCell(graph.getSelectionCell()) != null);
  this.actions.get("guides").setEnabled(graph.isEnabled());
  this.actions.get("grid").setEnabled(!this.editor.chromeless || this.editor.editable);
  var unlocked = graph.isEnabled() && !graph.isCellLocked(graph.getDefaultParent());
  this.menus.get("layout").setEnabled(unlocked);
  this.menus.get("insert").setEnabled(unlocked);
  this.menus.get("direction").setEnabled(unlocked && vertexSelected);
  this.menus.get("align").setEnabled(unlocked && vertexSelected && graph.getSelectionCount() > 1);
  this.menus.get("distribute").setEnabled(unlocked && vertexSelected && graph.getSelectionCount() > 1);
  this.actions.get("selectVertices").setEnabled(unlocked);
  this.actions.get("selectEdges").setEnabled(unlocked);
  this.actions.get("selectAll").setEnabled(unlocked);
  this.actions.get("selectNone").setEnabled(unlocked);
  this.updatePasteActionStates();
};
EditorUi.prototype.zeroOffset = new mxPoint2(0, 0);
EditorUi.prototype.getDiagramContainerOffset = function() {
  return this.zeroOffset;
};
EditorUi.prototype.refresh = function(sizeDidChange) {
  sizeDidChange = sizeDidChange != null ? sizeDidChange : true;
  var quirks = mxClient2.IS_IE && (document.documentMode == null || document.documentMode == 5);
  var w2 = this.container.clientWidth;
  var h2 = this.container.clientHeight;
  if (this.container == document.body) {
    w2 = document.body.clientWidth || document.documentElement.clientWidth;
    h2 = quirks ? document.body.clientHeight || document.documentElement.clientHeight : document.documentElement.clientHeight;
  }
  var off = 0;
  if (mxClient2.IS_IOS && !window.navigator.standalone) {
    if (window.innerHeight != document.documentElement.clientHeight) {
      off = document.documentElement.clientHeight - window.innerHeight;
      window.scrollTo(0, 0);
    }
  }
  var effHsplitPosition = Math.max(0, Math.min(this.hsplitPosition, w2 - this.splitSize - 20));
  var tmp = 0;
  if (this.menubar != null) {
    this.menubarContainer.style.height = this.menubarHeight + "px";
    tmp += this.menubarHeight;
  }
  if (this.toolbar != null) {
    this.toolbarContainer.style.top = this.menubarHeight + "px";
    this.toolbarContainer.style.height = this.toolbarHeight + "px";
    tmp += this.toolbarHeight;
  }
  if (tmp > 0 && !mxClient2.IS_QUIRKS) {
    tmp += 1;
  }
  var sidebarFooterHeight = 0;
  if (this.sidebarFooterContainer != null) {
    var bottom = this.footerHeight + off;
    sidebarFooterHeight = Math.max(0, Math.min(h2 - tmp - bottom, this.sidebarFooterHeight));
    this.sidebarFooterContainer.style.width = effHsplitPosition + "px";
    this.sidebarFooterContainer.style.height = sidebarFooterHeight + "px";
    this.sidebarFooterContainer.style.bottom = bottom + "px";
  }
  var fw = this.format != null ? this.formatWidth : 0;
  this.sidebarContainer.style.top = tmp + "px";
  this.sidebarContainer.style.width = effHsplitPosition + "px";
  this.formatContainer.style.top = tmp + "px";
  this.formatContainer.style.width = fw + "px";
  this.formatContainer.style.display = this.format != null ? "" : "none";
  var diagContOffset = this.getDiagramContainerOffset();
  var contLeft = this.hsplit.parentNode != null ? effHsplitPosition + this.splitSize : 0;
  this.diagramContainer.style.left = contLeft + diagContOffset.x + "px";
  this.diagramContainer.style.top = tmp + diagContOffset.y + "px";
  this.footerContainer.style.height = this.footerHeight + "px";
  this.hsplit.style.top = this.sidebarContainer.style.top;
  this.hsplit.style.bottom = this.footerHeight + off + "px";
  this.hsplit.style.left = effHsplitPosition + "px";
  this.footerContainer.style.display = this.footerHeight == 0 ? "none" : "";
  if (this.tabContainer != null) {
    this.tabContainer.style.left = contLeft + "px";
  }
  if (quirks) {
    this.menubarContainer.style.width = w2 + "px";
    this.toolbarContainer.style.width = this.menubarContainer.style.width;
    var sidebarHeight = Math.max(0, h2 - this.footerHeight - this.menubarHeight - this.toolbarHeight);
    this.sidebarContainer.style.height = sidebarHeight - sidebarFooterHeight + "px";
    this.formatContainer.style.height = sidebarHeight + "px";
    this.diagramContainer.style.width = this.hsplit.parentNode != null ? Math.max(0, w2 - effHsplitPosition - this.splitSize - fw) + "px" : w2 + "px";
    this.footerContainer.style.width = this.menubarContainer.style.width;
    var diagramHeight = Math.max(0, h2 - this.footerHeight - this.menubarHeight - this.toolbarHeight);
    if (this.tabContainer != null) {
      this.tabContainer.style.width = this.diagramContainer.style.width;
      this.tabContainer.style.bottom = this.footerHeight + off + "px";
      diagramHeight -= this.tabContainer.clientHeight;
    }
    this.diagramContainer.style.height = diagramHeight + "px";
    this.hsplit.style.height = diagramHeight + "px";
  } else {
    if (this.footerHeight > 0) {
      this.footerContainer.style.bottom = off + "px";
    }
    this.diagramContainer.style.right = fw + "px";
    var th = 0;
    if (this.tabContainer != null) {
      this.tabContainer.style.bottom = this.footerHeight + off + "px";
      this.tabContainer.style.right = this.diagramContainer.style.right;
      th = this.tabContainer.clientHeight;
    }
    this.sidebarContainer.style.bottom = this.footerHeight + sidebarFooterHeight + off + "px";
    this.formatContainer.style.bottom = this.footerHeight + off + "px";
    this.diagramContainer.style.bottom = this.footerHeight + off + th + "px";
  }
  if (sizeDidChange) {
    this.editor.graph.sizeDidChange();
  }
};
EditorUi.prototype.createTabContainer = function() {
  return null;
};
EditorUi.prototype.createDivs = function() {
  this.menubarContainer = this.createDiv("geMenubarContainer");
  this.toolbarContainer = this.createDiv("geToolbarContainer");
  this.sidebarContainer = this.createDiv("geSidebarContainer");
  this.formatContainer = this.createDiv("geSidebarContainer geFormatContainer");
  this.diagramContainer = this.createDiv("geDiagramContainer");
  this.footerContainer = this.createDiv("geFooterContainer");
  this.hsplit = this.createDiv("geHsplit");
  this.hsplit.setAttribute("title", mxResources2.get("collapseExpand"));
  this.menubarContainer.style.top = "0px";
  this.menubarContainer.style.left = "0px";
  this.menubarContainer.style.right = "0px";
  this.toolbarContainer.style.left = "0px";
  this.toolbarContainer.style.right = "0px";
  this.sidebarContainer.style.left = "0px";
  this.formatContainer.style.right = "0px";
  this.formatContainer.style.zIndex = "1";
  this.diagramContainer.style.right = (this.format != null ? this.formatWidth : 0) + "px";
  this.footerContainer.style.left = "0px";
  this.footerContainer.style.right = "0px";
  this.footerContainer.style.bottom = "0px";
  this.footerContainer.style.zIndex = mxPopupMenu.prototype.zIndex - 2;
  this.hsplit.style.width = this.splitSize + "px";
  this.sidebarFooterContainer = this.createSidebarFooterContainer();
  if (this.sidebarFooterContainer) {
    this.sidebarFooterContainer.style.left = "0px";
  }
  if (!this.editor.chromeless) {
    this.tabContainer = this.createTabContainer();
  } else {
    this.diagramContainer.style.border = "none";
  }
};
EditorUi.prototype.createSidebarFooterContainer = function() {
  return null;
};
EditorUi.prototype.createUi = function() {
  this.menubar = this.editor.chromeless ? null : this.menus.createMenubar(this.createDiv("geMenubar"));
  if (this.menubar != null) {
    this.menubarContainer.appendChild(this.menubar.container);
  }
  if (this.menubar != null) {
    this.statusContainer = this.createStatusContainer();
    this.editor.addListener("statusChanged", bind(this, function() {
      this.setStatusText(this.editor.getStatus());
    }));
    this.setStatusText(this.editor.getStatus());
    this.menubar.container.appendChild(this.statusContainer);
    this.container.appendChild(this.menubarContainer);
  }
  this.sidebar = this.editor.chromeless ? null : this.createSidebar(this.sidebarContainer);
  if (this.sidebar != null) {
    this.container.appendChild(this.sidebarContainer);
  }
  this.format = this.editor.chromeless || !this.formatEnabled ? null : this.createFormat(this.formatContainer);
  if (this.format != null) {
    this.container.appendChild(this.formatContainer);
  }
  var footer = this.editor.chromeless ? null : this.createFooter();
  if (footer != null) {
    this.footerContainer.appendChild(footer);
    this.container.appendChild(this.footerContainer);
  }
  if (this.sidebar != null && this.sidebarFooterContainer) {
    this.container.appendChild(this.sidebarFooterContainer);
  }
  this.container.appendChild(this.diagramContainer);
  if (this.container != null && this.tabContainer != null) {
    this.container.appendChild(this.tabContainer);
  }
  this.toolbar = this.editor.chromeless ? null : this.createToolbar(this.createDiv("geToolbar"));
  if (this.toolbar != null) {
    this.toolbarContainer.appendChild(this.toolbar.container);
    this.container.appendChild(this.toolbarContainer);
  }
  if (this.sidebar != null) {
    this.container.appendChild(this.hsplit);
    this.addSplitHandler(this.hsplit, true, 0, bind(this, function(value) {
      this.hsplitPosition = value;
      this.refresh();
    }));
  }
};
EditorUi.prototype.createStatusContainer = function() {
  var container = document.createElement("a");
  container.className = "geItem geStatus";
  return container;
};
EditorUi.prototype.setStatusText = function(value) {
  this.statusContainer.innerHTML = value;
};
EditorUi.prototype.createToolbar = function(container) {
  return new Toolbar(this, container);
};
EditorUi.prototype.createSidebar = function(container) {
  return new Sidebar2(this, container);
};
EditorUi.prototype.createFormat = function(container) {
  return new Format(this, container);
};
EditorUi.prototype.createFooter = function() {
  return this.createDiv("geFooter");
};
EditorUi.prototype.createDiv = function(classname) {
  var elt = document.createElement("div");
  elt.className = classname;
  return elt;
};
EditorUi.prototype.addSplitHandler = function(elt, horizontal, dx, onChange) {
  var start = null;
  var initial = null;
  var ignoreClick = true;
  var last = null;
  if (mxClient2.IS_POINTER) {
    elt.style.touchAction = "none";
  }
  var getValue2 = bind(this, function() {
    var result2 = parseInt(horizontal ? elt.style.left : elt.style.bottom);
    if (!horizontal) {
      result2 = result2 + dx - this.footerHeight;
    }
    return result2;
  });
  function moveHandler(evt) {
    if (start != null) {
      var pt = new mxPoint2(mxEvent2.getClientX(evt), mxEvent2.getClientY(evt));
      onChange(Math.max(0, initial + (horizontal ? pt.x - start.x : start.y - pt.y) - dx));
      mxEvent2.consume(evt);
      if (initial != getValue2()) {
        ignoreClick = true;
        last = null;
      }
    }
  }
  function dropHandler(evt) {
    moveHandler(evt);
    initial = null;
    start = null;
  }
  mxEvent2.addGestureListeners(elt, function(evt) {
    start = new mxPoint2(mxEvent2.getClientX(evt), mxEvent2.getClientY(evt));
    initial = getValue2();
    ignoreClick = false;
    mxEvent2.consume(evt);
  });
  mxEvent2.addListener(elt, "click", bind(this, function(evt) {
    if (!ignoreClick && this.hsplitClickEnabled) {
      var next = last != null ? last - dx : 0;
      last = getValue2();
      onChange(next);
      mxEvent2.consume(evt);
    }
  }));
  mxEvent2.addGestureListeners(document, null, moveHandler, dropHandler);
  this.destroyFunctions.push(function() {
    mxEvent2.removeGestureListeners(document, null, moveHandler, dropHandler);
  });
};
EditorUi.prototype.handleError = function(resp, title, fn, invokeFnOnClose, notFoundMessage) {
  var e = resp != null && resp.error != null ? resp.error : resp;
  if (e != null || title != null) {
    var msg = htmlEntities(mxResources2.get("unknownError"));
    var btn = mxResources2.get("ok");
    title = title != null ? title : mxResources2.get("error");
    if (e != null && e.message != null) {
      msg = htmlEntities(e.message);
    }
    this.showError(title, msg, btn, fn, null, null, null, null, null, null, null, null, invokeFnOnClose ? fn : null);
  } else if (fn != null) {
    fn();
  }
};
EditorUi.prototype.showError = function(title, msg, btn, fn, retry, btn2, fn2, btn3, fn3, w2, h2, hide3, onClose) {
  var dlg = new ErrorDialog(this, title, msg, btn || mxResources2.get("ok"), fn, retry, btn2, fn2, hide3, btn3, fn3);
  var lines = Math.ceil(msg != null ? msg.length / 50 : 1);
  this.showDialog(dlg.container, w2 || 340, h2 || 100 + lines * 20, true, false, onClose);
  dlg.init();
};
EditorUi.prototype.showDialog = function(elt, w2, h2, modal, closable, onClose, noScroll, transparent, onResize, ignoreBgClick) {
  this.editor.graph.tooltipHandler.hideTooltip();
  if (this.dialogs == null) {
    this.dialogs = [];
  }
  this.dialog = new Dialog2(this, elt, w2, h2, modal, closable, onClose, noScroll, transparent, onResize, ignoreBgClick);
  this.dialogs.push(this.dialog);
};
EditorUi.prototype.hideDialog = function(cancel, isEsc) {
  if (this.dialogs != null && this.dialogs.length > 0) {
    var dlg = this.dialogs.pop();
    if (dlg.close(cancel, isEsc) == false) {
      this.dialogs.push(dlg);
      return;
    }
    this.dialog = this.dialogs.length > 0 ? this.dialogs[this.dialogs.length - 1] : null;
    this.editor.fireEvent(new mxEventObject2("hideDialog"));
    if (this.dialog == null && this.editor.graph.container.style.visibility != "hidden") {
      window.setTimeout(bind(this, function() {
        if (this.editor.graph.isEditing() && this.editor.graph.cellEditor.textarea != null) {
          this.editor.graph.cellEditor.textarea.focus();
        } else {
          clearSelection();
          this.editor.graph.container.focus();
        }
      }), 0);
    }
  }
};
EditorUi.prototype.ctrlEnter = function() {
  var graph = this.editor.graph;
  if (graph.isEnabled()) {
    try {
      var cells = graph.getSelectionCells();
      var lookup = new mxDictionary();
      var newCells = [];
      for (var i = 0; i < cells.length; i++) {
        var cell2 = graph.isTableCell(cells[i]) ? graph.model.getParent(cells[i]) : cells[i];
        if (cell2 != null && !lookup.get(cell2)) {
          lookup.put(cell2, true);
          newCells.push(cell2);
        }
      }
      graph.setSelectionCells(graph.duplicateCells(newCells, false));
    } catch (e) {
      this.handleError(e);
    }
  }
};
EditorUi.prototype.pickColor = function(color, apply) {
  var graph = this.editor.graph;
  var selState = graph.cellEditor.saveSelection();
  var h2 = 226 + (Math.ceil(ColorDialog2.prototype.presetColors.length / 12) + Math.ceil(ColorDialog2.prototype.defaultColors.length / 12)) * 17;
  var dlg = new ColorDialog2(this, color || "none", function(color2) {
    graph.cellEditor.restoreSelection(selState);
    apply(color2);
  }, function() {
    graph.cellEditor.restoreSelection(selState);
  });
  this.showDialog(dlg.container, 230, h2, true, false);
  dlg.init();
};
EditorUi.prototype.openFile = function() {
  window.openFile = new OpenFile(bind(this, function(cancel) {
    this.hideDialog(cancel);
  }));
  this.showDialog(new OpenDialog(this).container, Editor2.useLocalStorage ? 640 : 320, Editor2.useLocalStorage ? 480 : 220, true, true, function() {
    window.openFile = null;
  });
};
EditorUi.prototype.extractGraphModelFromHtml = function(data) {
  var result2 = null;
  try {
    var idx = data.indexOf("&lt;mxGraphModel ");
    if (idx >= 0) {
      var idx2 = data.lastIndexOf("&lt;/mxGraphModel&gt;");
      if (idx2 > idx) {
        result2 = data.substring(idx, idx2 + 21).replace(/&gt;/g, ">").replace(/&lt;/g, "<").replace(/\\&quot;/g, '"').replace(/\n/g, "");
      }
    }
  } catch (e) {
  }
  return result2;
};
EditorUi.prototype.extractGraphModelFromEvent = function(evt) {
  var result2 = null;
  var data = null;
  if (evt != null) {
    var provider = evt.dataTransfer != null ? evt.dataTransfer : evt.clipboardData;
    if (provider != null) {
      if (document.documentMode == 10 || document.documentMode == 11) {
        data = provider.getData("Text");
      } else {
        data = indexOf(provider.types, "text/html") >= 0 ? provider.getData("text/html") : null;
        if (indexOf(provider.types, data == null || data.length == 0)) {
          data = provider.getData("text/plain");
        }
      }
      if (data != null) {
        data = Graph2.zapGremlins(trim(data));
        var xml2 = this.extractGraphModelFromHtml(data);
        if (xml2 != null) {
          data = xml2;
        }
      }
    }
  }
  if (data != null && this.isCompatibleString(data)) {
    result2 = data;
  }
  return result2;
};
EditorUi.prototype.isCompatibleString = function(data) {
  return false;
};
EditorUi.prototype.saveFile = function(forceDialog) {
  if (!forceDialog && this.editor.filename != null) {
    this.save(this.editor.getOrCreateFilename());
  } else {
    var dlg = new FilenameDialog2(this, this.editor.getOrCreateFilename(), mxResources2.get("save"), bind(this, function(name) {
      this.save(name);
    }), null, bind(this, function(name) {
      if (name != null && name.length > 0) {
        return true;
      }
      confirm(mxResources2.get("invalidName"));
      return false;
    }));
    this.showDialog(dlg.container, 300, 100, true, true);
    dlg.init();
  }
};
EditorUi.prototype.save = function(name) {
  if (name != null) {
    if (this.editor.graph.isEditing()) {
      this.editor.graph.stopEditing();
    }
    var xml2 = getXml(this.editor.getGraphXml());
    try {
      {
        if (localStorage.getItem(name) != null && !confirm(mxResources2.get("replaceIt", [name]))) {
          return;
        }
        localStorage.setItem(name, xml2);
        const blob = new Blob([xml2], { type: "application/xml" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = name;
        a.style.display = "none";
        document.body.appendChild(a);
        a.click();
        setTimeout(function() {
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }, 0);
        this.editor.setStatus(htmlEntities(mxResources2.get("saved")) + " " + new Date());
      }
      this.editor.setModified(false);
      this.editor.setFilename(name);
      this.updateDocumentTitle();
    } catch (e) {
      this.editor.setStatus(htmlEntities(mxResources2.get("errorSavingFile")));
    }
  }
};
EditorUi.prototype.executeLayout = function(exec, animate, post2) {
  var graph = this.editor.graph;
  if (graph.isEnabled()) {
    graph.getModel().beginUpdate();
    try {
      exec();
    } catch (e) {
      throw e;
    } finally {
      if (this.allowAnimation && animate && (navigator.userAgent == null || navigator.userAgent.indexOf("Camino") < 0)) {
        var morph = new mxMorphing(graph);
        morph.addListener(mxEvent2.DONE, bind(this, function() {
          graph.getModel().endUpdate();
          if (post2 != null) {
            post2();
          }
        }));
        morph.startAnimation();
      } else {
        graph.getModel().endUpdate();
        if (post2 != null) {
          post2();
        }
      }
    }
  }
};
EditorUi.prototype.showImageDialog = function(title, value, fn, ignoreExisting) {
  var cellEditor = this.editor.graph.cellEditor;
  var selState = cellEditor.saveSelection();
  var newValue = prompt(title, value);
  cellEditor.restoreSelection(selState);
  if (newValue != null && newValue.length > 0) {
    var img = new Image();
    img.onload = function() {
      fn(newValue, img.width, img.height);
    };
    img.onerror = function() {
      fn(null);
      alert2(mxResources2.get("fileNotFound"));
    };
    img.src = newValue;
  } else {
    fn(null);
  }
};
EditorUi.prototype.showLinkDialog = function(value, btnLabel, fn) {
  var dlg = new LinkDialog(this, value, btnLabel, fn);
  this.showDialog(dlg.container, 420, 90, true, true);
  dlg.init();
};
EditorUi.prototype.showDataDialog = function(cell2) {
  if (cell2 != null) {
    var dlg = new EditDataDialog(this, cell2);
    this.showDialog(dlg.container, 480, 420, true, false, null, false);
    dlg.init();
  }
};
EditorUi.prototype.showBackgroundImageDialog = function(apply, img) {
  apply = apply != null ? apply : bind(this, function(image) {
    var change = new ChangePageSetup2(this, null, image);
    change.ignoreColor = true;
    this.editor.graph.model.execute(change);
  });
  var newValue = prompt(mxResources2.get("backgroundImage"), img != null ? img.src : "");
  if (newValue != null && newValue.length > 0) {
    var img = new Image();
    img.onload = function() {
      apply(new mxImage(newValue, img.width, img.height), false);
    };
    img.onerror = function() {
      apply(null, true);
      alert2(mxResources2.get("fileNotFound"));
    };
    img.src = newValue;
  } else {
    apply(null);
  }
};
EditorUi.prototype.setBackgroundImage = function(image) {
  this.editor.graph.setBackgroundImage(image);
  this.editor.graph.view.validateBackgroundImage();
  this.fireEvent(new mxEventObject2("backgroundImageChanged"));
};
EditorUi.prototype.confirm = function(msg, okFn, cancelFn) {
  if (confirm(msg)) {
    if (okFn != null) {
      okFn();
    }
  } else if (cancelFn != null) {
    cancelFn();
  }
};
EditorUi.prototype.createOutline = function(wnd) {
  var outline = new mxOutline(this.editor.graph);
  outline.border = 20;
  mxEvent2.addListener(window, "resize", function() {
    outline.update();
  });
  this.addListener("pageFormatChanged", function() {
    outline.update();
  });
  return outline;
};
EditorUi.prototype.altShiftActions = {
  67: "clearWaypoints",
  65: "connectionArrows",
  76: "editLink",
  80: "connectionPoints",
  84: "editTooltip",
  86: "pasteSize",
  88: "copySize"
};
EditorUi.prototype.createKeyHandler = function(editor) {
  var editorUi = this;
  editorUi.actions.get("import").funct();
  var graph = this.editor.graph;
  var keyHandler2 = new mxKeyHandler(graph);
  var isEventIgnored = keyHandler2.isEventIgnored;
  keyHandler2.isEventIgnored = function(evt) {
    return !(mxEvent2.isShiftDown(evt) && evt.keyCode == 9) && (!this.isControlDown(evt) || mxEvent2.isShiftDown(evt) || evt.keyCode != 90 && evt.keyCode != 89 && evt.keyCode != 188 && evt.keyCode != 190 && evt.keyCode != 85) && (evt.keyCode != 66 && evt.keyCode != 73 || !this.isControlDown(evt) || this.graph.cellEditor.isContentEditing() && !mxClient2.IS_FF && !mxClient2.IS_SF) && isEventIgnored.apply(this, arguments);
  };
  keyHandler2.isEnabledForEvent = function(evt) {
    return !mxEvent2.isConsumed(evt) && this.isGraphEvent(evt) && this.isEnabled() && (editorUi.dialogs == null || editorUi.dialogs.length == 0);
  };
  keyHandler2.isControlDown = function(evt) {
    return mxEvent2.isControlDown(evt) || mxClient2.IS_MAC && evt.metaKey;
  };
  var queue = [];
  var thread = null;
  function nudge(keyCode, stepSize, resize) {
    queue.push(function() {
      if (!graph.isSelectionEmpty() && graph.isEnabled()) {
        stepSize = stepSize != null ? stepSize : 1;
        if (resize) {
          graph.getModel().beginUpdate();
          try {
            var cells = graph.getSelectionCells();
            for (var i = 0; i < cells.length; i++) {
              if (graph.getModel().isVertex(cells[i]) && graph.isCellResizable(cells[i])) {
                var geo = graph.getCellGeometry(cells[i]);
                if (geo != null) {
                  geo = geo.clone();
                  if (keyCode == 37) {
                    geo.width = Math.max(0, geo.width - stepSize);
                  } else if (keyCode == 38) {
                    geo.height = Math.max(0, geo.height - stepSize);
                  } else if (keyCode == 39) {
                    geo.width += stepSize;
                  } else if (keyCode == 40) {
                    geo.height += stepSize;
                  }
                  graph.getModel().setGeometry(cells[i], geo);
                }
              }
            }
          } finally {
            graph.getModel().endUpdate();
          }
        } else {
          var cell2 = graph.getSelectionCell();
          var parent2 = graph.model.getParent(cell2);
          var layout = null;
          if (graph.getSelectionCount() == 1 && graph.model.isVertex(cell2) && graph.layoutManager != null && !graph.isCellLocked(cell2)) {
            layout = graph.layoutManager.getLayout(parent2);
          }
          if (layout != null && layout.constructor == mxStackLayout) {
            var index = parent2.getIndex(cell2);
            if (keyCode == 37 || keyCode == 38) {
              graph.model.add(parent2, cell2, Math.max(0, index - 1));
            } else if (keyCode == 39 || keyCode == 40) {
              graph.model.add(parent2, cell2, Math.min(graph.model.getChildCount(parent2), index + 1));
            }
          } else {
            var cells = graph.getMovableCells(graph.getSelectionCells());
            var realCells = [];
            for (var i = 0; i < cells.length; i++) {
              var style = graph.getCurrentCellStyle(cells[i]);
              if (getValue(style, "part", "0") == "1") {
                var parent2 = graph.model.getParent(cells[i]);
                if (graph.model.isVertex(parent2) && indexOf(cells, parent2) < 0) {
                  realCells.push(parent2);
                }
              } else {
                realCells.push(cells[i]);
              }
            }
            if (realCells.length > 0) {
              cells = realCells;
              var dx = 0;
              var dy = 0;
              if (keyCode == 37) {
                dx = -stepSize;
              } else if (keyCode == 38) {
                dy = -stepSize;
              } else if (keyCode == 39) {
                dx = stepSize;
              } else if (keyCode == 40) {
                dy = stepSize;
              }
              graph.moveCells(cells, dx, dy);
            }
          }
        }
      }
    });
    if (thread != null) {
      window.clearTimeout(thread);
    }
    thread = window.setTimeout(function() {
      if (queue.length > 0) {
        graph.getModel().beginUpdate();
        try {
          for (var i = 0; i < queue.length; i++) {
            queue[i]();
          }
          queue = [];
        } finally {
          graph.getModel().endUpdate();
        }
      }
    }, 200);
  }
  var directions = {
    37: mxConstants2.DIRECTION_WEST,
    38: mxConstants2.DIRECTION_NORTH,
    39: mxConstants2.DIRECTION_EAST,
    40: mxConstants2.DIRECTION_SOUTH
  };
  var keyHandlerGetFunction = keyHandler2.getFunction;
  mxKeyHandler.prototype.getFunction = function(evt) {
    if (graph.isEnabled()) {
      if (mxEvent2.isShiftDown(evt) && mxEvent2.isAltDown(evt)) {
        var action = editorUi.actions.get(editorUi.altShiftActions[evt.keyCode]);
        if (action != null) {
          return action.funct;
        }
      }
      if (evt.keyCode == 9 && mxEvent2.isAltDown(evt)) {
        if (graph.cellEditor.isContentEditing()) {
          return function() {
            document.execCommand("outdent", false, null);
          };
        } else if (mxEvent2.isShiftDown(evt)) {
          return function() {
            graph.selectParentCell();
          };
        } else {
          return function() {
            graph.selectChildCell();
          };
        }
      } else if (directions[evt.keyCode] != null && !graph.isSelectionEmpty()) {
        if (!this.isControlDown(evt) && mxEvent2.isShiftDown(evt) && mxEvent2.isAltDown(evt)) {
          if (graph.model.isVertex(graph.getSelectionCell())) {
            return function() {
              var cells = graph.connectVertex(graph.getSelectionCell(), directions[evt.keyCode], graph.defaultEdgeLength, evt, true);
              if (cells != null && cells.length > 0) {
                if (cells.length == 1 && graph.model.isEdge(cells[0])) {
                  graph.setSelectionCell(graph.model.getTerminal(cells[0], false));
                } else {
                  graph.setSelectionCell(cells[cells.length - 1]);
                }
                graph.scrollCellToVisible(graph.getSelectionCell());
                if (editorUi.hoverIcons != null) {
                  editorUi.hoverIcons.update(graph.view.getState(graph.getSelectionCell()));
                }
              }
            };
          }
        } else {
          if (this.isControlDown(evt)) {
            return function() {
              nudge(evt.keyCode, mxEvent2.isShiftDown(evt) ? graph.gridSize : null, true);
            };
          } else {
            return function() {
              nudge(evt.keyCode, mxEvent2.isShiftDown(evt) ? graph.gridSize : null);
            };
          }
        }
      }
    }
    return keyHandlerGetFunction.apply(this, arguments);
  };
  keyHandler2.bindAction = bind(this, function(code, control, key, shift) {
    var action = this.actions.get(key);
    if (action != null) {
      var f = function() {
        if (action.isEnabled()) {
          action.funct();
        }
      };
      if (control) {
        if (shift) {
          keyHandler2.bindControlShiftKey(code, f);
        } else {
          keyHandler2.bindControlKey(code, f);
        }
      } else {
        if (shift) {
          keyHandler2.bindShiftKey(code, f);
        } else {
          keyHandler2.bindKey(code, f);
        }
      }
    }
  });
  var ui = this;
  var keyHandlerEscape = keyHandler2.escape;
  keyHandler2.escape = function(evt) {
    keyHandlerEscape.apply(this, arguments);
  };
  keyHandler2.enter = function() {
  };
  keyHandler2.bindControlShiftKey(36, function() {
    graph.exitGroup();
  });
  keyHandler2.bindControlShiftKey(35, function() {
    graph.enterGroup();
  });
  keyHandler2.bindShiftKey(36, function() {
    graph.home();
  });
  keyHandler2.bindKey(35, function() {
    graph.refresh();
  });
  keyHandler2.bindAction(107, true, "zoomIn");
  keyHandler2.bindAction(109, true, "zoomOut");
  keyHandler2.bindAction(80, true, "print");
  keyHandler2.bindAction(79, true, "outline", true);
  if (!this.editor.chromeless || this.editor.editable) {
    keyHandler2.bindControlKey(36, function() {
      if (graph.isEnabled()) {
        graph.foldCells(true);
      }
    });
    keyHandler2.bindControlKey(35, function() {
      if (graph.isEnabled()) {
        graph.foldCells(false);
      }
    });
    keyHandler2.bindControlKey(13, function() {
      ui.ctrlEnter();
    });
    keyHandler2.bindAction(8, false, "delete");
    keyHandler2.bindAction(8, true, "deleteAll");
    keyHandler2.bindAction(8, false, "deleteLabels", true);
    keyHandler2.bindAction(46, false, "delete");
    keyHandler2.bindAction(46, true, "deleteAll");
    keyHandler2.bindAction(46, false, "deleteLabels", true);
    keyHandler2.bindAction(36, false, "resetView");
    keyHandler2.bindAction(72, true, "fitWindow", true);
    keyHandler2.bindAction(74, true, "fitPage");
    keyHandler2.bindAction(74, true, "fitTwoPages", true);
    keyHandler2.bindAction(48, true, "customZoom");
    keyHandler2.bindAction(82, true, "turn");
    keyHandler2.bindAction(82, true, "clearDefaultStyle", true);
    keyHandler2.bindAction(83, true, "save");
    keyHandler2.bindAction(83, true, "saveAs", true);
    keyHandler2.bindAction(65, true, "selectAll");
    keyHandler2.bindAction(65, true, "selectNone", true);
    keyHandler2.bindAction(73, true, "selectVertices", true);
    keyHandler2.bindAction(69, true, "selectEdges", true);
    keyHandler2.bindAction(69, true, "editStyle");
    keyHandler2.bindAction(66, true, "bold");
    keyHandler2.bindAction(66, true, "toBack", true);
    keyHandler2.bindAction(70, true, "toFront", true);
    keyHandler2.bindAction(68, true, "duplicate");
    keyHandler2.bindAction(68, true, "setAsDefaultStyle", true);
    keyHandler2.bindAction(90, true, "undo");
    keyHandler2.bindAction(89, true, "autosize", true);
    keyHandler2.bindAction(88, true, "cut");
    keyHandler2.bindAction(67, true, "copy");
    keyHandler2.bindAction(86, true, "paste");
    keyHandler2.bindAction(71, true, "group");
    keyHandler2.bindAction(77, true, "editData");
    keyHandler2.bindAction(71, true, "grid", true);
    keyHandler2.bindAction(73, true, "italic");
    keyHandler2.bindAction(76, true, "lockUnlock");
    keyHandler2.bindAction(76, true, "layers", true);
    keyHandler2.bindAction(80, true, "formatPanel", true);
    keyHandler2.bindAction(85, true, "underline");
    keyHandler2.bindAction(85, true, "ungroup", true);
    keyHandler2.bindAction(190, true, "superscript");
    keyHandler2.bindAction(188, true, "subscript");
    keyHandler2.bindAction(9, false, "indent", true);
    keyHandler2.bindKey(13, function() {
      if (graph.isEnabled()) {
        graph.startEditingAtCell();
      }
    });
    keyHandler2.bindKey(113, function() {
      if (graph.isEnabled()) {
        graph.startEditingAtCell();
      }
    });
  }
  if (!mxClient2.IS_WIN) {
    keyHandler2.bindAction(90, true, "redo", true);
  } else {
    keyHandler2.bindAction(89, true, "redo");
  }
  return keyHandler2;
};
EditorUi.prototype.destroy = function() {
  if (this.editor != null) {
    this.editor.destroy();
    this.editor = null;
  }
  if (this.menubar != null) {
    this.menubar.destroy();
    this.menubar = null;
  }
  if (this.toolbar != null) {
    this.toolbar.destroy();
    this.toolbar = null;
  }
  if (this.sidebar != null) {
    this.sidebar.destroy();
    this.sidebar = null;
  }
  if (this.keyHandler != null) {
    this.keyHandler.destroy();
    this.keyHandler = null;
  }
  if (this.keydownHandler != null) {
    mxEvent2.removeListener(document, "keydown", this.keydownHandler);
    this.keydownHandler = null;
  }
  if (this.keyupHandler != null) {
    mxEvent2.removeListener(document, "keyup", this.keyupHandler);
    this.keyupHandler = null;
  }
  if (this.resizeHandler != null) {
    mxEvent2.removeListener(window, "resize", this.resizeHandler);
    this.resizeHandler = null;
  }
  if (this.gestureHandler != null) {
    mxEvent2.removeGestureListeners(document, this.gestureHandler);
    this.gestureHandler = null;
  }
  if (this.orientationChangeHandler != null) {
    mxEvent2.removeListener(window, "orientationchange", this.orientationChangeHandler);
    this.orientationChangeHandler = null;
  }
  if (this.scrollHandler != null) {
    mxEvent2.removeListener(window, "scroll", this.scrollHandler);
    this.scrollHandler = null;
  }
  if (this.destroyFunctions != null) {
    for (var i = 0; i < this.destroyFunctions.length; i++) {
      this.destroyFunctions[i]();
    }
    this.destroyFunctions = null;
  }
  var c = [
    this.menubarContainer,
    this.toolbarContainer,
    this.sidebarContainer,
    this.formatContainer,
    this.diagramContainer,
    this.footerContainer,
    this.chromelessToolbar,
    this.hsplit,
    this.sidebarFooterContainer,
    this.layersDialog
  ];
  for (var i = 0; i < c.length; i++) {
    if (c[i] != null && c[i].parentNode != null) {
      c[i].parentNode.removeChild(c[i]);
    }
  }
};
EditorUi.prototype.createMenus = function() {
  return new Menus(this);
};

// js/graph/mxForm.js
var mxForm = function(className) {
  this.table = document.createElement("table");
  this.table.className = className;
  this.body = document.createElement("tbody");
  this.table.appendChild(this.body);
};
mxForm.prototype.table = null;
mxForm.prototype.body = false;
var getTable = mxForm.prototype.getTable = function() {
  return this.table;
};
var addButtons = mxForm.prototype.addButtons = function(okFunct, cancelFunct) {
  const tr = document.createElement("tr");
  let td = document.createElement("td");
  tr.appendChild(td);
  td = document.createElement("td");
  let button2 = document.createElement("button");
  write(button2, mxResources2.get("ok") || "OK");
  td.appendChild(button2);
  mxEvent2.addListener(button2, "click", () => {
    okFunct();
  });
  button2 = document.createElement("button");
  write(button2, mxResources2.get("cancel") || "Cancel");
  td.appendChild(button2);
  mxEvent2.addListener(button2, "click", () => {
    cancelFunct();
  });
  tr.appendChild(td);
  this.body.appendChild(tr);
};
var addText = mxForm.prototype.addText = function(name, value, type) {
  const input = document.createElement("input");
  input.setAttribute("type", type || "text");
  input.value = value;
  return this.addField(name, input);
};
var addCheckbox = mxForm.prototype.addCheckbox = function(name, value) {
  const input = document.createElement("input");
  input.setAttribute("type", "checkbox");
  this.addField(name, input);
  if (value) {
    input.checked = true;
  }
  return input;
};
var addTextarea = mxForm.prototype.addTextarea = function(name, value, rows) {
  const input = document.createElement("textarea");
  if (mxClient_default.IS_NS) {
    rows--;
  }
  input.setAttribute("rows", rows || 2);
  input.value = value;
  return this.addField(name, input);
};
var addCombo = mxForm.prototype.addCombo = function(name, isMultiSelect, size) {
  const select = document.createElement("select");
  if (size != null) {
    select.setAttribute("size", size);
  }
  if (isMultiSelect) {
    select.setAttribute("multiple", "true");
  }
  return this.addField(name, select);
};
var addOption = mxForm.prototype.addOption = function(combo, label, value, isSelected) {
  const option = document.createElement("option");
  writeln(option, label);
  option.setAttribute("value", value);
  if (isSelected) {
    option.setAttribute("selected", isSelected);
  }
  combo.appendChild(option);
};
var addField = mxForm.prototype.addField = function(name, input) {
  const tr = document.createElement("tr");
  let td = document.createElement("td");
  write(td, name);
  tr.appendChild(td);
  td = document.createElement("td");
  td.appendChild(input);
  tr.appendChild(td);
  this.body.appendChild(tr);
  return input;
};

// js/graph/mxImageExport.js
var includeOverlays = false;
function mxImageExport2() {
}
mxImageExport2.prototype.includeOverlays = includeOverlays;
var drawState = function(state2, canvas) {
  if (state2 != null) {
    this.visitStatesRecursive(state2, canvas, bind(this, function() {
      this.drawCellState.apply(this, arguments);
    }));
    if (this.includeOverlays) {
      this.visitStatesRecursive(state2, canvas, bind(this, function() {
        this.drawOverlays.apply(this, arguments);
      }));
    }
  }
};
mxImageExport2.prototype.drawState = drawState;
var visitStatesRecursive = function(state2, canvas, visitor) {
  if (state2 != null) {
    visitor(state2, canvas);
    const graph = state2.view.graph;
    const childCount = graph.model.getChildCount(state2.cell);
    for (let i = 0; i < childCount; i++) {
      const childState = graph.view.getState(graph.model.getChildAt(state2.cell, i));
      this.visitStatesRecursive(childState, canvas, visitor);
    }
  }
};
mxImageExport2.prototype.visitStatesRecursive = visitStatesRecursive;
var getLinkForCellState = function(state2, canvas) {
  return null;
};
mxImageExport2.prototype.getLinkForCellState = getLinkForCellState;
var drawCellState = function(state2, canvas) {
  const link2 = this.getLinkForCellState(state2, canvas);
  if (link2 != null) {
    canvas.setLink(link2);
  }
  this.drawShape(state2, canvas);
  this.drawText(state2, canvas);
  if (link2 != null) {
    canvas.setLink(null);
  }
};
mxImageExport2.prototype.drawCellState = drawCellState;
var drawShape = function(state2, canvas) {
  if (state2.shape instanceof mxShape && state2.shape.checkBounds()) {
    canvas.save();
    state2.shape.beforePaint(canvas);
    state2.shape.paint(canvas);
    state2.shape.afterPaint(canvas);
    canvas.restore();
  }
};
mxImageExport2.prototype.drawShape = drawShape;
var drawText = function(state2, canvas) {
  if (state2.text != null && state2.text.checkBounds()) {
    canvas.save();
    state2.text.beforePaint(canvas);
    state2.text.paint(canvas);
    state2.text.afterPaint(canvas);
    canvas.restore();
  }
};
mxImageExport2.prototype.drawText = drawText;
var drawOverlays = function(state2, canvas) {
  if (state2.overlays != null) {
    state2.overlays.visit(function(id, shape) {
      if (shape instanceof mxShape) {
        shape.paint(canvas);
      }
    });
  }
};
mxImageExport2.prototype.drawOverlays = drawOverlays;

// js/graph/mxXmlCanvas2D.js
function mxXmlCanvas2D(root) {
  mxAbstractCanvas2D.call(this);
  this.root = root;
  this.writeDefaults();
}
extend(mxXmlCanvas2D, mxAbstractCanvas2D);
mxXmlCanvas2D.prototype.textEnabled = true;
mxXmlCanvas2D.prototype.compressed = true;
mxXmlCanvas2D.prototype.writeDefaults = function() {
  let elem;
  elem = this.createElement("fontfamily");
  elem.setAttribute("family", mxConstants2.DEFAULT_FONTFAMILY);
  this.root.appendChild(elem);
  elem = this.createElement("fontsize");
  elem.setAttribute("size", mxConstants2.DEFAULT_FONTSIZE);
  this.root.appendChild(elem);
  elem = this.createElement("shadowcolor");
  elem.setAttribute("color", mxConstants2.SHADOWCOLOR);
  this.root.appendChild(elem);
  elem = this.createElement("shadowalpha");
  elem.setAttribute("alpha", mxConstants2.SHADOW_OPACITY);
  this.root.appendChild(elem);
  elem = this.createElement("shadowoffset");
  elem.setAttribute("dx", mxConstants2.SHADOW_OFFSET_X);
  elem.setAttribute("dy", mxConstants2.SHADOW_OFFSET_Y);
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.format = function(value) {
  return parseFloat(parseFloat(value).toFixed(2));
};
mxXmlCanvas2D.prototype.createElement = function(name) {
  return this.root.ownerDocument.createElement(name);
};
mxXmlCanvas2D.prototype.save = function() {
  if (this.compressed) {
    mxAbstractCanvas2D.prototype.save.apply(this, arguments);
  }
  this.root.appendChild(this.createElement("save"));
};
mxXmlCanvas2D.prototype.restore = function() {
  if (this.compressed) {
    mxAbstractCanvas2D.prototype.restore.apply(this, arguments);
  }
  this.root.appendChild(this.createElement("restore"));
};
mxXmlCanvas2D.prototype.scale = function(value) {
  const elem = this.createElement("scale");
  elem.setAttribute("scale", value);
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.translate = function(dx, dy) {
  const elem = this.createElement("translate");
  elem.setAttribute("dx", this.format(dx));
  elem.setAttribute("dy", this.format(dy));
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.rotate = function(theta, flipH, flipV, cx, cy) {
  const elem = this.createElement("rotate");
  if (theta != 0 || flipH || flipV) {
    elem.setAttribute("theta", this.format(theta));
    elem.setAttribute("flipH", flipH ? "1" : "0");
    elem.setAttribute("flipV", flipV ? "1" : "0");
    elem.setAttribute("cx", this.format(cx));
    elem.setAttribute("cy", this.format(cy));
    this.root.appendChild(elem);
  }
};
mxXmlCanvas2D.prototype.setAlpha = function(value) {
  if (this.compressed) {
    if (this.state.alpha == value) {
      return;
    }
    mxAbstractCanvas2D.prototype.setAlpha.apply(this, arguments);
  }
  const elem = this.createElement("alpha");
  elem.setAttribute("alpha", this.format(value));
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.setFillAlpha = function(value) {
  if (this.compressed) {
    if (this.state.fillAlpha == value) {
      return;
    }
    mxAbstractCanvas2D.prototype.setFillAlpha.apply(this, arguments);
  }
  const elem = this.createElement("fillalpha");
  elem.setAttribute("alpha", this.format(value));
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.setStrokeAlpha = function(value) {
  if (this.compressed) {
    if (this.state.strokeAlpha == value) {
      return;
    }
    mxAbstractCanvas2D.prototype.setStrokeAlpha.apply(this, arguments);
  }
  const elem = this.createElement("strokealpha");
  elem.setAttribute("alpha", this.format(value));
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.setFillColor = function(value) {
  if (value == mxConstants2.NONE) {
    value = null;
  }
  if (this.compressed) {
    if (this.state.fillColor == value) {
      return;
    }
    mxAbstractCanvas2D.prototype.setFillColor.apply(this, arguments);
  }
  const elem = this.createElement("fillcolor");
  elem.setAttribute("color", value != null ? value : mxConstants2.NONE);
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.setGradient = function(color1, color2, x, y, w2, h2, direction, alpha12, alpha22) {
  if (color1 != null && color2 != null) {
    mxAbstractCanvas2D.prototype.setGradient.apply(this, arguments);
    const elem = this.createElement("gradient");
    elem.setAttribute("c1", color1);
    elem.setAttribute("c2", color2);
    elem.setAttribute("x", this.format(x));
    elem.setAttribute("y", this.format(y));
    elem.setAttribute("w", this.format(w2));
    elem.setAttribute("h", this.format(h2));
    if (direction != null) {
      elem.setAttribute("direction", direction);
    }
    if (alpha12 != null) {
      elem.setAttribute("alpha1", alpha12);
    }
    if (alpha22 != null) {
      elem.setAttribute("alpha2", alpha22);
    }
    this.root.appendChild(elem);
  }
};
mxXmlCanvas2D.prototype.setStrokeColor = function(value) {
  if (value == mxConstants2.NONE) {
    value = null;
  }
  if (this.compressed) {
    if (this.state.strokeColor == value) {
      return;
    }
    mxAbstractCanvas2D.prototype.setStrokeColor.apply(this, arguments);
  }
  const elem = this.createElement("strokecolor");
  elem.setAttribute("color", value != null ? value : mxConstants2.NONE);
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.setStrokeWidth = function(value) {
  if (this.compressed) {
    if (this.state.strokeWidth == value) {
      return;
    }
    mxAbstractCanvas2D.prototype.setStrokeWidth.apply(this, arguments);
  }
  const elem = this.createElement("strokewidth");
  elem.setAttribute("width", this.format(value));
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.setDashed = function(value, fixDash) {
  if (this.compressed) {
    if (this.state.dashed == value) {
      return;
    }
    mxAbstractCanvas2D.prototype.setDashed.apply(this, arguments);
  }
  const elem = this.createElement("dashed");
  elem.setAttribute("dashed", value ? "1" : "0");
  if (fixDash != null) {
    elem.setAttribute("fixDash", fixDash ? "1" : "0");
  }
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.setDashPattern = function(value) {
  if (this.compressed) {
    if (this.state.dashPattern == value) {
      return;
    }
    mxAbstractCanvas2D.prototype.setDashPattern.apply(this, arguments);
  }
  const elem = this.createElement("dashpattern");
  elem.setAttribute("pattern", value);
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.setLineCap = function(value) {
  if (this.compressed) {
    if (this.state.lineCap == value) {
      return;
    }
    mxAbstractCanvas2D.prototype.setLineCap.apply(this, arguments);
  }
  const elem = this.createElement("linecap");
  elem.setAttribute("cap", value);
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.setLineJoin = function(value) {
  if (this.compressed) {
    if (this.state.lineJoin == value) {
      return;
    }
    mxAbstractCanvas2D.prototype.setLineJoin.apply(this, arguments);
  }
  const elem = this.createElement("linejoin");
  elem.setAttribute("join", value);
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.setMiterLimit = function(value) {
  if (this.compressed) {
    if (this.state.miterLimit == value) {
      return;
    }
    mxAbstractCanvas2D.prototype.setMiterLimit.apply(this, arguments);
  }
  const elem = this.createElement("miterlimit");
  elem.setAttribute("limit", value);
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.setFontColor = function(value) {
  if (this.textEnabled) {
    if (value == mxConstants2.NONE) {
      value = null;
    }
    if (this.compressed) {
      if (this.state.fontColor == value) {
        return;
      }
      mxAbstractCanvas2D.prototype.setFontColor.apply(this, arguments);
    }
    const elem = this.createElement("fontcolor");
    elem.setAttribute("color", value != null ? value : mxConstants2.NONE);
    this.root.appendChild(elem);
  }
};
mxXmlCanvas2D.prototype.setFontBackgroundColor = function(value) {
  if (this.textEnabled) {
    if (value == mxConstants2.NONE) {
      value = null;
    }
    if (this.compressed) {
      if (this.state.fontBackgroundColor == value) {
        return;
      }
      mxAbstractCanvas2D.prototype.setFontBackgroundColor.apply(this, arguments);
    }
    const elem = this.createElement("fontbackgroundcolor");
    elem.setAttribute("color", value != null ? value : mxConstants2.NONE);
    this.root.appendChild(elem);
  }
};
mxXmlCanvas2D.prototype.setFontBorderColor = function(value) {
  if (this.textEnabled) {
    if (value == mxConstants2.NONE) {
      value = null;
    }
    if (this.compressed) {
      if (this.state.fontBorderColor == value) {
        return;
      }
      mxAbstractCanvas2D.prototype.setFontBorderColor.apply(this, arguments);
    }
    const elem = this.createElement("fontbordercolor");
    elem.setAttribute("color", value != null ? value : mxConstants2.NONE);
    this.root.appendChild(elem);
  }
};
mxXmlCanvas2D.prototype.setFontSize = function(value) {
  if (this.textEnabled) {
    if (this.compressed) {
      if (this.state.fontSize == value) {
        return;
      }
      mxAbstractCanvas2D.prototype.setFontSize.apply(this, arguments);
    }
    const elem = this.createElement("fontsize");
    elem.setAttribute("size", value);
    this.root.appendChild(elem);
  }
};
mxXmlCanvas2D.prototype.setFontFamily = function(value) {
  if (this.textEnabled) {
    if (this.compressed) {
      if (this.state.fontFamily == value) {
        return;
      }
      mxAbstractCanvas2D.prototype.setFontFamily.apply(this, arguments);
    }
    const elem = this.createElement("fontfamily");
    elem.setAttribute("family", value);
    this.root.appendChild(elem);
  }
};
mxXmlCanvas2D.prototype.setFontStyle = function(value) {
  if (this.textEnabled) {
    if (value == null) {
      value = 0;
    }
    if (this.compressed) {
      if (this.state.fontStyle == value) {
        return;
      }
      mxAbstractCanvas2D.prototype.setFontStyle.apply(this, arguments);
    }
    const elem = this.createElement("fontstyle");
    elem.setAttribute("style", value);
    this.root.appendChild(elem);
  }
};
mxXmlCanvas2D.prototype.setShadow = function(value) {
  if (this.compressed) {
    if (this.state.shadow == value) {
      return;
    }
    mxAbstractCanvas2D.prototype.setShadow.apply(this, arguments);
  }
  const elem = this.createElement("shadow");
  elem.setAttribute("enabled", value ? "1" : "0");
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.setShadowColor = function(value) {
  if (this.compressed) {
    if (value == mxConstants2.NONE) {
      value = null;
    }
    if (this.state.shadowColor == value) {
      return;
    }
    mxAbstractCanvas2D.prototype.setShadowColor.apply(this, arguments);
  }
  const elem = this.createElement("shadowcolor");
  elem.setAttribute("color", value != null ? value : mxConstants2.NONE);
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.setShadowAlpha = function(value) {
  if (this.compressed) {
    if (this.state.shadowAlpha == value) {
      return;
    }
    mxAbstractCanvas2D.prototype.setShadowAlpha.apply(this, arguments);
  }
  const elem = this.createElement("shadowalpha");
  elem.setAttribute("alpha", value);
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.setShadowOffset = function(dx, dy) {
  if (this.compressed) {
    if (this.state.shadowDx == dx && this.state.shadowDy == dy) {
      return;
    }
    mxAbstractCanvas2D.prototype.setShadowOffset.apply(this, arguments);
  }
  const elem = this.createElement("shadowoffset");
  elem.setAttribute("dx", dx);
  elem.setAttribute("dy", dy);
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.rect = function(x, y, w2, h2) {
  const elem = this.createElement("rect");
  elem.setAttribute("x", this.format(x));
  elem.setAttribute("y", this.format(y));
  elem.setAttribute("w", this.format(w2));
  elem.setAttribute("h", this.format(h2));
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.roundrect = function(x, y, w2, h2, dx, dy) {
  const elem = this.createElement("roundrect");
  elem.setAttribute("x", this.format(x));
  elem.setAttribute("y", this.format(y));
  elem.setAttribute("w", this.format(w2));
  elem.setAttribute("h", this.format(h2));
  elem.setAttribute("dx", this.format(dx));
  elem.setAttribute("dy", this.format(dy));
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.ellipse = function(x, y, w2, h2) {
  const elem = this.createElement("ellipse");
  elem.setAttribute("x", this.format(x));
  elem.setAttribute("y", this.format(y));
  elem.setAttribute("w", this.format(w2));
  elem.setAttribute("h", this.format(h2));
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.image = function(x, y, w2, h2, src, aspect, flipH, flipV) {
  src = this.converter.convert(src);
  const elem = this.createElement("image");
  elem.setAttribute("x", this.format(x));
  elem.setAttribute("y", this.format(y));
  elem.setAttribute("w", this.format(w2));
  elem.setAttribute("h", this.format(h2));
  elem.setAttribute("src", src);
  elem.setAttribute("aspect", aspect ? "1" : "0");
  elem.setAttribute("flipH", flipH ? "1" : "0");
  elem.setAttribute("flipV", flipV ? "1" : "0");
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.begin = function() {
  this.root.appendChild(this.createElement("begin"));
  this.lastX = 0;
  this.lastY = 0;
};
mxXmlCanvas2D.prototype.moveTo = function(x, y) {
  const elem = this.createElement("move");
  elem.setAttribute("x", this.format(x));
  elem.setAttribute("y", this.format(y));
  this.root.appendChild(elem);
  this.lastX = x;
  this.lastY = y;
};
mxXmlCanvas2D.prototype.lineTo = function(x, y) {
  const elem = this.createElement("line");
  elem.setAttribute("x", this.format(x));
  elem.setAttribute("y", this.format(y));
  this.root.appendChild(elem);
  this.lastX = x;
  this.lastY = y;
};
mxXmlCanvas2D.prototype.quadTo = function(x1, y1, x2, y2) {
  const elem = this.createElement("quad");
  elem.setAttribute("x1", this.format(x1));
  elem.setAttribute("y1", this.format(y1));
  elem.setAttribute("x2", this.format(x2));
  elem.setAttribute("y2", this.format(y2));
  this.root.appendChild(elem);
  this.lastX = x2;
  this.lastY = y2;
};
mxXmlCanvas2D.prototype.curveTo = function(x1, y1, x2, y2, x3, y3) {
  const elem = this.createElement("curve");
  elem.setAttribute("x1", this.format(x1));
  elem.setAttribute("y1", this.format(y1));
  elem.setAttribute("x2", this.format(x2));
  elem.setAttribute("y2", this.format(y2));
  elem.setAttribute("x3", this.format(x3));
  elem.setAttribute("y3", this.format(y3));
  this.root.appendChild(elem);
  this.lastX = x3;
  this.lastY = y3;
};
mxXmlCanvas2D.prototype.close = function() {
  this.root.appendChild(this.createElement("close"));
};
mxXmlCanvas2D.prototype.text = function(x, y, w2, h2, str, align, valign, wrap, format, overflow, clip, rotation, dir) {
  if (this.textEnabled && str != null) {
    if (isNode(str)) {
      str = getOuterHtml(str);
    }
    const elem = this.createElement("text");
    elem.setAttribute("x", this.format(x));
    elem.setAttribute("y", this.format(y));
    elem.setAttribute("w", this.format(w2));
    elem.setAttribute("h", this.format(h2));
    elem.setAttribute("str", str);
    if (align != null) {
      elem.setAttribute("align", align);
    }
    if (valign != null) {
      elem.setAttribute("valign", valign);
    }
    elem.setAttribute("wrap", wrap ? "1" : "0");
    if (format == null) {
      format = "";
    }
    elem.setAttribute("format", format);
    if (overflow != null) {
      elem.setAttribute("overflow", overflow);
    }
    if (clip != null) {
      elem.setAttribute("clip", clip ? "1" : "0");
    }
    if (rotation != null) {
      elem.setAttribute("rotation", rotation);
    }
    if (dir != null) {
      elem.setAttribute("dir", dir);
    }
    this.root.appendChild(elem);
  }
};
mxXmlCanvas2D.prototype.stroke = function() {
  this.root.appendChild(this.createElement("stroke"));
};
mxXmlCanvas2D.prototype.fill = function() {
  this.root.appendChild(this.createElement("fill"));
};
mxXmlCanvas2D.prototype.fillAndStroke = function() {
  this.root.appendChild(this.createElement("fillstroke"));
};

// js/Dialogs.js
var OpenDialog = function() {
  var iframe2 = document.createElement("iframe");
  iframe2.style.borderStyle = "none";
  iframe2.style.borderWidth = "0px";
  iframe2.frameBorder = "0";
  iframe2.style.position = "fixed";
  iframe2.style.top = "0";
  iframe2.style.left = "0";
  iframe2.style.width = "100vw";
  iframe2.style.height = "100vh";
  iframe2.style.zIndex = "1000";
  iframe2.style.backgroundColor = "#ffffff";
  iframe2.setAttribute("src", OPEN_FORM);
  this.container = iframe2;
};
var ColorDialog2 = function(editorUi, color, apply, cancelFn) {
  this.editorUi = editorUi;
  var input = document.createElement("input");
  input.style.marginBottom = "10px";
  input.style.width = "216px";
  if (mxClient_default.IS_IE) {
    input.style.marginTop = "10px";
    document.body.appendChild(input);
  }
  var applyFunction = apply != null ? apply : this.createApplyFunction();
  function doApply() {
    var color2 = input.value;
    if (/(^#?[a-zA-Z0-9]*$)/.test(color2)) {
      if (color2 != "none" && color2.charAt(0) != "#") {
        color2 = "#" + color2;
      }
      ColorDialog2.addRecentColor(color2 != "none" ? color2.substring(1) : color2, 12);
      applyFunction(color2);
      editorUi.hideDialog();
    } else {
      editorUi.handleError({ message: mxResources2.get("invalidInput") });
    }
  }
  this.init = function() {
    if (!mxClient_default.IS_TOUCH) {
      input.focus();
    }
  };
  var picker = new mxJSColor.color(input);
  picker.pickerOnfocus = false;
  picker.showPicker();
  var div = document.createElement("div");
  mxJSColor.picker.box.style.position = "relative";
  mxJSColor.picker.box.style.width = "230px";
  mxJSColor.picker.box.style.height = "100px";
  mxJSColor.picker.box.style.paddingBottom = "10px";
  div.appendChild(mxJSColor.picker.box);
  var center = document.createElement("center");
  function createRecentColorTable() {
    var table2 = addPresets(ColorDialog2.recentColors.length == 0 ? ["FFFFFF"] : ColorDialog2.recentColors, 11, "FFFFFF", true);
    table2.style.marginBottom = "8px";
    return table2;
  }
  function addPresets(presets, rowLength, defaultColor, addResetOption) {
    rowLength = rowLength != null ? rowLength : 12;
    var table2 = document.createElement("table");
    table2.style.borderCollapse = "collapse";
    table2.setAttribute("cellspacing", "0");
    table2.style.marginBottom = "20px";
    table2.style.cellSpacing = "0px";
    var tbody = document.createElement("tbody");
    table2.appendChild(tbody);
    var rows = presets.length / rowLength;
    for (var row = 0; row < rows; row++) {
      var tr = document.createElement("tr");
      for (var i = 0; i < rowLength; i++) {
        (function(clr) {
          var td2 = document.createElement("td");
          td2.style.border = "1px solid black";
          td2.style.padding = "0px";
          td2.style.width = "16px";
          td2.style.height = "16px";
          if (clr == null) {
            clr = defaultColor;
          }
          if (clr == "none") {
            td2.style.background = "url('" + Dialog.prototype.noColorImage + "')";
          } else {
            td2.style.backgroundColor = "#" + clr;
          }
          tr.appendChild(td2);
          if (clr != null) {
            td2.style.cursor = "pointer";
            mxEvent2.addListener(td2, "click", function() {
              if (clr == "none") {
                picker.fromString("ffffff");
                input.value = "none";
              } else {
                picker.fromString(clr);
              }
            });
            mxEvent2.addListener(td2, "dblclick", doApply);
          }
        })(presets[row * rowLength + i]);
      }
      tbody.appendChild(tr);
    }
    if (addResetOption) {
      var td = document.createElement("td");
      td.setAttribute("title", mxResources2.get("reset"));
      td.style.border = "1px solid black";
      td.style.padding = "0px";
      td.style.width = "16px";
      td.style.height = "16px";
      td.style.backgroundImage = "url('" + Dialog.prototype.closeImage + "')";
      td.style.backgroundPosition = "center center";
      td.style.backgroundRepeat = "no-repeat";
      td.style.cursor = "pointer";
      tr.appendChild(td);
      mxEvent2.addListener(td, "click", function() {
        ColorDialog2.resetRecentColors();
        table2.parentNode.replaceChild(createRecentColorTable(), table2);
      });
    }
    center.appendChild(table2);
    return table2;
  }
  div.appendChild(input);
  br(div);
  createRecentColorTable();
  var table = addPresets(this.presetColors);
  table.style.marginBottom = "8px";
  table = addPresets(this.defaultColors);
  table.style.marginBottom = "16px";
  div.appendChild(center);
  var buttons = document.createElement("div");
  buttons.style.textAlign = "right";
  buttons.style.whiteSpace = "nowrap";
  var cancelBtn = button(mxResources2.get("cancel"), function() {
    editorUi.hideDialog();
    if (cancelFn != null) {
      cancelFn();
    }
  });
  cancelBtn.className = "geBtn";
  if (editorUi.editor.cancelFirst) {
    buttons.appendChild(cancelBtn);
  }
  var applyBtn = button(mxResources2.get("apply"), doApply);
  applyBtn.className = "geBtn gePrimaryBtn";
  buttons.appendChild(applyBtn);
  if (!editorUi.editor.cancelFirst) {
    buttons.appendChild(cancelBtn);
  }
  if (color != null) {
    if (color == "none") {
      picker.fromString("ffffff");
      input.value = "none";
    } else {
      picker.fromString(color);
    }
  }
  div.appendChild(buttons);
  this.picker = picker;
  this.colorInput = input;
  mxEvent2.addListener(div, "keydown", function(e) {
    if (e.keyCode == 27) {
      editorUi.hideDialog();
      if (cancelFn != null) {
        cancelFn();
      }
      mxEvent2.consume(e);
    }
  });
  this.container = div;
};
ColorDialog2.prototype.presetColors = [
  "E6D0DE",
  "CDA2BE",
  "B5739D",
  "E1D5E7",
  "C3ABD0",
  "A680B8",
  "D4E1F5",
  "A9C4EB",
  "7EA6E0",
  "D5E8D4",
  "9AC7BF",
  "67AB9F",
  "D5E8D4",
  "B9E0A5",
  "97D077",
  "FFF2CC",
  "FFE599",
  "FFD966",
  "FFF4C3",
  "FFCE9F",
  "FFB570",
  "F8CECC",
  "F19C99",
  "EA6B66"
];
ColorDialog2.prototype.defaultColors = [
  "none",
  "FFFFFF",
  "E6E6E6",
  "CCCCCC",
  "B3B3B3",
  "999999",
  "808080",
  "666666",
  "4D4D4D",
  "333333",
  "1A1A1A",
  "000000",
  "FFCCCC",
  "FFE6CC",
  "FFFFCC",
  "E6FFCC",
  "CCFFCC",
  "CCFFE6",
  "CCFFFF",
  "CCE5FF",
  "CCCCFF",
  "E5CCFF",
  "FFCCFF",
  "FFCCE6",
  "FF9999",
  "FFCC99",
  "FFFF99",
  "CCFF99",
  "99FF99",
  "99FFCC",
  "99FFFF",
  "99CCFF",
  "9999FF",
  "CC99FF",
  "FF99FF",
  "FF99CC",
  "FF6666",
  "FFB366",
  "FFFF66",
  "B3FF66",
  "66FF66",
  "66FFB3",
  "66FFFF",
  "66B2FF",
  "6666FF",
  "B266FF",
  "FF66FF",
  "FF66B3",
  "FF3333",
  "FF9933",
  "FFFF33",
  "99FF33",
  "33FF33",
  "33FF99",
  "33FFFF",
  "3399FF",
  "3333FF",
  "9933FF",
  "FF33FF",
  "FF3399",
  "FF0000",
  "FF8000",
  "FFFF00",
  "80FF00",
  "00FF00",
  "00FF80",
  "00FFFF",
  "007FFF",
  "0000FF",
  "7F00FF",
  "FF00FF",
  "FF0080",
  "CC0000",
  "CC6600",
  "CCCC00",
  "66CC00",
  "00CC00",
  "00CC66",
  "00CCCC",
  "0066CC",
  "0000CC",
  "6600CC",
  "CC00CC",
  "CC0066",
  "990000",
  "994C00",
  "999900",
  "4D9900",
  "009900",
  "00994D",
  "009999",
  "004C99",
  "000099",
  "4C0099",
  "990099",
  "99004D",
  "660000",
  "663300",
  "666600",
  "336600",
  "006600",
  "006633",
  "006666",
  "003366",
  "000066",
  "330066",
  "660066",
  "660033",
  "330000",
  "331A00",
  "333300",
  "1A3300",
  "003300",
  "00331A",
  "003333",
  "001933",
  "000033",
  "190033",
  "330033",
  "33001A"
];
ColorDialog2.prototype.createApplyFunction = function() {
  return bind(this, function(color) {
    var graph = this.editorUi.editor.graph;
    graph.getModel().beginUpdate();
    try {
      graph.setCellStyles(this.currentColorKey, color);
      this.editorUi.fireEvent(new mxEventObject2("styleChanged", "keys", [this.currentColorKey], "values", [color], "cells", graph.getSelectionCells()));
    } finally {
      graph.getModel().endUpdate();
    }
  });
};
ColorDialog2.recentColors = [];
ColorDialog2.addRecentColor = function(color, max) {
  if (color != null) {
    remove(color, ColorDialog2.recentColors);
    ColorDialog2.recentColors.splice(0, 0, color);
    if (ColorDialog2.recentColors.length >= max) {
      ColorDialog2.recentColors.pop();
    }
  }
};
ColorDialog2.resetRecentColors = function() {
  ColorDialog2.recentColors = [];
};
var AboutDialog = function(editorUi) {
  var div = document.createElement("div");
  div.setAttribute("align", "center");
  var h3 = document.createElement("h3");
  write(h3, mxResources2.get("about") + " Threagile+");
  div.appendChild(h3);
  var img = document.createElement("img");
  img.style.border = "0px";
  img.setAttribute("width", "176");
  img.setAttribute("width", "151");
  img.setAttribute("src", IMAGE_PATH + "/logo.png");
  div.appendChild(img);
  br(div);
  write(div, "Powered by mxGraph " + mxClient_default.VERSION);
  br(div);
  var link2 = document.createElement("a");
  var link22 = document.createElement("a");
  link2.setAttribute("href", "http://www.jgraph.com/");
  link2.setAttribute("target", "_blank");
  write(link2, "www.jgraph.com");
  div.appendChild(link2);
  br(div);
  br(div);
  br(div);
  write(div, "and Powered by Threagile ");
  br(div);
  link22.setAttribute("href", "https://github.com/Threagile/threagile");
  link22.setAttribute("target", "_blank");
  write(link22, "https://github.com/Threagile/threagile");
  div.appendChild(link22);
  br(div);
  var closeBtn = button(mxResources2.get("close"), function() {
    editorUi.hideDialog();
  });
  closeBtn.className = "geBtn gePrimaryBtn";
  div.appendChild(closeBtn);
  this.container = div;
};
var TextareaDialog2 = function(editorUi, title, url, fn, cancelFn, cancelTitle, w2, h2, addButtons2, noHide, noWrap, applyTitle, helpLink, customButtons) {
  w2 = w2 != null ? w2 : 300;
  h2 = h2 != null ? h2 : 120;
  noHide = noHide != null ? noHide : false;
  var row, td;
  var table = document.createElement("table");
  var tbody = document.createElement("tbody");
  row = document.createElement("tr");
  td = document.createElement("td");
  td.style.fontSize = "10pt";
  td.style.width = "100px";
  write(td, title);
  row.appendChild(td);
  tbody.appendChild(row);
  row = document.createElement("tr");
  td = document.createElement("td");
  var nameInput = document.createElement("textarea");
  if (noWrap) {
    nameInput.setAttribute("wrap", "off");
  }
  nameInput.setAttribute("spellcheck", "false");
  nameInput.setAttribute("autocorrect", "off");
  nameInput.setAttribute("autocomplete", "off");
  nameInput.setAttribute("autocapitalize", "off");
  write(nameInput, url || "");
  nameInput.style.resize = "none";
  nameInput.style.width = w2 + "px";
  nameInput.style.height = h2 + "px";
  this.textarea = nameInput;
  this.init = function() {
    nameInput.focus();
    nameInput.scrollTop = 0;
  };
  td.appendChild(nameInput);
  row.appendChild(td);
  tbody.appendChild(row);
  row = document.createElement("tr");
  td = document.createElement("td");
  td.style.paddingTop = "14px";
  td.style.whiteSpace = "nowrap";
  td.setAttribute("align", "right");
  if (helpLink != null) {
    var helpBtn = button(mxResources2.get("help"), function() {
      editorUi.editor.graph.openLink(helpLink);
    });
    helpBtn.className = "geBtn";
    td.appendChild(helpBtn);
  }
  if (customButtons != null) {
    for (var i = 0; i < customButtons.length; i++) {
      (function(label, fn2) {
        var customBtn = button(label, function(e) {
          fn2(e, nameInput);
        });
        customBtn.className = "geBtn";
        td.appendChild(customBtn);
      })(customButtons[i][0], customButtons[i][1]);
    }
  }
  var cancelBtn = button(cancelTitle || mxResources2.get("cancel"), function() {
    editorUi.hideDialog();
    if (cancelFn != null) {
      cancelFn();
    }
  });
  cancelBtn.className = "geBtn";
  if (editorUi.editor.cancelFirst) {
    td.appendChild(cancelBtn);
  }
  if (addButtons2 != null) {
    addButtons2(td, nameInput);
  }
  if (fn != null) {
    var genericBtn = button(applyTitle || mxResources2.get("apply"), function() {
      if (!noHide) {
        editorUi.hideDialog();
      }
      fn(nameInput.value);
    });
    genericBtn.className = "geBtn gePrimaryBtn";
    td.appendChild(genericBtn);
  }
  if (!editorUi.editor.cancelFirst) {
    td.appendChild(cancelBtn);
  }
  row.appendChild(td);
  tbody.appendChild(row);
  table.appendChild(tbody);
  this.container = table;
};
var EditDiagramDialog = function(editorUi) {
  var div = document.createElement("div");
  div.style.textAlign = "right";
  var textarea = document.createElement("textarea");
  textarea.setAttribute("wrap", "off");
  textarea.setAttribute("spellcheck", "false");
  textarea.setAttribute("autocorrect", "off");
  textarea.setAttribute("autocomplete", "off");
  textarea.setAttribute("autocapitalize", "off");
  textarea.style.overflow = "auto";
  textarea.style.resize = "none";
  textarea.style.width = "600px";
  textarea.style.height = "360px";
  textarea.style.marginBottom = "16px";
  textarea.value = getPrettyXml(editorUi.editor.getGraphXml());
  div.appendChild(textarea);
  this.init = function() {
    textarea.focus();
  };
  if (mxGraph.fileSupport) {
    let handleDrop = function(evt) {
      evt.stopPropagation();
      evt.preventDefault();
      if (evt.dataTransfer.files.length > 0) {
        var file = evt.dataTransfer.files[0];
        var reader = new FileReader();
        reader.onload = function(e) {
          textarea.value = e.target.result;
        };
        reader.readAsText(file);
      } else {
        textarea.value = editorUi.extractGraphModelFromEvent(evt);
      }
    }, handleDragOver = function(evt) {
      evt.stopPropagation();
      evt.preventDefault();
    };
    textarea.addEventListener("dragover", handleDragOver, false);
    textarea.addEventListener("drop", handleDrop, false);
  }
  var cancelBtn = button(mxResources2.get("cancel"), function() {
    editorUi.hideDialog();
  });
  cancelBtn.className = "geBtn";
  if (editorUi.editor.cancelFirst) {
    div.appendChild(cancelBtn);
  }
  var select = document.createElement("select");
  select.style.width = "180px";
  select.className = "geBtn";
  if (editorUi.editor.graph.isEnabled()) {
    var replaceOption = document.createElement("option");
    replaceOption.setAttribute("value", "replace");
    write(replaceOption, mxResources2.get("replaceExistingDrawing"));
    select.appendChild(replaceOption);
  }
  var newOption = document.createElement("option");
  newOption.setAttribute("value", "new");
  write(newOption, mxResources2.get("openInNewWindow"));
  if (EditDiagramDialog.showNewWindowOption) {
    select.appendChild(newOption);
  }
  if (editorUi.editor.graph.isEnabled()) {
    var importOption = document.createElement("option");
    importOption.setAttribute("value", "import");
    write(importOption, mxResources2.get("addToExistingDrawing"));
    select.appendChild(importOption);
  }
  div.appendChild(select);
  var okBtn = button(mxResources2.get("ok"), function() {
    var data = mxGraph.zapGremlins(trim(textarea.value));
    var error2 = null;
    if (select.value == "new") {
      editorUi.hideDialog();
      editorUi.editor.editAsNew(data);
    } else if (select.value == "replace") {
      editorUi.editor.graph.model.beginUpdate();
      try {
        editorUi.editor.setGraphXml(parseXml(data).documentElement);
        editorUi.hideDialog();
      } catch (e) {
        error2 = e;
      } finally {
        editorUi.editor.graph.model.endUpdate();
      }
    } else if (select.value == "import") {
      editorUi.editor.graph.model.beginUpdate();
      try {
        var doc = parseXml(data);
        var model = new mxGraphModel();
        var codec = new mxCodec(doc);
        codec.decode(doc.documentElement, model);
        var children = model.getChildren(model.getChildAt(model.getRoot(), 0));
        editorUi.editor.graph.setSelectionCells(editorUi.editor.graph.importCells(children));
        editorUi.hideDialog();
      } catch (e) {
        error2 = e;
      } finally {
        editorUi.editor.graph.model.endUpdate();
      }
    }
    if (error2 != null) {
      alert2(error2.message);
    }
  });
  okBtn.className = "geBtn gePrimaryBtn";
  div.appendChild(okBtn);
  if (!editorUi.editor.cancelFirst) {
    div.appendChild(cancelBtn);
  }
  this.container = div;
};
EditDiagramDialog.showNewWindowOption = true;
var ExportDialog = function(editorUi) {
  var graph = editorUi.editor.graph;
  var bounds = graph.getGraphBounds();
  var scale = graph.view.scale;
  var width = Math.ceil(bounds.width / scale);
  var height = Math.ceil(bounds.height / scale);
  var row, td;
  var table = document.createElement("table");
  var tbody = document.createElement("tbody");
  table.setAttribute("cellpadding", mxClient_default.IS_SF ? "0" : "2");
  row = document.createElement("tr");
  td = document.createElement("td");
  td.style.fontSize = "10pt";
  td.style.width = "100px";
  write(td, mxResources2.get("filename") + ":");
  row.appendChild(td);
  var nameInput = document.createElement("input");
  nameInput.setAttribute("value", editorUi.editor.getOrCreateFilename());
  nameInput.style.width = "180px";
  td = document.createElement("td");
  td.appendChild(nameInput);
  row.appendChild(td);
  tbody.appendChild(row);
  row = document.createElement("tr");
  td = document.createElement("td");
  td.style.fontSize = "10pt";
  write(td, mxResources2.get("format") + ":");
  row.appendChild(td);
  var imageFormatSelect = document.createElement("select");
  imageFormatSelect.style.width = "180px";
  var threagileYamlOption = document.createElement("option");
  threagileYamlOption.setAttribute("value", "yaml");
  write(threagileYamlOption, "YAML");
  imageFormatSelect.appendChild(threagileYamlOption);
  var threagilePackageOption = document.createElement("option");
  threagilePackageOption.setAttribute("value", "threagile-package");
  write(threagilePackageOption, "THREAGILE-PACKAGE");
  imageFormatSelect.appendChild(threagilePackageOption);
  var svgOption = document.createElement("option");
  svgOption.setAttribute("value", "svg");
  write(svgOption, mxResources2.get("formatSvg"));
  imageFormatSelect.appendChild(svgOption);
  if (ExportDialog.showXmlOption) {
    var xmlOption = document.createElement("option");
    xmlOption.setAttribute("value", "xml");
    write(xmlOption, mxResources2.get("formatXml"));
    imageFormatSelect.appendChild(xmlOption);
  }
  td = document.createElement("td");
  td.appendChild(imageFormatSelect);
  row.appendChild(td);
  tbody.appendChild(row);
  row = document.createElement("tr");
  td = document.createElement("td");
  td.style.fontSize = "10pt";
  write(td, mxResources2.get("zoom") + " (%):");
  row.appendChild(td);
  var zoomInput = document.createElement("input");
  zoomInput.setAttribute("type", "number");
  zoomInput.setAttribute("value", "100");
  zoomInput.style.width = "180px";
  td = document.createElement("td");
  td.appendChild(zoomInput);
  row.appendChild(td);
  tbody.appendChild(row);
  row = document.createElement("tr");
  td = document.createElement("td");
  td.style.fontSize = "10pt";
  write(td, mxResources2.get("width") + ":");
  row.appendChild(td);
  var widthInput = document.createElement("input");
  widthInput.setAttribute("value", width);
  widthInput.style.width = "180px";
  td = document.createElement("td");
  td.appendChild(widthInput);
  row.appendChild(td);
  tbody.appendChild(row);
  row = document.createElement("tr");
  td = document.createElement("td");
  td.style.fontSize = "10pt";
  write(td, mxResources2.get("height") + ":");
  row.appendChild(td);
  var heightInput = document.createElement("input");
  heightInput.setAttribute("value", height);
  heightInput.style.width = "180px";
  td = document.createElement("td");
  td.appendChild(heightInput);
  row.appendChild(td);
  tbody.appendChild(row);
  row = document.createElement("tr");
  td = document.createElement("td");
  td.style.fontSize = "10pt";
  write(td, mxResources2.get("dpi") + ":");
  row.appendChild(td);
  var dpiSelect = document.createElement("select");
  dpiSelect.style.width = "180px";
  var dpi100Option = document.createElement("option");
  dpi100Option.setAttribute("value", "100");
  write(dpi100Option, "100dpi");
  dpiSelect.appendChild(dpi100Option);
  var dpi200Option = document.createElement("option");
  dpi200Option.setAttribute("value", "200");
  write(dpi200Option, "200dpi");
  dpiSelect.appendChild(dpi200Option);
  var dpi300Option = document.createElement("option");
  dpi300Option.setAttribute("value", "300");
  write(dpi300Option, "300dpi");
  dpiSelect.appendChild(dpi300Option);
  var dpi400Option = document.createElement("option");
  dpi400Option.setAttribute("value", "400");
  write(dpi400Option, "400dpi");
  dpiSelect.appendChild(dpi400Option);
  var dpiCustOption = document.createElement("option");
  dpiCustOption.setAttribute("value", "custom");
  write(dpiCustOption, mxResources2.get("custom"));
  dpiSelect.appendChild(dpiCustOption);
  var customDpi = document.createElement("input");
  customDpi.style.width = "180px";
  customDpi.style.display = "none";
  customDpi.setAttribute("value", "100");
  customDpi.setAttribute("type", "number");
  customDpi.setAttribute("min", "50");
  customDpi.setAttribute("step", "50");
  var zoomUserChanged = false;
  mxEvent2.addListener(dpiSelect, "change", function() {
    if (this.value == "custom") {
      this.style.display = "none";
      customDpi.style.display = "";
      customDpi.focus();
    } else {
      customDpi.value = this.value;
      if (!zoomUserChanged) {
        zoomInput.value = this.value;
      }
    }
  });
  mxEvent2.addListener(customDpi, "change", function() {
    var dpi = parseInt(customDpi.value);
    if (isNaN(dpi) || dpi <= 0) {
      customDpi.style.backgroundColor = "red";
    } else {
      customDpi.style.backgroundColor = "";
      if (!zoomUserChanged) {
        zoomInput.value = dpi;
      }
    }
  });
  td = document.createElement("td");
  td.appendChild(dpiSelect);
  td.appendChild(customDpi);
  row.appendChild(td);
  tbody.appendChild(row);
  row = document.createElement("tr");
  td = document.createElement("td");
  td.style.fontSize = "10pt";
  write(td, mxResources2.get("background") + ":");
  row.appendChild(td);
  var transparentCheckbox = document.createElement("input");
  transparentCheckbox.setAttribute("type", "checkbox");
  transparentCheckbox.checked = graph.background == null || graph.background == mxConstants2.NONE;
  td = document.createElement("td");
  td.appendChild(transparentCheckbox);
  write(td, mxResources2.get("transparent"));
  row.appendChild(td);
  tbody.appendChild(row);
  row = document.createElement("tr");
  td = document.createElement("td");
  td.style.fontSize = "10pt";
  write(td, mxResources2.get("borderWidth") + ":");
  row.appendChild(td);
  var borderInput = document.createElement("input");
  borderInput.setAttribute("type", "number");
  borderInput.setAttribute("value", ExportDialog.lastBorderValue);
  borderInput.style.width = "180px";
  td = document.createElement("td");
  td.appendChild(borderInput);
  row.appendChild(td);
  tbody.appendChild(row);
  table.appendChild(tbody);
  function formatChanged() {
    var name = nameInput.value;
    var dot = name.lastIndexOf(".");
    if (dot > 0) {
      nameInput.value = name.substring(0, dot + 1) + imageFormatSelect.value;
    } else {
      nameInput.value = name + "." + imageFormatSelect.value;
    }
    if (imageFormatSelect.value === "xml" || imageFormatSelect.value === "yaml" || imageFormatSelect.value === "threagileYaml") {
      zoomInput.setAttribute("disabled", "true");
      widthInput.setAttribute("disabled", "true");
      heightInput.setAttribute("disabled", "true");
      borderInput.setAttribute("disabled", "true");
    } else {
      zoomInput.removeAttribute("disabled");
      widthInput.removeAttribute("disabled");
      heightInput.removeAttribute("disabled");
      borderInput.removeAttribute("disabled");
    }
    if (imageFormatSelect.value === "png" || imageFormatSelect.value === "svg" || imageFormatSelect.value === "pdf") {
      transparentCheckbox.removeAttribute("disabled");
    } else {
      transparentCheckbox.setAttribute("disabled", "disabled");
    }
    if (imageFormatSelect.value === "png") {
      dpiSelect.removeAttribute("disabled");
      customDpi.removeAttribute("disabled");
    } else {
      dpiSelect.setAttribute("disabled", "disabled");
      customDpi.setAttribute("disabled", "disabled");
    }
  }
  mxEvent2.addListener(imageFormatSelect, "change", formatChanged);
  formatChanged();
  function checkValues() {
    if (widthInput.value * heightInput.value > MAX_AREA || widthInput.value <= 0) {
      widthInput.style.backgroundColor = "red";
    } else {
      widthInput.style.backgroundColor = "";
    }
    if (widthInput.value * heightInput.value > MAX_AREA || heightInput.value <= 0) {
      heightInput.style.backgroundColor = "red";
    } else {
      heightInput.style.backgroundColor = "";
    }
  }
  mxEvent2.addListener(zoomInput, "change", function() {
    zoomUserChanged = true;
    var s = Math.max(0, parseFloat(zoomInput.value) || 100) / 100;
    zoomInput.value = parseFloat((s * 100).toFixed(2));
    if (width > 0) {
      widthInput.value = Math.floor(width * s);
      heightInput.value = Math.floor(height * s);
    } else {
      zoomInput.value = "100";
      widthInput.value = width;
      heightInput.value = height;
    }
    checkValues();
  });
  mxEvent2.addListener(widthInput, "change", function() {
    var s = parseInt(widthInput.value) / width;
    if (s > 0) {
      zoomInput.value = parseFloat((s * 100).toFixed(2));
      heightInput.value = Math.floor(height * s);
    } else {
      zoomInput.value = "100";
      widthInput.value = width;
      heightInput.value = height;
    }
    checkValues();
  });
  mxEvent2.addListener(heightInput, "change", function() {
    var s = parseInt(heightInput.value) / height;
    if (s > 0) {
      zoomInput.value = parseFloat((s * 100).toFixed(2));
      widthInput.value = Math.floor(width * s);
    } else {
      zoomInput.value = "100";
      widthInput.value = width;
      heightInput.value = height;
    }
    checkValues();
  });
  row = document.createElement("tr");
  td = document.createElement("td");
  td.setAttribute("align", "right");
  td.style.paddingTop = "22px";
  td.colSpan = 2;
  var saveBtn = button(mxResources2.get("export"), bind(this, function() {
    if (parseInt(zoomInput.value) <= 0) {
      alert2(mxResources2.get("drawingEmpty"));
    } else {
      var name = nameInput.value;
      var format = imageFormatSelect.value;
      var s = Math.max(0, parseFloat(zoomInput.value) || 100) / 100;
      var b = Math.max(0, parseInt(borderInput.value));
      var bg = graph.background;
      var dpi = Math.max(1, parseInt(customDpi.value));
      if ((format == "svg" || format == "png" || format == "pdf") && transparentCheckbox.checked) {
        bg = null;
      } else if (bg == null || bg == mxConstants2.NONE) {
        bg = "#ffffff";
      }
      ExportDialog.lastBorderValue = b;
      ExportDialog.exportFile(editorUi, name, format, bg, s, b, dpi);
    }
  }));
  saveBtn.className = "geBtn gePrimaryBtn";
  var cancelBtn = button(mxResources2.get("cancel"), function() {
    editorUi.hideDialog();
  });
  cancelBtn.className = "geBtn";
  if (editorUi.editor.cancelFirst) {
    td.appendChild(cancelBtn);
    td.appendChild(saveBtn);
  } else {
    td.appendChild(saveBtn);
    td.appendChild(cancelBtn);
  }
  row.appendChild(td);
  tbody.appendChild(row);
  table.appendChild(tbody);
  this.container = table;
};
function exportToYaml(graph, full) {
  return graph.model.threagile.toString();
}
ExportDialog.lastBorderValue = 0;
ExportDialog.showGifOption = true;
ExportDialog.showXmlOption = true;
ExportDialog.exportFile = function(editorUi, name, format, bg, s, b, dpi) {
  var graph = editorUi.editor.graph;
  if (format == "xml") {
    ExportDialog.saveLocalFile(editorUi, getXml(editorUi.editor.getGraphXml()), name, format);
  } else if (format == "svg") {
    ExportDialog.saveLocalFile(editorUi, getXml(graph.getSvg(bg, s, b)), name, format);
  } else if (format == "yaml") {
    editorUi.hideDialog();
    let yaml = exportToYaml(graph, true);
    let filename = name;
    let blob2 = new Blob([yaml], { type: "text/yaml" });
    let url2 = URL.createObjectURL(blob2);
    let a = document.createElement("a");
    a.href = url2;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  } else if (format == "threagile-package") {
    editorUi.hideDialog();
  } else {
    var bounds = graph.getGraphBounds();
    var xmlDoc = createXmlDocument();
    var root = xmlDoc.createElement("output");
    xmlDoc.appendChild(root);
    var xmlCanvas = new mxXmlCanvas2D(root);
    xmlCanvas.translate(Math.floor((b / s - bounds.x) / graph.view.scale), Math.floor((b / s - bounds.y) / graph.view.scale));
    xmlCanvas.scale(s / graph.view.scale);
    var imgExport = new mxImageExport2();
    imgExport.drawState(graph.getView().getState(graph.model.root), xmlCanvas);
    var param = "xml=" + encodeURIComponent(getXml(root));
    var w2 = Math.ceil(bounds.width * s / graph.view.scale + 2 * b);
    var h2 = Math.ceil(bounds.height * s / graph.view.scale + 2 * b);
    if (param.length <= MAX_REQUEST_SIZE && w2 * h2 < MAX_AREA) {
      editorUi.hideDialog();
      var blob = new Blob([getXml(root)], {
        type: "text/xml;charset=utf-8"
      });
      var url = URL.createObjectURL(blob);
      var link2 = document.createElement("a");
      link2.href = url;
      link2.download = name + ".xml";
      document.body.appendChild(link2);
      link2.click();
      document.body.removeChild(link2);
    } else {
      alert2(mxResources2.get("drawingTooLarge"));
    }
  }
};
ExportDialog.saveLocalFile = function(editorUi, data, filename, format) {
  if (data.length < MAX_REQUEST_SIZE) {
    editorUi.hideDialog();
    editorUi.hideDialog();
    var blob = new Blob([data], { type: "text/plain;charset=utf-8" });
    var url = URL.createObjectURL(blob);
    var link2 = document.createElement("a");
    link2.href = url;
    link2.download = filename;
    document.body.appendChild(link2);
    link2.click();
    document.body.removeChild(link2);
  } else {
    alert2(mxResources2.get("drawingTooLarge"));
    popup(xml);
  }
};
var EditDataDialog = function(ui, cell2) {
  var div = document.createElement("div");
  var graph = ui.editor.graph;
  var value = graph.getModel().getValue(cell2);
  if (!isNode(value)) {
    var doc = createXmlDocument();
    var obj = doc.createElement("object");
    obj.setAttribute("label", value || "");
    value = obj;
  }
  var meta = {};
  try {
    var temp2 = getValue(ui.editor.graph.getCurrentCellStyle(cell2), "metaData", null);
    if (temp2 != null) {
      meta = JSON.parse(temp2);
    }
  } catch (e) {
  }
  var form = new mxForm("properties");
  form.table.style.width = "100%";
  var attrs = value.attributes;
  var names = [];
  var texts = [];
  var count = 0;
  var id = EditDataDialog.getDisplayIdForCell != null ? EditDataDialog.getDisplayIdForCell(ui, cell2) : null;
  var addRemoveButton = function(text2, name) {
    var wrapper = document.createElement("div");
    wrapper.style.position = "relative";
    wrapper.style.paddingRight = "20px";
    wrapper.style.boxSizing = "border-box";
    wrapper.style.width = "100%";
    var removeAttr = document.createElement("a");
    var img = createImage(Dialog.prototype.closeImage);
    img.style.height = "9px";
    img.style.fontSize = "9px";
    img.style.marginBottom = mxClient_default.IS_IE11 ? "-1px" : "5px";
    removeAttr.className = "geButton";
    removeAttr.setAttribute("title", mxResources2.get("delete"));
    removeAttr.style.position = "absolute";
    removeAttr.style.top = "4px";
    removeAttr.style.right = "0px";
    removeAttr.style.margin = "0px";
    removeAttr.style.width = "9px";
    removeAttr.style.height = "9px";
    removeAttr.style.cursor = "pointer";
    removeAttr.appendChild(img);
    var removeAttrFn = function(name2) {
      return function() {
        var count2 = 0;
        for (var j = 0; j < names.length; j++) {
          if (names[j] == name2) {
            texts[j] = null;
            form.table.deleteRow(count2 + (id != null ? 1 : 0));
            break;
          }
          if (texts[j] != null) {
            count2++;
          }
        }
      };
    }(name);
    mxEvent2.addListener(removeAttr, "click", removeAttrFn);
    var parent2 = text2.parentNode;
    wrapper.appendChild(text2);
    wrapper.appendChild(removeAttr);
    parent2.appendChild(wrapper);
  };
  var addTextArea = function(index, name, value2) {
    names[index] = name;
    texts[index] = form.addTextarea(names[count] + ":", value2, 2);
    texts[index].style.width = "100%";
    if (value2.indexOf("\n") > 0) {
      texts[index].setAttribute("rows", "2");
    }
    addRemoveButton(texts[index], name);
    if (meta[name] != null && meta[name].editable == false) {
      texts[index].setAttribute("disabled", "disabled");
    }
  };
  var temp2 = [];
  var isLayer = graph.getModel().getParent(cell2) == graph.getModel().getRoot();
  for (var i = 0; i < attrs.length; i++) {
    if ((isLayer || attrs[i].nodeName != "label") && attrs[i].nodeName != "placeholders") {
      temp2.push({ name: attrs[i].nodeName, value: attrs[i].nodeValue });
    }
  }
  temp2.sort(function(a, b) {
    if (a.name < b.name) {
      return -1;
    } else if (a.name > b.name) {
      return 1;
    } else {
      return 0;
    }
  });
  if (id != null) {
    var text = document.createElement("div");
    text.style.width = "100%";
    text.style.fontSize = "11px";
    text.style.textAlign = "center";
    write(text, id);
    form.addField(mxResources2.get("id") + ":", text);
  }
  for (var i = 0; i < temp2.length; i++) {
    addTextArea(count, temp2[i].name, temp2[i].value);
    count++;
  }
  var top = document.createElement("div");
  top.style.cssText = "position:absolute;left:30px;right:30px;overflow-y:auto;top:30px;bottom:80px;";
  top.appendChild(form.table);
  var newProp = document.createElement("div");
  newProp.style.boxSizing = "border-box";
  newProp.style.paddingRight = "160px";
  newProp.style.whiteSpace = "nowrap";
  newProp.style.marginTop = "6px";
  newProp.style.width = "100%";
  var nameInput = document.createElement("input");
  nameInput.setAttribute("placeholder", mxResources2.get("enterPropertyName"));
  nameInput.setAttribute("type", "text");
  nameInput.setAttribute("size", mxClient_default.IS_IE || mxClient_default.IS_IE11 ? "36" : "40");
  nameInput.style.boxSizing = "border-box";
  nameInput.style.marginLeft = "2px";
  nameInput.style.width = "100%";
  newProp.appendChild(nameInput);
  top.appendChild(newProp);
  div.appendChild(top);
  var addBtn = button(mxResources2.get("addProperty"), function() {
    var name = nameInput.value;
    if (name.length > 0 && name != "label" && name != "placeholders" && name.indexOf(":") < 0) {
      try {
        var idx = indexOf(names, name);
        if (idx >= 0 && texts[idx] != null) {
          texts[idx].focus();
        } else {
          var clone3 = value.cloneNode(false);
          clone3.setAttribute(name, "");
          if (idx >= 0) {
            names.splice(idx, 1);
            texts.splice(idx, 1);
          }
          names.push(name);
          var text2 = form.addTextarea(name + ":", "", 2);
          text2.style.width = "100%";
          texts.push(text2);
          addRemoveButton(text2, name);
          text2.focus();
        }
        addBtn.setAttribute("disabled", "disabled");
        nameInput.value = "";
      } catch (e) {
        alert2(e);
      }
    } else {
      alert2(mxResources2.get("invalidName"));
    }
  });
  this.init = function() {
    if (texts.length > 0) {
      texts[0].focus();
    } else {
      nameInput.focus();
    }
  };
  addBtn.setAttribute("title", mxResources2.get("addProperty"));
  addBtn.setAttribute("disabled", "disabled");
  addBtn.style.textOverflow = "ellipsis";
  addBtn.style.position = "absolute";
  addBtn.style.overflow = "hidden";
  addBtn.style.width = "144px";
  addBtn.style.right = "0px";
  addBtn.className = "geBtn";
  newProp.appendChild(addBtn);
  var cancelBtn = button(mxResources2.get("cancel"), function() {
    ui.hideDialog.apply(ui, arguments);
  });
  cancelBtn.className = "geBtn";
  var applyBtn = button(mxResources2.get("apply"), function() {
    try {
      ui.hideDialog.apply(ui, arguments);
      value = value.cloneNode(true);
      var removeLabel = false;
      for (var i2 = 0; i2 < names.length; i2++) {
        if (texts[i2] == null) {
          value.removeAttribute(names[i2]);
        } else {
          value.setAttribute(names[i2], texts[i2].value);
          removeLabel = removeLabel || names[i2] == "placeholder" && value.getAttribute("placeholders") == "1";
        }
      }
      if (removeLabel) {
        value.removeAttribute("label");
      }
      graph.getModel().setValue(cell2, value);
    } catch (e) {
      alert2(e);
    }
  });
  applyBtn.className = "geBtn gePrimaryBtn";
  function updateAddBtn() {
    if (nameInput.value.length > 0) {
      addBtn.removeAttribute("disabled");
    } else {
      addBtn.setAttribute("disabled", "disabled");
    }
  }
  mxEvent2.addListener(nameInput, "keyup", updateAddBtn);
  mxEvent2.addListener(nameInput, "change", updateAddBtn);
  var buttons = document.createElement("div");
  buttons.style.cssText = "position:absolute;left:30px;right:30px;text-align:right;bottom:30px;height:40px;";
  if (ui.editor.graph.getModel().isVertex(cell2) || ui.editor.graph.getModel().isEdge(cell2)) {
    var replace = document.createElement("span");
    replace.style.marginRight = "10px";
    var input = document.createElement("input");
    input.setAttribute("type", "checkbox");
    input.style.marginRight = "6px";
    if (value.getAttribute("placeholders") == "1") {
      input.setAttribute("checked", "checked");
      input.defaultChecked = true;
    }
    mxEvent2.addListener(input, "click", function() {
      if (value.getAttribute("placeholders") == "1") {
        value.removeAttribute("placeholders");
      } else {
        value.setAttribute("placeholders", "1");
      }
    });
    replace.appendChild(input);
    write(replace, mxResources2.get("placeholders"));
    if (EditDataDialog.placeholderHelpLink != null) {
      var link2 = document.createElement("a");
      link2.setAttribute("href", EditDataDialog.placeholderHelpLink);
      link2.setAttribute("title", mxResources2.get("help"));
      link2.setAttribute("target", "_blank");
      link2.style.marginLeft = "8px";
      link2.style.cursor = "help";
      var icon = document.createElement("img");
      setOpacity(icon, 50);
      icon.style.height = "16px";
      icon.style.width = "16px";
      icon.setAttribute("border", "0");
      icon.setAttribute("valign", "middle");
      icon.style.marginTop = mxClient_default.IS_IE11 ? "0px" : "-4px";
      icon.setAttribute("src", Editor2.helpImage);
      link2.appendChild(icon);
      replace.appendChild(link2);
    }
    buttons.appendChild(replace);
  }
  if (ui.editor.cancelFirst) {
    buttons.appendChild(cancelBtn);
    buttons.appendChild(applyBtn);
  } else {
    buttons.appendChild(applyBtn);
    buttons.appendChild(cancelBtn);
  }
  div.appendChild(buttons);
  this.container = div;
};
EditDataDialog.getDisplayIdForCell = function(ui, cell2) {
  var id = null;
  if (ui.editor.graph.getModel().getParent(cell2) != null) {
    id = cell2.getId();
  }
  return id;
};
EditDataDialog.placeholderHelpLink = null;
var LinkDialog = function(editorUi, initialValue, btnLabel, fn) {
  var div = document.createElement("div");
  write(div, mxResources2.get("editLink") + ":");
  var inner = document.createElement("div");
  inner.className = "geTitle";
  inner.style.backgroundColor = "transparent";
  inner.style.borderColor = "transparent";
  inner.style.whiteSpace = "nowrap";
  inner.style.textOverflow = "clip";
  inner.style.cursor = "default";
  if (!mxClient_default.IS_VML) {
    inner.style.paddingRight = "20px";
  }
  var linkInput = document.createElement("input");
  linkInput.setAttribute("value", initialValue);
  linkInput.setAttribute("placeholder", "http://www.example.com/");
  linkInput.setAttribute("type", "text");
  linkInput.style.marginTop = "6px";
  linkInput.style.width = "400px";
  linkInput.style.backgroundImage = "url('" + Dialog.prototype.clearImage + "')";
  linkInput.style.backgroundRepeat = "no-repeat";
  linkInput.style.backgroundPosition = "100% 50%";
  linkInput.style.paddingRight = "14px";
  var cross = document.createElement("div");
  cross.setAttribute("title", mxResources2.get("reset"));
  cross.style.position = "relative";
  cross.style.left = "-16px";
  cross.style.width = "12px";
  cross.style.height = "14px";
  cross.style.cursor = "pointer";
  cross.style.display = mxClient_default.IS_VML ? "inline" : "inline-block";
  cross.style.top = (mxClient_default.IS_VML ? 0 : 3) + "px";
  cross.style.background = "url(" + IMAGE_PATH + "/transparent.gif)";
  mxEvent2.addListener(cross, "click", function() {
    linkInput.value = "";
    linkInput.focus();
  });
  inner.appendChild(linkInput);
  inner.appendChild(cross);
  div.appendChild(inner);
  this.init = function() {
    linkInput.focus();
    if (mxClient_default.IS_GC || mxClient_default.IS_FF || document.documentMode >= 5 || mxClient_default.IS_QUIRKS) {
      linkInput.select();
    } else {
      document.execCommand("selectAll", false, null);
    }
  };
  var btns = document.createElement("div");
  btns.style.marginTop = "18px";
  btns.style.textAlign = "right";
  mxEvent2.addListener(linkInput, "keypress", function(e) {
    if (e.keyCode == 13) {
      editorUi.hideDialog();
      fn(linkInput.value);
    }
  });
  var cancelBtn = button(mxResources2.get("cancel"), function() {
    editorUi.hideDialog();
  });
  cancelBtn.className = "geBtn";
  if (editorUi.editor.cancelFirst) {
    btns.appendChild(cancelBtn);
  }
  var mainBtn = button(btnLabel, function() {
    editorUi.hideDialog();
    fn(linkInput.value);
  });
  mainBtn.className = "geBtn gePrimaryBtn";
  btns.appendChild(mainBtn);
  if (!editorUi.editor.cancelFirst) {
    btns.appendChild(cancelBtn);
  }
  div.appendChild(btns);
  this.container = div;
};
var OutlineWindow = function(editorUi, x, y, w2, h2) {
  var graph = editorUi.editor.graph;
  var div = document.createElement("div");
  div.style.position = "absolute";
  div.style.width = "100%";
  div.style.height = "100%";
  div.style.border = "1px solid whiteSmoke";
  div.style.overflow = "hidden";
  this.window = new mxWindow(mxResources2.get("outline"), div, x, y, w2, h2, true, true);
  this.window.minimumSize = new mxRectangle(0, 0, 80, 80);
  this.window.destroyOnClose = false;
  this.window.setMaximizable(false);
  this.window.setResizable(true);
  this.window.setClosable(true);
  this.window.setVisible(true);
  this.window.setLocation = function(x2, y2) {
    var iw = window.innerWidth || document.body.clientWidth || document.documentElement.clientWidth;
    var ih = window.innerHeight || document.body.clientHeight || document.documentElement.clientHeight;
    x2 = Math.max(0, Math.min(x2, iw - this.table.clientWidth));
    y2 = Math.max(0, Math.min(y2, ih - this.table.clientHeight - 48));
    if (this.getX() != x2 || this.getY() != y2) {
      mxWindow.prototype.setLocation.apply(this, arguments);
    }
  };
  var resizeListener = bind(this, function() {
    var x2 = this.window.getX();
    var y2 = this.window.getY();
    this.window.setLocation(x2, y2);
  });
  mxEvent2.addListener(window, "resize", resizeListener);
  var outline = editorUi.createOutline(this.window);
  this.destroy = function() {
    mxEvent2.removeListener(window, "resize", resizeListener);
    this.window.destroy();
    outline.destroy();
  };
  this.window.addListener(mxEvent2.RESIZE, bind(this, function() {
    outline.update(false);
    outline.outline.sizeDidChange();
  }));
  this.window.addListener(mxEvent2.SHOW, bind(this, function() {
    this.window.fit();
    outline.suspended = false;
    outline.outline.refresh();
    outline.update();
  }));
  this.window.addListener(mxEvent2.HIDE, bind(this, function() {
    outline.suspended = true;
  }));
  this.window.addListener(mxEvent2.NORMALIZE, bind(this, function() {
    outline.suspended = false;
    outline.update();
  }));
  this.window.addListener(mxEvent2.MINIMIZE, bind(this, function() {
    outline.suspended = true;
  }));
  var outlineCreateGraph = outline.createGraph;
  outline.createGraph = function(container) {
    var g = outlineCreateGraph.apply(this, arguments);
    g.gridEnabled = false;
    g.pageScale = graph.pageScale;
    g.pageFormat = graph.pageFormat;
    g.background = graph.background == null || graph.background == mxConstants2.NONE ? graph.defaultPageBackgroundColor : graph.background;
    g.pageVisible = graph.pageVisible;
    var current2 = getCurrentStyle(graph.container);
    div.style.backgroundColor = current2.backgroundColor;
    return g;
  };
  function update() {
    outline.outline.pageScale = graph.pageScale;
    outline.outline.pageFormat = graph.pageFormat;
    outline.outline.pageVisible = graph.pageVisible;
    outline.outline.background = graph.background == null || graph.background == mxConstants2.NONE ? graph.defaultPageBackgroundColor : graph.background;
    var current2 = getCurrentStyle(graph.container);
    div.style.backgroundColor = current2.backgroundColor;
    if (graph.view.backgroundPageShape != null && outline.outline.view.backgroundPageShape != null) {
      outline.outline.view.backgroundPageShape.fill = graph.view.backgroundPageShape.fill;
    }
    outline.outline.refresh();
  }
  outline.init(div);
  editorUi.editor.addListener("resetGraphView", update);
  editorUi.addListener("pageFormatChanged", update);
  editorUi.addListener("backgroundColorChanged", update);
  editorUi.addListener("backgroundImageChanged", update);
  editorUi.addListener("pageViewChanged", function() {
    update();
    outline.update(true);
  });
  if (outline.outline.dialect == mxConstants2.DIALECT_SVG) {
    var zoomInAction = editorUi.actions.get("zoomIn");
    var zoomOutAction = editorUi.actions.get("zoomOut");
    mxEvent2.addMouseWheelListener(function(evt, up) {
      var outlineWheel = false;
      var source = mxEvent2.getSource(evt);
      while (source != null) {
        if (source == outline.outline.view.canvas.ownerSVGElement) {
          outlineWheel = true;
          break;
        }
        source = source.parentNode;
      }
      if (outlineWheel) {
        if (up) {
          zoomInAction.funct();
        } else {
          zoomOutAction.funct();
        }
      }
    });
  }
};
var LayersWindow = function(editorUi, x, y, w2, h2) {
  var graph = editorUi.editor.graph;
  var div = document.createElement("div");
  div.style.userSelect = "none";
  div.style.background = Dialog.backdropColor == "white" ? "whiteSmoke" : Dialog.backdropColor;
  div.style.border = "1px solid whiteSmoke";
  div.style.height = "100%";
  div.style.marginBottom = "10px";
  div.style.overflow = "auto";
  var tbarHeight = !EditorUi.compactUi ? "30px" : "26px";
  var listDiv = document.createElement("div");
  listDiv.style.backgroundColor = Dialog.backdropColor == "white" ? "#dcdcdc" : Dialog.backdropColor;
  listDiv.style.position = "absolute";
  listDiv.style.overflow = "auto";
  listDiv.style.left = "0px";
  listDiv.style.right = "0px";
  listDiv.style.top = "0px";
  listDiv.style.bottom = parseInt(tbarHeight) + 7 + "px";
  div.appendChild(listDiv);
  var dragSource = null;
  var dropIndex = null;
  mxEvent2.addListener(div, "dragover", function(evt) {
    evt.dataTransfer.dropEffect = "move";
    dropIndex = 0;
    evt.stopPropagation();
    evt.preventDefault();
  });
  mxEvent2.addListener(div, "drop", function(evt) {
    evt.stopPropagation();
    evt.preventDefault();
  });
  var layerCount = null;
  var selectionLayer = null;
  var ldiv = document.createElement("div");
  ldiv.className = "geToolbarContainer";
  ldiv.style.position = "absolute";
  ldiv.style.bottom = "0px";
  ldiv.style.left = "0px";
  ldiv.style.right = "0px";
  ldiv.style.height = tbarHeight;
  ldiv.style.overflow = "hidden";
  ldiv.style.padding = !EditorUi.compactUi ? "1px" : "4px 0px 3px 0px";
  ldiv.style.backgroundColor = Dialog.backdropColor == "white" ? "whiteSmoke" : Dialog.backdropColor;
  ldiv.style.borderWidth = "1px 0px 0px 0px";
  ldiv.style.borderColor = "#c3c3c3";
  ldiv.style.borderStyle = "solid";
  ldiv.style.display = "block";
  ldiv.style.whiteSpace = "nowrap";
  if (mxClient_default.IS_QUIRKS) {
    ldiv.style.filter = "none";
  }
  var link2 = document.createElement("a");
  link2.className = "geButton";
  if (mxClient_default.IS_QUIRKS) {
    link2.style.filter = "none";
  }
  var removeLink = link2.cloneNode();
  removeLink.innerHTML = '<div class="geSprite geSprite-delete" style="display:inline-block;"></div>';
  mxEvent2.addListener(removeLink, "click", function(evt) {
    if (graph.isEnabled()) {
      graph.model.beginUpdate();
      try {
        var index = graph.model.root.getIndex(selectionLayer);
        graph.removeCells([selectionLayer], false);
        if (graph.model.getChildCount(graph.model.root) == 0) {
          graph.model.add(graph.model.root, new mxCell());
          graph.setDefaultParent(null);
        } else if (index > 0 && index <= graph.model.getChildCount(graph.model.root)) {
          graph.setDefaultParent(graph.model.getChildAt(graph.model.root, index - 1));
        } else {
          graph.setDefaultParent(null);
        }
      } finally {
        graph.model.endUpdate();
      }
    }
    mxEvent2.consume(evt);
  });
  if (!graph.isEnabled()) {
    removeLink.className = "geButton mxDisabled";
  }
  ldiv.appendChild(removeLink);
  var insertLink = link2.cloneNode();
  insertLink.setAttribute("title", trim(mxResources2.get("moveSelectionTo", ["..."])));
  insertLink.innerHTML = '<div class="geSprite geSprite-insert" style="display:inline-block;"></div>';
  mxEvent2.addListener(insertLink, "click", function(evt) {
    if (graph.isEnabled() && !graph.isSelectionEmpty()) {
      var offset = getOffset(insertLink);
      editorUi.showPopupMenu(bind(this, function(menu, parent2) {
        for (var i = layerCount - 1; i >= 0; i--) {
          bind(this, function(child) {
            var item = menu.addItem(graph.convertValueToString(child) || mxResources2.get("background"), null, bind(this, function() {
              graph.moveCells(graph.getSelectionCells(), 0, 0, false, child);
            }), parent2);
            if (graph.getSelectionCount() == 1 && graph.model.isAncestor(child, graph.getSelectionCell())) {
              menu.addCheckmark(item, Editor2.checkmarkImage);
            }
          })(graph.model.getChildAt(graph.model.root, i));
        }
      }), offset.x, offset.y + insertLink.offsetHeight, evt);
    }
  });
  ldiv.appendChild(insertLink);
  var dataLink = link2.cloneNode();
  dataLink.innerHTML = '<div class="geSprite geSprite-dots" style="display:inline-block;"></div>';
  dataLink.setAttribute("title", mxResources2.get("rename"));
  mxEvent2.addListener(dataLink, "click", function(evt) {
    if (graph.isEnabled()) {
      editorUi.showDataDialog(selectionLayer);
    }
    mxEvent2.consume(evt);
  });
  if (!graph.isEnabled()) {
    dataLink.className = "geButton mxDisabled";
  }
  ldiv.appendChild(dataLink);
  function renameLayer(layer) {
    if (graph.isEnabled() && layer != null) {
      var label = graph.convertValueToString(layer);
      var dlg = new FilenameDialog(editorUi, label || mxResources2.get("background"), mxResources2.get("rename"), bind(this, function(newValue) {
        if (newValue != null) {
          graph.cellLabelChanged(layer, newValue);
        }
      }), mxResources2.get("enterName"));
      editorUi.showDialog(dlg.container, 300, 100, true, true);
      dlg.init();
    }
  }
  var duplicateLink = link2.cloneNode();
  duplicateLink.innerHTML = '<div class="geSprite geSprite-duplicate" style="display:inline-block;"></div>';
  mxEvent2.addListener(duplicateLink, "click", function(evt) {
    if (graph.isEnabled()) {
      var newCell = null;
      graph.model.beginUpdate();
      try {
        newCell = graph.cloneCell(selectionLayer);
        graph.cellLabelChanged(newCell, mxResources2.get("untitledLayer"));
        newCell.setVisible(true);
        newCell = graph.addCell(newCell, graph.model.root);
        graph.setDefaultParent(newCell);
      } finally {
        graph.model.endUpdate();
      }
      if (newCell != null && !graph.isCellLocked(newCell)) {
        graph.selectAll(newCell);
      }
    }
  });
  if (!graph.isEnabled()) {
    duplicateLink.className = "geButton mxDisabled";
  }
  ldiv.appendChild(duplicateLink);
  var addLink = link2.cloneNode();
  addLink.innerHTML = '<div class="geSprite geSprite-plus" style="display:inline-block;"></div>';
  addLink.setAttribute("title", mxResources2.get("addLayer"));
  mxEvent2.addListener(addLink, "click", function(evt) {
    if (graph.isEnabled()) {
      graph.model.beginUpdate();
      try {
        var cell2 = graph.addCell(new mxCell(mxResources2.get("untitledLayer")), graph.model.root);
        graph.setDefaultParent(cell2);
      } finally {
        graph.model.endUpdate();
      }
    }
    mxEvent2.consume(evt);
  });
  if (!graph.isEnabled()) {
    addLink.className = "geButton mxDisabled";
  }
  ldiv.appendChild(addLink);
  div.appendChild(ldiv);
  function refresh() {
    layerCount = graph.model.getChildCount(graph.model.root);
    listDiv.innerHTML = "";
    function addLayer(index, label2, child, defaultParent) {
      var ldiv2 = document.createElement("div");
      ldiv2.className = "geToolbarContainer";
      ldiv2.style.overflow = "hidden";
      ldiv2.style.position = "relative";
      ldiv2.style.padding = "4px";
      ldiv2.style.height = "22px";
      ldiv2.style.display = "block";
      ldiv2.style.backgroundColor = Dialog.backdropColor == "white" ? "whiteSmoke" : Dialog.backdropColor;
      ldiv2.style.borderWidth = "0px 0px 1px 0px";
      ldiv2.style.borderColor = "#c3c3c3";
      ldiv2.style.borderStyle = "solid";
      ldiv2.style.whiteSpace = "nowrap";
      ldiv2.setAttribute("title", label2);
      var left = document.createElement("div");
      left.style.display = "inline-block";
      left.style.width = "100%";
      left.style.textOverflow = "ellipsis";
      left.style.overflow = "hidden";
      mxEvent2.addListener(ldiv2, "dragover", function(evt) {
        evt.dataTransfer.dropEffect = "move";
        dropIndex = index;
        evt.stopPropagation();
        evt.preventDefault();
      });
      mxEvent2.addListener(ldiv2, "dragstart", function(evt) {
        dragSource = ldiv2;
        if (mxClient_default.IS_FF) {
          evt.dataTransfer.setData("Text", "<layer/>");
        }
      });
      mxEvent2.addListener(ldiv2, "dragend", function(evt) {
        if (dragSource != null && dropIndex != null) {
          graph.addCell(child, graph.model.root, dropIndex);
        }
        dragSource = null;
        dropIndex = null;
        evt.stopPropagation();
        evt.preventDefault();
      });
      var btn = document.createElement("img");
      btn.setAttribute("draggable", "false");
      btn.setAttribute("align", "top");
      btn.setAttribute("border", "0");
      btn.style.padding = "4px";
      btn.setAttribute("title", mxResources2.get("lockUnlock"));
      var style = graph.getCurrentCellStyle(child);
      if (getValue(style, "locked", "0") == "1") {
        btn.setAttribute("src", Dialog.prototype.lockedImage);
      } else {
        btn.setAttribute("src", Dialog.prototype.unlockedImage);
      }
      if (graph.isEnabled()) {
        btn.style.cursor = "pointer";
      }
      mxEvent2.addListener(btn, "click", function(evt) {
        if (graph.isEnabled()) {
          var value = null;
          graph.getModel().beginUpdate();
          try {
            value = getValue(style, "locked", "0") == "1" ? null : "1";
            graph.setCellStyles("locked", value, [child]);
          } finally {
            graph.getModel().endUpdate();
          }
          if (value == "1") {
            graph.removeSelectionCells(graph.getModel().getDescendants(child));
          }
          mxEvent2.consume(evt);
        }
      });
      left.appendChild(btn);
      var inp = document.createElement("input");
      inp.setAttribute("type", "checkbox");
      inp.setAttribute("title", mxResources2.get("hideIt", [
        child.value || mxResources2.get("background")
      ]));
      inp.style.marginLeft = "4px";
      inp.style.marginRight = "6px";
      inp.style.marginTop = "4px";
      left.appendChild(inp);
      if (graph.model.isVisible(child)) {
        inp.setAttribute("checked", "checked");
        inp.defaultChecked = true;
      }
      mxEvent2.addListener(inp, "click", function(evt) {
        graph.model.setVisible(child, !graph.model.isVisible(child));
        mxEvent2.consume(evt);
      });
      write(left, label2);
      ldiv2.appendChild(left);
      if (graph.isEnabled()) {
        if (mxClient_default.IS_TOUCH || mxClient_default.IS_POINTER || mxClient_default.IS_VML || mxClient_default.IS_IE && document.documentMode < 10) {
          var right = document.createElement("div");
          right.style.display = "block";
          right.style.textAlign = "right";
          right.style.whiteSpace = "nowrap";
          right.style.position = "absolute";
          right.style.right = "6px";
          right.style.top = "6px";
          if (index > 0) {
            var img2 = document.createElement("a");
            img2.setAttribute("title", mxResources2.get("toBack"));
            img2.className = "geButton";
            img2.style.cssFloat = "none";
            img2.innerHTML = "&#9660;";
            img2.style.width = "14px";
            img2.style.height = "14px";
            img2.style.fontSize = "14px";
            img2.style.margin = "0px";
            img2.style.marginTop = "-1px";
            right.appendChild(img2);
            mxEvent2.addListener(img2, "click", function(evt) {
              if (graph.isEnabled()) {
                graph.addCell(child, graph.model.root, index - 1);
              }
              mxEvent2.consume(evt);
            });
          }
          if (index >= 0 && index < layerCount - 1) {
            var img1 = document.createElement("a");
            img1.setAttribute("title", mxResources2.get("toFront"));
            img1.className = "geButton";
            img1.style.cssFloat = "none";
            img1.innerHTML = "&#9650;";
            img1.style.width = "14px";
            img1.style.height = "14px";
            img1.style.fontSize = "14px";
            img1.style.margin = "0px";
            img1.style.marginTop = "-1px";
            right.appendChild(img1);
            mxEvent2.addListener(img1, "click", function(evt) {
              if (graph.isEnabled()) {
                graph.addCell(child, graph.model.root, index + 1);
              }
              mxEvent2.consume(evt);
            });
          }
          ldiv2.appendChild(right);
        }
        if (mxClient_default.IS_SVG && (!mxClient_default.IS_IE || document.documentMode >= 10)) {
          ldiv2.setAttribute("draggable", "true");
          ldiv2.style.cursor = "move";
        }
      }
      mxEvent2.addListener(ldiv2, "dblclick", function(evt) {
        var nodeName = mxEvent2.getSource(evt).nodeName;
        if (nodeName != "INPUT" && nodeName != "IMG") {
          renameLayer(child);
          mxEvent2.consume(evt);
        }
      });
      if (graph.getDefaultParent() == child) {
        ldiv2.style.background = Dialog.backdropColor == "white" ? "#e6eff8" : "#505759";
        ldiv2.style.fontWeight = graph.isEnabled() ? "bold" : "";
        selectionLayer = child;
      } else {
        mxEvent2.addListener(ldiv2, "click", function(evt) {
          if (graph.isEnabled()) {
            graph.setDefaultParent(defaultParent);
            graph.view.setCurrentRoot(null);
          }
        });
      }
      listDiv.appendChild(ldiv2);
    }
    for (var i = layerCount - 1; i >= 0; i--) {
      bind(this, function(child) {
        addLayer(i, graph.convertValueToString(child) || mxResources2.get("background"), child, child);
      })(graph.model.getChildAt(graph.model.root, i));
    }
    var label = graph.convertValueToString(selectionLayer) || mxResources2.get("background");
    removeLink.setAttribute("title", mxResources2.get("removeIt", [label]));
    duplicateLink.setAttribute("title", mxResources2.get("duplicateIt", [label]));
    dataLink.setAttribute("title", mxResources2.get("editData"));
    if (graph.isSelectionEmpty()) {
      insertLink.className = "geButton mxDisabled";
    }
  }
  refresh();
  graph.model.addListener(mxEvent2.CHANGE, refresh);
  graph.addListener("defaultParentChanged", refresh);
  graph.selectionModel.addListener(mxEvent2.CHANGE, function() {
    if (graph.isSelectionEmpty()) {
      insertLink.className = "geButton mxDisabled";
    } else {
      insertLink.className = "geButton";
    }
  });
  this.window = new mxWindow(mxResources2.get("layers"), div, x, y, w2, h2, true, true);
  this.window.minimumSize = new mxRectangle(0, 0, 120, 120);
  this.window.destroyOnClose = false;
  this.window.setMaximizable(false);
  this.window.setResizable(true);
  this.window.setClosable(true);
  this.window.setVisible(true);
  this.init = function() {
    listDiv.scrollTop = listDiv.scrollHeight - listDiv.clientHeight;
  };
  this.window.addListener(mxEvent2.SHOW, bind(this, function() {
    this.window.fit();
  }));
  this.refreshLayers = refresh;
  this.window.setLocation = function(x2, y2) {
    var iw = window.innerWidth || document.body.clientWidth || document.documentElement.clientWidth;
    var ih = window.innerHeight || document.body.clientHeight || document.documentElement.clientHeight;
    x2 = Math.max(0, Math.min(x2, iw - this.table.clientWidth));
    y2 = Math.max(0, Math.min(y2, ih - this.table.clientHeight - 48));
    if (this.getX() != x2 || this.getY() != y2) {
      mxWindow.prototype.setLocation.apply(this, arguments);
    }
  };
  var resizeListener = bind(this, function() {
    var x2 = this.window.getX();
    var y2 = this.window.getY();
    this.window.setLocation(x2, y2);
  });
  mxEvent2.addListener(window, "resize", resizeListener);
  this.destroy = function() {
    mxEvent2.removeListener(window, "resize", resizeListener);
    this.window.destroy();
  };
};

// js/graph/mxDoubleEllipse.js
var { mxConstants: mxConstants3 } = mxClient_default;
var mxDoubleEllipse2 = function(bounds, fill, stroke, strokewidth) {
  mxShape.call(this);
  this.bounds = bounds;
  this.fill = fill;
  this.stroke = stroke;
  this.strokewidth = strokewidth != null ? strokewidth : 1;
};
extend(mxDoubleEllipse2, mxShape);
mxDoubleEllipse2.prototype.vmlScale = 10;
mxDoubleEllipse2.prototype.paintBackground = function(c, x, y, w2, h2) {
  c.ellipse(x, y, w2, h2);
  c.fillAndStroke();
};
mxDoubleEllipse2.prototype.paintForeground = function(c, x, y, w2, h2) {
  if (!this.outline) {
    const margin = getValue(this.style, mxConstants3.STYLE_MARGIN, Math.min(3 + this.strokewidth, Math.min(w2 / 5, h2 / 5)));
    x += margin;
    y += margin;
    w2 -= 2 * margin;
    h2 -= 2 * margin;
    if (w2 > 0 && h2 > 0) {
      c.ellipse(x, y, w2, h2);
    }
    c.stroke();
  }
};
mxDoubleEllipse2.prototype.getLabelBounds = function(rect) {
  const margin = getValue(this.style, mxConstants3.STYLE_MARGIN, Math.min(3 + this.strokewidth, Math.min(rect.width / 5 / this.scale, rect.height / 5 / this.scale))) * this.scale;
  return new mxRectangle(rect.x + margin, rect.y + margin, rect.width - 2 * margin, rect.height - 2 * margin);
};

// js/Shapes.js
function TableShape() {
  mxSwimlane2.call(this);
}
extend(TableShape, mxSwimlane2);
TableShape.prototype.getLabelBounds = function(rect) {
  var start = this.getTitleSize();
  if (start == 0) {
    return mxShape.prototype.getLabelBounds.apply(this, arguments);
  } else {
    return mxSwimlane2.prototype.getLabelBounds.apply(this, arguments);
  }
};
TableShape.prototype.paintVertexShape = function(c, x, y, w2, h2) {
  var start = this.getTitleSize();
  if (start == 0) {
    mxRectangleShape.prototype.paintBackground.apply(this, arguments);
  } else {
    mxSwimlane2.prototype.paintVertexShape.apply(this, arguments);
    c.translate(-x, -y);
  }
  this.paintForeground(c, x, y, w2, h2);
};
TableShape.prototype.paintForeground = function(c, x, y, w2, h2) {
  if (this.state != null) {
    var flipH = this.flipH;
    var flipV = this.flipV;
    if (this.direction == mxConstants2.DIRECTION_NORTH || this.direction == mxConstants2.DIRECTION_SOUTH) {
      var tmp = flipH;
      flipH = flipV;
      flipV = tmp;
    }
    c.rotate(-this.getShapeRotation(), flipH, flipV, x + w2 / 2, y + h2 / 2);
    var s = this.scale;
    x = this.bounds.x / s;
    y = this.bounds.y / s;
    w2 = this.bounds.width / s;
    h2 = this.bounds.height / s;
    this.paintTableForeground(c, x, y, w2, h2);
  }
};
TableShape.prototype.paintTableForeground = function(c, x, y, w2, h2) {
  var graph = this.state.view.graph;
  var start = graph.getActualStartSize(this.state.cell);
  var rows = graph.model.getChildCells(this.state.cell, true);
  if (rows.length > 0) {
    var rowLines = getValue(this.state.style, "rowLines", "1") != "0";
    var columnLines = getValue(this.state.style, "columnLines", "1") != "0";
    if (rowLines) {
      for (var i = 1; i < rows.length; i++) {
        var geo = graph.getCellGeometry(rows[i]);
        if (geo != null) {
          c.begin();
          c.moveTo(x + start.x, y + geo.y);
          c.lineTo(x + w2 - start.width, y + geo.y);
          c.end();
          c.stroke();
        }
      }
    }
    if (columnLines) {
      var cols = graph.model.getChildCells(rows[0], true);
      for (var i = 1; i < cols.length; i++) {
        var geo = graph.getCellGeometry(cols[i]);
        if (geo != null) {
          c.begin();
          c.moveTo(x + geo.x + start.x, y + start.y);
          c.lineTo(x + geo.x + start.x, y + h2 - start.height);
          c.end();
          c.stroke();
        }
      }
    }
  }
};
mxCellRenderer2.registerShape("table", TableShape);
function CubeShape() {
  mxCylinder.call(this);
}
extend(CubeShape, mxCylinder);
CubeShape.prototype.size = 20;
CubeShape.prototype.darkOpacity = 0;
CubeShape.prototype.darkOpacity2 = 0;
CubeShape.prototype.paintVertexShape = function(c, x, y, w2, h2) {
  var s = Math.max(0, Math.min(w2, Math.min(h2, parseFloat(getValue(this.style, "size", this.size)))));
  var op = Math.max(-1, Math.min(1, parseFloat(getValue(this.style, "darkOpacity", this.darkOpacity))));
  var op2 = Math.max(-1, Math.min(1, parseFloat(getValue(this.style, "darkOpacity2", this.darkOpacity2))));
  c.translate(x, y);
  c.begin();
  c.moveTo(0, 0);
  c.lineTo(w2 - s, 0);
  c.lineTo(w2, s);
  c.lineTo(w2, h2);
  c.lineTo(s, h2);
  c.lineTo(0, h2 - s);
  c.lineTo(0, 0);
  c.close();
  c.end();
  c.fillAndStroke();
  if (!this.outline) {
    c.setShadow(false);
    if (op != 0) {
      c.setFillAlpha(Math.abs(op));
      c.setFillColor(op < 0 ? "#FFFFFF" : "#000000");
      c.begin();
      c.moveTo(0, 0);
      c.lineTo(w2 - s, 0);
      c.lineTo(w2, s);
      c.lineTo(s, s);
      c.close();
      c.fill();
    }
    if (op2 != 0) {
      c.setFillAlpha(Math.abs(op2));
      c.setFillColor(op2 < 0 ? "#FFFFFF" : "#000000");
      c.begin();
      c.moveTo(0, 0);
      c.lineTo(s, s);
      c.lineTo(s, h2);
      c.lineTo(0, h2 - s);
      c.close();
      c.fill();
    }
    c.begin();
    c.moveTo(s, h2);
    c.lineTo(s, s);
    c.lineTo(0, 0);
    c.moveTo(s, s);
    c.lineTo(w2, s);
    c.end();
    c.stroke();
  }
};
CubeShape.prototype.getLabelMargins = function(rect) {
  if (getValue(this.style, "boundedLbl", false)) {
    var s = parseFloat(getValue(this.style, "size", this.size)) * this.scale;
    return new mxRectangle(s, s, 0, 0);
  }
  return null;
};
mxCellRenderer2.registerShape("cube", CubeShape);
var tan30 = Math.tan(toRadians(30));
var tan30Dx = (0.5 - tan30) / 2;
function IsoRectangleShape() {
  mxActor.call(this);
}
extend(IsoRectangleShape, mxActor);
IsoRectangleShape.prototype.size = 20;
IsoRectangleShape.prototype.redrawPath = function(path, x, y, w2, h2) {
  var m = Math.min(w2, h2 / tan30);
  path.translate((w2 - m) / 2, (h2 - m) / 2 + m / 4);
  path.moveTo(0, 0.25 * m);
  path.lineTo(0.5 * m, m * tan30Dx);
  path.lineTo(m, 0.25 * m);
  path.lineTo(0.5 * m, (0.5 - tan30Dx) * m);
  path.lineTo(0, 0.25 * m);
  path.close();
  path.end();
};
mxCellRenderer2.registerShape("isoRectangle", IsoRectangleShape);
function IsoCubeShape() {
  mxCylinder.call(this);
}
extend(IsoCubeShape, mxCylinder);
IsoCubeShape.prototype.size = 20;
IsoCubeShape.prototype.redrawPath = function(path, x, y, w2, h2, isForeground) {
  var m = Math.min(w2, h2 / (0.5 + tan30));
  if (isForeground) {
    path.moveTo(0, 0.25 * m);
    path.lineTo(0.5 * m, (0.5 - tan30Dx) * m);
    path.lineTo(m, 0.25 * m);
    path.moveTo(0.5 * m, (0.5 - tan30Dx) * m);
    path.lineTo(0.5 * m, (1 - tan30Dx) * m);
    path.end();
  } else {
    path.translate((w2 - m) / 2, (h2 - m) / 2);
    path.moveTo(0, 0.25 * m);
    path.lineTo(0.5 * m, m * tan30Dx);
    path.lineTo(m, 0.25 * m);
    path.lineTo(m, 0.75 * m);
    path.lineTo(0.5 * m, (1 - tan30Dx) * m);
    path.lineTo(0, 0.75 * m);
    path.close();
    path.end();
  }
};
mxCellRenderer2.registerShape("isoCube", IsoCubeShape);
function DataStoreShape() {
  mxCylinder.call(this);
}
extend(DataStoreShape, mxCylinder);
DataStoreShape.prototype.redrawPath = function(c, x, y, w2, h2, isForeground) {
  var dy = Math.min(h2 / 2, Math.round(h2 / 8) + this.strokewidth - 1);
  if (isForeground && this.fill != null || !isForeground && this.fill == null) {
    c.moveTo(0, dy);
    c.curveTo(0, 2 * dy, w2, 2 * dy, w2, dy);
    if (!isForeground) {
      c.stroke();
      c.begin();
    }
    c.translate(0, dy / 2);
    c.moveTo(0, dy);
    c.curveTo(0, 2 * dy, w2, 2 * dy, w2, dy);
    if (!isForeground) {
      c.stroke();
      c.begin();
    }
    c.translate(0, dy / 2);
    c.moveTo(0, dy);
    c.curveTo(0, 2 * dy, w2, 2 * dy, w2, dy);
    if (!isForeground) {
      c.stroke();
      c.begin();
    }
    c.translate(0, -dy);
  }
  if (!isForeground) {
    c.moveTo(0, dy);
    c.curveTo(0, -dy / 3, w2, -dy / 3, w2, dy);
    c.lineTo(w2, h2 - dy);
    c.curveTo(w2, h2 + dy / 3, 0, h2 + dy / 3, 0, h2 - dy);
    c.close();
  }
};
DataStoreShape.prototype.getLabelMargins = function(rect) {
  return new mxRectangle(0, 2.5 * Math.min(rect.height / 2, Math.round(rect.height / 8) + this.strokewidth - 1), 0, 0);
};
mxCellRenderer2.registerShape("datastore", DataStoreShape);
function NoteShape() {
  mxCylinder.call(this);
}
extend(NoteShape, mxCylinder);
NoteShape.prototype.size = 30;
NoteShape.prototype.darkOpacity = 0;
NoteShape.prototype.paintVertexShape = function(c, x, y, w2, h2) {
  var s = Math.max(0, Math.min(w2, Math.min(h2, parseFloat(getValue(this.style, "size", this.size)))));
  var op = Math.max(-1, Math.min(1, parseFloat(getValue(this.style, "darkOpacity", this.darkOpacity))));
  c.translate(x, y);
  c.begin();
  c.moveTo(0, 0);
  c.lineTo(w2 - s, 0);
  c.lineTo(w2, s);
  c.lineTo(w2, h2);
  c.lineTo(0, h2);
  c.lineTo(0, 0);
  c.close();
  c.end();
  c.fillAndStroke();
  if (!this.outline) {
    c.setShadow(false);
    if (op != 0) {
      c.setFillAlpha(Math.abs(op));
      c.setFillColor(op < 0 ? "#FFFFFF" : "#000000");
      c.begin();
      c.moveTo(w2 - s, 0);
      c.lineTo(w2 - s, s);
      c.lineTo(w2, s);
      c.close();
      c.fill();
    }
    c.begin();
    c.moveTo(w2 - s, 0);
    c.lineTo(w2 - s, s);
    c.lineTo(w2, s);
    c.end();
    c.stroke();
  }
};
mxCellRenderer2.registerShape("note", NoteShape);
function NoteShape2() {
  NoteShape.call(this);
}
extend(NoteShape2, NoteShape);
mxCellRenderer2.registerShape("note2", NoteShape2);
function IsoCubeShape2() {
  mxShape.call(this);
}
extend(IsoCubeShape2, mxShape);
IsoCubeShape2.prototype.isoAngle = 15;
IsoCubeShape2.prototype.paintVertexShape = function(c, x, y, w2, h2) {
  var isoAngle = Math.max(0.01, Math.min(94, parseFloat(getValue(this.style, "isoAngle", this.isoAngle)))) * Math.PI / 200;
  var isoH = Math.min(w2 * Math.tan(isoAngle), h2 * 0.5);
  c.translate(x, y);
  c.begin();
  c.moveTo(w2 * 0.5, 0);
  c.lineTo(w2, isoH);
  c.lineTo(w2, h2 - isoH);
  c.lineTo(w2 * 0.5, h2);
  c.lineTo(0, h2 - isoH);
  c.lineTo(0, isoH);
  c.close();
  c.fillAndStroke();
  c.setShadow(false);
  c.begin();
  c.moveTo(0, isoH);
  c.lineTo(w2 * 0.5, 2 * isoH);
  c.lineTo(w2, isoH);
  c.moveTo(w2 * 0.5, 2 * isoH);
  c.lineTo(w2 * 0.5, h2);
  c.stroke();
};
mxCellRenderer2.registerShape("isoCube2", IsoCubeShape2);
function CylinderShape() {
  mxShape.call(this);
}
extend(CylinderShape, mxShape);
CylinderShape.prototype.size = 15;
CylinderShape.prototype.paintVertexShape = function(c, x, y, w2, h2) {
  var size = Math.max(0, Math.min(h2 * 0.5, parseFloat(getValue(this.style, "size", this.size))));
  c.translate(x, y);
  if (size == 0) {
    c.rect(0, 0, w2, h2);
    c.fillAndStroke();
  } else {
    c.begin();
    c.moveTo(0, size);
    c.arcTo(w2 * 0.5, size, 0, 0, 1, w2 * 0.5, 0);
    c.arcTo(w2 * 0.5, size, 0, 0, 1, w2, size);
    c.lineTo(w2, h2 - size);
    c.arcTo(w2 * 0.5, size, 0, 0, 1, w2 * 0.5, h2);
    c.arcTo(w2 * 0.5, size, 0, 0, 1, 0, h2 - size);
    c.close();
    c.fillAndStroke();
    c.setShadow(false);
    c.begin();
    c.moveTo(w2, size);
    c.arcTo(w2 * 0.5, size, 0, 0, 1, w2 * 0.5, 2 * size);
    c.arcTo(w2 * 0.5, size, 0, 0, 1, 0, size);
    c.stroke();
  }
};
mxCellRenderer2.registerShape("cylinder2", CylinderShape);
function CylinderShape3(bounds, fill, stroke, strokewidth) {
  mxShape.call(this);
  this.bounds = bounds;
  this.fill = fill;
  this.stroke = stroke;
  this.strokewidth = strokewidth != null ? strokewidth : 1;
}
extend(CylinderShape3, mxCylinder);
CylinderShape3.prototype.size = 15;
CylinderShape3.prototype.paintVertexShape = function(c, x, y, w2, h2) {
  var size = Math.max(0, Math.min(h2 * 0.5, parseFloat(getValue(this.style, "size", this.size))));
  var lid = getValue(this.style, "lid", true);
  c.translate(x, y);
  if (size == 0) {
    c.rect(0, 0, w2, h2);
    c.fillAndStroke();
  } else {
    c.begin();
    if (lid) {
      c.moveTo(0, size);
      c.arcTo(w2 * 0.5, size, 0, 0, 1, w2 * 0.5, 0);
      c.arcTo(w2 * 0.5, size, 0, 0, 1, w2, size);
    } else {
      c.moveTo(0, 0);
      c.arcTo(w2 * 0.5, size, 0, 0, 0, w2 * 0.5, size);
      c.arcTo(w2 * 0.5, size, 0, 0, 0, w2, 0);
    }
    c.lineTo(w2, h2 - size);
    c.arcTo(w2 * 0.5, size, 0, 0, 1, w2 * 0.5, h2);
    c.arcTo(w2 * 0.5, size, 0, 0, 1, 0, h2 - size);
    c.close();
    c.fillAndStroke();
    c.setShadow(false);
    if (lid) {
      c.begin();
      c.moveTo(w2, size);
      c.arcTo(w2 * 0.5, size, 0, 0, 1, w2 * 0.5, 2 * size);
      c.arcTo(w2 * 0.5, size, 0, 0, 1, 0, size);
      c.stroke();
    }
  }
};
mxCellRenderer2.registerShape("cylinder3", CylinderShape3);
function SwitchShape() {
  mxActor.call(this);
}
extend(SwitchShape, mxActor);
SwitchShape.prototype.redrawPath = function(c, x, y, w2, h2) {
  var curve = 0.5;
  c.moveTo(0, 0);
  c.quadTo(w2 / 2, h2 * curve, w2, 0);
  c.quadTo(w2 * (1 - curve), h2 / 2, w2, h2);
  c.quadTo(w2 / 2, h2 * (1 - curve), 0, h2);
  c.quadTo(w2 * curve, h2 / 2, 0, 0);
  c.end();
};
mxCellRenderer2.registerShape("switch", SwitchShape);
function FolderShape() {
  mxCylinder.call(this);
}
extend(FolderShape, mxCylinder);
FolderShape.prototype.tabWidth = 60;
FolderShape.prototype.tabHeight = 20;
FolderShape.prototype.tabPosition = "right";
FolderShape.prototype.arcSize = 0.1;
FolderShape.prototype.paintVertexShape = function(c, x, y, w2, h2) {
  c.translate(x, y);
  var dx = Math.max(0, Math.min(w2, parseFloat(getValue(this.style, "tabWidth", this.tabWidth))));
  var dy = Math.max(0, Math.min(h2, parseFloat(getValue(this.style, "tabHeight", this.tabHeight))));
  var tp = getValue(this.style, "tabPosition", this.tabPosition);
  var rounded = getValue(this.style, "rounded", false);
  var absArcSize = getValue(this.style, "absoluteArcSize", false);
  var arcSize = parseFloat(getValue(this.style, "arcSize", this.arcSize));
  if (!absArcSize) {
    arcSize = Math.min(w2, h2) * arcSize;
  }
  arcSize = Math.min(arcSize, w2 * 0.5, (h2 - dy) * 0.5);
  dx = Math.max(dx, arcSize);
  dx = Math.min(w2 - arcSize, dx);
  if (!rounded) {
    arcSize = 0;
  }
  c.begin();
  if (tp == "left") {
    c.moveTo(Math.max(arcSize, 0), dy);
    c.lineTo(Math.max(arcSize, 0), 0);
    c.lineTo(dx, 0);
    c.lineTo(dx, dy);
  } else {
    c.moveTo(w2 - dx, dy);
    c.lineTo(w2 - dx, 0);
    c.lineTo(w2 - Math.max(arcSize, 0), 0);
    c.lineTo(w2 - Math.max(arcSize, 0), dy);
  }
  if (rounded) {
    c.moveTo(0, arcSize + dy);
    c.arcTo(arcSize, arcSize, 0, 0, 1, arcSize, dy);
    c.lineTo(w2 - arcSize, dy);
    c.arcTo(arcSize, arcSize, 0, 0, 1, w2, arcSize + dy);
    c.lineTo(w2, h2 - arcSize);
    c.arcTo(arcSize, arcSize, 0, 0, 1, w2 - arcSize, h2);
    c.lineTo(arcSize, h2);
    c.arcTo(arcSize, arcSize, 0, 0, 1, 0, h2 - arcSize);
  } else {
    c.moveTo(0, dy);
    c.lineTo(w2, dy);
    c.lineTo(w2, h2);
    c.lineTo(0, h2);
  }
  c.close();
  c.fillAndStroke();
  c.setShadow(false);
  var sym = getValue(this.style, "folderSymbol", null);
  if (sym == "triangle") {
    c.begin();
    c.moveTo(w2 - 30, dy + 20);
    c.lineTo(w2 - 20, dy + 10);
    c.lineTo(w2 - 10, dy + 20);
    c.close();
    c.stroke();
  }
};
mxCellRenderer2.registerShape("folder", FolderShape);
function UMLStateShape() {
  mxCylinder.call(this);
}
extend(UMLStateShape, mxCylinder);
UMLStateShape.prototype.arcSize = 0.1;
UMLStateShape.prototype.paintVertexShape = function(c, x, y, w2, h2) {
  c.translate(x, y);
  var rounded = getValue(this.style, "rounded", false);
  var absArcSize = getValue(this.style, "absoluteArcSize", false);
  var arcSize = parseFloat(getValue(this.style, "arcSize", this.arcSize));
  var connPoint = getValue(this.style, "umlStateConnection", null);
  if (!absArcSize) {
    arcSize = Math.min(w2, h2) * arcSize;
  }
  arcSize = Math.min(arcSize, w2 * 0.5, h2 * 0.5);
  if (!rounded) {
    arcSize = 0;
  }
  var dx = 0;
  if (connPoint != null) {
    dx = 10;
  }
  c.begin();
  c.moveTo(dx, arcSize);
  c.arcTo(arcSize, arcSize, 0, 0, 1, dx + arcSize, 0);
  c.lineTo(w2 - arcSize, 0);
  c.arcTo(arcSize, arcSize, 0, 0, 1, w2, arcSize);
  c.lineTo(w2, h2 - arcSize);
  c.arcTo(arcSize, arcSize, 0, 0, 1, w2 - arcSize, h2);
  c.lineTo(dx + arcSize, h2);
  c.arcTo(arcSize, arcSize, 0, 0, 1, dx, h2 - arcSize);
  c.close();
  c.fillAndStroke();
  c.setShadow(false);
  var sym = getValue(this.style, "umlStateSymbol", null);
  if (sym == "collapseState") {
    c.roundrect(w2 - 40, h2 - 20, 10, 10, 3, 3);
    c.stroke();
    c.roundrect(w2 - 20, h2 - 20, 10, 10, 3, 3);
    c.stroke();
    c.begin();
    c.moveTo(w2 - 30, h2 - 15);
    c.lineTo(w2 - 20, h2 - 15);
    c.stroke();
  }
  if (connPoint == "connPointRefEntry") {
    c.ellipse(0, h2 * 0.5 - 10, 20, 20);
    c.fillAndStroke();
  } else if (connPoint == "connPointRefExit") {
    c.ellipse(0, h2 * 0.5 - 10, 20, 20);
    c.fillAndStroke();
    c.begin();
    c.moveTo(5, h2 * 0.5 - 5);
    c.lineTo(15, h2 * 0.5 + 5);
    c.moveTo(15, h2 * 0.5 - 5);
    c.lineTo(5, h2 * 0.5 + 5);
    c.stroke();
  }
};
mxCellRenderer2.registerShape("umlState", UMLStateShape);
function CardShape() {
  mxActor.call(this);
}
extend(CardShape, mxActor);
CardShape.prototype.size = 30;
CardShape.prototype.isRoundable = function() {
  return true;
};
CardShape.prototype.redrawPath = function(c, x, y, w2, h2) {
  var s = Math.max(0, Math.min(w2, Math.min(h2, parseFloat(getValue(this.style, "size", this.size)))));
  var arcSize = getValue(this.style, mxConstants2.STYLE_ARCSIZE, mxConstants2.LINE_ARCSIZE) / 2;
  this.addPoints(c, [new mxPoint2(s, 0), new mxPoint2(w2, 0), new mxPoint2(w2, h2), new mxPoint2(0, h2), new mxPoint2(0, s)], this.isRounded, arcSize, true);
  c.end();
};
mxCellRenderer2.registerShape("card", CardShape);
function TapeShape() {
  mxActor.call(this);
}
extend(TapeShape, mxActor);
TapeShape.prototype.size = 0.4;
TapeShape.prototype.redrawPath = function(c, x, y, w2, h2) {
  var dy = h2 * Math.max(0, Math.min(1, parseFloat(getValue(this.style, "size", this.size))));
  var fy = 1.4;
  c.moveTo(0, dy / 2);
  c.quadTo(w2 / 4, dy * fy, w2 / 2, dy / 2);
  c.quadTo(w2 * 3 / 4, dy * (1 - fy), w2, dy / 2);
  c.lineTo(w2, h2 - dy / 2);
  c.quadTo(w2 * 3 / 4, h2 - dy * fy, w2 / 2, h2 - dy / 2);
  c.quadTo(w2 / 4, h2 - dy * (1 - fy), 0, h2 - dy / 2);
  c.lineTo(0, dy / 2);
  c.close();
  c.end();
};
TapeShape.prototype.getLabelBounds = function(rect) {
  if (getValue(this.style, "boundedLbl", false)) {
    var size = getValue(this.style, "size", this.size);
    var w2 = rect.width;
    var h2 = rect.height;
    if (this.direction == null || this.direction == mxConstants2.DIRECTION_EAST || this.direction == mxConstants2.DIRECTION_WEST) {
      var dy = h2 * size;
      return new mxRectangle(rect.x, rect.y + dy, w2, h2 - 2 * dy);
    } else {
      var dx = w2 * size;
      return new mxRectangle(rect.x + dx, rect.y, w2 - 2 * dx, h2);
    }
  }
  return rect;
};
mxCellRenderer2.registerShape("tape", TapeShape);
function DocumentShape() {
  mxActor.call(this);
}
extend(DocumentShape, mxActor);
DocumentShape.prototype.size = 0.3;
DocumentShape.prototype.getLabelMargins = function(rect) {
  if (getValue(this.style, "boundedLbl", false)) {
    return new mxRectangle(0, 0, 0, parseFloat(getValue(this.style, "size", this.size)) * rect.height);
  }
  return null;
};
DocumentShape.prototype.redrawPath = function(c, x, y, w2, h2) {
  var dy = h2 * Math.max(0, Math.min(1, parseFloat(getValue(this.style, "size", this.size))));
  var fy = 1.4;
  c.moveTo(0, 0);
  c.lineTo(w2, 0);
  c.lineTo(w2, h2 - dy / 2);
  c.quadTo(w2 * 3 / 4, h2 - dy * fy, w2 / 2, h2 - dy / 2);
  c.quadTo(w2 / 4, h2 - dy * (1 - fy), 0, h2 - dy / 2);
  c.lineTo(0, dy / 2);
  c.close();
  c.end();
};
mxCellRenderer2.registerShape("document", DocumentShape);
var cylinderGetCylinderSize = mxCylinder.prototype.getCylinderSize;
mxCylinder.prototype.getCylinderSize = function(x, y, w2, h2) {
  var size = getValue(this.style, "size");
  if (size != null) {
    return h2 * Math.max(0, Math.min(1, size));
  } else {
    return cylinderGetCylinderSize.apply(this, arguments);
  }
};
mxCylinder.prototype.getLabelMargins = function(rect) {
  if (getValue(this.style, "boundedLbl", false)) {
    var size = getValue(this.style, "size", 0.15) * 2;
    return new mxRectangle(0, Math.min(this.maxHeight * this.scale, rect.height * size), 0, 0);
  }
  return null;
};
CylinderShape3.prototype.getLabelMargins = function(rect) {
  if (getValue(this.style, "boundedLbl", false)) {
    var size = getValue(this.style, "size", 15);
    if (!getValue(this.style, "lid", true)) {
      size /= 2;
    }
    return new mxRectangle(0, Math.min(rect.height * this.scale, size * 2 * this.scale), 0, Math.max(0, size * 0.3 * this.scale));
  }
  return null;
};
FolderShape.prototype.getLabelMargins = function(rect) {
  if (getValue(this.style, "boundedLbl", false)) {
    var sizeY = getValue(this.style, "tabHeight", 15) * this.scale;
    if (getValue(this.style, "labelInHeader", false)) {
      var sizeX = getValue(this.style, "tabWidth", 15) * this.scale;
      var sizeY = getValue(this.style, "tabHeight", 15) * this.scale;
      var rounded = getValue(this.style, "rounded", false);
      var absArcSize = getValue(this.style, "absoluteArcSize", false);
      var arcSize = parseFloat(getValue(this.style, "arcSize", this.arcSize));
      if (!absArcSize) {
        arcSize = Math.min(rect.width, rect.height) * arcSize;
      }
      arcSize = Math.min(arcSize, rect.width * 0.5, (rect.height - sizeY) * 0.5);
      if (!rounded) {
        arcSize = 0;
      }
      if (getValue(this.style, "tabPosition", this.tabPosition) == "left") {
        return new mxRectangle(arcSize, 0, Math.min(rect.width, rect.width - sizeX), Math.min(rect.height, rect.height - sizeY));
      } else {
        return new mxRectangle(Math.min(rect.width, rect.width - sizeX), 0, arcSize, Math.min(rect.height, rect.height - sizeY));
      }
    } else {
      return new mxRectangle(0, Math.min(rect.height, sizeY), 0, 0);
    }
  }
  return null;
};
UMLStateShape.prototype.getLabelMargins = function(rect) {
  if (getValue(this.style, "boundedLbl", false)) {
    var connPoint = getValue(this.style, "umlStateConnection", null);
    if (connPoint != null) {
      return new mxRectangle(10 * this.scale, 0, 0, 0);
    }
  }
  return null;
};
NoteShape2.prototype.getLabelMargins = function(rect) {
  if (getValue(this.style, "boundedLbl", false)) {
    var size = getValue(this.style, "size", 15);
    return new mxRectangle(0, Math.min(rect.height * this.scale, size * this.scale), 0, Math.max(0, size * this.scale));
  }
  return null;
};
function ParallelogramShape() {
  mxActor.call(this);
}
extend(ParallelogramShape, mxActor);
ParallelogramShape.prototype.size = 0.2;
ParallelogramShape.prototype.fixedSize = 20;
ParallelogramShape.prototype.isRoundable = function() {
  return true;
};
ParallelogramShape.prototype.redrawPath = function(c, x, y, w2, h2) {
  var fixed = getValue(this.style, "fixedSize", "0") != "0";
  var dx = fixed ? Math.max(0, Math.min(w2, parseFloat(getValue(this.style, "size", this.fixedSize)))) : w2 * Math.max(0, Math.min(1, parseFloat(getValue(this.style, "size", this.size))));
  var arcSize = getValue(this.style, mxConstants2.STYLE_ARCSIZE, mxConstants2.LINE_ARCSIZE) / 2;
  this.addPoints(c, [new mxPoint2(0, h2), new mxPoint2(dx, 0), new mxPoint2(w2, 0), new mxPoint2(w2 - dx, h2)], this.isRounded, arcSize, true);
  c.end();
};
mxCellRenderer2.registerShape("parallelogram", ParallelogramShape);
function TrapezoidShape() {
  mxActor.call(this);
}
extend(TrapezoidShape, mxActor);
TrapezoidShape.prototype.size = 0.2;
TrapezoidShape.prototype.fixedSize = 20;
TrapezoidShape.prototype.isRoundable = function() {
  return true;
};
TrapezoidShape.prototype.redrawPath = function(c, x, y, w2, h2) {
  var fixed = getValue(this.style, "fixedSize", "0") != "0";
  var dx = fixed ? Math.max(0, Math.min(w2 * 0.5, parseFloat(getValue(this.style, "size", this.fixedSize)))) : w2 * Math.max(0, Math.min(0.5, parseFloat(getValue(this.style, "size", this.size))));
  var arcSize = getValue(this.style, mxConstants2.STYLE_ARCSIZE, mxConstants2.LINE_ARCSIZE) / 2;
  this.addPoints(c, [new mxPoint2(0, h2), new mxPoint2(dx, 0), new mxPoint2(w2 - dx, 0), new mxPoint2(w2, h2)], this.isRounded, arcSize, true);
};
mxCellRenderer2.registerShape("trapezoid", TrapezoidShape);
function CurlyBracketShape() {
  mxActor.call(this);
}
extend(CurlyBracketShape, mxActor);
CurlyBracketShape.prototype.size = 0.5;
CurlyBracketShape.prototype.redrawPath = function(c, x, y, w2, h2) {
  c.setFillColor(null);
  var s = w2 * Math.max(0, Math.min(1, parseFloat(getValue(this.style, "size", this.size))));
  var arcSize = getValue(this.style, mxConstants2.STYLE_ARCSIZE, mxConstants2.LINE_ARCSIZE) / 2;
  this.addPoints(c, [
    new mxPoint2(w2, 0),
    new mxPoint2(s, 0),
    new mxPoint2(s, h2 / 2),
    new mxPoint2(0, h2 / 2),
    new mxPoint2(s, h2 / 2),
    new mxPoint2(s, h2),
    new mxPoint2(w2, h2)
  ], this.isRounded, arcSize, false);
  c.end();
};
mxCellRenderer2.registerShape("curlyBracket", CurlyBracketShape);
function ParallelMarkerShape() {
  mxActor.call(this);
}
extend(ParallelMarkerShape, mxActor);
ParallelMarkerShape.prototype.redrawPath = function(c, x, y, w2, h2) {
  c.setStrokeWidth(1);
  c.setFillColor(this.stroke);
  var w22 = w2 / 5;
  c.rect(0, 0, w22, h2);
  c.fillAndStroke();
  c.rect(2 * w22, 0, w22, h2);
  c.fillAndStroke();
  c.rect(4 * w22, 0, w22, h2);
  c.fillAndStroke();
};
mxCellRenderer2.registerShape("parallelMarker", ParallelMarkerShape);
function HandJiggle(canvas, defaultVariation) {
  this.canvas = canvas;
  this.canvas.setLineJoin("round");
  this.canvas.setLineCap("round");
  this.defaultVariation = defaultVariation;
  this.originalLineTo = this.canvas.lineTo;
  this.canvas.lineTo = bind(this, HandJiggle.prototype.lineTo);
  this.originalMoveTo = this.canvas.moveTo;
  this.canvas.moveTo = bind(this, HandJiggle.prototype.moveTo);
  this.originalClose = this.canvas.close;
  this.canvas.close = bind(this, HandJiggle.prototype.close);
  this.originalQuadTo = this.canvas.quadTo;
  this.canvas.quadTo = bind(this, HandJiggle.prototype.quadTo);
  this.originalCurveTo = this.canvas.curveTo;
  this.canvas.curveTo = bind(this, HandJiggle.prototype.curveTo);
  this.originalArcTo = this.canvas.arcTo;
  this.canvas.arcTo = bind(this, HandJiggle.prototype.arcTo);
}
HandJiggle.prototype.moveTo = function(endX, endY) {
  this.originalMoveTo.apply(this.canvas, arguments);
  this.lastX = endX;
  this.lastY = endY;
  this.firstX = endX;
  this.firstY = endY;
};
HandJiggle.prototype.close = function() {
  if (this.firstX != null && this.firstY != null) {
    this.lineTo(this.firstX, this.firstY);
    this.originalClose.apply(this.canvas, arguments);
  }
  this.originalClose.apply(this.canvas, arguments);
};
HandJiggle.prototype.quadTo = function(x1, y1, x2, y2) {
  this.originalQuadTo.apply(this.canvas, arguments);
  this.lastX = x2;
  this.lastY = y2;
};
HandJiggle.prototype.curveTo = function(x1, y1, x2, y2, x3, y3) {
  this.originalCurveTo.apply(this.canvas, arguments);
  this.lastX = x3;
  this.lastY = y3;
};
HandJiggle.prototype.arcTo = function(rx, ry, angle, largeArcFlag, sweepFlag, x, y) {
  this.originalArcTo.apply(this.canvas, arguments);
  this.lastX = x;
  this.lastY = y;
};
HandJiggle.prototype.lineTo = function(endX, endY) {
  if (this.lastX != null && this.lastY != null) {
    let sign = function(x2) {
      return typeof x2 === "number" ? x2 ? x2 < 0 ? -1 : 1 : x2 === x2 ? 0 : NaN : NaN;
    };
    var dx = Math.abs(endX - this.lastX);
    var dy = Math.abs(endY - this.lastY);
    var dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < 2) {
      this.originalLineTo.apply(this.canvas, arguments);
      this.lastX = endX;
      this.lastY = endY;
      return;
    }
    var segs = Math.round(dist / 10);
    var variation = this.defaultVariation;
    if (segs < 5) {
      segs = 5;
      variation /= 3;
    }
    var stepX = sign(endX - this.lastX) * dx / segs;
    var stepY = sign(endY - this.lastY) * dy / segs;
    var fx = dx / dist;
    var fy = dy / dist;
    for (var s = 0; s < segs; s++) {
      var x = stepX * s + this.lastX;
      var y = stepY * s + this.lastY;
      var offset = (Math.random() - 0.5) * variation;
      this.originalLineTo.call(this.canvas, x - offset * fy, y - offset * fx);
    }
    this.originalLineTo.call(this.canvas, endX, endY);
    this.lastX = endX;
    this.lastY = endY;
  } else {
    this.originalLineTo.apply(this.canvas, arguments);
    this.lastX = endX;
    this.lastY = endY;
  }
};
HandJiggle.prototype.destroy = function() {
  this.canvas.lineTo = this.originalLineTo;
  this.canvas.moveTo = this.originalMoveTo;
  this.canvas.close = this.originalClose;
  this.canvas.quadTo = this.originalQuadTo;
  this.canvas.curveTo = this.originalCurveTo;
  this.canvas.arcTo = this.originalArcTo;
};
mxShape.prototype.defaultJiggle = 1.5;
var shapeBeforePaint = mxShape.prototype.beforePaint;
mxShape.prototype.beforePaint = function(c) {
  shapeBeforePaint.apply(this, arguments);
  if (c.handJiggle == null) {
    c.handJiggle = this.createHandJiggle(c);
  }
};
var shapeAfterPaint = mxShape.prototype.afterPaint;
mxShape.prototype.afterPaint = function(c) {
  shapeAfterPaint.apply(this, arguments);
  if (c.handJiggle != null) {
    c.handJiggle.destroy();
    delete c.handJiggle;
  }
};
mxShape.prototype.createComicCanvas = function(c) {
  return new HandJiggle(c, getValue(this.style, "jiggle", this.defaultJiggle));
};
mxShape.prototype.createHandJiggle = function(c) {
  if (!this.outline && this.style != null && getValue(this.style, "comic", "0") != "0") {
    return this.createComicCanvas(c);
  }
  return null;
};
mxRhombus.prototype.defaultJiggle = 2;
var mxRectangleShapeIsHtmlAllowed0 = mxRectangleShape.prototype.isHtmlAllowed;
mxRectangleShape.prototype.isHtmlAllowed = function() {
  var urlParams3 = {};
  try {
    if (window.urlParams)
      urlParams3 = window.urlParams;
  } catch (e) {
  }
  return !this.outline && (this.style == null || getValue(this.style, "comic", "0") == "0" && getValue(this.style, "sketch", urlParams3["rough"] == "1" ? "1" : "0") == "0") && mxRectangleShapeIsHtmlAllowed0.apply(this, arguments);
};
var mxRectangleShapePaintBackground0 = mxRectangleShape.prototype.paintBackground;
mxRectangleShape.prototype.paintBackground = function(c, x, y, w2, h2) {
  if (c.handJiggle == null || c.handJiggle.constructor != HandJiggle) {
    mxRectangleShapePaintBackground0.apply(this, arguments);
  } else {
    var events = true;
    if (this.style != null) {
      events = getValue(this.style, mxConstants2.STYLE_POINTER_EVENTS, "1") == "1";
    }
    if (events || this.fill != null && this.fill != mxConstants2.NONE || this.stroke != null && this.stroke != mxConstants2.NONE) {
      if (!events && (this.fill == null || this.fill == mxConstants2.NONE)) {
        c.pointerEvents = false;
      }
      c.begin();
      if (this.isRounded) {
        var r = 0;
        if (getValue(this.style, mxConstants2.STYLE_ABSOLUTE_ARCSIZE, 0) == "1") {
          r = Math.min(w2 / 2, Math.min(h2 / 2, getValue(this.style, mxConstants2.STYLE_ARCSIZE, mxConstants2.LINE_ARCSIZE) / 2));
        } else {
          var f = getValue(this.style, mxConstants2.STYLE_ARCSIZE, mxConstants2.RECTANGLE_ROUNDING_FACTOR * 100) / 100;
          r = Math.min(w2 * f, h2 * f);
        }
        c.moveTo(x + r, y);
        c.lineTo(x + w2 - r, y);
        c.quadTo(x + w2, y, x + w2, y + r);
        c.lineTo(x + w2, y + h2 - r);
        c.quadTo(x + w2, y + h2, x + w2 - r, y + h2);
        c.lineTo(x + r, y + h2);
        c.quadTo(x, y + h2, x, y + h2 - r);
        c.lineTo(x, y + r);
        c.quadTo(x, y, x + r, y);
      } else {
        c.moveTo(x, y);
        c.lineTo(x + w2, y);
        c.lineTo(x + w2, y + h2);
        c.lineTo(x, y + h2);
        c.lineTo(x, y);
      }
      c.close();
      c.end();
      c.fillAndStroke();
    }
  }
};
var mxRectangleShapePaintForeground0 = mxRectangleShape.prototype.paintForeground;
mxRectangleShape.prototype.paintForeground = function(c, x, y, w2, h2) {
  if (c.handJiggle == null) {
    mxRectangleShapePaintForeground0.apply(this, arguments);
  }
};
function ProcessShape() {
  mxRectangleShape.call(this);
}
extend(ProcessShape, mxRectangleShape);
ProcessShape.prototype.size = 0.1;
ProcessShape.prototype.fixedSize = false;
ProcessShape.prototype.isHtmlAllowed = function() {
  return false;
};
ProcessShape.prototype.getLabelBounds = function(rect) {
  if (getValue(this.state.style, mxConstants2.STYLE_HORIZONTAL, true) == (this.direction == null || this.direction == mxConstants2.DIRECTION_EAST || this.direction == mxConstants2.DIRECTION_WEST)) {
    var w2 = rect.width;
    var h2 = rect.height;
    var r = new mxRectangle(rect.x, rect.y, w2, h2);
    var inset = w2 * Math.max(0, Math.min(1, parseFloat(getValue(this.style, "size", this.size))));
    if (this.isRounded) {
      var f = getValue(this.style, mxConstants2.STYLE_ARCSIZE, mxConstants2.RECTANGLE_ROUNDING_FACTOR * 100) / 100;
      inset = Math.max(inset, Math.min(w2 * f, h2 * f));
    }
    r.x += Math.round(inset);
    r.width -= Math.round(2 * inset);
    return r;
  }
  return rect;
};
ProcessShape.prototype.paintForeground = function(c, x, y, w2, h2) {
  var isFixedSize = getValue(this.style, "fixedSize", this.fixedSize);
  var inset = parseFloat(getValue(this.style, "size", this.size));
  if (isFixedSize) {
    inset = Math.max(0, Math.min(w2, inset));
  } else {
    inset = w2 * Math.max(0, Math.min(1, inset));
  }
  if (this.isRounded) {
    var f = getValue(this.style, mxConstants2.STYLE_ARCSIZE, mxConstants2.RECTANGLE_ROUNDING_FACTOR * 100) / 100;
    inset = Math.max(inset, Math.min(w2 * f, h2 * f));
  }
  inset = Math.round(inset);
  c.begin();
  c.moveTo(x + inset, y);
  c.lineTo(x + inset, y + h2);
  c.moveTo(x + w2 - inset, y);
  c.lineTo(x + w2 - inset, y + h2);
  c.end();
  c.stroke();
  mxRectangleShape.prototype.paintForeground.apply(this, arguments);
};
mxCellRenderer2.registerShape("process", ProcessShape);
function TransparentShape() {
  mxRectangleShape.call(this);
}
extend(TransparentShape, mxRectangleShape);
TransparentShape.prototype.paintBackground = function(c, x, y, w2, h2) {
  c.setFillColor(mxConstants2.NONE);
  c.rect(x, y, w2, h2);
  c.fill();
};
TransparentShape.prototype.paintForeground = function(c, x, y, w2, h2) {
};
mxCellRenderer2.registerShape("transparent", TransparentShape);
function CalloutShape() {
  mxActor.call(this);
}
extend(CalloutShape, mxHexagon);
CalloutShape.prototype.size = 30;
CalloutShape.prototype.position = 0.5;
CalloutShape.prototype.position2 = 0.5;
CalloutShape.prototype.base = 20;
CalloutShape.prototype.getLabelMargins = function() {
  return new mxRectangle(0, 0, 0, parseFloat(getValue(this.style, "size", this.size)) * this.scale);
};
CalloutShape.prototype.isRoundable = function() {
  return true;
};
CalloutShape.prototype.redrawPath = function(c, x, y, w2, h2) {
  var arcSize = getValue(this.style, mxConstants2.STYLE_ARCSIZE, mxConstants2.LINE_ARCSIZE) / 2;
  var s = Math.max(0, Math.min(h2, parseFloat(getValue(this.style, "size", this.size))));
  var dx = w2 * Math.max(0, Math.min(1, parseFloat(getValue(this.style, "position", this.position))));
  var dx2 = w2 * Math.max(0, Math.min(1, parseFloat(getValue(this.style, "position2", this.position2))));
  var base = Math.max(0, Math.min(w2, parseFloat(getValue(this.style, "base", this.base))));
  this.addPoints(c, [
    new mxPoint2(0, 0),
    new mxPoint2(w2, 0),
    new mxPoint2(w2, h2 - s),
    new mxPoint2(Math.min(w2, dx + base), h2 - s),
    new mxPoint2(dx2, h2),
    new mxPoint2(Math.max(0, dx), h2 - s),
    new mxPoint2(0, h2 - s)
  ], this.isRounded, arcSize, true, [4]);
};
mxCellRenderer2.registerShape("callout", CalloutShape);
function StepShape() {
  mxActor.call(this);
}
extend(StepShape, mxActor);
StepShape.prototype.size = 0.2;
StepShape.prototype.fixedSize = 20;
StepShape.prototype.isRoundable = function() {
  return true;
};
StepShape.prototype.redrawPath = function(c, x, y, w2, h2) {
  var fixed = getValue(this.style, "fixedSize", "0") != "0";
  var s = fixed ? Math.max(0, Math.min(w2, parseFloat(getValue(this.style, "size", this.fixedSize)))) : w2 * Math.max(0, Math.min(1, parseFloat(getValue(this.style, "size", this.size))));
  var arcSize = getValue(this.style, mxConstants2.STYLE_ARCSIZE, mxConstants2.LINE_ARCSIZE) / 2;
  this.addPoints(c, [
    new mxPoint2(0, 0),
    new mxPoint2(w2 - s, 0),
    new mxPoint2(w2, h2 / 2),
    new mxPoint2(w2 - s, h2),
    new mxPoint2(0, h2),
    new mxPoint2(s, h2 / 2)
  ], this.isRounded, arcSize, true);
  c.end();
};
mxCellRenderer2.registerShape("step", StepShape);
function HexagonShape() {
  mxActor.call(this);
}
extend(HexagonShape, mxHexagon);
HexagonShape.prototype.size = 0.25;
HexagonShape.prototype.fixedSize = 20;
HexagonShape.prototype.isRoundable = function() {
  return true;
};
HexagonShape.prototype.redrawPath = function(c, x, y, w2, h2) {
  var fixed = getValue(this.style, "fixedSize", "0") != "0";
  var s = fixed ? Math.max(0, Math.min(w2 * 0.5, parseFloat(getValue(this.style, "size", this.fixedSize)))) : w2 * Math.max(0, Math.min(1, parseFloat(getValue(this.style, "size", this.size))));
  var arcSize = getValue(this.style, mxConstants2.STYLE_ARCSIZE, mxConstants2.LINE_ARCSIZE) / 2;
  this.addPoints(c, [
    new mxPoint2(s, 0),
    new mxPoint2(w2 - s, 0),
    new mxPoint2(w2, 0.5 * h2),
    new mxPoint2(w2 - s, h2),
    new mxPoint2(s, h2),
    new mxPoint2(0, 0.5 * h2)
  ], this.isRounded, arcSize, true);
};
mxCellRenderer2.registerShape("hexagon", HexagonShape);
function PlusShape() {
  mxRectangleShape.call(this);
}
extend(PlusShape, mxRectangleShape);
PlusShape.prototype.isHtmlAllowed = function() {
  return false;
};
PlusShape.prototype.paintForeground = function(c, x, y, w2, h2) {
  var border = Math.min(w2 / 5, h2 / 5) + 1;
  c.begin();
  c.moveTo(x + w2 / 2, y + border);
  c.lineTo(x + w2 / 2, y + h2 - border);
  c.moveTo(x + border, y + h2 / 2);
  c.lineTo(x + w2 - border, y + h2 / 2);
  c.end();
  c.stroke();
  mxRectangleShape.prototype.paintForeground.apply(this, arguments);
};
mxCellRenderer2.registerShape("plus", PlusShape);
var mxRhombusPaintVertexShape = mxRhombus.prototype.paintVertexShape;
mxRhombus.prototype.getLabelBounds = function(rect) {
  if (this.style["double"] == 1) {
    var margin = (Math.max(2, this.strokewidth + 1) * 2 + parseFloat(this.style[mxConstants2.STYLE_MARGIN] || 0)) * this.scale;
    return new mxRectangle(rect.x + margin, rect.y + margin, rect.width - 2 * margin, rect.height - 2 * margin);
  }
  return rect;
};
mxRhombus.prototype.paintVertexShape = function(c, x, y, w2, h2) {
  mxRhombusPaintVertexShape.apply(this, arguments);
  if (!this.outline && this.style["double"] == 1) {
    var margin = Math.max(2, this.strokewidth + 1) * 2 + parseFloat(this.style[mxConstants2.STYLE_MARGIN] || 0);
    x += margin;
    y += margin;
    w2 -= 2 * margin;
    h2 -= 2 * margin;
    if (w2 > 0 && h2 > 0) {
      c.setShadow(false);
      mxRhombusPaintVertexShape.apply(this, [c, x, y, w2, h2]);
    }
  }
};
function ExtendedShape() {
  mxRectangleShape.call(this);
}
extend(ExtendedShape, mxRectangleShape);
ExtendedShape.prototype.isHtmlAllowed = function() {
  return false;
};
ExtendedShape.prototype.getLabelBounds = function(rect) {
  if (this.style["double"] == 1) {
    var margin = (Math.max(2, this.strokewidth + 1) + parseFloat(this.style[mxConstants2.STYLE_MARGIN] || 0)) * this.scale;
    return new mxRectangle(rect.x + margin, rect.y + margin, rect.width - 2 * margin, rect.height - 2 * margin);
  }
  return rect;
};
ExtendedShape.prototype.paintForeground = function(c, x, y, w2, h2) {
  if (this.style != null) {
    if (!this.outline && this.style["double"] == 1) {
      var margin = Math.max(2, this.strokewidth + 1) + parseFloat(this.style[mxConstants2.STYLE_MARGIN] || 0);
      x += margin;
      y += margin;
      w2 -= 2 * margin;
      h2 -= 2 * margin;
      if (w2 > 0 && h2 > 0) {
        mxRectangleShape.prototype.paintBackground.apply(this, arguments);
      }
    }
    c.setDashed(false);
    var counter = 0;
    var shape = null;
    do {
      shape = mxCellRenderer2.defaultShapes[this.style["symbol" + counter]];
      if (shape != null) {
        var align = this.style["symbol" + counter + "Align"];
        var valign = this.style["symbol" + counter + "VerticalAlign"];
        var width = this.style["symbol" + counter + "Width"];
        var height = this.style["symbol" + counter + "Height"];
        var spacing = this.style["symbol" + counter + "Spacing"] || 0;
        var vspacing = this.style["symbol" + counter + "VSpacing"] || spacing;
        var arcspacing = this.style["symbol" + counter + "ArcSpacing"];
        if (arcspacing != null) {
          var arcSize = this.getArcSize(w2 + this.strokewidth, h2 + this.strokewidth) * arcspacing;
          spacing += arcSize;
          vspacing += arcSize;
        }
        var x2 = x;
        var y2 = y;
        if (align == mxConstants2.ALIGN_CENTER) {
          x2 += (w2 - width) / 2;
        } else if (align == mxConstants2.ALIGN_RIGHT) {
          x2 += w2 - width - spacing;
        } else {
          x2 += spacing;
        }
        if (valign == mxConstants2.ALIGN_MIDDLE) {
          y2 += (h2 - height) / 2;
        } else if (valign == mxConstants2.ALIGN_BOTTOM) {
          y2 += h2 - height - vspacing;
        } else {
          y2 += vspacing;
        }
        c.save();
        var tmp = new shape();
        tmp.style = this.style;
        shape.prototype.paintVertexShape.call(tmp, c, x2, y2, width, height);
        c.restore();
      }
      counter++;
    } while (shape != null);
  }
  mxRectangleShape.prototype.paintForeground.apply(this, arguments);
};
mxCellRenderer2.registerShape("ext", ExtendedShape);
function MessageShape() {
  mxCylinder.call(this);
}
extend(MessageShape, mxCylinder);
MessageShape.prototype.redrawPath = function(path, x, y, w2, h2, isForeground) {
  if (isForeground) {
    path.moveTo(0, 0);
    path.lineTo(w2 / 2, h2 / 2);
    path.lineTo(w2, 0);
    path.end();
  } else {
    path.moveTo(0, 0);
    path.lineTo(w2, 0);
    path.lineTo(w2, h2);
    path.lineTo(0, h2);
    path.close();
  }
};
mxCellRenderer2.registerShape("message", MessageShape);
function UmlActorShape() {
  mxShape.call(this);
}
extend(UmlActorShape, mxShape);
UmlActorShape.prototype.paintBackground = function(c, x, y, w2, h2) {
  c.translate(x, y);
  c.ellipse(w2 / 4, 0, w2 / 2, h2 / 4);
  c.fillAndStroke();
  c.begin();
  c.moveTo(w2 / 2, h2 / 4);
  c.lineTo(w2 / 2, 2 * h2 / 3);
  c.moveTo(w2 / 2, h2 / 3);
  c.lineTo(0, h2 / 3);
  c.moveTo(w2 / 2, h2 / 3);
  c.lineTo(w2, h2 / 3);
  c.moveTo(w2 / 2, 2 * h2 / 3);
  c.lineTo(0, h2);
  c.moveTo(w2 / 2, 2 * h2 / 3);
  c.lineTo(w2, h2);
  c.end();
  c.stroke();
};
mxCellRenderer2.registerShape("umlActor", UmlActorShape);
function UmlBoundaryShape() {
  mxShape.call(this);
}
extend(UmlBoundaryShape, mxShape);
UmlBoundaryShape.prototype.getLabelMargins = function(rect) {
  return new mxRectangle(rect.width / 6, 0, 0, 0);
};
UmlBoundaryShape.prototype.paintBackground = function(c, x, y, w2, h2) {
  c.translate(x, y);
  c.begin();
  c.moveTo(0, h2 / 4);
  c.lineTo(0, h2 * 3 / 4);
  c.end();
  c.stroke();
  c.begin();
  c.moveTo(0, h2 / 2);
  c.lineTo(w2 / 6, h2 / 2);
  c.end();
  c.stroke();
  c.ellipse(w2 / 6, 0, w2 * 5 / 6, h2);
  c.fillAndStroke();
};
mxCellRenderer2.registerShape("umlBoundary", UmlBoundaryShape);
function UmlEntityShape() {
  mxEllipse.call(this);
}
extend(UmlEntityShape, mxEllipse);
UmlEntityShape.prototype.paintVertexShape = function(c, x, y, w2, h2) {
  mxEllipse.prototype.paintVertexShape.apply(this, arguments);
  c.begin();
  c.moveTo(x + w2 / 8, y + h2);
  c.lineTo(x + w2 * 7 / 8, y + h2);
  c.end();
  c.stroke();
};
mxCellRenderer2.registerShape("umlEntity", UmlEntityShape);
function UmlDestroyShape() {
  mxShape.call(this);
}
extend(UmlDestroyShape, mxShape);
UmlDestroyShape.prototype.paintVertexShape = function(c, x, y, w2, h2) {
  c.translate(x, y);
  c.begin();
  c.moveTo(w2, 0);
  c.lineTo(0, h2);
  c.moveTo(0, 0);
  c.lineTo(w2, h2);
  c.end();
  c.stroke();
};
mxCellRenderer2.registerShape("umlDestroy", UmlDestroyShape);
function UmlControlShape() {
  mxShape.call(this);
}
extend(UmlControlShape, mxShape);
UmlControlShape.prototype.getLabelBounds = function(rect) {
  return new mxRectangle(rect.x, rect.y + rect.height / 8, rect.width, rect.height * 7 / 8);
};
UmlControlShape.prototype.paintBackground = function(c, x, y, w2, h2) {
  c.translate(x, y);
  c.begin();
  c.moveTo(w2 * 3 / 8, h2 / 8 * 1.1);
  c.lineTo(w2 * 5 / 8, 0);
  c.end();
  c.stroke();
  c.ellipse(0, h2 / 8, w2, h2 * 7 / 8);
  c.fillAndStroke();
};
UmlControlShape.prototype.paintForeground = function(c, x, y, w2, h2) {
  c.begin();
  c.moveTo(w2 * 3 / 8, h2 / 8 * 1.1);
  c.lineTo(w2 * 5 / 8, h2 / 4);
  c.end();
  c.stroke();
};
mxCellRenderer2.registerShape("umlControl", UmlControlShape);
function UmlLifeline() {
  mxRectangleShape.call(this);
}
extend(UmlLifeline, mxRectangleShape);
UmlLifeline.prototype.size = 40;
UmlLifeline.prototype.isHtmlAllowed = function() {
  return false;
};
UmlLifeline.prototype.getLabelBounds = function(rect) {
  var size = Math.max(0, Math.min(rect.height, parseFloat(getValue(this.style, "size", this.size)) * this.scale));
  return new mxRectangle(rect.x, rect.y, rect.width, size);
};
UmlLifeline.prototype.paintBackground = function(c, x, y, w2, h2) {
  var size = Math.max(0, Math.min(h2, parseFloat(getValue(this.style, "size", this.size))));
  var participant = getValue(this.style, "participant");
  if (participant == null || this.state == null) {
    mxRectangleShape.prototype.paintBackground.call(this, c, x, y, w2, size);
  } else {
    var ctor = this.state.view.graph.cellRenderer.getShape(participant);
    if (ctor != null && ctor != UmlLifeline) {
      var shape = new ctor();
      shape.apply(this.state);
      c.save();
      shape.paintVertexShape(c, x, y, w2, size);
      c.restore();
    }
  }
  if (size < h2) {
    c.setDashed(true);
    c.begin();
    c.moveTo(x + w2 / 2, y + size);
    c.lineTo(x + w2 / 2, y + h2);
    c.end();
    c.stroke();
  }
};
UmlLifeline.prototype.paintForeground = function(c, x, y, w2, h2) {
  var size = Math.max(0, Math.min(h2, parseFloat(getValue(this.style, "size", this.size))));
  mxRectangleShape.prototype.paintForeground.call(this, c, x, y, w2, Math.min(h2, size));
};
mxCellRenderer2.registerShape("umlLifeline", UmlLifeline);
function UmlFrame() {
  mxShape.call(this);
}
extend(UmlFrame, mxShape);
UmlFrame.prototype.width = 60;
UmlFrame.prototype.height = 30;
UmlFrame.prototype.corner = 10;
UmlFrame.prototype.getLabelMargins = function(rect) {
  return new mxRectangle(0, 0, rect.width - parseFloat(getValue(this.style, "width", this.width) * this.scale), rect.height - parseFloat(getValue(this.style, "height", this.height) * this.scale));
};
UmlFrame.prototype.paintBackground = function(c, x, y, w2, h2) {
  var co = this.corner;
  var w0 = Math.min(w2, Math.max(co, parseFloat(getValue(this.style, "width", this.width))));
  var h0 = Math.min(h2, Math.max(co * 1.5, parseFloat(getValue(this.style, "height", this.height))));
  var bg = getValue(this.style, mxConstants2.STYLE_SWIMLANE_FILLCOLOR, mxConstants2.NONE);
  if (bg != mxConstants2.NONE) {
    c.setFillColor(bg);
    c.rect(x, y, w2, h2);
    c.fill();
  }
  if (this.fill != null && this.fill != mxConstants2.NONE && this.gradient && this.gradient != mxConstants2.NONE) {
    var b = this.getGradientBounds(c, x, y, w2, h2);
    c.setGradient(this.fill, this.gradient, x, y, w2, h2, this.gradientDirection);
  } else {
    c.setFillColor(this.fill);
  }
  c.begin();
  c.moveTo(x, y);
  c.lineTo(x + w0, y);
  c.lineTo(x + w0, y + Math.max(0, h0 - co * 1.5));
  c.lineTo(x + Math.max(0, w0 - co), y + h0);
  c.lineTo(x, y + h0);
  c.close();
  c.fillAndStroke();
  c.begin();
  c.moveTo(x + w0, y);
  c.lineTo(x + w2, y);
  c.lineTo(x + w2, y + h2);
  c.lineTo(x, y + h2);
  c.lineTo(x, y + h0);
  c.stroke();
};
mxCellRenderer2.registerShape("umlFrame", UmlFrame);
var LifelinePerimeter = function(bounds, vertex, next, orthogonal) {
  var size = UmlLifeline.prototype.size;
  if (vertex != null) {
    size = getValue(vertex.style, "size", size) * vertex.view.scale;
  }
  var sw = parseFloat(vertex.style[mxConstants2.STYLE_STROKEWIDTH] || 1) * vertex.view.scale / 2 - 1;
  if (next.x < bounds.getCenterX()) {
    sw += 1;
    sw *= -1;
  }
  return new mxPoint2(bounds.getCenterX() + sw, Math.min(bounds.y + bounds.height, Math.max(bounds.y + size, next.y)));
};
mxStyleRegistry2.putValue("lifelinePerimeter", LifelinePerimeter);
var OrthogonalPerimeter = function(bounds, vertex, next, orthogonal) {
  orthogonal = true;
  return RectanglePerimeter.apply(this, arguments);
};
mxStyleRegistry2.putValue("orthogonalPerimeter", OrthogonalPerimeter);
var BackbonePerimeter = function(bounds, vertex, next, orthogonal) {
  var sw = parseFloat(vertex.style[mxConstants2.STYLE_STROKEWIDTH] || 1) * vertex.view.scale / 2 - 1;
  if (vertex.style["backboneSize"] != null) {
    sw += parseFloat(vertex.style["backboneSize"]) * vertex.view.scale / 2 - 1;
  }
  if (vertex.style[mxConstants2.STYLE_DIRECTION] == "south" || vertex.style[mxConstants2.STYLE_DIRECTION] == "north") {
    if (next.x < bounds.getCenterX()) {
      sw += 1;
      sw *= -1;
    }
    return new mxPoint2(bounds.getCenterX() + sw, Math.min(bounds.y + bounds.height, Math.max(bounds.y, next.y)));
  } else {
    if (next.y < bounds.getCenterY()) {
      sw += 1;
      sw *= -1;
    }
    return new mxPoint2(Math.min(bounds.x + bounds.width, Math.max(bounds.x, next.x)), bounds.getCenterY() + sw);
  }
};
mxStyleRegistry2.putValue("backbonePerimeter", BackbonePerimeter);
var CalloutPerimeter = function(bounds, vertex, next, orthogonal) {
  return RectanglePerimeter(getDirectedBounds(bounds, new mxRectangle(0, 0, 0, Math.max(0, Math.min(bounds.height, parseFloat(getValue(vertex.style, "size", CalloutShape.prototype.size)) * vertex.view.scale))), vertex.style), vertex, next, orthogonal);
};
mxStyleRegistry2.putValue("calloutPerimeter", CalloutPerimeter);
var ParallelogramPerimeter = function(bounds, vertex, next, orthogonal) {
  var fixed = getValue(vertex.style, "fixedSize", "0") != "0";
  var size = fixed ? ParallelogramShape.prototype.fixedSize : ParallelogramShape.prototype.size;
  if (vertex != null) {
    size = getValue(vertex.style, "size", size);
  }
  if (fixed) {
    size *= vertex.view.scale;
  }
  var x = bounds.x;
  var y = bounds.y;
  var w2 = bounds.width;
  var h2 = bounds.height;
  var direction = vertex != null ? getValue(vertex.style, mxConstants2.STYLE_DIRECTION, mxConstants2.DIRECTION_EAST) : mxConstants2.DIRECTION_EAST;
  var vertical = direction == mxConstants2.DIRECTION_NORTH || direction == mxConstants2.DIRECTION_SOUTH;
  var points;
  if (vertical) {
    var dy = fixed ? Math.max(0, Math.min(h2, size)) : h2 * Math.max(0, Math.min(1, size));
    points = [
      new mxPoint2(x, y),
      new mxPoint2(x + w2, y + dy),
      new mxPoint2(x + w2, y + h2),
      new mxPoint2(x, y + h2 - dy),
      new mxPoint2(x, y)
    ];
  } else {
    var dx = fixed ? Math.max(0, Math.min(w2 * 0.5, size)) : w2 * Math.max(0, Math.min(1, size));
    points = [
      new mxPoint2(x + dx, y),
      new mxPoint2(x + w2, y),
      new mxPoint2(x + w2 - dx, y + h2),
      new mxPoint2(x, y + h2),
      new mxPoint2(x + dx, y)
    ];
  }
  var cx = bounds.getCenterX();
  var cy = bounds.getCenterY();
  var p1 = new mxPoint2(cx, cy);
  if (orthogonal) {
    if (next.x < x || next.x > x + w2) {
      p1.y = next.y;
    } else {
      p1.x = next.x;
    }
  }
  return getPerimeterPoint(points, p1, next);
};
mxStyleRegistry2.putValue("parallelogramPerimeter", ParallelogramPerimeter);
var TrapezoidPerimeter = function(bounds, vertex, next, orthogonal) {
  var fixed = getValue(vertex.style, "fixedSize", "0") != "0";
  var size = fixed ? TrapezoidShape.prototype.fixedSize : TrapezoidShape.prototype.size;
  if (vertex != null) {
    size = getValue(vertex.style, "size", size);
  }
  if (fixed) {
    size *= vertex.view.scale;
  }
  var x = bounds.x;
  var y = bounds.y;
  var w2 = bounds.width;
  var h2 = bounds.height;
  var direction = vertex != null ? getValue(vertex.style, mxConstants2.STYLE_DIRECTION, mxConstants2.DIRECTION_EAST) : mxConstants2.DIRECTION_EAST;
  var points = [];
  if (direction == mxConstants2.DIRECTION_EAST) {
    var dx = fixed ? Math.max(0, Math.min(w2 * 0.5, size)) : w2 * Math.max(0, Math.min(1, size));
    points = [
      new mxPoint2(x + dx, y),
      new mxPoint2(x + w2 - dx, y),
      new mxPoint2(x + w2, y + h2),
      new mxPoint2(x, y + h2),
      new mxPoint2(x + dx, y)
    ];
  } else if (direction == mxConstants2.DIRECTION_WEST) {
    var dx = fixed ? Math.max(0, Math.min(w2, size)) : w2 * Math.max(0, Math.min(1, size));
    points = [
      new mxPoint2(x, y),
      new mxPoint2(x + w2, y),
      new mxPoint2(x + w2 - dx, y + h2),
      new mxPoint2(x + dx, y + h2),
      new mxPoint2(x, y)
    ];
  } else if (direction == mxConstants2.DIRECTION_NORTH) {
    var dy = fixed ? Math.max(0, Math.min(h2, size)) : h2 * Math.max(0, Math.min(1, size));
    points = [
      new mxPoint2(x, y + dy),
      new mxPoint2(x + w2, y),
      new mxPoint2(x + w2, y + h2),
      new mxPoint2(x, y + h2 - dy),
      new mxPoint2(x, y + dy)
    ];
  } else {
    var dy = fixed ? Math.max(0, Math.min(h2, size)) : h2 * Math.max(0, Math.min(1, size));
    points = [
      new mxPoint2(x, y),
      new mxPoint2(x + w2, y + dy),
      new mxPoint2(x + w2, y + h2 - dy),
      new mxPoint2(x, y + h2),
      new mxPoint2(x, y)
    ];
  }
  var cx = bounds.getCenterX();
  var cy = bounds.getCenterY();
  var p1 = new mxPoint2(cx, cy);
  if (orthogonal) {
    if (next.x < x || next.x > x + w2) {
      p1.y = next.y;
    } else {
      p1.x = next.x;
    }
  }
  return getPerimeterPoint(points, p1, next);
};
mxStyleRegistry2.putValue("trapezoidPerimeter", TrapezoidPerimeter);
var StepPerimeter = function(bounds, vertex, next, orthogonal) {
  var fixed = getValue(vertex.style, "fixedSize", "0") != "0";
  var size = fixed ? StepShape.prototype.fixedSize : StepShape.prototype.size;
  if (vertex != null) {
    size = getValue(vertex.style, "size", size);
  }
  if (fixed) {
    size *= vertex.view.scale;
  }
  var x = bounds.x;
  var y = bounds.y;
  var w2 = bounds.width;
  var h2 = bounds.height;
  var cx = bounds.getCenterX();
  var cy = bounds.getCenterY();
  var direction = vertex != null ? getValue(vertex.style, mxConstants2.STYLE_DIRECTION, mxConstants2.DIRECTION_EAST) : mxConstants2.DIRECTION_EAST;
  var points;
  if (direction == mxConstants2.DIRECTION_EAST) {
    var dx = fixed ? Math.max(0, Math.min(w2, size)) : w2 * Math.max(0, Math.min(1, size));
    points = [
      new mxPoint2(x, y),
      new mxPoint2(x + w2 - dx, y),
      new mxPoint2(x + w2, cy),
      new mxPoint2(x + w2 - dx, y + h2),
      new mxPoint2(x, y + h2),
      new mxPoint2(x + dx, cy),
      new mxPoint2(x, y)
    ];
  } else if (direction == mxConstants2.DIRECTION_WEST) {
    var dx = fixed ? Math.max(0, Math.min(w2, size)) : w2 * Math.max(0, Math.min(1, size));
    points = [
      new mxPoint2(x + dx, y),
      new mxPoint2(x + w2, y),
      new mxPoint2(x + w2 - dx, cy),
      new mxPoint2(x + w2, y + h2),
      new mxPoint2(x + dx, y + h2),
      new mxPoint2(x, cy),
      new mxPoint2(x + dx, y)
    ];
  } else if (direction == mxConstants2.DIRECTION_NORTH) {
    var dy = fixed ? Math.max(0, Math.min(h2, size)) : h2 * Math.max(0, Math.min(1, size));
    points = [
      new mxPoint2(x, y + dy),
      new mxPoint2(cx, y),
      new mxPoint2(x + w2, y + dy),
      new mxPoint2(x + w2, y + h2),
      new mxPoint2(cx, y + h2 - dy),
      new mxPoint2(x, y + h2),
      new mxPoint2(x, y + dy)
    ];
  } else {
    var dy = fixed ? Math.max(0, Math.min(h2, size)) : h2 * Math.max(0, Math.min(1, size));
    points = [
      new mxPoint2(x, y),
      new mxPoint2(cx, y + dy),
      new mxPoint2(x + w2, y),
      new mxPoint2(x + w2, y + h2 - dy),
      new mxPoint2(cx, y + h2),
      new mxPoint2(x, y + h2 - dy),
      new mxPoint2(x, y)
    ];
  }
  var p1 = new mxPoint2(cx, cy);
  if (orthogonal) {
    if (next.x < x || next.x > x + w2) {
      p1.y = next.y;
    } else {
      p1.x = next.x;
    }
  }
  return getPerimeterPoint(points, p1, next);
};
mxStyleRegistry2.putValue("stepPerimeter", StepPerimeter);
var HexagonPerimeter2 = function(bounds, vertex, next, orthogonal) {
  var fixed = getValue(vertex.style, "fixedSize", "0") != "0";
  var size = fixed ? HexagonShape.prototype.fixedSize : HexagonShape.prototype.size;
  if (vertex != null) {
    size = getValue(vertex.style, "size", size);
  }
  if (fixed) {
    size *= vertex.view.scale;
  }
  var x = bounds.x;
  var y = bounds.y;
  var w2 = bounds.width;
  var h2 = bounds.height;
  var cx = bounds.getCenterX();
  var cy = bounds.getCenterY();
  var direction = vertex != null ? getValue(vertex.style, mxConstants2.STYLE_DIRECTION, mxConstants2.DIRECTION_EAST) : mxConstants2.DIRECTION_EAST;
  var vertical = direction == mxConstants2.DIRECTION_NORTH || direction == mxConstants2.DIRECTION_SOUTH;
  var points;
  if (vertical) {
    var dy = fixed ? Math.max(0, Math.min(h2, size)) : h2 * Math.max(0, Math.min(1, size));
    points = [
      new mxPoint2(cx, y),
      new mxPoint2(x + w2, y + dy),
      new mxPoint2(x + w2, y + h2 - dy),
      new mxPoint2(cx, y + h2),
      new mxPoint2(x, y + h2 - dy),
      new mxPoint2(x, y + dy),
      new mxPoint2(cx, y)
    ];
  } else {
    var dx = fixed ? Math.max(0, Math.min(w2, size)) : w2 * Math.max(0, Math.min(1, size));
    points = [
      new mxPoint2(x + dx, y),
      new mxPoint2(x + w2 - dx, y),
      new mxPoint2(x + w2, cy),
      new mxPoint2(x + w2 - dx, y + h2),
      new mxPoint2(x + dx, y + h2),
      new mxPoint2(x, cy),
      new mxPoint2(x + dx, y)
    ];
  }
  var p1 = new mxPoint2(cx, cy);
  if (orthogonal) {
    if (next.x < x || next.x > x + w2) {
      p1.y = next.y;
    } else {
      p1.x = next.x;
    }
  }
  return getPerimeterPoint(points, p1, next);
};
mxStyleRegistry2.putValue("hexagonPerimeter2", HexagonPerimeter2);
function LollipopShape() {
  mxShape.call(this);
}
extend(LollipopShape, mxShape);
LollipopShape.prototype.size = 10;
LollipopShape.prototype.paintBackground = function(c, x, y, w2, h2) {
  var sz = parseFloat(getValue(this.style, "size", this.size));
  c.translate(x, y);
  c.ellipse((w2 - sz) / 2, 0, sz, sz);
  c.fillAndStroke();
  c.begin();
  c.moveTo(w2 / 2, sz);
  c.lineTo(w2 / 2, h2);
  c.end();
  c.stroke();
};
mxCellRenderer2.registerShape("lollipop", LollipopShape);
function RequiresShape() {
  mxShape.call(this);
}
extend(RequiresShape, mxShape);
RequiresShape.prototype.size = 10;
RequiresShape.prototype.inset = 2;
RequiresShape.prototype.paintBackground = function(c, x, y, w2, h2) {
  var sz = parseFloat(getValue(this.style, "size", this.size));
  var inset = parseFloat(getValue(this.style, "inset", this.inset)) + this.strokewidth;
  c.translate(x, y);
  c.begin();
  c.moveTo(w2 / 2, sz + inset);
  c.lineTo(w2 / 2, h2);
  c.end();
  c.stroke();
  c.begin();
  c.moveTo((w2 - sz) / 2 - inset, sz / 2);
  c.quadTo((w2 - sz) / 2 - inset, sz + inset, w2 / 2, sz + inset);
  c.quadTo((w2 + sz) / 2 + inset, sz + inset, (w2 + sz) / 2 + inset, sz / 2);
  c.end();
  c.stroke();
};
mxCellRenderer2.registerShape("requires", RequiresShape);
function RequiredInterfaceShape() {
  mxShape.call(this);
}
extend(RequiredInterfaceShape, mxShape);
RequiredInterfaceShape.prototype.paintBackground = function(c, x, y, w2, h2) {
  c.translate(x, y);
  c.begin();
  c.moveTo(0, 0);
  c.quadTo(w2, 0, w2, h2 / 2);
  c.quadTo(w2, h2, 0, h2);
  c.end();
  c.stroke();
};
mxCellRenderer2.registerShape("requiredInterface", RequiredInterfaceShape);
function ProvidedRequiredInterfaceShape() {
  mxShape.call(this);
}
extend(ProvidedRequiredInterfaceShape, mxShape);
ProvidedRequiredInterfaceShape.prototype.inset = 2;
ProvidedRequiredInterfaceShape.prototype.paintBackground = function(c, x, y, w2, h2) {
  var inset = parseFloat(getValue(this.style, "inset", this.inset)) + this.strokewidth;
  c.translate(x, y);
  c.ellipse(0, inset, w2 - 2 * inset, h2 - 2 * inset);
  c.fillAndStroke();
  c.begin();
  c.moveTo(w2 / 2, 0);
  c.quadTo(w2, 0, w2, h2 / 2);
  c.quadTo(w2, h2, w2 / 2, h2);
  c.end();
  c.stroke();
};
mxCellRenderer2.registerShape("providedRequiredInterface", ProvidedRequiredInterfaceShape);
function ModuleShape() {
  mxCylinder.call(this);
}
extend(ModuleShape, mxCylinder);
ModuleShape.prototype.jettyWidth = 20;
ModuleShape.prototype.jettyHeight = 10;
ModuleShape.prototype.redrawPath = function(path, x, y, w2, h2, isForeground) {
  var dx = parseFloat(getValue(this.style, "jettyWidth", this.jettyWidth));
  var dy = parseFloat(getValue(this.style, "jettyHeight", this.jettyHeight));
  var x0 = dx / 2;
  var x1 = x0 + dx / 2;
  var y0 = Math.min(dy, h2 - dy);
  var y1 = Math.min(y0 + 2 * dy, h2 - dy);
  if (isForeground) {
    path.moveTo(x0, y0);
    path.lineTo(x1, y0);
    path.lineTo(x1, y0 + dy);
    path.lineTo(x0, y0 + dy);
    path.moveTo(x0, y1);
    path.lineTo(x1, y1);
    path.lineTo(x1, y1 + dy);
    path.lineTo(x0, y1 + dy);
    path.end();
  } else {
    path.moveTo(x0, 0);
    path.lineTo(w2, 0);
    path.lineTo(w2, h2);
    path.lineTo(x0, h2);
    path.lineTo(x0, y1 + dy);
    path.lineTo(0, y1 + dy);
    path.lineTo(0, y1);
    path.lineTo(x0, y1);
    path.lineTo(x0, y0 + dy);
    path.lineTo(0, y0 + dy);
    path.lineTo(0, y0);
    path.lineTo(x0, y0);
    path.close();
    path.end();
  }
};
mxCellRenderer2.registerShape("module", ModuleShape);
function ComponentShape() {
  mxCylinder.call(this);
}
extend(ComponentShape, mxCylinder);
ComponentShape.prototype.jettyWidth = 32;
ComponentShape.prototype.jettyHeight = 12;
ComponentShape.prototype.redrawPath = function(path, x, y, w2, h2, isForeground) {
  var dx = parseFloat(getValue(this.style, "jettyWidth", this.jettyWidth));
  var dy = parseFloat(getValue(this.style, "jettyHeight", this.jettyHeight));
  var x0 = dx / 2;
  var x1 = x0 + dx / 2;
  var y0 = 0.3 * h2 - dy / 2;
  var y1 = 0.7 * h2 - dy / 2;
  if (isForeground) {
    path.moveTo(x0, y0);
    path.lineTo(x1, y0);
    path.lineTo(x1, y0 + dy);
    path.lineTo(x0, y0 + dy);
    path.moveTo(x0, y1);
    path.lineTo(x1, y1);
    path.lineTo(x1, y1 + dy);
    path.lineTo(x0, y1 + dy);
    path.end();
  } else {
    path.moveTo(x0, 0);
    path.lineTo(w2, 0);
    path.lineTo(w2, h2);
    path.lineTo(x0, h2);
    path.lineTo(x0, y1 + dy);
    path.lineTo(0, y1 + dy);
    path.lineTo(0, y1);
    path.lineTo(x0, y1);
    path.lineTo(x0, y0 + dy);
    path.lineTo(0, y0 + dy);
    path.lineTo(0, y0);
    path.lineTo(x0, y0);
    path.close();
    path.end();
  }
};
mxCellRenderer2.registerShape("component", ComponentShape);
function AssociativeEntity() {
  mxRectangleShape.call(this);
}
extend(AssociativeEntity, mxRectangleShape);
AssociativeEntity.prototype.paintForeground = function(c, x, y, w2, h2) {
  var hw = w2 / 2;
  var hh = h2 / 2;
  var arcSize = getValue(this.style, mxConstants2.STYLE_ARCSIZE, mxConstants2.LINE_ARCSIZE) / 2;
  c.begin();
  this.addPoints(c, [
    new mxPoint2(x + hw, y),
    new mxPoint2(x + w2, y + hh),
    new mxPoint2(x + hw, y + h2),
    new mxPoint2(x, y + hh)
  ], this.isRounded, arcSize, true);
  c.stroke();
  mxRectangleShape.prototype.paintForeground.apply(this, arguments);
};
mxCellRenderer2.registerShape("associativeEntity", AssociativeEntity);
function StateShape() {
  mxDoubleEllipse2.call(this);
}
extend(StateShape, mxDoubleEllipse2);
StateShape.prototype.outerStroke = true;
StateShape.prototype.paintVertexShape = function(c, x, y, w2, h2) {
  var inset = Math.min(4, Math.min(w2 / 5, h2 / 5));
  if (w2 > 0 && h2 > 0) {
    c.ellipse(x + inset, y + inset, w2 - 2 * inset, h2 - 2 * inset);
    c.fillAndStroke();
  }
  c.setShadow(false);
  if (this.outerStroke) {
    c.ellipse(x, y, w2, h2);
    c.stroke();
  }
};
mxCellRenderer2.registerShape("endState", StateShape);
function StartStateShape() {
  StateShape.call(this);
}
extend(StartStateShape, StateShape);
StartStateShape.prototype.outerStroke = false;
mxCellRenderer2.registerShape("startState", StartStateShape);
function LinkShape() {
  mxArrowConnector.call(this);
  this.spacing = 0;
}
extend(LinkShape, mxArrowConnector);
LinkShape.prototype.defaultWidth = 4;
LinkShape.prototype.isOpenEnded = function() {
  return true;
};
LinkShape.prototype.getEdgeWidth = function() {
  return getNumber(this.style, "width", this.defaultWidth) + Math.max(0, this.strokewidth - 1);
};
LinkShape.prototype.isArrowRounded = function() {
  return this.isRounded;
};
mxCellRenderer2.registerShape("link", LinkShape);
function FlexArrowShape() {
  mxArrowConnector.call(this);
  this.spacing = 0;
}
extend(FlexArrowShape, mxArrowConnector);
FlexArrowShape.prototype.defaultWidth = 10;
FlexArrowShape.prototype.defaultArrowWidth = 20;
FlexArrowShape.prototype.getStartArrowWidth = function() {
  return this.getEdgeWidth() + getNumber(this.style, "startWidth", this.defaultArrowWidth);
};
FlexArrowShape.prototype.getEndArrowWidth = function() {
  return this.getEdgeWidth() + getNumber(this.style, "endWidth", this.defaultArrowWidth);
  ;
};
FlexArrowShape.prototype.getEdgeWidth = function() {
  return getNumber(this.style, "width", this.defaultWidth) + Math.max(0, this.strokewidth - 1);
};
mxCellRenderer2.registerShape("flexArrow", FlexArrowShape);
function ManualInputShape() {
  mxActor.call(this);
}
extend(ManualInputShape, mxActor);
ManualInputShape.prototype.size = 30;
ManualInputShape.prototype.isRoundable = function() {
  return true;
};
ManualInputShape.prototype.redrawPath = function(c, x, y, w2, h2) {
  var s = Math.min(h2, parseFloat(getValue(this.style, "size", this.size)));
  var arcSize = getValue(this.style, mxConstants2.STYLE_ARCSIZE, mxConstants2.LINE_ARCSIZE) / 2;
  this.addPoints(c, [new mxPoint2(0, h2), new mxPoint2(0, s), new mxPoint2(w2, 0), new mxPoint2(w2, h2)], this.isRounded, arcSize, true);
  c.end();
};
mxCellRenderer2.registerShape("manualInput", ManualInputShape);
function InternalStorageShape() {
  mxRectangleShape.call(this);
}
extend(InternalStorageShape, mxRectangleShape);
InternalStorageShape.prototype.dx = 20;
InternalStorageShape.prototype.dy = 20;
InternalStorageShape.prototype.isHtmlAllowed = function() {
  return false;
};
InternalStorageShape.prototype.paintForeground = function(c, x, y, w2, h2) {
  mxRectangleShape.prototype.paintForeground.apply(this, arguments);
  var inset = 0;
  if (this.isRounded) {
    var f = getValue(this.style, mxConstants2.STYLE_ARCSIZE, mxConstants2.RECTANGLE_ROUNDING_FACTOR * 100) / 100;
    inset = Math.max(inset, Math.min(w2 * f, h2 * f));
  }
  var dx = Math.max(inset, Math.min(w2, parseFloat(getValue(this.style, "dx", this.dx))));
  var dy = Math.max(inset, Math.min(h2, parseFloat(getValue(this.style, "dy", this.dy))));
  c.begin();
  c.moveTo(x, y + dy);
  c.lineTo(x + w2, y + dy);
  c.end();
  c.stroke();
  c.begin();
  c.moveTo(x + dx, y);
  c.lineTo(x + dx, y + h2);
  c.end();
  c.stroke();
};
mxCellRenderer2.registerShape("internalStorage", InternalStorageShape);
function CornerShape() {
  mxActor.call(this);
}
extend(CornerShape, mxActor);
CornerShape.prototype.dx = 20;
CornerShape.prototype.dy = 20;
CornerShape.prototype.redrawPath = function(c, x, y, w2, h2) {
  var dx = Math.max(0, Math.min(w2, parseFloat(getValue(this.style, "dx", this.dx))));
  var dy = Math.max(0, Math.min(h2, parseFloat(getValue(this.style, "dy", this.dy))));
  var s = Math.min(w2 / 2, Math.min(h2, parseFloat(getValue(this.style, "size", this.size))));
  var arcSize = getValue(this.style, mxConstants2.STYLE_ARCSIZE, mxConstants2.LINE_ARCSIZE) / 2;
  this.addPoints(c, [
    new mxPoint2(0, 0),
    new mxPoint2(w2, 0),
    new mxPoint2(w2, dy),
    new mxPoint2(dx, dy),
    new mxPoint2(dx, h2),
    new mxPoint2(0, h2)
  ], this.isRounded, arcSize, true);
  c.end();
};
mxCellRenderer2.registerShape("corner", CornerShape);
function CrossbarShape() {
  mxActor.call(this);
}
extend(CrossbarShape, mxActor);
CrossbarShape.prototype.redrawPath = function(c, x, y, w2, h2) {
  c.moveTo(0, 0);
  c.lineTo(0, h2);
  c.end();
  c.moveTo(w2, 0);
  c.lineTo(w2, h2);
  c.end();
  c.moveTo(0, h2 / 2);
  c.lineTo(w2, h2 / 2);
  c.end();
};
mxCellRenderer2.registerShape("crossbar", CrossbarShape);
function TeeShape() {
  mxActor.call(this);
}
extend(TeeShape, mxActor);
TeeShape.prototype.dx = 20;
TeeShape.prototype.dy = 20;
TeeShape.prototype.redrawPath = function(c, x, y, w2, h2) {
  var dx = Math.max(0, Math.min(w2, parseFloat(getValue(this.style, "dx", this.dx))));
  var dy = Math.max(0, Math.min(h2, parseFloat(getValue(this.style, "dy", this.dy))));
  var w22 = Math.abs(w2 - dx) / 2;
  var s = Math.min(w2 / 2, Math.min(h2, parseFloat(getValue(this.style, "size", this.size))));
  var arcSize = getValue(this.style, mxConstants2.STYLE_ARCSIZE, mxConstants2.LINE_ARCSIZE) / 2;
  this.addPoints(c, [
    new mxPoint2(0, 0),
    new mxPoint2(w2, 0),
    new mxPoint2(w2, dy),
    new mxPoint2((w2 + dx) / 2, dy),
    new mxPoint2((w2 + dx) / 2, h2),
    new mxPoint2((w2 - dx) / 2, h2),
    new mxPoint2((w2 - dx) / 2, dy),
    new mxPoint2(0, dy)
  ], this.isRounded, arcSize, true);
  c.end();
};
mxCellRenderer2.registerShape("tee", TeeShape);
function SingleArrowShape() {
  mxActor.call(this);
}
extend(SingleArrowShape, mxActor);
SingleArrowShape.prototype.arrowWidth = 0.3;
SingleArrowShape.prototype.arrowSize = 0.2;
SingleArrowShape.prototype.redrawPath = function(c, x, y, w2, h2) {
  var aw = h2 * Math.max(0, Math.min(1, parseFloat(getValue(this.style, "arrowWidth", this.arrowWidth))));
  var as = w2 * Math.max(0, Math.min(1, parseFloat(getValue(this.style, "arrowSize", this.arrowSize))));
  var at = (h2 - aw) / 2;
  var ab = at + aw;
  var arcSize = getValue(this.style, mxConstants2.STYLE_ARCSIZE, mxConstants2.LINE_ARCSIZE) / 2;
  this.addPoints(c, [
    new mxPoint2(0, at),
    new mxPoint2(w2 - as, at),
    new mxPoint2(w2 - as, 0),
    new mxPoint2(w2, h2 / 2),
    new mxPoint2(w2 - as, h2),
    new mxPoint2(w2 - as, ab),
    new mxPoint2(0, ab)
  ], this.isRounded, arcSize, true);
  c.end();
};
mxCellRenderer2.registerShape("singleArrow", SingleArrowShape);
function DoubleArrowShape() {
  mxActor.call(this);
}
extend(DoubleArrowShape, mxActor);
DoubleArrowShape.prototype.redrawPath = function(c, x, y, w2, h2) {
  var aw = h2 * Math.max(0, Math.min(1, parseFloat(getValue(this.style, "arrowWidth", SingleArrowShape.prototype.arrowWidth))));
  var as = w2 * Math.max(0, Math.min(1, parseFloat(getValue(this.style, "arrowSize", SingleArrowShape.prototype.arrowSize))));
  var at = (h2 - aw) / 2;
  var ab = at + aw;
  var arcSize = getValue(this.style, mxConstants2.STYLE_ARCSIZE, mxConstants2.LINE_ARCSIZE) / 2;
  this.addPoints(c, [
    new mxPoint2(0, h2 / 2),
    new mxPoint2(as, 0),
    new mxPoint2(as, at),
    new mxPoint2(w2 - as, at),
    new mxPoint2(w2 - as, 0),
    new mxPoint2(w2, h2 / 2),
    new mxPoint2(w2 - as, h2),
    new mxPoint2(w2 - as, ab),
    new mxPoint2(as, ab),
    new mxPoint2(as, h2)
  ], this.isRounded, arcSize, true);
  c.end();
};
mxCellRenderer2.registerShape("doubleArrow", DoubleArrowShape);
function DataStorageShape() {
  mxActor.call(this);
}
extend(DataStorageShape, mxActor);
DataStorageShape.prototype.size = 0.1;
DataStorageShape.prototype.fixedSize = 20;
DataStorageShape.prototype.redrawPath = function(c, x, y, w2, h2) {
  var fixed = getValue(this.style, "fixedSize", "0") != "0";
  var s = fixed ? Math.max(0, Math.min(w2, parseFloat(getValue(this.style, "size", this.fixedSize)))) : w2 * Math.max(0, Math.min(1, parseFloat(getValue(this.style, "size", this.size))));
  c.moveTo(s, 0);
  c.lineTo(w2, 0);
  c.quadTo(w2 - s * 2, h2 / 2, w2, h2);
  c.lineTo(s, h2);
  c.quadTo(s - s * 2, h2 / 2, s, 0);
  c.close();
  c.end();
};
mxCellRenderer2.registerShape("dataStorage", DataStorageShape);
function OrShape() {
  mxActor.call(this);
}
extend(OrShape, mxActor);
OrShape.prototype.redrawPath = function(c, x, y, w2, h2) {
  c.moveTo(0, 0);
  c.quadTo(w2, 0, w2, h2 / 2);
  c.quadTo(w2, h2, 0, h2);
  c.close();
  c.end();
};
mxCellRenderer2.registerShape("or", OrShape);
function XorShape() {
  mxActor.call(this);
}
extend(XorShape, mxActor);
XorShape.prototype.redrawPath = function(c, x, y, w2, h2) {
  c.moveTo(0, 0);
  c.quadTo(w2, 0, w2, h2 / 2);
  c.quadTo(w2, h2, 0, h2);
  c.quadTo(w2 / 2, h2 / 2, 0, 0);
  c.close();
  c.end();
};
mxCellRenderer2.registerShape("xor", XorShape);
function LoopLimitShape() {
  mxActor.call(this);
}
extend(LoopLimitShape, mxActor);
LoopLimitShape.prototype.size = 20;
LoopLimitShape.prototype.isRoundable = function() {
  return true;
};
LoopLimitShape.prototype.redrawPath = function(c, x, y, w2, h2) {
  var s = Math.min(w2 / 2, Math.min(h2, parseFloat(getValue(this.style, "size", this.size))));
  var arcSize = getValue(this.style, mxConstants2.STYLE_ARCSIZE, mxConstants2.LINE_ARCSIZE) / 2;
  this.addPoints(c, [
    new mxPoint2(s, 0),
    new mxPoint2(w2 - s, 0),
    new mxPoint2(w2, s * 0.8),
    new mxPoint2(w2, h2),
    new mxPoint2(0, h2),
    new mxPoint2(0, s * 0.8)
  ], this.isRounded, arcSize, true);
  c.end();
};
mxCellRenderer2.registerShape("loopLimit", LoopLimitShape);
function OffPageConnectorShape() {
  mxActor.call(this);
}
extend(OffPageConnectorShape, mxActor);
OffPageConnectorShape.prototype.size = 3 / 8;
OffPageConnectorShape.prototype.isRoundable = function() {
  return true;
};
OffPageConnectorShape.prototype.redrawPath = function(c, x, y, w2, h2) {
  var s = h2 * Math.max(0, Math.min(1, parseFloat(getValue(this.style, "size", this.size))));
  var arcSize = getValue(this.style, mxConstants2.STYLE_ARCSIZE, mxConstants2.LINE_ARCSIZE) / 2;
  this.addPoints(c, [
    new mxPoint2(0, 0),
    new mxPoint2(w2, 0),
    new mxPoint2(w2, h2 - s),
    new mxPoint2(w2 / 2, h2),
    new mxPoint2(0, h2 - s)
  ], this.isRounded, arcSize, true);
  c.end();
};
mxCellRenderer2.registerShape("offPageConnector", OffPageConnectorShape);
function TapeDataShape() {
  mxEllipse.call(this);
}
extend(TapeDataShape, mxEllipse);
TapeDataShape.prototype.paintVertexShape = function(c, x, y, w2, h2) {
  mxEllipse.prototype.paintVertexShape.apply(this, arguments);
  c.begin();
  c.moveTo(x + w2 / 2, y + h2);
  c.lineTo(x + w2, y + h2);
  c.end();
  c.stroke();
};
mxCellRenderer2.registerShape("tapeData", TapeDataShape);
function OrEllipseShape() {
  mxEllipse.call(this);
}
extend(OrEllipseShape, mxEllipse);
OrEllipseShape.prototype.paintVertexShape = function(c, x, y, w2, h2) {
  mxEllipse.prototype.paintVertexShape.apply(this, arguments);
  c.setShadow(false);
  c.begin();
  c.moveTo(x, y + h2 / 2);
  c.lineTo(x + w2, y + h2 / 2);
  c.end();
  c.stroke();
  c.begin();
  c.moveTo(x + w2 / 2, y);
  c.lineTo(x + w2 / 2, y + h2);
  c.end();
  c.stroke();
};
mxCellRenderer2.registerShape("orEllipse", OrEllipseShape);
function SumEllipseShape() {
  mxEllipse.call(this);
}
extend(SumEllipseShape, mxEllipse);
SumEllipseShape.prototype.paintVertexShape = function(c, x, y, w2, h2) {
  mxEllipse.prototype.paintVertexShape.apply(this, arguments);
  var s2 = 0.145;
  c.setShadow(false);
  c.begin();
  c.moveTo(x + w2 * s2, y + h2 * s2);
  c.lineTo(x + w2 * (1 - s2), y + h2 * (1 - s2));
  c.end();
  c.stroke();
  c.begin();
  c.moveTo(x + w2 * (1 - s2), y + h2 * s2);
  c.lineTo(x + w2 * s2, y + h2 * (1 - s2));
  c.end();
  c.stroke();
};
mxCellRenderer2.registerShape("sumEllipse", SumEllipseShape);
function SortShape() {
  mxRhombus.call(this);
}
extend(SortShape, mxRhombus);
SortShape.prototype.paintVertexShape = function(c, x, y, w2, h2) {
  mxRhombus.prototype.paintVertexShape.apply(this, arguments);
  c.setShadow(false);
  c.begin();
  c.moveTo(x, y + h2 / 2);
  c.lineTo(x + w2, y + h2 / 2);
  c.end();
  c.stroke();
};
mxCellRenderer2.registerShape("sortShape", SortShape);
function CollateShape() {
  mxEllipse.call(this);
}
extend(CollateShape, mxEllipse);
CollateShape.prototype.paintVertexShape = function(c, x, y, w2, h2) {
  c.begin();
  c.moveTo(x, y);
  c.lineTo(x + w2, y);
  c.lineTo(x + w2 / 2, y + h2 / 2);
  c.close();
  c.fillAndStroke();
  c.begin();
  c.moveTo(x, y + h2);
  c.lineTo(x + w2, y + h2);
  c.lineTo(x + w2 / 2, y + h2 / 2);
  c.close();
  c.fillAndStroke();
};
mxCellRenderer2.registerShape("collate", CollateShape);
function DimensionShape() {
  mxEllipse.call(this);
}
extend(DimensionShape, mxEllipse);
DimensionShape.prototype.paintVertexShape = function(c, x, y, w2, h2) {
  var al = 10;
  var cy = y + h2 - al / 2;
  c.begin();
  c.moveTo(x, y);
  c.lineTo(x, y + h2);
  c.moveTo(x, cy);
  c.lineTo(x + al, cy - al / 2);
  c.moveTo(x, cy);
  c.lineTo(x + al, cy + al / 2);
  c.moveTo(x, cy);
  c.lineTo(x + w2, cy);
  c.moveTo(x + w2, y);
  c.lineTo(x + w2, y + h2);
  c.moveTo(x + w2, cy);
  c.lineTo(x + w2 - al, cy - al / 2);
  c.moveTo(x + w2, cy);
  c.lineTo(x + w2 - al, cy + al / 2);
  c.end();
  c.stroke();
};
mxCellRenderer2.registerShape("dimension", DimensionShape);
function PartialRectangleShape() {
  mxEllipse.call(this);
}
extend(PartialRectangleShape, mxEllipse);
PartialRectangleShape.prototype.paintVertexShape = function(c, x, y, w2, h2) {
  if (!this.outline) {
    c.setStrokeColor(null);
  }
  if (this.style != null) {
    var pointerEvents = c.pointerEvents;
    var events = getValue(this.style, mxConstants2.STYLE_POINTER_EVENTS, "1") == "1";
    if (!events && (this.fill == null || this.fill == mxConstants2.NONE)) {
      c.pointerEvents = false;
    }
    c.rect(x, y, w2, h2);
    c.fill();
    c.pointerEvents = pointerEvents;
    c.setStrokeColor(this.stroke);
    c.begin();
    c.moveTo(x, y);
    if (this.outline || getValue(this.style, "top", "1") == "1") {
      c.lineTo(x + w2, y);
    } else {
      c.moveTo(x + w2, y);
    }
    if (this.outline || getValue(this.style, "right", "1") == "1") {
      c.lineTo(x + w2, y + h2);
    } else {
      c.moveTo(x + w2, y + h2);
    }
    if (this.outline || getValue(this.style, "bottom", "1") == "1") {
      c.lineTo(x, y + h2);
    } else {
      c.moveTo(x, y + h2);
    }
    if (this.outline || getValue(this.style, "left", "1") == "1") {
      c.lineTo(x, y);
    }
    c.end();
    c.stroke();
  }
};
mxCellRenderer2.registerShape("partialRectangle", PartialRectangleShape);
function LineEllipseShape() {
  mxEllipse.call(this);
}
extend(LineEllipseShape, mxEllipse);
LineEllipseShape.prototype.paintVertexShape = function(c, x, y, w2, h2) {
  mxEllipse.prototype.paintVertexShape.apply(this, arguments);
  c.setShadow(false);
  c.begin();
  if (getValue(this.style, "line") == "vertical") {
    c.moveTo(x + w2 / 2, y);
    c.lineTo(x + w2 / 2, y + h2);
  } else {
    c.moveTo(x, y + h2 / 2);
    c.lineTo(x + w2, y + h2 / 2);
  }
  c.end();
  c.stroke();
};
mxCellRenderer2.registerShape("lineEllipse", LineEllipseShape);
function DelayShape() {
  mxActor.call(this);
}
extend(DelayShape, mxActor);
DelayShape.prototype.redrawPath = function(c, x, y, w2, h2) {
  var dx = Math.min(w2, h2 / 2);
  c.moveTo(0, 0);
  c.lineTo(w2 - dx, 0);
  c.quadTo(w2, 0, w2, h2 / 2);
  c.quadTo(w2, h2, w2 - dx, h2);
  c.lineTo(0, h2);
  c.close();
  c.end();
};
mxCellRenderer2.registerShape("delay", DelayShape);
function CrossShape() {
  mxActor.call(this);
}
extend(CrossShape, mxActor);
CrossShape.prototype.size = 0.2;
CrossShape.prototype.redrawPath = function(c, x, y, w2, h2) {
  var m = Math.min(h2, w2);
  var size = Math.max(0, Math.min(m, m * parseFloat(getValue(this.style, "size", this.size))));
  var t = (h2 - size) / 2;
  var b = t + size;
  var l = (w2 - size) / 2;
  var r = l + size;
  c.moveTo(0, t);
  c.lineTo(l, t);
  c.lineTo(l, 0);
  c.lineTo(r, 0);
  c.lineTo(r, t);
  c.lineTo(w2, t);
  c.lineTo(w2, b);
  c.lineTo(r, b);
  c.lineTo(r, h2);
  c.lineTo(l, h2);
  c.lineTo(l, b);
  c.lineTo(0, b);
  c.close();
  c.end();
};
mxCellRenderer2.registerShape("cross", CrossShape);
function DisplayShape() {
  mxActor.call(this);
}
extend(DisplayShape, mxActor);
DisplayShape.prototype.size = 0.25;
DisplayShape.prototype.redrawPath = function(c, x, y, w2, h2) {
  var dx = Math.min(w2, h2 / 2);
  var s = Math.min(w2 - dx, Math.max(0, parseFloat(getValue(this.style, "size", this.size))) * w2);
  c.moveTo(0, h2 / 2);
  c.lineTo(s, 0);
  c.lineTo(w2 - dx, 0);
  c.quadTo(w2, 0, w2, h2 / 2);
  c.quadTo(w2, h2, w2 - dx, h2);
  c.lineTo(s, h2);
  c.close();
  c.end();
};
mxCellRenderer2.registerShape("display", DisplayShape);
function FilledEdge() {
  mxConnector.call(this);
}
extend(FilledEdge, mxConnector);
FilledEdge.prototype.origPaintEdgeShape = FilledEdge.prototype.paintEdgeShape;
FilledEdge.prototype.paintEdgeShape = function(c, pts, rounded) {
  var temp2 = [];
  for (var i = 0; i < pts.length; i++) {
    temp2.push(clone(pts[i]));
  }
  var dashed = c.state.dashed;
  var fixDash = c.state.fixDash;
  FilledEdge.prototype.origPaintEdgeShape.apply(this, [c, temp2, rounded]);
  if (c.state.strokeWidth >= 3) {
    var fillClr = getValue(this.style, "fillColor", null);
    if (fillClr != null) {
      c.setStrokeColor(fillClr);
      c.setStrokeWidth(c.state.strokeWidth - 2);
      c.setDashed(dashed, fixDash);
      FilledEdge.prototype.origPaintEdgeShape.apply(this, [c, pts, rounded]);
    }
  }
};
mxCellRenderer2.registerShape("filledEdge", FilledEdge);
if (typeof StyleFormatPanel !== "undefined") {
  const styleFormatPanelGetCustomColors = StyleFormatPanel.prototype.getCustomColors;
  StyleFormatPanel.prototype.getCustomColors = function() {
    var ss = this.format.getSelectionState();
    var result2 = styleFormatPanelGetCustomColors.apply(this, arguments);
    if (ss.style.shape == "umlFrame") {
      result2.push({ title: mxResources2.get("laneColor"), key: "swimlaneFillColor", defaultValue: "#ffffff" });
    }
    return result2;
  };
}
mxMarker.addMarker("dash", function(c, shape, type, pe, unitX, unitY, size, source, sw, filled) {
  var nx = unitX * (size + sw + 1);
  var ny = unitY * (size + sw + 1);
  return function() {
    c.begin();
    c.moveTo(pe.x - nx / 2 - ny / 2, pe.y - ny / 2 + nx / 2);
    c.lineTo(pe.x + ny / 2 - 3 * nx / 2, pe.y - 3 * ny / 2 - nx / 2);
    c.stroke();
  };
});
mxMarker.addMarker("box", function(c, shape, type, pe, unitX, unitY, size, source, sw, filled) {
  var nx = unitX * (size + sw + 1);
  var ny = unitY * (size + sw + 1);
  var px = pe.x + nx / 2;
  var py = pe.y + ny / 2;
  pe.x -= nx;
  pe.y -= ny;
  return function() {
    c.begin();
    c.moveTo(px - nx / 2 - ny / 2, py - ny / 2 + nx / 2);
    c.lineTo(px - nx / 2 + ny / 2, py - ny / 2 - nx / 2);
    c.lineTo(px + ny / 2 - 3 * nx / 2, py - 3 * ny / 2 - nx / 2);
    c.lineTo(px - ny / 2 - 3 * nx / 2, py - 3 * ny / 2 + nx / 2);
    c.close();
    if (filled) {
      c.fillAndStroke();
    } else {
      c.stroke();
    }
  };
});
mxMarker.addMarker("cross", function(c, shape, type, pe, unitX, unitY, size, source, sw, filled) {
  var nx = unitX * (size + sw + 1);
  var ny = unitY * (size + sw + 1);
  return function() {
    c.begin();
    c.moveTo(pe.x - nx / 2 - ny / 2, pe.y - ny / 2 + nx / 2);
    c.lineTo(pe.x + ny / 2 - 3 * nx / 2, pe.y - 3 * ny / 2 - nx / 2);
    c.moveTo(pe.x - nx / 2 + ny / 2, pe.y - ny / 2 - nx / 2);
    c.lineTo(pe.x - ny / 2 - 3 * nx / 2, pe.y - 3 * ny / 2 + nx / 2);
    c.stroke();
  };
});
function circleMarker(c, shape, type, pe, unitX, unitY, size, source, sw, filled) {
  var a = size / 2;
  var size = size + sw;
  var pt = pe.clone();
  pe.x -= unitX * (2 * size + sw);
  pe.y -= unitY * (2 * size + sw);
  unitX = unitX * (size + sw);
  unitY = unitY * (size + sw);
  return function() {
    c.ellipse(pt.x - unitX - size, pt.y - unitY - size, 2 * size, 2 * size);
    if (filled) {
      c.fillAndStroke();
    } else {
      c.stroke();
    }
  };
}
mxMarker.addMarker("circle", circleMarker);
mxMarker.addMarker("circlePlus", function(c, shape, type, pe, unitX, unitY, size, source, sw, filled) {
  var pt = pe.clone();
  var fn = circleMarker.apply(this, arguments);
  var nx = unitX * (size + 2 * sw);
  var ny = unitY * (size + 2 * sw);
  return function() {
    fn.apply(this, arguments);
    c.begin();
    c.moveTo(pt.x - unitX * sw, pt.y - unitY * sw);
    c.lineTo(pt.x - 2 * nx + unitX * sw, pt.y - 2 * ny + unitY * sw);
    c.moveTo(pt.x - nx - ny + unitY * sw, pt.y - ny + nx - unitX * sw);
    c.lineTo(pt.x + ny - nx - unitY * sw, pt.y - ny - nx + unitX * sw);
    c.stroke();
  };
});
mxMarker.addMarker("halfCircle", function(c, shape, type, pe, unitX, unitY, size, source, sw, filled) {
  var nx = unitX * (size + sw + 1);
  var ny = unitY * (size + sw + 1);
  var pt = pe.clone();
  pe.x -= nx;
  pe.y -= ny;
  return function() {
    c.begin();
    c.moveTo(pt.x - ny, pt.y + nx);
    c.quadTo(pe.x - ny, pe.y + nx, pe.x, pe.y);
    c.quadTo(pe.x + ny, pe.y - nx, pt.x + ny, pt.y - nx);
    c.stroke();
  };
});
mxMarker.addMarker("async", function(c, shape, type, pe, unitX, unitY, size, source, sw, filled) {
  var endOffsetX = unitX * sw * 1.118;
  var endOffsetY = unitY * sw * 1.118;
  unitX = unitX * (size + sw);
  unitY = unitY * (size + sw);
  var pt = pe.clone();
  pt.x -= endOffsetX;
  pt.y -= endOffsetY;
  var f = 1;
  pe.x += -unitX * f - endOffsetX;
  pe.y += -unitY * f - endOffsetY;
  return function() {
    c.begin();
    c.moveTo(pt.x, pt.y);
    if (source) {
      c.lineTo(pt.x - unitX - unitY / 2, pt.y - unitY + unitX / 2);
    } else {
      c.lineTo(pt.x + unitY / 2 - unitX, pt.y - unitY - unitX / 2);
    }
    c.lineTo(pt.x - unitX, pt.y - unitY);
    c.close();
    if (filled) {
      c.fillAndStroke();
    } else {
      c.stroke();
    }
  };
});
function createOpenAsyncArrow(widthFactor2) {
  widthFactor2 = widthFactor2 != null ? widthFactor2 : 2;
  return function(c, shape, type, pe, unitX, unitY, size, source, sw, filled) {
    unitX = unitX * (size + sw);
    unitY = unitY * (size + sw);
    var pt = pe.clone();
    return function() {
      c.begin();
      c.moveTo(pt.x, pt.y);
      if (source) {
        c.lineTo(pt.x - unitX - unitY / widthFactor2, pt.y - unitY + unitX / widthFactor2);
      } else {
        c.lineTo(pt.x + unitY / widthFactor2 - unitX, pt.y - unitY - unitX / widthFactor2);
      }
      c.stroke();
    };
  };
}
mxMarker.addMarker("openAsync", createOpenAsyncArrow(2));
if (typeof mxVertexHandler !== "undefined") {
  let createHandle = function(state2, keys, getPositionFn, setPositionFn, ignoreGrid, redrawEdges, executeFn) {
    var handle = new mxHandle(state2, null, mxVertexHandler.prototype.secondaryHandleImage);
    handle.execute = function(me) {
      for (var i = 0; i < keys.length; i++) {
        this.copyStyle(keys[i]);
      }
      if (executeFn) {
        executeFn(me);
      }
    };
    handle.getPosition = getPositionFn;
    handle.setPosition = setPositionFn;
    handle.ignoreGrid = ignoreGrid != null ? ignoreGrid : true;
    if (redrawEdges) {
      var positionChanged = handle.positionChanged;
      handle.positionChanged = function() {
        positionChanged.apply(this, arguments);
        state2.view.invalidate(this.state.cell);
        state2.view.validate();
      };
    }
    return handle;
  }, createArcHandle = function(state2, yOffset) {
    return createHandle(state2, [mxConstants2.STYLE_ARCSIZE], function(bounds) {
      var tmp = yOffset != null ? yOffset : bounds.height / 8;
      if (getValue(state2.style, mxConstants2.STYLE_ABSOLUTE_ARCSIZE, 0) == "1") {
        var arcSize = getValue(state2.style, mxConstants2.STYLE_ARCSIZE, mxConstants2.LINE_ARCSIZE) / 2;
        return new mxPoint2(bounds.x + bounds.width - Math.min(bounds.width / 2, arcSize), bounds.y + tmp);
      } else {
        var arcSize = Math.max(0, parseFloat(getValue(state2.style, mxConstants2.STYLE_ARCSIZE, mxConstants2.RECTANGLE_ROUNDING_FACTOR * 100))) / 100;
        return new mxPoint2(bounds.x + bounds.width - Math.min(Math.max(bounds.width / 2, bounds.height / 2), Math.min(bounds.width, bounds.height) * arcSize), bounds.y + tmp);
      }
    }, function(bounds, pt, me) {
      if (getValue(state2.style, mxConstants2.STYLE_ABSOLUTE_ARCSIZE, 0) == "1") {
        this.state.style[mxConstants2.STYLE_ARCSIZE] = Math.round(Math.max(0, Math.min(bounds.width, (bounds.x + bounds.width - pt.x) * 2)));
      } else {
        var f = Math.min(50, Math.max(0, (bounds.width - pt.x + bounds.x) * 100 / Math.min(bounds.width, bounds.height)));
        this.state.style[mxConstants2.STYLE_ARCSIZE] = Math.round(f);
      }
    });
  }, createArcHandleFunction = function() {
    return function(state2) {
      var handles = [];
      if (getValue(state2.style, mxConstants2.STYLE_ROUNDED, false)) {
        handles.push(createArcHandle(state2));
      }
      return handles;
    };
  }, createTrapezoidHandleFunction = function(max, defaultValue, fixedDefaultValue) {
    max = max != null ? max : 0.5;
    return function(state2) {
      var handles = [createHandle(state2, ["size"], function(bounds) {
        var fixed = fixedDefaultValue != null ? getValue(this.state.style, "fixedSize", "0") != "0" : null;
        var size = Math.max(0, parseFloat(getValue(this.state.style, "size", fixed ? fixedDefaultValue : defaultValue)));
        return new mxPoint2(bounds.x + Math.min(bounds.width * 0.75 * max, size * (fixed ? 0.75 : bounds.width * 0.75)), bounds.y + bounds.height / 4);
      }, function(bounds, pt) {
        var fixed = fixedDefaultValue != null ? getValue(this.state.style, "fixedSize", "0") != "0" : null;
        var size = fixed ? pt.x - bounds.x : Math.max(0, Math.min(max, (pt.x - bounds.x) / bounds.width * 0.75));
        this.state.style["size"] = size;
      }, false, true)];
      if (getValue(state2.style, mxConstants2.STYLE_ROUNDED, false)) {
        handles.push(createArcHandle(state2));
      }
      return handles;
    };
  }, createDisplayHandleFunction = function(defaultValue, allowArcHandle, max, redrawEdges, fixedDefaultValue) {
    max = max != null ? max : 0.5;
    return function(state2) {
      var handles = [createHandle(state2, ["size"], function(bounds) {
        var fixed = fixedDefaultValue != null ? getValue(this.state.style, "fixedSize", "0") != "0" : null;
        var size = parseFloat(getValue(this.state.style, "size", fixed ? fixedDefaultValue : defaultValue));
        return new mxPoint2(bounds.x + Math.max(0, Math.min(bounds.width * 0.5, size * (fixed ? 1 : bounds.width))), bounds.getCenterY());
      }, function(bounds, pt, me) {
        var fixed = fixedDefaultValue != null ? getValue(this.state.style, "fixedSize", "0") != "0" : null;
        var size = fixed ? pt.x - bounds.x : Math.max(0, Math.min(max, (pt.x - bounds.x) / bounds.width));
        this.state.style["size"] = size;
      }, false, redrawEdges)];
      if (allowArcHandle && getValue(state2.style, mxConstants2.STYLE_ROUNDED, false)) {
        handles.push(createArcHandle(state2));
      }
      return handles;
    };
  }, createCubeHandleFunction = function(factor, defaultValue, allowArcHandle) {
    return function(state2) {
      var handles = [createHandle(state2, ["size"], function(bounds) {
        var size = Math.max(0, Math.min(bounds.width, Math.min(bounds.height, parseFloat(getValue(this.state.style, "size", defaultValue))))) * factor;
        return new mxPoint2(bounds.x + size, bounds.y + size);
      }, function(bounds, pt) {
        this.state.style["size"] = Math.round(Math.max(0, Math.min(Math.min(bounds.width, pt.x - bounds.x), Math.min(bounds.height, pt.y - bounds.y))) / factor);
      }, false)];
      if (allowArcHandle && getValue(state2.style, mxConstants2.STYLE_ROUNDED, false)) {
        handles.push(createArcHandle(state2));
      }
      return handles;
    };
  }, createCylinderHandleFunction = function(defaultValue) {
    return function(state2) {
      return [createHandle(state2, ["size"], function(bounds) {
        var size = Math.max(0, Math.min(bounds.height * 0.5, parseFloat(getValue(this.state.style, "size", defaultValue))));
        return new mxPoint2(bounds.x, bounds.y + size);
      }, function(bounds, pt) {
        this.state.style["size"] = Math.max(0, pt.y - bounds.y);
      }, true)];
    };
  }, createArrowHandleFunction = function(maxSize) {
    return function(state2) {
      return [createHandle(state2, ["arrowWidth", "arrowSize"], function(bounds) {
        var aw = Math.max(0, Math.min(1, getValue(this.state.style, "arrowWidth", SingleArrowShape.prototype.arrowWidth)));
        var as = Math.max(0, Math.min(maxSize, getValue(this.state.style, "arrowSize", SingleArrowShape.prototype.arrowSize)));
        return new mxPoint2(bounds.x + (1 - as) * bounds.width, bounds.y + (1 - aw) * bounds.height / 2);
      }, function(bounds, pt) {
        this.state.style["arrowWidth"] = Math.max(0, Math.min(1, Math.abs(bounds.y + bounds.height / 2 - pt.y) / bounds.height * 2));
        this.state.style["arrowSize"] = Math.max(0, Math.min(maxSize, (bounds.x + bounds.width - pt.x) / bounds.width));
      })];
    };
  }, createEdgeHandle = function(state2, keys, start, getPosition, setPosition) {
    return createHandle(state2, keys, function(bounds) {
      var pts = state2.absolutePoints;
      var n = pts.length - 1;
      var tr = state2.view.translate;
      var s = state2.view.scale;
      var p0 = start ? pts[0] : pts[n];
      var p1 = start ? pts[1] : pts[n - 1];
      var dx = start ? p1.x - p0.x : p1.x - p0.x;
      var dy = start ? p1.y - p0.y : p1.y - p0.y;
      var dist = Math.sqrt(dx * dx + dy * dy);
      var pt = getPosition.call(this, dist, dx / dist, dy / dist, p0, p1);
      return new mxPoint2(pt.x / s - tr.x, pt.y / s - tr.y);
    }, function(bounds, pt, me) {
      var pts = state2.absolutePoints;
      var n = pts.length - 1;
      var tr = state2.view.translate;
      var s = state2.view.scale;
      var p0 = start ? pts[0] : pts[n];
      var p1 = start ? pts[1] : pts[n - 1];
      var dx = start ? p1.x - p0.x : p1.x - p0.x;
      var dy = start ? p1.y - p0.y : p1.y - p0.y;
      var dist = Math.sqrt(dx * dx + dy * dy);
      pt.x = (pt.x + tr.x) * s;
      pt.y = (pt.y + tr.y) * s;
      setPosition.call(this, dist, dx / dist, dy / dist, p0, p1, pt, me);
    });
  }, createEdgeWidthHandle = function(state2, start, spacing) {
    return createEdgeHandle(state2, ["width"], start, function(dist, nx, ny, p0, p1) {
      var w2 = state2.shape.getEdgeWidth() * state2.view.scale + spacing;
      return new mxPoint2(p0.x + nx * dist / 4 + ny * w2 / 2, p0.y + ny * dist / 4 - nx * w2 / 2);
    }, function(dist, nx, ny, p0, p1, pt) {
      var w2 = Math.sqrt(ptSegDistSq(p0.x, p0.y, p1.x, p1.y, pt.x, pt.y));
      state2.style["width"] = Math.round(w2 * 2) / state2.view.scale - spacing;
    });
  }, ptLineDistance = function(x1, y1, x2, y2, x0, y0) {
    return Math.abs((y2 - y1) * x0 - (x2 - x1) * y0 + x2 * y1 - y2 * x1) / Math.sqrt((y2 - y1) * (y2 - y1) + (x2 - x1) * (x2 - x1));
  };
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  handleFactory = {
    "link": function(state2) {
      var spacing = 10;
      return [createEdgeWidthHandle(state2, true, spacing), createEdgeWidthHandle(state2, false, spacing)];
    },
    "flexArrow": function(state2) {
      var tol = state2.view.graph.gridSize / state2.view.scale;
      var handles = [];
      if (getValue(state2.style, mxConstants2.STYLE_STARTARROW, mxConstants2.NONE) != mxConstants2.NONE) {
        handles.push(createEdgeHandle(state2, ["width", mxConstants2.STYLE_STARTSIZE, mxConstants2.STYLE_ENDSIZE], true, function(dist, nx, ny, p0, p1) {
          var w2 = (state2.shape.getEdgeWidth() - state2.shape.strokewidth) * state2.view.scale;
          var l = getNumber(state2.style, mxConstants2.STYLE_STARTSIZE, mxConstants2.ARROW_SIZE / 5) * 3 * state2.view.scale;
          return new mxPoint2(p0.x + nx * (l + state2.shape.strokewidth * state2.view.scale) + ny * w2 / 2, p0.y + ny * (l + state2.shape.strokewidth * state2.view.scale) - nx * w2 / 2);
        }, function(dist, nx, ny, p0, p1, pt, me) {
          var w2 = Math.sqrt(ptSegDistSq(p0.x, p0.y, p1.x, p1.y, pt.x, pt.y));
          var l = ptLineDist(p0.x, p0.y, p0.x + ny, p0.y - nx, pt.x, pt.y);
          state2.style[mxConstants2.STYLE_STARTSIZE] = Math.round((l - state2.shape.strokewidth) * 100 / 3) / 100 / state2.view.scale;
          state2.style["width"] = Math.round(w2 * 2) / state2.view.scale;
          if (mxEvent2.isControlDown(me.getEvent())) {
            state2.style[mxConstants2.STYLE_ENDSIZE] = state2.style[mxConstants2.STYLE_STARTSIZE];
          }
          if (!mxEvent2.isAltDown(me.getEvent())) {
            if (Math.abs(parseFloat(state2.style[mxConstants2.STYLE_STARTSIZE]) - parseFloat(state2.style[mxConstants2.STYLE_ENDSIZE])) < tol / 6) {
              state2.style[mxConstants2.STYLE_STARTSIZE] = state2.style[mxConstants2.STYLE_ENDSIZE];
            }
          }
        }));
        handles.push(createEdgeHandle(state2, ["startWidth", "endWidth", mxConstants2.STYLE_STARTSIZE, mxConstants2.STYLE_ENDSIZE], true, function(dist, nx, ny, p0, p1) {
          var w2 = (state2.shape.getStartArrowWidth() - state2.shape.strokewidth) * state2.view.scale;
          var l = getNumber(state2.style, mxConstants2.STYLE_STARTSIZE, mxConstants2.ARROW_SIZE / 5) * 3 * state2.view.scale;
          return new mxPoint2(p0.x + nx * (l + state2.shape.strokewidth * state2.view.scale) + ny * w2 / 2, p0.y + ny * (l + state2.shape.strokewidth * state2.view.scale) - nx * w2 / 2);
        }, function(dist, nx, ny, p0, p1, pt, me) {
          var w2 = Math.sqrt(ptSegDistSq(p0.x, p0.y, p1.x, p1.y, pt.x, pt.y));
          var l = ptLineDist(p0.x, p0.y, p0.x + ny, p0.y - nx, pt.x, pt.y);
          state2.style[mxConstants2.STYLE_STARTSIZE] = Math.round((l - state2.shape.strokewidth) * 100 / 3) / 100 / state2.view.scale;
          state2.style["startWidth"] = Math.max(0, Math.round(w2 * 2) - state2.shape.getEdgeWidth()) / state2.view.scale;
          if (mxEvent2.isControlDown(me.getEvent())) {
            state2.style[mxConstants2.STYLE_ENDSIZE] = state2.style[mxConstants2.STYLE_STARTSIZE];
            state2.style["endWidth"] = state2.style["startWidth"];
          }
          if (!mxEvent2.isAltDown(me.getEvent())) {
            if (Math.abs(parseFloat(state2.style[mxConstants2.STYLE_STARTSIZE]) - parseFloat(state2.style[mxConstants2.STYLE_ENDSIZE])) < tol / 6) {
              state2.style[mxConstants2.STYLE_STARTSIZE] = state2.style[mxConstants2.STYLE_ENDSIZE];
            }
            if (Math.abs(parseFloat(state2.style["startWidth"]) - parseFloat(state2.style["endWidth"])) < tol) {
              state2.style["startWidth"] = state2.style["endWidth"];
            }
          }
        }));
      }
      if (getValue(state2.style, mxConstants2.STYLE_ENDARROW, mxConstants2.NONE) != mxConstants2.NONE) {
        handles.push(createEdgeHandle(state2, ["width", mxConstants2.STYLE_STARTSIZE, mxConstants2.STYLE_ENDSIZE], false, function(dist, nx, ny, p0, p1) {
          var w2 = (state2.shape.getEdgeWidth() - state2.shape.strokewidth) * state2.view.scale;
          var l = getNumber(state2.style, mxConstants2.STYLE_ENDSIZE, mxConstants2.ARROW_SIZE / 5) * 3 * state2.view.scale;
          return new mxPoint2(p0.x + nx * (l + state2.shape.strokewidth * state2.view.scale) - ny * w2 / 2, p0.y + ny * (l + state2.shape.strokewidth * state2.view.scale) + nx * w2 / 2);
        }, function(dist, nx, ny, p0, p1, pt, me) {
          var w2 = Math.sqrt(ptSegDistSq(p0.x, p0.y, p1.x, p1.y, pt.x, pt.y));
          var l = ptLineDist(p0.x, p0.y, p0.x + ny, p0.y - nx, pt.x, pt.y);
          state2.style[mxConstants2.STYLE_ENDSIZE] = Math.round((l - state2.shape.strokewidth) * 100 / 3) / 100 / state2.view.scale;
          state2.style["width"] = Math.round(w2 * 2) / state2.view.scale;
          if (mxEvent2.isControlDown(me.getEvent())) {
            state2.style[mxConstants2.STYLE_STARTSIZE] = state2.style[mxConstants2.STYLE_ENDSIZE];
          }
          if (!mxEvent2.isAltDown(me.getEvent())) {
            if (Math.abs(parseFloat(state2.style[mxConstants2.STYLE_ENDSIZE]) - parseFloat(state2.style[mxConstants2.STYLE_STARTSIZE])) < tol / 6) {
              state2.style[mxConstants2.STYLE_ENDSIZE] = state2.style[mxConstants2.STYLE_STARTSIZE];
            }
          }
        }));
        handles.push(createEdgeHandle(state2, ["startWidth", "endWidth", mxConstants2.STYLE_STARTSIZE, mxConstants2.STYLE_ENDSIZE], false, function(dist, nx, ny, p0, p1) {
          var w2 = (state2.shape.getEndArrowWidth() - state2.shape.strokewidth) * state2.view.scale;
          var l = getNumber(state2.style, mxConstants2.STYLE_ENDSIZE, mxConstants2.ARROW_SIZE / 5) * 3 * state2.view.scale;
          return new mxPoint2(p0.x + nx * (l + state2.shape.strokewidth * state2.view.scale) - ny * w2 / 2, p0.y + ny * (l + state2.shape.strokewidth * state2.view.scale) + nx * w2 / 2);
        }, function(dist, nx, ny, p0, p1, pt, me) {
          var w2 = Math.sqrt(ptSegDistSq(p0.x, p0.y, p1.x, p1.y, pt.x, pt.y));
          var l = ptLineDist(p0.x, p0.y, p0.x + ny, p0.y - nx, pt.x, pt.y);
          state2.style[mxConstants2.STYLE_ENDSIZE] = Math.round((l - state2.shape.strokewidth) * 100 / 3) / 100 / state2.view.scale;
          state2.style["endWidth"] = Math.max(0, Math.round(w2 * 2) - state2.shape.getEdgeWidth()) / state2.view.scale;
          if (mxEvent2.isControlDown(me.getEvent())) {
            state2.style[mxConstants2.STYLE_STARTSIZE] = state2.style[mxConstants2.STYLE_ENDSIZE];
            state2.style["startWidth"] = state2.style["endWidth"];
          }
          if (!mxEvent2.isAltDown(me.getEvent())) {
            if (Math.abs(parseFloat(state2.style[mxConstants2.STYLE_ENDSIZE]) - parseFloat(state2.style[mxConstants2.STYLE_STARTSIZE])) < tol / 6) {
              state2.style[mxConstants2.STYLE_ENDSIZE] = state2.style[mxConstants2.STYLE_STARTSIZE];
            }
            if (Math.abs(parseFloat(state2.style["endWidth"]) - parseFloat(state2.style["startWidth"])) < tol) {
              state2.style["endWidth"] = state2.style["startWidth"];
            }
          }
        }));
      }
      return handles;
    },
    "swimlane": function(state2) {
      var handles = [];
      if (getValue(state2.style, mxConstants2.STYLE_ROUNDED)) {
        var size = parseFloat(getValue(state2.style, mxConstants2.STYLE_STARTSIZE, mxConstants2.DEFAULT_STARTSIZE));
        handles.push(createArcHandle(state2, size / 2));
      }
      handles.push(createHandle(state2, [mxConstants2.STYLE_STARTSIZE], function(bounds) {
        var size2 = parseFloat(getValue(state2.style, mxConstants2.STYLE_STARTSIZE, mxConstants2.DEFAULT_STARTSIZE));
        if (getValue(state2.style, mxConstants2.STYLE_HORIZONTAL, 1) == 1) {
          return new mxPoint2(bounds.getCenterX(), bounds.y + Math.max(0, Math.min(bounds.height, size2)));
        } else {
          return new mxPoint2(bounds.x + Math.max(0, Math.min(bounds.width, size2)), bounds.getCenterY());
        }
      }, function(bounds, pt) {
        state2.style[mxConstants2.STYLE_STARTSIZE] = getValue(this.state.style, mxConstants2.STYLE_HORIZONTAL, 1) == 1 ? Math.round(Math.max(0, Math.min(bounds.height, pt.y - bounds.y))) : Math.round(Math.max(0, Math.min(bounds.width, pt.x - bounds.x)));
      }, false, null, function(me) {
        if (mxEvent2.isControlDown(me.getEvent())) {
          var graph = state2.view.graph;
          if (graph.isTableRow(state2.cell) || graph.isTableCell(state2.cell)) {
            var dir = graph.getSwimlaneDirection(state2.style);
            var parent2 = graph.model.getParent(state2.cell);
            var cells = graph.model.getChildCells(parent2, true);
            var temp2 = [];
            for (var i = 0; i < cells.length; i++) {
              if (cells[i] != state2.cell && graph.isSwimlane(cells[i]) && graph.getSwimlaneDirection(graph.getCurrentCellStyle(cells[i])) == dir) {
                temp2.push(cells[i]);
              }
            }
            graph.setCellStyles(mxConstants2.STYLE_STARTSIZE, state2.style[mxConstants2.STYLE_STARTSIZE], temp2);
          }
        }
      }));
      return handles;
    },
    "label": createArcHandleFunction(),
    "ext": createArcHandleFunction(),
    "rectangle": createArcHandleFunction(),
    "triangle": createArcHandleFunction(),
    "rhombus": createArcHandleFunction(),
    "umlLifeline": function(state2) {
      return [createHandle(state2, ["size"], function(bounds) {
        var size = Math.max(0, Math.min(bounds.height, parseFloat(getValue(this.state.style, "size", UmlLifeline.prototype.size))));
        return new mxPoint2(bounds.getCenterX(), bounds.y + size);
      }, function(bounds, pt) {
        this.state.style["size"] = Math.round(Math.max(0, Math.min(bounds.height, pt.y - bounds.y)));
      }, false)];
    },
    "umlFrame": function(state2) {
      var handles = [createHandle(state2, ["width", "height"], function(bounds) {
        var w0 = Math.max(UmlFrame.prototype.corner, Math.min(bounds.width, getValue(this.state.style, "width", UmlFrame.prototype.width)));
        var h0 = Math.max(UmlFrame.prototype.corner * 1.5, Math.min(bounds.height, getValue(this.state.style, "height", UmlFrame.prototype.height)));
        return new mxPoint2(bounds.x + w0, bounds.y + h0);
      }, function(bounds, pt) {
        this.state.style["width"] = Math.round(Math.max(UmlFrame.prototype.corner, Math.min(bounds.width, pt.x - bounds.x)));
        this.state.style["height"] = Math.round(Math.max(UmlFrame.prototype.corner * 1.5, Math.min(bounds.height, pt.y - bounds.y)));
      }, false)];
      return handles;
    },
    "process": function(state2) {
      var handles = [createHandle(state2, ["size"], function(bounds) {
        var fixed = getValue(this.state.style, "fixedSize", "0") != "0";
        var size = parseFloat(getValue(this.state.style, "size", ProcessShape.prototype.size));
        return fixed ? new mxPoint2(bounds.x + size, bounds.y + bounds.height / 4) : new mxPoint2(bounds.x + bounds.width * size, bounds.y + bounds.height / 4);
      }, function(bounds, pt) {
        var fixed = getValue(this.state.style, "fixedSize", "0") != "0";
        var size = fixed ? Math.max(0, Math.min(bounds.width * 0.5, pt.x - bounds.x)) : Math.max(0, Math.min(0.5, (pt.x - bounds.x) / bounds.width));
        this.state.style["size"] = size;
      }, false)];
      if (getValue(state2.style, mxConstants2.STYLE_ROUNDED, false)) {
        handles.push(createArcHandle(state2));
      }
      return handles;
    },
    "cross": function(state2) {
      return [createHandle(state2, ["size"], function(bounds) {
        var m = Math.min(bounds.width, bounds.height);
        var size = Math.max(0, Math.min(1, getValue(this.state.style, "size", CrossShape.prototype.size))) * m / 2;
        return new mxPoint2(bounds.getCenterX() - size, bounds.getCenterY() - size);
      }, function(bounds, pt) {
        var m = Math.min(bounds.width, bounds.height);
        this.state.style["size"] = Math.max(0, Math.min(1, Math.min(Math.max(0, bounds.getCenterY() - pt.y) / m * 2, Math.max(0, bounds.getCenterX() - pt.x) / m * 2)));
      })];
    },
    "note": function(state2) {
      return [createHandle(state2, ["size"], function(bounds) {
        var size = Math.max(0, Math.min(bounds.width, Math.min(bounds.height, parseFloat(getValue(this.state.style, "size", NoteShape.prototype.size)))));
        return new mxPoint2(bounds.x + bounds.width - size, bounds.y + size);
      }, function(bounds, pt) {
        this.state.style["size"] = Math.round(Math.max(0, Math.min(Math.min(bounds.width, bounds.x + bounds.width - pt.x), Math.min(bounds.height, pt.y - bounds.y))));
      })];
    },
    "note2": function(state2) {
      return [createHandle(state2, ["size"], function(bounds) {
        var size = Math.max(0, Math.min(bounds.width, Math.min(bounds.height, parseFloat(getValue(this.state.style, "size", NoteShape2.prototype.size)))));
        return new mxPoint2(bounds.x + bounds.width - size, bounds.y + size);
      }, function(bounds, pt) {
        this.state.style["size"] = Math.round(Math.max(0, Math.min(Math.min(bounds.width, bounds.x + bounds.width - pt.x), Math.min(bounds.height, pt.y - bounds.y))));
      })];
    },
    "manualInput": function(state2) {
      var handles = [createHandle(state2, ["size"], function(bounds) {
        var size = Math.max(0, Math.min(bounds.height, getValue(this.state.style, "size", ManualInputShape.prototype.size)));
        return new mxPoint2(bounds.x + bounds.width / 4, bounds.y + size * 3 / 4);
      }, function(bounds, pt) {
        this.state.style["size"] = Math.round(Math.max(0, Math.min(bounds.height, (pt.y - bounds.y) * 4 / 3)));
      }, false)];
      if (getValue(state2.style, mxConstants2.STYLE_ROUNDED, false)) {
        handles.push(createArcHandle(state2));
      }
      return handles;
    },
    "dataStorage": function(state2) {
      return [createHandle(state2, ["size"], function(bounds) {
        var fixed = getValue(this.state.style, "fixedSize", "0") != "0";
        var size = parseFloat(getValue(this.state.style, "size", fixed ? DataStorageShape.prototype.fixedSize : DataStorageShape.prototype.size));
        return new mxPoint2(bounds.x + bounds.width - size * (fixed ? 1 : bounds.width), bounds.getCenterY());
      }, function(bounds, pt) {
        var fixed = getValue(this.state.style, "fixedSize", "0") != "0";
        var size = fixed ? Math.max(0, Math.min(bounds.width, bounds.x + bounds.width - pt.x)) : Math.max(0, Math.min(1, (bounds.x + bounds.width - pt.x) / bounds.width));
        this.state.style["size"] = size;
      }, false)];
    },
    "callout": function(state2) {
      var handles = [createHandle(state2, ["size", "position"], function(bounds) {
        var size = Math.max(0, Math.min(bounds.height, getValue(this.state.style, "size", CalloutShape.prototype.size)));
        var position = Math.max(0, Math.min(1, getValue(this.state.style, "position", CalloutShape.prototype.position)));
        var base = Math.max(0, Math.min(bounds.width, getValue(this.state.style, "base", CalloutShape.prototype.base)));
        return new mxPoint2(bounds.x + position * bounds.width, bounds.y + bounds.height - size);
      }, function(bounds, pt) {
        var base = Math.max(0, Math.min(bounds.width, getValue(this.state.style, "base", CalloutShape.prototype.base)));
        this.state.style["size"] = Math.round(Math.max(0, Math.min(bounds.height, bounds.y + bounds.height - pt.y)));
        this.state.style["position"] = Math.round(Math.max(0, Math.min(1, (pt.x - bounds.x) / bounds.width)) * 100) / 100;
      }, false), createHandle(state2, ["position2"], function(bounds) {
        var position2 = Math.max(0, Math.min(1, getValue(this.state.style, "position2", CalloutShape.prototype.position2)));
        return new mxPoint2(bounds.x + position2 * bounds.width, bounds.y + bounds.height);
      }, function(bounds, pt) {
        this.state.style["position2"] = Math.round(Math.max(0, Math.min(1, (pt.x - bounds.x) / bounds.width)) * 100) / 100;
      }, false), createHandle(state2, ["base"], function(bounds) {
        var size = Math.max(0, Math.min(bounds.height, getValue(this.state.style, "size", CalloutShape.prototype.size)));
        var position = Math.max(0, Math.min(1, getValue(this.state.style, "position", CalloutShape.prototype.position)));
        var base = Math.max(0, Math.min(bounds.width, getValue(this.state.style, "base", CalloutShape.prototype.base)));
        return new mxPoint2(bounds.x + Math.min(bounds.width, position * bounds.width + base), bounds.y + bounds.height - size);
      }, function(bounds, pt) {
        var position = Math.max(0, Math.min(1, getValue(this.state.style, "position", CalloutShape.prototype.position)));
        this.state.style["base"] = Math.round(Math.max(0, Math.min(bounds.width, pt.x - bounds.x - position * bounds.width)));
      }, false)];
      if (getValue(state2.style, mxConstants2.STYLE_ROUNDED, false)) {
        handles.push(createArcHandle(state2));
      }
      return handles;
    },
    "internalStorage": function(state2) {
      var handles = [createHandle(state2, ["dx", "dy"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width, getValue(this.state.style, "dx", InternalStorageShape.prototype.dx)));
        var dy = Math.max(0, Math.min(bounds.height, getValue(this.state.style, "dy", InternalStorageShape.prototype.dy)));
        return new mxPoint2(bounds.x + dx, bounds.y + dy);
      }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(Math.max(0, Math.min(bounds.width, pt.x - bounds.x)));
        this.state.style["dy"] = Math.round(Math.max(0, Math.min(bounds.height, pt.y - bounds.y)));
      }, false)];
      if (getValue(state2.style, mxConstants2.STYLE_ROUNDED, false)) {
        handles.push(createArcHandle(state2));
      }
      return handles;
    },
    "module": function(state2) {
      var handles = [createHandle(state2, ["jettyWidth", "jettyHeight"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width, getValue(this.state.style, "jettyWidth", ModuleShape.prototype.jettyWidth)));
        var dy = Math.max(0, Math.min(bounds.height, getValue(this.state.style, "jettyHeight", ModuleShape.prototype.jettyHeight)));
        return new mxPoint2(bounds.x + dx / 2, bounds.y + dy * 2);
      }, function(bounds, pt) {
        this.state.style["jettyWidth"] = Math.round(Math.max(0, Math.min(bounds.width, pt.x - bounds.x)) * 2);
        this.state.style["jettyHeight"] = Math.round(Math.max(0, Math.min(bounds.height, pt.y - bounds.y)) / 2);
      })];
      return handles;
    },
    "corner": function(state2) {
      return [createHandle(state2, ["dx", "dy"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width, getValue(this.state.style, "dx", CornerShape.prototype.dx)));
        var dy = Math.max(0, Math.min(bounds.height, getValue(this.state.style, "dy", CornerShape.prototype.dy)));
        return new mxPoint2(bounds.x + dx, bounds.y + dy);
      }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(Math.max(0, Math.min(bounds.width, pt.x - bounds.x)));
        this.state.style["dy"] = Math.round(Math.max(0, Math.min(bounds.height, pt.y - bounds.y)));
      }, false)];
    },
    "tee": function(state2) {
      return [createHandle(state2, ["dx", "dy"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width, getValue(this.state.style, "dx", TeeShape.prototype.dx)));
        var dy = Math.max(0, Math.min(bounds.height, getValue(this.state.style, "dy", TeeShape.prototype.dy)));
        return new mxPoint2(bounds.x + (bounds.width + dx) / 2, bounds.y + dy);
      }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(Math.max(0, Math.min(bounds.width / 2, pt.x - bounds.x - bounds.width / 2) * 2));
        this.state.style["dy"] = Math.round(Math.max(0, Math.min(bounds.height, pt.y - bounds.y)));
      }, false)];
    },
    "singleArrow": createArrowHandleFunction(1),
    "doubleArrow": createArrowHandleFunction(0.5),
    "folder": function(state2) {
      return [createHandle(state2, ["tabWidth", "tabHeight"], function(bounds) {
        var tw = Math.max(0, Math.min(bounds.width, getValue(this.state.style, "tabWidth", FolderShape.prototype.tabWidth)));
        var th = Math.max(0, Math.min(bounds.height, getValue(this.state.style, "tabHeight", FolderShape.prototype.tabHeight)));
        if (getValue(this.state.style, "tabPosition", FolderShape.prototype.tabPosition) == mxConstants2.ALIGN_RIGHT) {
          tw = bounds.width - tw;
        }
        return new mxPoint2(bounds.x + tw, bounds.y + th);
      }, function(bounds, pt) {
        var tw = Math.max(0, Math.min(bounds.width, pt.x - bounds.x));
        if (getValue(this.state.style, "tabPosition", FolderShape.prototype.tabPosition) == mxConstants2.ALIGN_RIGHT) {
          tw = bounds.width - tw;
        }
        this.state.style["tabWidth"] = Math.round(tw);
        this.state.style["tabHeight"] = Math.round(Math.max(0, Math.min(bounds.height, pt.y - bounds.y)));
      }, false)];
    },
    "document": function(state2) {
      return [createHandle(state2, ["size"], function(bounds) {
        var size = Math.max(0, Math.min(1, parseFloat(getValue(this.state.style, "size", DocumentShape.prototype.size))));
        return new mxPoint2(bounds.x + 3 * bounds.width / 4, bounds.y + (1 - size) * bounds.height);
      }, function(bounds, pt) {
        this.state.style["size"] = Math.max(0, Math.min(1, (bounds.y + bounds.height - pt.y) / bounds.height));
      }, false)];
    },
    "tape": function(state2) {
      return [createHandle(state2, ["size"], function(bounds) {
        var size = Math.max(0, Math.min(1, parseFloat(getValue(this.state.style, "size", TapeShape.prototype.size))));
        return new mxPoint2(bounds.getCenterX(), bounds.y + size * bounds.height / 2);
      }, function(bounds, pt) {
        this.state.style["size"] = Math.max(0, Math.min(1, (pt.y - bounds.y) / bounds.height * 2));
      }, false)];
    },
    "isoCube2": function(state2) {
      return [createHandle(state2, ["isoAngle"], function(bounds) {
        var isoAngle = Math.max(0.01, Math.min(94, parseFloat(getValue(this.state.style, "isoAngle", IsoCubeShape2.isoAngle)))) * Math.PI / 200;
        var isoH = Math.min(bounds.width * Math.tan(isoAngle), bounds.height * 0.5);
        return new mxPoint2(bounds.x, bounds.y + isoH);
      }, function(bounds, pt) {
        this.state.style["isoAngle"] = Math.max(0, (pt.y - bounds.y) * 50 / bounds.height);
      }, true)];
    },
    "cylinder2": createCylinderHandleFunction(CylinderShape.prototype.size),
    "cylinder3": createCylinderHandleFunction(CylinderShape3.prototype.size),
    "offPageConnector": function(state2) {
      return [createHandle(state2, ["size"], function(bounds) {
        var size = Math.max(0, Math.min(1, parseFloat(getValue(this.state.style, "size", OffPageConnectorShape.prototype.size))));
        return new mxPoint2(bounds.getCenterX(), bounds.y + (1 - size) * bounds.height);
      }, function(bounds, pt) {
        this.state.style["size"] = Math.max(0, Math.min(1, (bounds.y + bounds.height - pt.y) / bounds.height));
      }, false)];
    },
    "step": createDisplayHandleFunction(StepShape.prototype.size, true, null, true, StepShape.prototype.fixedSize),
    "hexagon": createDisplayHandleFunction(HexagonShape.prototype.size, true, 0.5, true, HexagonShape.prototype.fixedSize),
    "curlyBracket": createDisplayHandleFunction(CurlyBracketShape.prototype.size, false),
    "display": createDisplayHandleFunction(DisplayShape.prototype.size, false),
    "cube": createCubeHandleFunction(1, CubeShape.prototype.size, false),
    "card": createCubeHandleFunction(0.5, CardShape.prototype.size, true),
    "loopLimit": createCubeHandleFunction(0.5, LoopLimitShape.prototype.size, true),
    "trapezoid": createTrapezoidHandleFunction(0.5, TrapezoidShape.prototype.size, TrapezoidShape.prototype.fixedSize),
    "parallelogram": createTrapezoidHandleFunction(1, ParallelogramShape.prototype.size, ParallelogramShape.prototype.fixedSize)
  };
  Graph2.createHandle = createHandle;
  Graph2.handleFactory = handleFactory;
  vertexHandlerCreateCustomHandles = mxVertexHandler.prototype.createCustomHandles;
  mxVertexHandler.prototype.createCustomHandles = function() {
    var handles = vertexHandlerCreateCustomHandles.apply(this, arguments);
    if (this.graph.isCellRotatable(this.state.cell)) {
      var name = this.state.style["shape"];
      if (mxCellRenderer2.defaultShapes[name] == null && MyMxStencilRegistry.getStencil(name) == null) {
        name = mxConstants2.SHAPE_RECTANGLE;
      } else if (this.state.view.graph.isSwimlane(this.state.cell)) {
        name = mxConstants2.SHAPE_SWIMLANE;
      }
      var fn = handleFactory[name];
      if (fn == null && this.state.shape != null && this.state.shape.isRoundable()) {
        fn = handleFactory[mxConstants2.SHAPE_RECTANGLE];
      }
      if (fn != null) {
        var temp2 = fn(this.state);
        if (temp2 != null) {
          if (handles == null) {
            handles = temp2;
          } else {
            handles = handles.concat(temp2);
          }
        }
      }
    }
    return handles;
  };
  mxEdgeHandler2.prototype.createCustomHandles = function() {
    var name = this.state.style["shape"];
    if (mxCellRenderer2.defaultShapes[name] == null && MyMxStencilRegistry.getStencil(name) == null) {
      name = mxConstants2.SHAPE_CONNECTOR;
    }
    var fn = handleFactory[name];
    if (fn != null) {
      return fn(this.state);
    }
    return null;
  };
} else {
  Graph2.createHandle = function() {
  };
  Graph2.handleFactory = {};
}
var handleFactory;
var vertexHandlerCreateCustomHandles;
var isoHVector = new mxPoint2(1, 0);
var isoVVector = new mxPoint2(1, 0);
var alpha1 = toRadians(-30);
var cos1 = Math.cos(alpha1);
var sin1 = Math.sin(alpha1);
isoHVector = getRotatedPoint(isoHVector, cos1, sin1);
var alpha2 = toRadians(-150);
var cos2 = Math.cos(alpha2);
var sin2 = Math.sin(alpha2);
isoVVector = getRotatedPoint(isoVVector, cos2, sin2);
mxEdgeStyle.IsometricConnector = function(state2, source, target, points, result2) {
  var view = state2.view;
  var pt = points != null && points.length > 0 ? points[0] : null;
  var pts = state2.absolutePoints;
  var p0 = pts[0];
  var pe = pts[pts.length - 1];
  if (pt != null) {
    pt = view.transformControlPoint(state2, pt);
  }
  if (p0 == null) {
    if (source != null) {
      p0 = new mxPoint2(source.getCenterX(), source.getCenterY());
    }
  }
  if (pe == null) {
    if (target != null) {
      pe = new mxPoint2(target.getCenterX(), target.getCenterY());
    }
  }
  var a1 = isoHVector.x;
  var a2 = isoHVector.y;
  var b1 = isoVVector.x;
  var b2 = isoVVector.y;
  var elbow = getValue(state2.style, "elbow", "horizontal") == "horizontal";
  if (pe != null && p0 != null) {
    let isoLineTo = function(x, y, ignoreFirst) {
      var c1 = x - last.x;
      var c2 = y - last.y;
      var h2 = (b2 * c1 - b1 * c2) / (a1 * b2 - a2 * b1);
      var v = (a2 * c1 - a1 * c2) / (a2 * b1 - a1 * b2);
      if (elbow) {
        if (ignoreFirst) {
          last = new mxPoint2(last.x + a1 * h2, last.y + a2 * h2);
          result2.push(last);
        }
        last = new mxPoint2(last.x + b1 * v, last.y + b2 * v);
        result2.push(last);
      } else {
        if (ignoreFirst) {
          last = new mxPoint2(last.x + b1 * v, last.y + b2 * v);
          result2.push(last);
        }
        last = new mxPoint2(last.x + a1 * h2, last.y + a2 * h2);
        result2.push(last);
      }
    };
    var last = p0;
    ;
    if (pt == null) {
      pt = new mxPoint2(p0.x + (pe.x - p0.x) / 2, p0.y + (pe.y - p0.y) / 2);
    }
    isoLineTo(pt.x, pt.y, true);
    isoLineTo(pe.x, pe.y, false);
  }
};
mxStyleRegistry2.putValue("isometricEdgeStyle", mxEdgeStyle.IsometricConnector);
var graphCreateEdgeHandler = Graph2.prototype.createEdgeHandler;
Graph2.prototype.createEdgeHandler = function(state2, edgeStyle) {
  if (edgeStyle == mxEdgeStyle.IsometricConnector) {
    var handler = new mxElbowEdgeHandler(state2);
    handler.snapToTerminals = false;
    return handler;
  }
  return graphCreateEdgeHandler.apply(this, arguments);
};
IsoRectangleShape.prototype.constraints = [];
IsoCubeShape.prototype.getConstraints = function(style, w2, h2) {
  var constr = [];
  var tan302 = Math.tan(toRadians(30));
  var tan30Dx2 = (0.5 - tan302) / 2;
  var m = Math.min(w2, h2 / (0.5 + tan302));
  var dx = (w2 - m) / 2;
  var dy = (h2 - m) / 2;
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, dx, dy + 0.25 * m));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, dx + 0.5 * m, dy + m * tan30Dx2));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, dx + m, dy + 0.25 * m));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, dx + m, dy + 0.75 * m));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, dx + 0.5 * m, dy + (1 - tan30Dx2) * m));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, dx, dy + 0.75 * m));
  return constr;
};
IsoCubeShape2.prototype.getConstraints = function(style, w2, h2) {
  var constr = [];
  var isoAngle = Math.max(0.01, Math.min(94, parseFloat(getValue(this.style, "isoAngle", this.isoAngle)))) * Math.PI / 200;
  var isoH = Math.min(w2 * Math.tan(isoAngle), h2 * 0.5);
  constr.push(new mxConnectionConstraint2(new mxPoint2(0.5, 0), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, w2, isoH));
  constr.push(new mxConnectionConstraint2(new mxPoint2(1, 0.5), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, w2, h2 - isoH));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0.5, 1), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, 0, h2 - isoH));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0.5), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, 0, isoH));
  return constr;
};
CalloutShape.prototype.getConstraints = function(style, w2, h2) {
  var constr = [];
  var arcSize = getValue(this.style, mxConstants2.STYLE_ARCSIZE, mxConstants2.LINE_ARCSIZE) / 2;
  var s = Math.max(0, Math.min(h2, parseFloat(getValue(this.style, "size", this.size))));
  var dx = w2 * Math.max(0, Math.min(1, parseFloat(getValue(this.style, "position", this.position))));
  var dx2 = w2 * Math.max(0, Math.min(1, parseFloat(getValue(this.style, "position2", this.position2))));
  var base = Math.max(0, Math.min(w2, parseFloat(getValue(this.style, "base", this.base))));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0.25, 0), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0.5, 0), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0.75, 0), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(1, 0), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, w2, (h2 - s) * 0.5));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, w2, h2 - s));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, dx2, h2));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, 0, h2 - s));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, 0, (h2 - s) * 0.5));
  if (w2 >= s * 2) {
    constr.push(new mxConnectionConstraint2(new mxPoint2(0.5, 0), false));
  }
  return constr;
};
mxRectangleShape.prototype.constraints = [
  new mxConnectionConstraint2(new mxPoint2(0, 0), true),
  new mxConnectionConstraint2(new mxPoint2(0.25, 0), true),
  new mxConnectionConstraint2(new mxPoint2(0.5, 0), true),
  new mxConnectionConstraint2(new mxPoint2(0.75, 0), true),
  new mxConnectionConstraint2(new mxPoint2(1, 0), true),
  new mxConnectionConstraint2(new mxPoint2(0, 0.25), true),
  new mxConnectionConstraint2(new mxPoint2(0, 0.5), true),
  new mxConnectionConstraint2(new mxPoint2(0, 0.75), true),
  new mxConnectionConstraint2(new mxPoint2(1, 0.25), true),
  new mxConnectionConstraint2(new mxPoint2(1, 0.5), true),
  new mxConnectionConstraint2(new mxPoint2(1, 0.75), true),
  new mxConnectionConstraint2(new mxPoint2(0, 1), true),
  new mxConnectionConstraint2(new mxPoint2(0.25, 1), true),
  new mxConnectionConstraint2(new mxPoint2(0.5, 1), true),
  new mxConnectionConstraint2(new mxPoint2(0.75, 1), true),
  new mxConnectionConstraint2(new mxPoint2(1, 1), true)
];
mxEllipse.prototype.constraints = [
  new mxConnectionConstraint2(new mxPoint2(0, 0), true),
  new mxConnectionConstraint2(new mxPoint2(1, 0), true),
  new mxConnectionConstraint2(new mxPoint2(0, 1), true),
  new mxConnectionConstraint2(new mxPoint2(1, 1), true),
  new mxConnectionConstraint2(new mxPoint2(0.5, 0), true),
  new mxConnectionConstraint2(new mxPoint2(0.5, 1), true),
  new mxConnectionConstraint2(new mxPoint2(0, 0.5), true),
  new mxConnectionConstraint2(new mxPoint2(1, 0.5))
];
PartialRectangleShape.prototype.constraints = mxRectangleShape.prototype.constraints;
mxImageShape.prototype.constraints = mxRectangleShape.prototype.constraints;
mxSwimlane2.prototype.constraints = mxRectangleShape.prototype.constraints;
PlusShape.prototype.constraints = mxRectangleShape.prototype.constraints;
mxLabel.prototype.constraints = mxRectangleShape.prototype.constraints;
NoteShape.prototype.getConstraints = function(style, w2, h2) {
  var constr = [];
  var s = Math.max(0, Math.min(w2, Math.min(h2, parseFloat(getValue(this.style, "size", this.size)))));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, (w2 - s) * 0.5, 0));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, w2 - s, 0));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, w2 - s * 0.5, s * 0.5));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, w2, s));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, w2, (h2 + s) * 0.5));
  constr.push(new mxConnectionConstraint2(new mxPoint2(1, 1), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0.5, 1), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 1), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0.5), false));
  if (w2 >= s * 2) {
    constr.push(new mxConnectionConstraint2(new mxPoint2(0.5, 0), false));
  }
  return constr;
};
CardShape.prototype.getConstraints = function(style, w2, h2) {
  var constr = [];
  var s = Math.max(0, Math.min(w2, Math.min(h2, parseFloat(getValue(this.style, "size", this.size)))));
  constr.push(new mxConnectionConstraint2(new mxPoint2(1, 0), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, (w2 + s) * 0.5, 0));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, s, 0));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, s * 0.5, s * 0.5));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, 0, s));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, 0, (h2 + s) * 0.5));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 1), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0.5, 1), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(1, 1), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(1, 0.5), false));
  if (w2 >= s * 2) {
    constr.push(new mxConnectionConstraint2(new mxPoint2(0.5, 0), false));
  }
  return constr;
};
CubeShape.prototype.getConstraints = function(style, w2, h2) {
  var constr = [];
  var s = Math.max(0, Math.min(w2, Math.min(h2, parseFloat(getValue(this.style, "size", this.size)))));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, (w2 - s) * 0.5, 0));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, w2 - s, 0));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, w2 - s * 0.5, s * 0.5));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, w2, s));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, w2, (h2 + s) * 0.5));
  constr.push(new mxConnectionConstraint2(new mxPoint2(1, 1), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, (w2 + s) * 0.5, h2));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, s, h2));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, s * 0.5, h2 - s * 0.5));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, 0, h2 - s));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, 0, (h2 - s) * 0.5));
  return constr;
};
CylinderShape3.prototype.getConstraints = function(style, w2, h2) {
  var constr = [];
  var s = Math.max(0, Math.min(h2, parseFloat(getValue(this.style, "size", this.size))));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0.5, 0), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0.5), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0.5, 1), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(1, 0.5), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, 0, s));
  constr.push(new mxConnectionConstraint2(new mxPoint2(1, 0), false, null, 0, s));
  constr.push(new mxConnectionConstraint2(new mxPoint2(1, 1), false, null, 0, -s));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 1), false, null, 0, -s));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, 0, s + (h2 * 0.5 - s) * 0.5));
  constr.push(new mxConnectionConstraint2(new mxPoint2(1, 0), false, null, 0, s + (h2 * 0.5 - s) * 0.5));
  constr.push(new mxConnectionConstraint2(new mxPoint2(1, 0), false, null, 0, h2 - s - (h2 * 0.5 - s) * 0.5));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, 0, h2 - s - (h2 * 0.5 - s) * 0.5));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0.145, 0), false, null, 0, s * 0.29));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0.855, 0), false, null, 0, s * 0.29));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0.855, 1), false, null, 0, -s * 0.29));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0.145, 1), false, null, 0, -s * 0.29));
  return constr;
};
FolderShape.prototype.getConstraints = function(style, w2, h2) {
  var constr = [];
  var dx = Math.max(0, Math.min(w2, parseFloat(getValue(this.style, "tabWidth", this.tabWidth))));
  var dy = Math.max(0, Math.min(h2, parseFloat(getValue(this.style, "tabHeight", this.tabHeight))));
  var tp = getValue(this.style, "tabPosition", this.tabPosition);
  if (tp == "left") {
    constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false));
    constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, dx * 0.5, 0));
    constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, dx, 0));
    constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, dx, dy));
    constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, (w2 + dx) * 0.5, dy));
  } else {
    constr.push(new mxConnectionConstraint2(new mxPoint2(1, 0), false));
    constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, w2 - dx * 0.5, 0));
    constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, w2 - dx, 0));
    constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, w2 - dx, dy));
    constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, (w2 - dx) * 0.5, dy));
  }
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, w2, dy));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, w2, (h2 - dy) * 0.25 + dy));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, w2, (h2 - dy) * 0.5 + dy));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, w2, (h2 - dy) * 0.75 + dy));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, w2, h2));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, 0, dy));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, 0, (h2 - dy) * 0.25 + dy));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, 0, (h2 - dy) * 0.5 + dy));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, 0, (h2 - dy) * 0.75 + dy));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, 0, h2));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0.25, 1), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0.5, 1), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0.75, 1), false));
  return constr;
};
InternalStorageShape.prototype.constraints = mxRectangleShape.prototype.constraints;
DataStorageShape.prototype.constraints = mxRectangleShape.prototype.constraints;
TapeDataShape.prototype.constraints = mxEllipse.prototype.constraints;
OrEllipseShape.prototype.constraints = mxEllipse.prototype.constraints;
SumEllipseShape.prototype.constraints = mxEllipse.prototype.constraints;
LineEllipseShape.prototype.constraints = mxEllipse.prototype.constraints;
ManualInputShape.prototype.constraints = mxRectangleShape.prototype.constraints;
DelayShape.prototype.constraints = mxRectangleShape.prototype.constraints;
DisplayShape.prototype.getConstraints = function(style, w2, h2) {
  var constr = [];
  var dx = Math.min(w2, h2 / 2);
  var s = Math.min(w2 - dx, Math.max(0, parseFloat(getValue(this.style, "size", this.size))) * w2);
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0.5), false, null));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, s, 0));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, (s + w2 - dx) * 0.5, 0));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, w2 - dx, 0));
  constr.push(new mxConnectionConstraint2(new mxPoint2(1, 0.5), false, null));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, w2 - dx, h2));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, (s + w2 - dx) * 0.5, h2));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, s, h2));
  return constr;
};
ModuleShape.prototype.getConstraints = function(style, w2, h2) {
  var x0 = parseFloat(getValue(style, "jettyWidth", ModuleShape.prototype.jettyWidth)) / 2;
  var dy = parseFloat(getValue(style, "jettyHeight", ModuleShape.prototype.jettyHeight));
  var constr = [
    new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, x0),
    new mxConnectionConstraint2(new mxPoint2(0.25, 0), true),
    new mxConnectionConstraint2(new mxPoint2(0.5, 0), true),
    new mxConnectionConstraint2(new mxPoint2(0.75, 0), true),
    new mxConnectionConstraint2(new mxPoint2(1, 0), true),
    new mxConnectionConstraint2(new mxPoint2(1, 0.25), true),
    new mxConnectionConstraint2(new mxPoint2(1, 0.5), true),
    new mxConnectionConstraint2(new mxPoint2(1, 0.75), true),
    new mxConnectionConstraint2(new mxPoint2(0, 1), false, null, x0),
    new mxConnectionConstraint2(new mxPoint2(0.25, 1), true),
    new mxConnectionConstraint2(new mxPoint2(0.5, 1), true),
    new mxConnectionConstraint2(new mxPoint2(0.75, 1), true),
    new mxConnectionConstraint2(new mxPoint2(1, 1), true),
    new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, 0, Math.min(h2 - 0.5 * dy, 1.5 * dy)),
    new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, 0, Math.min(h2 - 0.5 * dy, 3.5 * dy))
  ];
  if (h2 > 5 * dy) {
    constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0.75), false, null, x0));
  }
  if (h2 > 8 * dy) {
    constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0.5), false, null, x0));
  }
  if (h2 > 15 * dy) {
    constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0.25), false, null, x0));
  }
  return constr;
};
LoopLimitShape.prototype.constraints = mxRectangleShape.prototype.constraints;
OffPageConnectorShape.prototype.constraints = mxRectangleShape.prototype.constraints;
mxCylinder.prototype.constraints = [
  new mxConnectionConstraint2(new mxPoint2(0.15, 0.05), false),
  new mxConnectionConstraint2(new mxPoint2(0.5, 0), true),
  new mxConnectionConstraint2(new mxPoint2(0.85, 0.05), false),
  new mxConnectionConstraint2(new mxPoint2(0, 0.3), true),
  new mxConnectionConstraint2(new mxPoint2(0, 0.5), true),
  new mxConnectionConstraint2(new mxPoint2(0, 0.7), true),
  new mxConnectionConstraint2(new mxPoint2(1, 0.3), true),
  new mxConnectionConstraint2(new mxPoint2(1, 0.5), true),
  new mxConnectionConstraint2(new mxPoint2(1, 0.7), true),
  new mxConnectionConstraint2(new mxPoint2(0.15, 0.95), false),
  new mxConnectionConstraint2(new mxPoint2(0.5, 1), true),
  new mxConnectionConstraint2(new mxPoint2(0.85, 0.95), false)
];
UmlActorShape.prototype.constraints = [
  new mxConnectionConstraint2(new mxPoint2(0.25, 0.1), false),
  new mxConnectionConstraint2(new mxPoint2(0.5, 0), false),
  new mxConnectionConstraint2(new mxPoint2(0.75, 0.1), false),
  new mxConnectionConstraint2(new mxPoint2(0, 1 / 3), false),
  new mxConnectionConstraint2(new mxPoint2(0, 1), false),
  new mxConnectionConstraint2(new mxPoint2(1, 1 / 3), false),
  new mxConnectionConstraint2(new mxPoint2(1, 1), false),
  new mxConnectionConstraint2(new mxPoint2(0.5, 0.5), false)
];
ComponentShape.prototype.constraints = [
  new mxConnectionConstraint2(new mxPoint2(0.25, 0), true),
  new mxConnectionConstraint2(new mxPoint2(0.5, 0), true),
  new mxConnectionConstraint2(new mxPoint2(0.75, 0), true),
  new mxConnectionConstraint2(new mxPoint2(0, 0.3), true),
  new mxConnectionConstraint2(new mxPoint2(0, 0.7), true),
  new mxConnectionConstraint2(new mxPoint2(1, 0.25), true),
  new mxConnectionConstraint2(new mxPoint2(1, 0.5), true),
  new mxConnectionConstraint2(new mxPoint2(1, 0.75), true),
  new mxConnectionConstraint2(new mxPoint2(0.25, 1), true),
  new mxConnectionConstraint2(new mxPoint2(0.5, 1), true),
  new mxConnectionConstraint2(new mxPoint2(0.75, 1), true)
];
mxActor.prototype.constraints = [
  new mxConnectionConstraint2(new mxPoint2(0.5, 0), true),
  new mxConnectionConstraint2(new mxPoint2(0.25, 0.2), false),
  new mxConnectionConstraint2(new mxPoint2(0.1, 0.5), false),
  new mxConnectionConstraint2(new mxPoint2(0, 0.75), true),
  new mxConnectionConstraint2(new mxPoint2(0.75, 0.25), false),
  new mxConnectionConstraint2(new mxPoint2(0.9, 0.5), false),
  new mxConnectionConstraint2(new mxPoint2(1, 0.75), true),
  new mxConnectionConstraint2(new mxPoint2(0.25, 1), true),
  new mxConnectionConstraint2(new mxPoint2(0.5, 1), true),
  new mxConnectionConstraint2(new mxPoint2(0.75, 1), true)
];
SwitchShape.prototype.constraints = [
  new mxConnectionConstraint2(new mxPoint2(0, 0), false),
  new mxConnectionConstraint2(new mxPoint2(0.5, 0.25), false),
  new mxConnectionConstraint2(new mxPoint2(1, 0), false),
  new mxConnectionConstraint2(new mxPoint2(0.25, 0.5), false),
  new mxConnectionConstraint2(new mxPoint2(0.75, 0.5), false),
  new mxConnectionConstraint2(new mxPoint2(0, 1), false),
  new mxConnectionConstraint2(new mxPoint2(0.5, 0.75), false),
  new mxConnectionConstraint2(new mxPoint2(1, 1), false)
];
TapeShape.prototype.constraints = [
  new mxConnectionConstraint2(new mxPoint2(0, 0.35), false),
  new mxConnectionConstraint2(new mxPoint2(0, 0.5), false),
  new mxConnectionConstraint2(new mxPoint2(0, 0.65), false),
  new mxConnectionConstraint2(new mxPoint2(1, 0.35), false),
  new mxConnectionConstraint2(new mxPoint2(1, 0.5), false),
  new mxConnectionConstraint2(new mxPoint2(1, 0.65), false),
  new mxConnectionConstraint2(new mxPoint2(0.25, 1), false),
  new mxConnectionConstraint2(new mxPoint2(0.75, 0), false)
];
StepShape.prototype.constraints = [
  new mxConnectionConstraint2(new mxPoint2(0.25, 0), true),
  new mxConnectionConstraint2(new mxPoint2(0.5, 0), true),
  new mxConnectionConstraint2(new mxPoint2(0.75, 0), true),
  new mxConnectionConstraint2(new mxPoint2(0.25, 1), true),
  new mxConnectionConstraint2(new mxPoint2(0.5, 1), true),
  new mxConnectionConstraint2(new mxPoint2(0.75, 1), true),
  new mxConnectionConstraint2(new mxPoint2(0, 0.25), true),
  new mxConnectionConstraint2(new mxPoint2(0, 0.5), true),
  new mxConnectionConstraint2(new mxPoint2(0, 0.75), true),
  new mxConnectionConstraint2(new mxPoint2(1, 0.25), true),
  new mxConnectionConstraint2(new mxPoint2(1, 0.5), true),
  new mxConnectionConstraint2(new mxPoint2(1, 0.75), true)
];
mxLine.prototype.constraints = [
  new mxConnectionConstraint2(new mxPoint2(0, 0.5), false),
  new mxConnectionConstraint2(new mxPoint2(0.25, 0.5), false),
  new mxConnectionConstraint2(new mxPoint2(0.75, 0.5), false),
  new mxConnectionConstraint2(new mxPoint2(1, 0.5), false)
];
LollipopShape.prototype.constraints = [
  new mxConnectionConstraint2(new mxPoint2(0.5, 0), false),
  new mxConnectionConstraint2(new mxPoint2(0.5, 1), false)
];
mxDoubleEllipse2.prototype.constraints = mxEllipse.prototype.constraints;
mxRhombus.prototype.constraints = mxEllipse.prototype.constraints;
mxTriangle.prototype.constraints = [
  new mxConnectionConstraint2(new mxPoint2(0, 0.25), true),
  new mxConnectionConstraint2(new mxPoint2(0, 0.5), true),
  new mxConnectionConstraint2(new mxPoint2(0, 0.75), true),
  new mxConnectionConstraint2(new mxPoint2(0.5, 0), true),
  new mxConnectionConstraint2(new mxPoint2(0.5, 1), true),
  new mxConnectionConstraint2(new mxPoint2(1, 0.5), true)
];
mxHexagon.prototype.constraints = [
  new mxConnectionConstraint2(new mxPoint2(0.375, 0), true),
  new mxConnectionConstraint2(new mxPoint2(0.5, 0), true),
  new mxConnectionConstraint2(new mxPoint2(0.625, 0), true),
  new mxConnectionConstraint2(new mxPoint2(0, 0.25), true),
  new mxConnectionConstraint2(new mxPoint2(0, 0.5), true),
  new mxConnectionConstraint2(new mxPoint2(0, 0.75), true),
  new mxConnectionConstraint2(new mxPoint2(1, 0.25), true),
  new mxConnectionConstraint2(new mxPoint2(1, 0.5), true),
  new mxConnectionConstraint2(new mxPoint2(1, 0.75), true),
  new mxConnectionConstraint2(new mxPoint2(0.375, 1), true),
  new mxConnectionConstraint2(new mxPoint2(0.5, 1), true),
  new mxConnectionConstraint2(new mxPoint2(0.625, 1), true)
];
mxCloud.prototype.constraints = [
  new mxConnectionConstraint2(new mxPoint2(0.25, 0.25), false),
  new mxConnectionConstraint2(new mxPoint2(0.4, 0.1), false),
  new mxConnectionConstraint2(new mxPoint2(0.16, 0.55), false),
  new mxConnectionConstraint2(new mxPoint2(0.07, 0.4), false),
  new mxConnectionConstraint2(new mxPoint2(0.31, 0.8), false),
  new mxConnectionConstraint2(new mxPoint2(0.13, 0.77), false),
  new mxConnectionConstraint2(new mxPoint2(0.8, 0.8), false),
  new mxConnectionConstraint2(new mxPoint2(0.55, 0.95), false),
  new mxConnectionConstraint2(new mxPoint2(0.875, 0.5), false),
  new mxConnectionConstraint2(new mxPoint2(0.96, 0.7), false),
  new mxConnectionConstraint2(new mxPoint2(0.625, 0.2), false),
  new mxConnectionConstraint2(new mxPoint2(0.88, 0.25), false)
];
ParallelogramShape.prototype.constraints = mxRectangleShape.prototype.constraints;
TrapezoidShape.prototype.constraints = mxRectangleShape.prototype.constraints;
DocumentShape.prototype.constraints = [
  new mxConnectionConstraint2(new mxPoint2(0.25, 0), true),
  new mxConnectionConstraint2(new mxPoint2(0.5, 0), true),
  new mxConnectionConstraint2(new mxPoint2(0.75, 0), true),
  new mxConnectionConstraint2(new mxPoint2(0, 0.25), true),
  new mxConnectionConstraint2(new mxPoint2(0, 0.5), true),
  new mxConnectionConstraint2(new mxPoint2(0, 0.75), true),
  new mxConnectionConstraint2(new mxPoint2(1, 0.25), true),
  new mxConnectionConstraint2(new mxPoint2(1, 0.5), true),
  new mxConnectionConstraint2(new mxPoint2(1, 0.75), true)
];
mxArrow2.prototype.constraints = null;
TeeShape.prototype.getConstraints = function(style, w2, h2) {
  var constr = [];
  var dx = Math.max(0, Math.min(w2, parseFloat(getValue(this.style, "dx", this.dx))));
  var dy = Math.max(0, Math.min(h2, parseFloat(getValue(this.style, "dy", this.dy))));
  var w22 = Math.abs(w2 - dx) / 2;
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0.5, 0), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(1, 0), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, w2, dy * 0.5));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, w2, dy));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, w2 * 0.75 + dx * 0.25, dy));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, (w2 + dx) * 0.5, dy));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, (w2 + dx) * 0.5, (h2 + dy) * 0.5));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, (w2 + dx) * 0.5, h2));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0.5, 1), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, (w2 - dx) * 0.5, h2));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, (w2 - dx) * 0.5, (h2 + dy) * 0.5));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, (w2 - dx) * 0.5, dy));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, w2 * 0.25 - dx * 0.25, dy));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, 0, dy));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, 0, dy * 0.5));
  return constr;
};
CornerShape.prototype.getConstraints = function(style, w2, h2) {
  var constr = [];
  var dx = Math.max(0, Math.min(w2, parseFloat(getValue(this.style, "dx", this.dx))));
  var dy = Math.max(0, Math.min(h2, parseFloat(getValue(this.style, "dy", this.dy))));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0.5, 0), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(1, 0), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, w2, dy * 0.5));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, w2, dy));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, (w2 + dx) * 0.5, dy));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, dx, dy));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, dx, (h2 + dy) * 0.5));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, dx, h2));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, dx * 0.5, h2));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0.5), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 1), false));
  return constr;
};
CrossbarShape.prototype.constraints = [
  new mxConnectionConstraint2(new mxPoint2(0, 0), false),
  new mxConnectionConstraint2(new mxPoint2(0, 0.5), false),
  new mxConnectionConstraint2(new mxPoint2(0, 1), false),
  new mxConnectionConstraint2(new mxPoint2(0.25, 0.5), false),
  new mxConnectionConstraint2(new mxPoint2(0.5, 0.5), false),
  new mxConnectionConstraint2(new mxPoint2(0.75, 0.5), false),
  new mxConnectionConstraint2(new mxPoint2(1, 0), false),
  new mxConnectionConstraint2(new mxPoint2(1, 0.5), false),
  new mxConnectionConstraint2(new mxPoint2(1, 1), false)
];
SingleArrowShape.prototype.getConstraints = function(style, w2, h2) {
  var constr = [];
  var aw = h2 * Math.max(0, Math.min(1, parseFloat(getValue(this.style, "arrowWidth", this.arrowWidth))));
  var as = w2 * Math.max(0, Math.min(1, parseFloat(getValue(this.style, "arrowSize", this.arrowSize))));
  var at = (h2 - aw) / 2;
  var ab = at + aw;
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0.5), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, 0, at));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, (w2 - as) * 0.5, at));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, w2 - as, 0));
  constr.push(new mxConnectionConstraint2(new mxPoint2(1, 0.5), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, w2 - as, h2));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, (w2 - as) * 0.5, h2 - at));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, 0, h2 - at));
  return constr;
};
DoubleArrowShape.prototype.getConstraints = function(style, w2, h2) {
  var constr = [];
  var aw = h2 * Math.max(0, Math.min(1, parseFloat(getValue(this.style, "arrowWidth", SingleArrowShape.prototype.arrowWidth))));
  var as = w2 * Math.max(0, Math.min(1, parseFloat(getValue(this.style, "arrowSize", SingleArrowShape.prototype.arrowSize))));
  var at = (h2 - aw) / 2;
  var ab = at + aw;
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0.5), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, as, 0));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, w2 * 0.5, at));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, w2 - as, 0));
  constr.push(new mxConnectionConstraint2(new mxPoint2(1, 0.5), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, w2 - as, h2));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, w2 * 0.5, h2 - at));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, as, h2));
  return constr;
};
CrossShape.prototype.getConstraints = function(style, w2, h2) {
  var constr = [];
  var m = Math.min(h2, w2);
  var size = Math.max(0, Math.min(m, m * parseFloat(getValue(this.style, "size", this.size))));
  var t = (h2 - size) / 2;
  var b = t + size;
  var l = (w2 - size) / 2;
  var r = l + size;
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, l, t * 0.5));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, l, 0));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0.5, 0), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, r, 0));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, r, t * 0.5));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, r, t));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, l, h2 - t * 0.5));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, l, h2));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0.5, 1), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, r, h2));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, r, h2 - t * 0.5));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, r, b));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, (w2 + r) * 0.5, t));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, w2, t));
  constr.push(new mxConnectionConstraint2(new mxPoint2(1, 0.5), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, w2, b));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, (w2 + r) * 0.5, b));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, l, b));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, l * 0.5, t));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, 0, t));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0.5), false));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, 0, b));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, l * 0.5, b));
  constr.push(new mxConnectionConstraint2(new mxPoint2(0, 0), false, null, l, t));
  return constr;
};
UmlLifeline.prototype.constraints = null;
OrShape.prototype.constraints = [
  new mxConnectionConstraint2(new mxPoint2(0, 0.25), false),
  new mxConnectionConstraint2(new mxPoint2(0, 0.5), false),
  new mxConnectionConstraint2(new mxPoint2(0, 0.75), false),
  new mxConnectionConstraint2(new mxPoint2(1, 0.5), false),
  new mxConnectionConstraint2(new mxPoint2(0.7, 0.1), false),
  new mxConnectionConstraint2(new mxPoint2(0.7, 0.9), false)
];
XorShape.prototype.constraints = [
  new mxConnectionConstraint2(new mxPoint2(0.175, 0.25), false),
  new mxConnectionConstraint2(new mxPoint2(0.25, 0.5), false),
  new mxConnectionConstraint2(new mxPoint2(0.175, 0.75), false),
  new mxConnectionConstraint2(new mxPoint2(1, 0.5), false),
  new mxConnectionConstraint2(new mxPoint2(0.7, 0.1), false),
  new mxConnectionConstraint2(new mxPoint2(0.7, 0.9), false)
];
RequiredInterfaceShape.prototype.constraints = [
  new mxConnectionConstraint2(new mxPoint2(0, 0.5), false),
  new mxConnectionConstraint2(new mxPoint2(1, 0.5), false)
];
ProvidedRequiredInterfaceShape.prototype.constraints = [
  new mxConnectionConstraint2(new mxPoint2(0, 0.5), false),
  new mxConnectionConstraint2(new mxPoint2(1, 0.5), false)
];

// main.js
window.urlParams = window.urlParams || {};
window.MAX_REQUEST_SIZE = window.MAX_REQUEST_SIZE || 10485760;
window.MAX_AREA = window.MAX_AREA || 15e3 * 15e3;
window.EXPORT_URL = window.EXPORT_URL || "/export";
window.SAVE_URL = window.SAVE_URL || "/save";
window.OPEN_URL = window.OPEN_URL || "/open";
window.RESOURCES_PATH = window.RESOURCES_PATH || "resources";
window.RESOURCE_BASE = window.RESOURCE_BASE || window.RESOURCES_PATH + "/grapheditor";
window.STENCIL_PATH = window.STENCIL_PATH || "stencils";
window.IMAGE_PATH = window.IMAGE_PATH || "images";
window.STYLE_PATH = window.STYLE_PATH || "styles";
window.CSS_PATH = window.CSS_PATH || "styles";
window.OPEN_FORM = window.OPEN_FORM || "open.html";
window.mxBasePath = window.mxBasePath || "../../../src";
window.mxLanguage = window.mxLanguage || urlParams["lang"];
window.mxLanguages = window.mxLanguages || ["de", "se"];
function initApp() {
  const editorUiInit = EditorUi.prototype.init;
  EditorUi.prototype.init = function() {
    editorUiInit.apply(this, arguments);
    this.actions.get("export").setEnabled(false);
    if (!Editor2.useLocalStorage) {
      if (typeof OPEN_URL !== "undefined") {
        post(OPEN_URL, "", bind(this, function(req) {
          const enabled = req.getStatus() != 404;
          this.actions.get("open").setEnabled(enabled || Graph2.fileSupport);
          this.actions.get("import").setEnabled(enabled || Graph2.fileSupport);
          this.actions.get("save").setEnabled(enabled);
          this.actions.get("saveAs").setEnabled(enabled);
          this.actions.get("export").setEnabled(enabled);
        }));
      } else {
        console.warn("OPEN_URL is not defined.");
      }
    }
  };
  mxResources2.loadDefaultBundle = false;
  const mxLanguage2 = urlParams["lang"] || "en";
  const bundle = mxResources2.getDefaultBundle(RESOURCE_BASE, mxLanguage2) || mxResources2.getSpecialBundle(RESOURCE_BASE, mxLanguage2);
  getAll([bundle, `${STYLE_PATH}/default.xml`], function(xhr) {
    mxResources2.parse(xhr[0].getText());
    const themes = {};
    themes[Graph2.prototype.defaultThemeName] = xhr[1].getDocumentElement();
    new EditorUi(new Editor2(urlParams["chrome"] === "0", themes));
  }, function() {
    document.body.innerHTML = '<center style="margin-top:10%;">Error loading resource files. Check console.</center>';
  });
}
window.addEventListener("load", () => {
  initApp();
});
/**
 * @license
 * Copyright (c) 2006-2015, JGraph Ltd
 * Copyright (c) 2006-2015, Gaudenz Alder
 */
//# sourceMappingURL=bootstrap.bundle.js.map
